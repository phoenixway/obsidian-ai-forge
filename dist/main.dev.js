"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;

var __export = function __export(target, all) {
  for (var name in all) {
    __defProp(target, name, {
      get: all[name],
      enumerable: true
    });
  }
};

var __copyProps = function __copyProps(to, from, except, desc) {
  if (from && _typeof(from) === "object" || typeof from === "function") {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      var _loop = function _loop() {
        var key = _step.value;
        if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
          get: function get() {
            return from[key];
          },
          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
      };

      for (var _iterator = __getOwnPropNames(from)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        _loop();
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return to;
};

var __toCommonJS = function __toCommonJS(mod) {
  return __copyProps(__defProp({}, "__esModule", {
    value: true
  }), mod);
}; // main.ts


var main_exports = {};

__export(main_exports, {
  "default": function _default() {
    return OllamaPlugin;
  }
});

module.exports = __toCommonJS(main_exports);

var import_obsidian3 = require("obsidian"); // ollamaView.ts


var import_obsidian = require("obsidian");

var VIEW_TYPE_OLLAMA = "ollama-chat-view";

var _OllamaView =
/*#__PURE__*/
function (_import_obsidian$Item) {
  _inherits(_OllamaView, _import_obsidian$Item);

  // Додана нова змінна
  function _OllamaView(leaf, plugin) {
    var _this;

    _classCallCheck(this, _OllamaView);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(_OllamaView).call(this, leaf));
    _this.messages = [];
    _this.isProcessing = false;
    _this.historyLoaded = false;
    _this.scrollTimeout = null;
    _this.mediaRecorder = null;
    _this.plugin = plugin;

    if (_OllamaView.instance) {
      return _possibleConstructorReturn(_this, _OllamaView.instance);
    }

    _OllamaView.instance = _assertThisInitialized(_this);
    _this.mediaRecorder = null;

    try {
      var workerCode = "\nonmessage = async (event) => {\n    try {\n      const { apiKey, audioBlob, languageCode = 'uk-UA' } = event.data;\n      console.log(\"Worker received audioBlob:\", audioBlob);\n      \n      // \u041F\u0435\u0440\u0435\u0432\u0456\u0440\u044F\u0454\u043C\u043E \u043D\u0430\u044F\u0432\u043D\u0456\u0441\u0442\u044C API \u043A\u043B\u044E\u0447\u0430\n      if (!apiKey || apiKey.trim() === '') {\n        postMessage({ error: true, message: 'Google API Key is not configured. Please add it in plugin settings.' });\n        return;\n      }\n\n      const url = \"https://speech.googleapis.com/v1/speech:recognize?key=\" + apiKey;\n      \n      // \u041A\u043E\u043D\u0432\u0435\u0440\u0442\u0443\u0454\u043C\u043E Blob \u0443 Base64\n      const arrayBuffer = await audioBlob.arrayBuffer();\n      const base64Audio = btoa(\n        new Uint8Array(arrayBuffer).reduce(\n          (data, byte) => data + String.fromCharCode(byte), ''\n        )\n      );\n      \n      console.log(\"Audio converted to Base64\");\n  \n      const response = await fetch(url, {\n        method: 'POST',\n        body: JSON.stringify({\n          config: {\n            encoding: 'WEBM_OPUS',\n            sampleRateHertz: 48000,\n            languageCode: languageCode, // \u0412\u0438\u043A\u043E\u0440\u0438\u0441\u0442\u043E\u0432\u0443\u0454\u043C\u043E \u043F\u0430\u0440\u0430\u043C\u0435\u0442\u0440 \u043C\u043E\u0432\u0438\n            model: 'latest_long', // \u0412\u0438\u043A\u043E\u0440\u0438\u0441\u0442\u043E\u0432\u0443\u0454\u043C\u043E \u043C\u043E\u0434\u0435\u043B\u044C \u0434\u043B\u044F \u0434\u043E\u0432\u0433\u0438\u0445 \u0437\u0430\u043F\u0438\u0441\u0456\u0432\n            enableAutomaticPunctuation: true, // \u0414\u043E\u0434\u0430\u0454\u043C\u043E \u0430\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u043D\u0443 \u043F\u0443\u043D\u043A\u0442\u0443\u0430\u0446\u0456\u044E\n          },\n          audio: {\n            content: base64Audio\n          },\n        }),\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n  \n      if (!response.ok) {\n        const errorData = await response.json();\n        console.error(\"API error details:\", errorData);\n        postMessage({ \n          error: true, \n          message: \"Error from Google Speech API: \" + (errorData.error?.message || response.status)\n        });\n        return;\n      }\n  \n      const data = await response.json();\n      console.log(\"Speech recognition data:\", data);\n      \n      if (data.results && data.results.length > 0) {\n        // \u041E\u0431'\u0454\u0434\u043D\u0443\u0454\u043C\u043E \u0432\u0441\u0456 \u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0456 \u0444\u0440\u0430\u0433\u043C\u0435\u043D\u0442\u0438 \u0442\u0435\u043A\u0441\u0442\u0443\n        const transcript = data.results\n          .map(result => result.alternatives[0].transcript)\n          .join(' ')\n          .trim();\n        \n        postMessage(transcript);\n      } else {\n        postMessage({ error: true, message: 'No speech detected' });\n      }\n    } catch (error) {\n      console.error('Error in speech recognition:', error);\n      postMessage({ \n        error: true, \n        message: 'Error processing speech recognition: ' + error.message \n      });\n    }\n};\n  \nonerror = (event) => {\n  console.error('Worker error:', event);\n};\n";
      var workerBlob = new Blob([workerCode], {
        type: "application/javascript"
      });
      var workerUrl = URL.createObjectURL(workerBlob);
      _this.speechWorker = new Worker(workerUrl);
      console.log("Worker initialized successfully:", _this.speechWorker);
    } catch (error) {
      console.error("Failed to initialize worker:", error);
    }

    _this.speechWorker.onmessage = function (event) {
      var transcript = event.data;
      console.log("Received transcript from worker:", transcript);
      var cursorPosition = _this.inputEl.selectionStart || 0;
      var currentValue = _this.inputEl.value;
      var insertText = transcript;

      if (cursorPosition > 0 && currentValue.charAt(cursorPosition - 1) !== " " && insertText.charAt(0) !== " ") {
        insertText = " " + insertText;
      }

      var newValue = currentValue.substring(0, cursorPosition) + insertText + currentValue.substring(cursorPosition);
      _this.inputEl.value = newValue;
      var newCursorPosition = cursorPosition + insertText.length;

      _this.inputEl.setSelectionRange(newCursorPosition, newCursorPosition);

      _this.inputEl.focus();
    };

    _this.speechWorker.onerror = function (error) {
      console.error("Worker error:", error);
    };

    return _this;
  }

  _createClass(_OllamaView, [{
    key: "getViewType",
    value: function getViewType() {
      return VIEW_TYPE_OLLAMA;
    }
  }, {
    key: "getDisplayText",
    value: function getDisplayText() {
      return "Ollama Chat";
    }
  }, {
    key: "getIcon",
    value: function getIcon() {
      return "message-square";
    }
  }, {
    key: "onOpen",
    value: function onOpen() {
      var _this2 = this;

      var inputContainer, voiceButton, sendButton, settingsButton;
      return regeneratorRuntime.async(function onOpen$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              this.chatContainerEl = this.contentEl.createDiv({
                cls: "ollama-container"
              });
              this.chatContainer = this.chatContainerEl.createDiv({
                cls: "ollama-chat-container"
              });
              inputContainer = this.chatContainerEl.createDiv({
                cls: "chat-input-container"
              });
              this.inputEl = inputContainer.createEl("textarea", {
                attr: {
                  placeholder: "Type a message..."
                }
              });
              voiceButton = inputContainer.createEl("button", {
                cls: "voice-button"
              });
              (0, import_obsidian.setIcon)(voiceButton, "microphone");
              sendButton = inputContainer.createEl("button", {
                cls: "send-button"
              });
              (0, import_obsidian.setIcon)(sendButton, "send");
              settingsButton = inputContainer.createEl("button", {
                cls: "settings-button"
              });
              (0, import_obsidian.setIcon)(settingsButton, "settings");
              this.inputEl.addEventListener("keydown", function (e) {
                if (e.key === "Enter" && !e.shiftKey) {
                  e.preventDefault();

                  _this2.sendMessage();
                }
              });
              settingsButton.addEventListener("click", function () {
                var setting = _this2.app.setting;
                setting.open("obsidian-ollama-duet");
              });
              sendButton.addEventListener("click", function () {
                _this2.sendMessage();
              });
              voiceButton.addEventListener("click", function () {
                _this2.startVoiceRecognition();
              });
              _context.next = 16;
              return regeneratorRuntime.awrap(this.loadMessageHistory());

            case 16:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "loadMessageHistory",
    value: function loadMessageHistory() {
      var history, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, msg, message;

      return regeneratorRuntime.async(function loadMessageHistory$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!this.historyLoaded) {
                _context2.next = 2;
                break;
              }

              return _context2.abrupt("return");

            case 2:
              _context2.prev = 2;
              _context2.next = 5;
              return regeneratorRuntime.awrap(this.plugin.loadMessageHistory());

            case 5:
              history = _context2.sent;

              if (!(Array.isArray(history) && history.length > 0)) {
                _context2.next = 30;
                break;
              }

              this.messages = [];
              this.chatContainer.empty();
              _iteratorNormalCompletion2 = true;
              _didIteratorError2 = false;
              _iteratorError2 = undefined;
              _context2.prev = 12;

              for (_iterator2 = history[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                msg = _step2.value;
                message = _objectSpread({}, msg, {
                  timestamp: new Date(msg.timestamp)
                });
                this.messages.push(message);
                this.renderMessage(message);
              }

              _context2.next = 20;
              break;

            case 16:
              _context2.prev = 16;
              _context2.t0 = _context2["catch"](12);
              _didIteratorError2 = true;
              _iteratorError2 = _context2.t0;

            case 20:
              _context2.prev = 20;
              _context2.prev = 21;

              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }

            case 23:
              _context2.prev = 23;

              if (!_didIteratorError2) {
                _context2.next = 26;
                break;
              }

              throw _iteratorError2;

            case 26:
              return _context2.finish(23);

            case 27:
              return _context2.finish(20);

            case 28:
              this.guaranteedScrollToBottom();
              this.initializeThinkingBlocks();

            case 30:
              this.historyLoaded = true;
              _context2.next = 36;
              break;

            case 33:
              _context2.prev = 33;
              _context2.t1 = _context2["catch"](2);
              console.error("Error loading message history:", _context2.t1);

            case 36:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this, [[2, 33], [12, 16, 20, 28], [21,, 23, 27]]);
    }
  }, {
    key: "saveMessageHistory",
    value: function saveMessageHistory() {
      var serializedMessages;
      return regeneratorRuntime.async(function saveMessageHistory$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!(this.messages.length === 0)) {
                _context3.next = 2;
                break;
              }

              return _context3.abrupt("return");

            case 2:
              _context3.prev = 2;
              serializedMessages = this.messages.map(function (msg) {
                return {
                  role: msg.role,
                  content: msg.content,
                  timestamp: msg.timestamp.toISOString()
                };
              });
              _context3.next = 6;
              return regeneratorRuntime.awrap(this.plugin.saveMessageHistory(JSON.stringify(serializedMessages)));

            case 6:
              _context3.next = 11;
              break;

            case 8:
              _context3.prev = 8;
              _context3.t0 = _context3["catch"](2);
              console.error("Error saving message history:", _context3.t0);

            case 11:
            case "end":
              return _context3.stop();
          }
        }
      }, null, this, [[2, 8]]);
    }
  }, {
    key: "guaranteedScrollToBottom",
    value: function guaranteedScrollToBottom() {
      var _this3 = this;

      if (this.scrollTimeout) {
        clearTimeout(this.scrollTimeout);
      }

      requestAnimationFrame(function () {
        if (!_this3.chatContainer) return;
        _this3.chatContainer.scrollTop = _this3.chatContainer.scrollHeight;
      });
    }
  }, {
    key: "sendMessage",
    value: function sendMessage() {
      var content;
      return regeneratorRuntime.async(function sendMessage$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (!this.isProcessing) {
                _context4.next = 2;
                break;
              }

              return _context4.abrupt("return");

            case 2:
              content = this.inputEl.value.trim();

              if (content) {
                _context4.next = 5;
                break;
              }

              return _context4.abrupt("return");

            case 5:
              this.addMessage("user", content);
              this.inputEl.value = "";
              _context4.next = 9;
              return regeneratorRuntime.awrap(this.processWithOllama(content));

            case 9:
            case "end":
              return _context4.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "addMessage",
    value: function addMessage(role, content) {
      var _this4 = this;

      var message = {
        role: role,
        content: content,
        timestamp: new Date()
      };
      this.messages.push(message);
      this.renderMessage(message);
      this.saveMessageHistory();
      setTimeout(function () {
        _this4.guaranteedScrollToBottom();
      }, 100);
    }
  }, {
    key: "processThinkingTags",
    value: function processThinkingTags(content) {
      if (!content.includes("<think>")) {
        return content;
      }

      var parts = [];
      var currentPosition = 0;
      var thinkingRegex = /<think>([\s\S]*?)<\/think>/g;
      var match;

      while ((match = thinkingRegex.exec(content)) !== null) {
        if (match.index > currentPosition) {
          var textBefore = content.substring(currentPosition, match.index);
          parts.push(this.markdownToHtml(textBefore));
        }

        var thinkingContent = match[1];
        var foldableHtml = "\n        <div class=\"thinking-block\">\n          <div class=\"thinking-header\" data-fold-state=\"expanded\">\n            <div class=\"thinking-toggle\">\u25BC</div>\n            <div class=\"thinking-title\">Thinking</div>\n          </div>\n          <div class=\"thinking-content\">".concat(this.markdownToHtml(thinkingContent), "</div>\n        </div>\n      ");
        parts.push(foldableHtml);
        currentPosition = match.index + match[0].length;
      }

      if (currentPosition < content.length) {
        var textAfter = content.substring(currentPosition);
        parts.push(this.markdownToHtml(textAfter));
      }

      return parts.join("");
    }
  }, {
    key: "markdownToHtml",
    value: function markdownToHtml(markdown) {
      if (!markdown || markdown.trim() === "") return "";
      var tempDiv = document.createElement("div");
      import_obsidian.MarkdownRenderer.renderMarkdown(markdown, tempDiv, "", this);
      return tempDiv.innerHTML;
    }
    /**
     * Escape HTML special characters
     */

  }, {
    key: "escapeHtml",
    value: function escapeHtml(unsafe) {
      return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
    }
  }, {
    key: "addThinkingToggleListeners",
    value: function addThinkingToggleListeners(contentEl) {
      var thinkingHeaders = contentEl.querySelectorAll(".thinking-header");
      thinkingHeaders.forEach(function (header) {
        header.addEventListener("click", function () {
          var content = header.nextElementSibling;
          var toggleIcon = header.querySelector(".thinking-toggle");
          if (!content || !toggleIcon) return;
          var isFolded = header.getAttribute("data-fold-state") === "folded";

          if (isFolded) {
            content.style.display = "block";
            toggleIcon.textContent = "\u25BC";
            header.setAttribute("data-fold-state", "expanded");
          } else {
            content.style.display = "none";
            toggleIcon.textContent = "\u25BA";
            header.setAttribute("data-fold-state", "folded");
          }
        });
      });
    }
  }, {
    key: "hasThinkingTags",
    value: function hasThinkingTags(content) {
      var formats = ["<think>", "&lt;think&gt;", "<think ", // In case there are attributes
      "\\<think\\>", "%3Cthink%3E" // URL encoded
      ];
      return formats.some(function (format) {
        return content.includes(format);
      });
    }
    /**
     * Add toggle all button for thinking blocks
     */

  }, {
    key: "addToggleAllButton",
    value: function addToggleAllButton(contentContainer, contentEl) {
      var toggleAllButton = contentContainer.createEl("button", {
        cls: "toggle-all-thinking-button",
        attr: {
          title: "\u0417\u0433\u043E\u0440\u043D\u0443\u0442\u0438/\u0440\u043E\u0437\u0433\u043E\u0440\u043D\u0443\u0442\u0438 \u0432\u0441\u0456 \u0431\u043B\u043E\u043A\u0438 thinking"
        }
      });
      toggleAllButton.textContent = "Toggle All Thinking";
      toggleAllButton.addEventListener("click", function () {
        var thinkingContents = contentEl.querySelectorAll(".thinking-content");
        var thinkingToggles = contentEl.querySelectorAll(".thinking-toggle");
        var allHidden = true;
        thinkingContents.forEach(function (content) {
          if (content.style.display !== "none") {
            allHidden = false;
          }
        });
        thinkingContents.forEach(function (content, index) {
          content.style.display = allHidden ? "block" : "none";
          thinkingToggles[index].textContent = allHidden ? "\u25BC" : "\u25BA";
        });
      });
    }
  }, {
    key: "renderMessage",
    value: function renderMessage(message) {
      var isUser = message.role === "user";
      var isFirstInGroup = this.isFirstMessageInGroup(message);
      var isLastInGroup = this.isLastMessageInGroup(message);
      var messageGroup;
      var lastGroup = this.chatContainer.lastElementChild;

      if (isFirstInGroup) {
        messageGroup = this.chatContainer.createDiv({
          cls: "message-group ".concat(isUser ? "user-message-group" : "ollama-message-group")
        });
      } else {
        messageGroup = lastGroup;
      }

      var messageEl = messageGroup.createDiv({
        cls: "message ".concat(isUser ? "user-message bubble user-bubble" : "ollama-message bubble ollama-bubble", " ").concat(isLastInGroup ? isUser ? "user-message-tail" : "ollama-message-tail" : "")
      });
      var contentContainer = messageEl.createDiv({
        cls: "message-content-container"
      });
      var contentEl = contentContainer.createDiv({
        cls: "message-content"
      });

      if (message.role === "assistant") {
        var decodedContent = this.decodeHtmlEntities(message.content);
        var hasThinkingTags = message.content.includes("<think>") || decodedContent.includes("<think>");

        if (hasThinkingTags) {
          var contentToProcess = hasThinkingTags && !message.content.includes("<thing>") ? decodedContent : message.content;
          var processedContent = this.processThinkingTags(contentToProcess);
          contentEl.innerHTML = processedContent;
          this.addThinkingToggleListeners(contentEl);
        } else {
          import_obsidian.MarkdownRenderer.renderMarkdown(message.content, contentEl, "", this);
        }
      } else {
        message.content.split("\n").forEach(function (line, index, array) {
          contentEl.createSpan({
            text: line
          });

          if (index < array.length - 1) {
            contentEl.createEl("br");
          }
        });
      }

      var copyButton = contentContainer.createEl("button", {
        cls: "copy-button",
        attr: {
          title: "\u0421\u043A\u043E\u043F\u0456\u044E\u0432\u0430\u0442\u0438"
        }
      });
      (0, import_obsidian.setIcon)(copyButton, "copy");
      copyButton.addEventListener("click", function () {
        var textToCopy = message.content;

        if (message.role === "assistant" && textToCopy.includes("<think>")) {
          textToCopy = textToCopy.replace(/<think>[\s\S]*?<\/think>/g, "");
        }

        navigator.clipboard.writeText(textToCopy);
        copyButton.setText("Copied!");
        setTimeout(function () {
          copyButton.empty();
          (0, import_obsidian.setIcon)(copyButton, "copy");
        }, 2e3);
      });

      if (isLastInGroup) {
        messageEl.createDiv({
          cls: "message-timestamp",
          text: this.formatTime(message.timestamp)
        });
      }
    }
  }, {
    key: "isFirstMessageInGroup",
    value: function isFirstMessageInGroup(message) {
      var index = this.messages.indexOf(message);
      if (index === 0) return true;
      var prevMessage = this.messages[index - 1];
      return prevMessage.role !== message.role;
    }
  }, {
    key: "isLastMessageInGroup",
    value: function isLastMessageInGroup(message) {
      var index = this.messages.indexOf(message);
      if (index === this.messages.length - 1) return true;
      var nextMessage = this.messages[index + 1];
      return nextMessage.role !== message.role;
    }
  }, {
    key: "formatTime",
    value: function formatTime(date) {
      return date.toLocaleTimeString([], {
        hour: "2-digit",
        minute: "2-digit"
      });
    }
  }, {
    key: "decodeHtmlEntities",
    value: function decodeHtmlEntities(text) {
      var textArea = document.createElement("textarea");
      textArea.innerHTML = text;
      return textArea.value;
    }
  }, {
    key: "detectThinkingTags",
    value: function detectThinkingTags(content) {
      var formats = [{
        name: "standard",
        regex: /<think>[\s\S]*?<\/think>/g
      }, {
        name: "escaped",
        regex: /&lt;think&gt;[\s\S]*?&lt;\/think&gt;/g
      }, {
        name: "backslash-escaped",
        regex: /\\<think\\>[\s\S]*?\\<\/think\\>/g
      }, {
        name: "url-encoded",
        regex: /%3Cthink%3E[\s\S]*?%3C\/think%3E/g
      }];

      for (var _i = 0, _formats = formats; _i < _formats.length; _i++) {
        var format = _formats[_i];

        if (format.regex.test(content)) {
          return {
            hasThinkingTags: true,
            format: format.name
          };
        }
      }

      return {
        hasThinkingTags: false,
        format: "none"
      };
    }
  }, {
    key: "processWithOllama",
    value: function processWithOllama(content) {
      var _this5 = this;

      var loadingMessageEl;
      return regeneratorRuntime.async(function processWithOllama$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              this.isProcessing = true;
              loadingMessageEl = this.addLoadingMessage();
              setTimeout(function _callee() {
                var prompt, ragContext, data, decodedResponse, finalResponse;
                return regeneratorRuntime.async(function _callee$(_context5) {
                  while (1) {
                    switch (_context5.prev = _context5.next) {
                      case 0:
                        _context5.prev = 0;
                        prompt = content;

                        if (!_this5.plugin.settings.ragEnabled) {
                          _context5.next = 8;
                          break;
                        }

                        if (!(_this5.plugin.ragService && _this5.plugin.ragService.findRelevantDocuments("test").length === 0)) {
                          _context5.next = 6;
                          break;
                        }

                        _context5.next = 6;
                        return regeneratorRuntime.awrap(_this5.plugin.ragService.indexDocuments());

                      case 6:
                        ragContext = _this5.plugin.ragService.prepareContext(content);

                        if (ragContext) {
                          prompt = "".concat(ragContext, "\n\nUser Query: ").concat(content, "\n\nPlease respond to the user's query based on the provided context. If the context doesn't contain relevant information, please state that and answer based on your general knowledge.");
                        }

                      case 8:
                        _context5.next = 10;
                        return regeneratorRuntime.awrap(_this5.plugin.apiService.generateResponse(_this5.plugin.settings.modelName, prompt));

                      case 10:
                        data = _context5.sent;
                        decodedResponse = _this5.decodeHtmlEntities(data.response);
                        finalResponse = decodedResponse.includes("<think>") ? decodedResponse : data.response;

                        if (loadingMessageEl && loadingMessageEl.parentNode) {
                          loadingMessageEl.parentNode.removeChild(loadingMessageEl);
                        }

                        _this5.addMessage("assistant", finalResponse);

                        _this5.initializeThinkingBlocks();

                        _context5.next = 23;
                        break;

                      case 18:
                        _context5.prev = 18;
                        _context5.t0 = _context5["catch"](0);
                        console.error("Error processing request with Ollama:", _context5.t0);

                        if (loadingMessageEl && loadingMessageEl.parentNode) {
                          loadingMessageEl.parentNode.removeChild(loadingMessageEl);
                        }

                        _this5.addMessage("assistant", "Connection error with Ollama. Please check the settings and ensure the server is running.");

                      case 23:
                        _context5.prev = 23;
                        _this5.isProcessing = false;
                        return _context5.finish(23);

                      case 26:
                      case "end":
                        return _context5.stop();
                    }
                  }
                }, null, null, [[0, 18, 23, 26]]);
              }, 0);

            case 3:
            case "end":
              return _context6.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "initializeThinkingBlocks",
    value: function initializeThinkingBlocks() {
      var _this6 = this;

      setTimeout(function () {
        var thinkingHeaders = _this6.chatContainer.querySelectorAll(".thinking-header");

        thinkingHeaders.forEach(function (header) {
          var content = header.nextElementSibling;
          var toggleIcon = header.querySelector(".thinking-toggle");
          if (!content || !toggleIcon) return;
          content.style.display = "none";
          toggleIcon.textContent = "\u25BA";
          header.setAttribute("data-fold-state", "folded");
        });
      }, 100);
    }
  }, {
    key: "addLoadingMessage",
    value: function addLoadingMessage() {
      var messageGroup = this.chatContainer.createDiv({
        cls: "message-group ollama-message-group"
      });
      var messageEl = messageGroup.createDiv({
        cls: "message ollama-message ollama-message-tail"
      });
      var dotsContainer = messageEl.createDiv({
        cls: "thinking-dots"
      });

      for (var i = 0; i < 3; i++) {
        dotsContainer.createDiv({
          cls: "thinking-dot"
        });
      }

      this.guaranteedScrollToBottom();
      return messageGroup;
    }
  }, {
    key: "clearChatMessages",
    value: function clearChatMessages() {
      return regeneratorRuntime.async(function clearChatMessages$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              this.messages = [];
              this.chatContainer.empty();
              this.historyLoaded = false;

            case 3:
            case "end":
              return _context7.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "startVoiceRecognition",
    value: function startVoiceRecognition() {
      var _this7 = this;

      var voiceButton, stream, mediaRecorder, audioChunks;
      return regeneratorRuntime.async(function startVoiceRecognition$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              voiceButton = this.contentEl.querySelector(".voice-button");

              if (!(voiceButton == null ? void 0 : voiceButton.classList.contains("recording"))) {
                _context8.next = 4;
                break;
              }

              if (this.mediaRecorder && this.mediaRecorder.state === "recording") {
                this.mediaRecorder.stop();
              }

              return _context8.abrupt("return");

            case 4:
              _context8.prev = 4;
              _context8.next = 7;
              return regeneratorRuntime.awrap(navigator.mediaDevices.getUserMedia({
                audio: true
              }));

            case 7:
              stream = _context8.sent;
              mediaRecorder = new MediaRecorder(stream);
              this.mediaRecorder = mediaRecorder;
              audioChunks = [];
              voiceButton == null ? void 0 : voiceButton.classList.add("recording");

              mediaRecorder.ondataavailable = function (event) {
                if (event.data.size > 0) {
                  console.log("Data available, size:", event.data.size);
                  audioChunks.push(event.data);
                }
              };

              mediaRecorder.onstop = function () {
                console.log("Recording stopped, chunks:", audioChunks.length);
                voiceButton == null ? void 0 : voiceButton.classList.remove("recording");
                stream.getTracks().forEach(function (track) {
                  return track.stop();
                });
                _this7.inputEl.placeholder = "Type a message...";

                if (audioChunks.length > 0) {
                  var audioBlob = new Blob(audioChunks, {
                    type: mediaRecorder.mimeType
                  });
                  console.log("Audio blob created, type:", mediaRecorder.mimeType, "size:", audioBlob.size);

                  if (_this7.speechWorker) {
                    _this7.speechWorker.postMessage({
                      apiKey: _this7.plugin.settings.googleApiKey,
                      audioBlob: audioBlob
                    });
                  }
                } else {
                  console.error("No audio data recorded");
                }
              };

              mediaRecorder.start(100);
              console.log("Recording started with mime type:", mediaRecorder.mimeType);
              this.inputEl.placeholder = "Record...";
              setTimeout(function () {
                if (mediaRecorder.state === "recording") {
                  mediaRecorder.stop();
                  console.log("Recording stopped after timeout");
                }
              }, 5e3);
              _context8.next = 24;
              break;

            case 20:
              _context8.prev = 20;
              _context8.t0 = _context8["catch"](4);
              console.error("Error accessing microphone:", _context8.t0);
              voiceButton == null ? void 0 : voiceButton.classList.remove("recording");

            case 24:
            case "end":
              return _context8.stop();
          }
        }
      }, null, this, [[4, 20]]);
    }
  }]);

  return _OllamaView;
}(import_obsidian.ItemView);

var OllamaView = _OllamaView;
OllamaView.instance = null; // settings.ts

var import_obsidian2 = require("obsidian");

var DEFAULT_SETTINGS = {
  modelName: "mistral",
  ollamaServerUrl: "http://localhost:11434",
  logFileSizeLimit: 1024,
  saveMessageHistory: true,
  ragEnabled: false,
  ragFolderPath: "data",
  contextWindowSize: 5,
  googleApiKey: "",
  speechLanguage: "uk-UA",
  maxRecordingTime: 15,
  silenceDetection: true
};

var OllamaSettingTab =
/*#__PURE__*/
function (_import_obsidian2$Plu) {
  _inherits(OllamaSettingTab, _import_obsidian2$Plu);

  function OllamaSettingTab(app, plugin) {
    var _this8;

    _classCallCheck(this, OllamaSettingTab);

    _this8 = _possibleConstructorReturn(this, _getPrototypeOf(OllamaSettingTab).call(this, app, plugin));
    _this8.plugin = plugin;
    return _this8;
  }

  _createClass(OllamaSettingTab, [{
    key: "getDisplayText",
    value: function getDisplayText() {
      return "Ollama";
    }
  }, {
    key: "getId",
    value: function getId() {
      return "ollama-plugin";
    }
  }, {
    key: "display",
    value: function display() {
      var _this9 = this;

      var containerEl, availableModels, selectedModel, modelSetting, dropdown;
      return regeneratorRuntime.async(function display$(_context22) {
        while (1) {
          switch (_context22.prev = _context22.next) {
            case 0:
              containerEl = this.containerEl;
              containerEl.empty();
              new import_obsidian2.Setting(containerEl).setName("Ollama Server URL").setDesc("IP address and port where Ollama is running (e.g. http://192.168.1.10:11434)").addText(function (text) {
                return text.setPlaceholder("http://localhost:11434").setValue(_this9.plugin.settings.ollamaServerUrl).onChange(function _callee2(value) {
                  return regeneratorRuntime.async(function _callee2$(_context9) {
                    while (1) {
                      switch (_context9.prev = _context9.next) {
                        case 0:
                          _this9.plugin.settings.ollamaServerUrl = value;
                          _context9.next = 3;
                          return regeneratorRuntime.awrap(_this9.plugin.saveSettings());

                        case 3:
                        case "end":
                          return _context9.stop();
                      }
                    }
                  });
                });
              });
              new import_obsidian2.Setting(containerEl).setName("Server Connection").setDesc("Reconnect to local model server and refresh available models").addButton(function (button) {
                return button.setButtonText("Reconnect").setIcon("refresh-cw").onClick(function _callee3() {
                  var response;
                  return regeneratorRuntime.async(function _callee3$(_context10) {
                    while (1) {
                      switch (_context10.prev = _context10.next) {
                        case 0:
                          _context10.prev = 0;
                          new import_obsidian2.Notice("Connecting to Ollama server...");
                          _context10.next = 4;
                          return regeneratorRuntime.awrap(fetch("".concat(_this9.plugin.settings.ollamaServerUrl, "/api/tags"), {
                            method: "GET",
                            headers: {
                              "Content-Type": "application/json"
                            }
                          }));

                        case 4:
                          response = _context10.sent;

                          if (response.ok) {
                            new import_obsidian2.Notice("Successfully connected to Ollama server!");
                            containerEl.empty();

                            _this9.display();
                          } else {
                            new import_obsidian2.Notice("Failed to connect to Ollama server. Check the URL and ensure the server is running.");
                          }

                          _context10.next = 11;
                          break;

                        case 8:
                          _context10.prev = 8;
                          _context10.t0 = _context10["catch"](0);
                          new import_obsidian2.Notice("Connection error. Please check the server URL and your network connection.");

                        case 11:
                        case "end":
                          return _context10.stop();
                      }
                    }
                  }, null, null, [[0, 8]]);
                });
              });
              availableModels = [];
              _context22.prev = 5;
              _context22.next = 8;
              return regeneratorRuntime.awrap(this.plugin.apiService.getModels());

            case 8:
              availableModels = _context22.sent;
              _context22.next = 14;
              break;

            case 11:
              _context22.prev = 11;
              _context22.t0 = _context22["catch"](5);
              console.error("Error fetching available models:", _context22.t0);

            case 14:
              selectedModel = availableModels.includes(this.plugin.settings.modelName) ? this.plugin.settings.modelName : availableModels.length > 0 ? availableModels[0] : "";
              modelSetting = new import_obsidian2.Setting(containerEl).setName("Model Name").setDesc("Select the language model to use");
              dropdown = modelSetting.addDropdown(function (dropdown2) {
                var selectEl = dropdown2.selectEl;

                while (selectEl.firstChild) {
                  selectEl.removeChild(selectEl.firstChild);
                }

                availableModels.forEach(function (model) {
                  dropdown2.addOption(model, model);
                });

                if (availableModels.length === 0) {
                  dropdown2.addOption("", "No models available");
                }

                dropdown2.setValue(selectedModel);
                dropdown2.onChange(function _callee4(value) {
                  return regeneratorRuntime.async(function _callee4$(_context11) {
                    while (1) {
                      switch (_context11.prev = _context11.next) {
                        case 0:
                          _this9.plugin.settings.modelName = value;
                          _context11.next = 3;
                          return regeneratorRuntime.awrap(_this9.plugin.saveSettings());

                        case 3:
                        case "end":
                          return _context11.stop();
                      }
                    }
                  });
                });
              });
              new import_obsidian2.Setting(containerEl).setName("Save Message History").setDesc("Save chat message history between sessions").addToggle(function (toggle) {
                return toggle.setValue(_this9.plugin.settings.saveMessageHistory).onChange(function _callee5(value) {
                  return regeneratorRuntime.async(function _callee5$(_context12) {
                    while (1) {
                      switch (_context12.prev = _context12.next) {
                        case 0:
                          _this9.plugin.settings.saveMessageHistory = value;
                          _context12.next = 3;
                          return regeneratorRuntime.awrap(_this9.plugin.saveSettings());

                        case 3:
                        case "end":
                          return _context12.stop();
                      }
                    }
                  });
                });
              });
              new import_obsidian2.Setting(containerEl).setName("Log File Size Limit").setDesc("Maximum size of message history log file in KB (1024 KB = 1 MB)").addSlider(function (slider) {
                return slider.setLimits(256, 10240, 256).setValue(_this9.plugin.settings.logFileSizeLimit).setDynamicTooltip().onChange(function _callee6(value) {
                  return regeneratorRuntime.async(function _callee6$(_context13) {
                    while (1) {
                      switch (_context13.prev = _context13.next) {
                        case 0:
                          _this9.plugin.settings.logFileSizeLimit = value;
                          _context13.next = 3;
                          return regeneratorRuntime.awrap(_this9.plugin.saveSettings());

                        case 3:
                        case "end":
                          return _context13.stop();
                      }
                    }
                  });
                });
              }).addExtraButton(function (button) {
                return button.setIcon("reset").setTooltip("Reset to default (1024 KB)").onClick(function _callee7() {
                  return regeneratorRuntime.async(function _callee7$(_context14) {
                    while (1) {
                      switch (_context14.prev = _context14.next) {
                        case 0:
                          _this9.plugin.settings.logFileSizeLimit = DEFAULT_SETTINGS.logFileSizeLimit;
                          _context14.next = 3;
                          return regeneratorRuntime.awrap(_this9.plugin.saveSettings());

                        case 3:
                          _this9.display();

                        case 4:
                        case "end":
                          return _context14.stop();
                      }
                    }
                  });
                });
              });
              new import_obsidian2.Setting(containerEl).setName("Clear History").setDesc("Delete all chat history").addButton(function (button) {
                return button.setButtonText("Clear").onClick(function _callee8() {
                  return regeneratorRuntime.async(function _callee8$(_context15) {
                    while (1) {
                      switch (_context15.prev = _context15.next) {
                        case 0:
                          _context15.next = 2;
                          return regeneratorRuntime.awrap(_this9.plugin.clearMessageHistory());

                        case 2:
                          new import_obsidian2.Notice("Chat history cleared.");

                        case 3:
                        case "end":
                          return _context15.stop();
                      }
                    }
                  });
                });
              });
              new import_obsidian2.Setting(containerEl).setName("Enable RAG").setDesc("Use Retrieval Augmented Generation with your notes").addToggle(function (toggle) {
                return toggle.setValue(_this9.plugin.settings.ragEnabled).onChange(function _callee9(value) {
                  return regeneratorRuntime.async(function _callee9$(_context16) {
                    while (1) {
                      switch (_context16.prev = _context16.next) {
                        case 0:
                          _this9.plugin.settings.ragEnabled = value;
                          _context16.next = 3;
                          return regeneratorRuntime.awrap(_this9.plugin.saveSettings());

                        case 3:
                        case "end":
                          return _context16.stop();
                      }
                    }
                  });
                });
              });
              new import_obsidian2.Setting(containerEl).setName("RAG Folder Path").setDesc("Path to the folder containing notes for RAG (relative to vault root)").addText(function (text) {
                return text.setPlaceholder("data").setValue(_this9.plugin.settings.ragFolderPath).onChange(function _callee10(value) {
                  return regeneratorRuntime.async(function _callee10$(_context17) {
                    while (1) {
                      switch (_context17.prev = _context17.next) {
                        case 0:
                          _this9.plugin.settings.ragFolderPath = value;
                          _context17.next = 3;
                          return regeneratorRuntime.awrap(_this9.plugin.saveSettings());

                        case 3:
                        case "end":
                          return _context17.stop();
                      }
                    }
                  });
                });
              });
              new import_obsidian2.Setting(containerEl).setName("Context Window Size").setDesc("Number of relevant documents to include in context").addSlider(function (slider) {
                return slider.setLimits(1, 10, 1).setValue(_this9.plugin.settings.contextWindowSize).setDynamicTooltip().onChange(function _callee11(value) {
                  return regeneratorRuntime.async(function _callee11$(_context18) {
                    while (1) {
                      switch (_context18.prev = _context18.next) {
                        case 0:
                          _this9.plugin.settings.contextWindowSize = value;
                          _context18.next = 3;
                          return regeneratorRuntime.awrap(_this9.plugin.saveSettings());

                        case 3:
                        case "end":
                          return _context18.stop();
                      }
                    }
                  });
                });
              });
              new import_obsidian2.Setting(containerEl).setName("Google API Key").setDesc("API key for Google Speech-to-Text service").addText(function (text) {
                return text.setPlaceholder("Enter your Google API key").setValue(_this9.plugin.settings.googleApiKey).onChange(function _callee12(value) {
                  return regeneratorRuntime.async(function _callee12$(_context19) {
                    while (1) {
                      switch (_context19.prev = _context19.next) {
                        case 0:
                          _this9.plugin.settings.googleApiKey = value;
                          _context19.next = 3;
                          return regeneratorRuntime.awrap(_this9.plugin.saveSettings());

                        case 3:
                        case "end":
                          return _context19.stop();
                      }
                    }
                  });
                });
              });
              new import_obsidian2.Setting(containerEl).setName("Speech Recognition Language").setDesc("Language code for Google Speech-to-Text (e.g., uk-UA, en-US, ru-RU)").addText(function (text) {
                return text.setPlaceholder("uk-UA").setValue(_this9.plugin.settings.speechLanguage).onChange(function _callee13(value) {
                  return regeneratorRuntime.async(function _callee13$(_context20) {
                    while (1) {
                      switch (_context20.prev = _context20.next) {
                        case 0:
                          _this9.plugin.settings.speechLanguage = value;
                          _context20.next = 3;
                          return regeneratorRuntime.awrap(_this9.plugin.saveSettings());

                        case 3:
                        case "end":
                          return _context20.stop();
                      }
                    }
                  });
                });
              });
              new import_obsidian2.Setting(containerEl).setName("Maximum Recording Time").setDesc("Maximum time (in seconds) to record before automatically stopping").addSlider(function (slider) {
                return slider.setLimits(5, 60, 5).setValue(_this9.plugin.settings.maxRecordingTime).setDynamicTooltip().onChange(function _callee14(value) {
                  return regeneratorRuntime.async(function _callee14$(_context21) {
                    while (1) {
                      switch (_context21.prev = _context21.next) {
                        case 0:
                          _this9.plugin.settings.maxRecordingTime = value;
                          _context21.next = 3;
                          return regeneratorRuntime.awrap(_this9.plugin.saveSettings());

                        case 3:
                        case "end":
                          return _context21.stop();
                      }
                    }
                  });
                });
              });

            case 26:
            case "end":
              return _context22.stop();
          }
        }
      }, null, this, [[5, 11]]);
    }
  }]);

  return OllamaSettingTab;
}(import_obsidian2.PluginSettingTab); // ragService.ts


var RagService =
/*#__PURE__*/
function () {
  function RagService(plugin) {
    _classCallCheck(this, RagService);

    this.documents = [];
    this.isIndexing = false;
    this.plugin = plugin;
  }
  /**
   * Index all markdown files in the specified folder path
   */


  _createClass(RagService, [{
    key: "indexDocuments",
    value: function indexDocuments() {
      var _a, _b, folderPath, vault, allFiles, files, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, file, content;

      return regeneratorRuntime.async(function indexDocuments$(_context23) {
        while (1) {
          switch (_context23.prev = _context23.next) {
            case 0:
              if (!this.isIndexing) {
                _context23.next = 2;
                break;
              }

              return _context23.abrupt("return");

            case 2:
              this.isIndexing = true;
              _context23.prev = 3;
              folderPath = this.plugin.settings.ragFolderPath;
              vault = this.plugin.app.vault;
              console.log("RAG folder path: \"".concat(folderPath, "\""));
              allFiles = vault.getFiles();
              console.log("Total files in vault: ".concat(allFiles.length));
              _context23.next = 11;
              return regeneratorRuntime.awrap(this.getMarkdownFiles(vault, folderPath));

            case 11:
              files = _context23.sent;
              console.log("Found ".concat(files.length, " markdown files from \"").concat(folderPath, "\""));
              console.log("Indexing ".concat(files.length, " markdown files from ").concat(folderPath));
              this.documents = [];
              _iteratorNormalCompletion3 = true;
              _didIteratorError3 = false;
              _iteratorError3 = undefined;
              _context23.prev = 18;
              _iterator3 = files[Symbol.iterator]();

            case 20:
              if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
                _context23.next = 35;
                break;
              }

              file = _step3.value;
              _context23.prev = 22;
              _context23.next = 25;
              return regeneratorRuntime.awrap(vault.read(file));

            case 25:
              content = _context23.sent;
              this.documents.push({
                path: file.path,
                content: content,
                metadata: {
                  filename: file.name,
                  created: (_a = file.stat) == null ? void 0 : _a.ctime,
                  modified: (_b = file.stat) == null ? void 0 : _b.mtime
                }
              });
              _context23.next = 32;
              break;

            case 29:
              _context23.prev = 29;
              _context23.t0 = _context23["catch"](22);
              console.error("Error reading file ".concat(file.path, ":"), _context23.t0);

            case 32:
              _iteratorNormalCompletion3 = true;
              _context23.next = 20;
              break;

            case 35:
              _context23.next = 41;
              break;

            case 37:
              _context23.prev = 37;
              _context23.t1 = _context23["catch"](18);
              _didIteratorError3 = true;
              _iteratorError3 = _context23.t1;

            case 41:
              _context23.prev = 41;
              _context23.prev = 42;

              if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                _iterator3["return"]();
              }

            case 44:
              _context23.prev = 44;

              if (!_didIteratorError3) {
                _context23.next = 47;
                break;
              }

              throw _iteratorError3;

            case 47:
              return _context23.finish(44);

            case 48:
              return _context23.finish(41);

            case 49:
              console.log("Indexed ".concat(this.documents.length, " documents for RAG"));
              _context23.next = 55;
              break;

            case 52:
              _context23.prev = 52;
              _context23.t2 = _context23["catch"](3);
              console.error("Error indexing documents:", _context23.t2);

            case 55:
              _context23.prev = 55;
              this.isIndexing = false;
              return _context23.finish(55);

            case 58:
            case "end":
              return _context23.stop();
          }
        }
      }, null, this, [[3, 52, 55, 58], [18, 37, 41, 49], [22, 29], [42,, 44, 48]]);
    }
    /**
     * Get all markdown files in the specified folder path
     */

  }, {
    key: "getMarkdownFiles",
    value: function getMarkdownFiles(vault, folderPath) {
      var files, normalizedFolderPath, isRootPath, allFiles, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, file;

      return regeneratorRuntime.async(function getMarkdownFiles$(_context24) {
        while (1) {
          switch (_context24.prev = _context24.next) {
            case 0:
              files = [];
              normalizedFolderPath = folderPath;

              if (normalizedFolderPath && !normalizedFolderPath.endsWith("/")) {
                normalizedFolderPath += "/";
              }

              isRootPath = !normalizedFolderPath || normalizedFolderPath === "/";
              console.log("Normalized path: \"".concat(normalizedFolderPath, "\", isRoot: ").concat(isRootPath));
              allFiles = vault.getFiles();
              _iteratorNormalCompletion4 = true;
              _didIteratorError4 = false;
              _iteratorError4 = undefined;
              _context24.prev = 9;

              for (_iterator4 = allFiles[Symbol.iterator](); !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                file = _step4.value;

                if (file.extension === "md") {
                  if (isRootPath || file.path.startsWith(normalizedFolderPath)) {
                    console.log("Adding file: ".concat(file.path));
                    files.push(file);
                  } else {}
                }
              }

              _context24.next = 17;
              break;

            case 13:
              _context24.prev = 13;
              _context24.t0 = _context24["catch"](9);
              _didIteratorError4 = true;
              _iteratorError4 = _context24.t0;

            case 17:
              _context24.prev = 17;
              _context24.prev = 18;

              if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                _iterator4["return"]();
              }

            case 20:
              _context24.prev = 20;

              if (!_didIteratorError4) {
                _context24.next = 23;
                break;
              }

              throw _iteratorError4;

            case 23:
              return _context24.finish(20);

            case 24:
              return _context24.finish(17);

            case 25:
              return _context24.abrupt("return", files);

            case 26:
            case "end":
              return _context24.stop();
          }
        }
      }, null, null, [[9, 13, 17, 25], [18,, 20, 24]]);
    }
    /**
     * Simple search implementation to find relevant documents for a query
     * Later this could be replaced with a more sophisticated vector search
     */

  }, {
    key: "findRelevantDocuments",
    value: function findRelevantDocuments(query) {
      var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;

      if (!this.documents.length) {
        return [];
      }

      var scoredDocs = this.documents.map(function (doc) {
        var lowerContent = doc.content.toLowerCase();
        var lowerQuery = query.toLowerCase();
        var terms = lowerQuery.split(/\s+/);
        var score = 0;
        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
          for (var _iterator5 = terms[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            var term = _step5.value;

            if (term.length > 2) {
              var regex = new RegExp(term, "gi");
              var matches = lowerContent.match(regex);

              if (matches) {
                score += matches.length;
              }
            }
          }
        } catch (err) {
          _didIteratorError5 = true;
          _iteratorError5 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
              _iterator5["return"]();
            }
          } finally {
            if (_didIteratorError5) {
              throw _iteratorError5;
            }
          }
        }

        return {
          doc: doc,
          score: score
        };
      });
      return scoredDocs.sort(function (a, b) {
        return b.score - a.score;
      }).slice(0, limit).map(function (item) {
        return item.doc;
      });
    }
    /**
     * Prepare context from relevant documents
     */

  }, {
    key: "prepareContext",
    value: function prepareContext(query) {
      if (!this.plugin.settings.ragEnabled || this.documents.length === 0) {
        return "";
      }

      var limit = this.plugin.settings.contextWindowSize;
      var relevantDocs = this.findRelevantDocuments(query, limit);

      if (relevantDocs.length === 0) {
        return "";
      }

      var context = "### Context from your notes:\n\n";
      relevantDocs.forEach(function (doc, index) {
        var _a;

        context += "Document ".concat(index + 1, " (").concat((_a = doc.metadata) == null ? void 0 : _a.filename, "):\n");
        var maxChars = 1500;
        var content = doc.content.length > maxChars ? doc.content.substring(0, maxChars) + "..." : doc.content;
        context += content + "\n\n";
      });
      context += "### End of context\n\n";
      return context;
    }
  }]);

  return RagService;
}(); // apiServices.ts


var ApiService =
/*#__PURE__*/
function () {
  function ApiService(baseUrl) {
    _classCallCheck(this, ApiService);

    this.baseUrl = baseUrl;
  }
  /**
   * Set base URL for the API
   */


  _createClass(ApiService, [{
    key: "setBaseUrl",
    value: function setBaseUrl(url) {
      this.baseUrl = url;
    }
    /**
     * Generate response from Ollama
     */

  }, {
    key: "generateResponse",
    value: function generateResponse(model, prompt) {
      var response, errorText;
      return regeneratorRuntime.async(function generateResponse$(_context25) {
        while (1) {
          switch (_context25.prev = _context25.next) {
            case 0:
              _context25.next = 2;
              return regeneratorRuntime.awrap(fetch("".concat(this.baseUrl, "/api/generate"), {
                method: "POST",
                headers: {
                  "Content-Type": "application/json"
                },
                body: JSON.stringify({
                  model: model,
                  prompt: prompt,
                  stream: false
                })
              }));

            case 2:
              response = _context25.sent;

              if (response.ok) {
                _context25.next = 8;
                break;
              }

              _context25.next = 6;
              return regeneratorRuntime.awrap(response.text());

            case 6:
              errorText = _context25.sent;
              throw new Error("HTTP error! Status: ".concat(response.status, ", ").concat(errorText));

            case 8:
              _context25.next = 10;
              return regeneratorRuntime.awrap(response.json());

            case 10:
              return _context25.abrupt("return", _context25.sent);

            case 11:
            case "end":
              return _context25.stop();
          }
        }
      }, null, this);
    }
    /**
     * Get available models from Ollama
     */

  }, {
    key: "getModels",
    value: function getModels() {
      var response, data;
      return regeneratorRuntime.async(function getModels$(_context26) {
        while (1) {
          switch (_context26.prev = _context26.next) {
            case 0:
              _context26.prev = 0;
              _context26.next = 3;
              return regeneratorRuntime.awrap(fetch("".concat(this.baseUrl, "/api/tags"), {
                method: "GET",
                headers: {
                  "Content-Type": "application/json"
                }
              }));

            case 3:
              response = _context26.sent;

              if (response.ok) {
                _context26.next = 6;
                break;
              }

              throw new Error("HTTP error! Status: ".concat(response.status));

            case 6:
              _context26.next = 8;
              return regeneratorRuntime.awrap(response.json());

            case 8:
              data = _context26.sent;

              if (!Array.isArray(data.models)) {
                _context26.next = 11;
                break;
              }

              return _context26.abrupt("return", data.models.map(function (model) {
                return _typeof(model) === "object" ? model.name : model;
              }));

            case 11:
              return _context26.abrupt("return", []);

            case 14:
              _context26.prev = 14;
              _context26.t0 = _context26["catch"](0);
              console.error("Error fetching models:", _context26.t0);
              return _context26.abrupt("return", []);

            case 18:
            case "end":
              return _context26.stop();
          }
        }
      }, null, this, [[0, 14]]);
    }
  }]);

  return ApiService;
}(); // main.ts


var OllamaPlugin =
/*#__PURE__*/
function (_import_obsidian3$Plu) {
  _inherits(OllamaPlugin, _import_obsidian3$Plu);

  function OllamaPlugin() {
    var _this10;

    _classCallCheck(this, OllamaPlugin);

    _this10 = _possibleConstructorReturn(this, _getPrototypeOf(OllamaPlugin).apply(this, arguments));
    _this10.view = null;
    _this10.documents = [];
    _this10.embeddings = []; // Add debouncing to prevent excessive indexing

    _this10.indexUpdateTimeout = null;
    return _this10;
  }

  _createClass(OllamaPlugin, [{
    key: "onload",
    value: function onload() {
      var _this11 = this;

      return regeneratorRuntime.async(function onload$(_context28) {
        while (1) {
          switch (_context28.prev = _context28.next) {
            case 0:
              console.log("Ollama Plugin Loaded!");
              _context28.next = 3;
              return regeneratorRuntime.awrap(this.loadSettings());

            case 3:
              this.apiService = new ApiService(this.settings.ollamaServerUrl);
              this.ragService = new RagService(this);
              this.registerView(VIEW_TYPE_OLLAMA, function (leaf) {
                _this11.view = new OllamaView(leaf, _this11);
                return _this11.view;
              });
              this.addRibbonIcon("message-square", "\u0412\u0456\u0434\u043A\u0440\u0438\u0442\u0438 Ollama", function () {
                _this11.activateView();
              });
              this.addCommand({
                id: "open-ollama-view",
                name: "\u0412\u0456\u0434\u043A\u0440\u0438\u0442\u0438 Ollama Chat",
                callback: function callback() {
                  _this11.activateView();
                }
              });
              this.addCommand({
                id: "index-rag-documents",
                name: "\u0406\u043D\u0434\u0435\u043A\u0441\u0443\u0432\u0430\u0442\u0438 \u0434\u043E\u043A\u0443\u043C\u0435\u043D\u0442\u0438 \u0434\u043B\u044F RAG",
                callback: function callback() {
                  return regeneratorRuntime.async(function callback$(_context27) {
                    while (1) {
                      switch (_context27.prev = _context27.next) {
                        case 0:
                          _context27.next = 2;
                          return regeneratorRuntime.awrap(_this11.ragService.indexDocuments());

                        case 2:
                        case "end":
                          return _context27.stop();
                      }
                    }
                  });
                }
              });
              this.settingTab = new OllamaSettingTab(this.app, this);
              this.addSettingTab(this.settingTab);
              this.app.workspace.onLayoutReady(function () {
                var existingLeaf = _this11.app.workspace.getLeavesOfType(VIEW_TYPE_OLLAMA)[0];

                if (!existingLeaf) {
                  _this11.activateView();
                } else {
                  console.log("Ollama view already exists, not creating a new one");
                }

                if (_this11.settings.ragEnabled) {
                  _this11.ragService.indexDocuments();
                }
              });
              this.registerEvent(this.app.vault.on("modify", function () {
                if (_this11.settings.ragEnabled) {
                  _this11.debounceIndexUpdate();
                }
              }));

            case 13:
            case "end":
              return _context28.stop();
          }
        }
      }, null, this);
    } // Update API service when settings change

  }, {
    key: "updateApiService",
    value: function updateApiService() {
      this.apiService.setBaseUrl(this.settings.ollamaServerUrl);
    }
  }, {
    key: "debounceIndexUpdate",
    value: function debounceIndexUpdate() {
      var _this12 = this;

      if (this.indexUpdateTimeout) {
        clearTimeout(this.indexUpdateTimeout);
      }

      this.indexUpdateTimeout = setTimeout(function () {
        _this12.ragService.indexDocuments();

        _this12.indexUpdateTimeout = null;
      }, 3e4);
    }
  }, {
    key: "activateView",
    value: function activateView() {
      var _a, workspace, leaf;

      return regeneratorRuntime.async(function activateView$(_context29) {
        while (1) {
          switch (_context29.prev = _context29.next) {
            case 0:
              workspace = this.app.workspace;
              leaf = workspace.getLeavesOfType(VIEW_TYPE_OLLAMA)[0];

              if (leaf) {
                _context29.next = 9;
                break;
              }

              console.log("Creating new Ollama view leaf");
              leaf = (_a = workspace.getRightLeaf(false)) != null ? _a : workspace.getLeaf();
              _context29.next = 7;
              return regeneratorRuntime.awrap(leaf.setViewState({
                type: VIEW_TYPE_OLLAMA,
                active: true
              }));

            case 7:
              _context29.next = 10;
              break;

            case 9:
              console.log("Ollama view leaf already exists");

            case 10:
              workspace.revealLeaf(leaf);
              return _context29.abrupt("return", leaf);

            case 12:
            case "end":
              return _context29.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "loadSettings",
    value: function loadSettings() {
      return regeneratorRuntime.async(function loadSettings$(_context30) {
        while (1) {
          switch (_context30.prev = _context30.next) {
            case 0:
              _context30.t0 = Object;
              _context30.t1 = {};
              _context30.t2 = DEFAULT_SETTINGS;
              _context30.next = 5;
              return regeneratorRuntime.awrap(this.loadData());

            case 5:
              _context30.t3 = _context30.sent;
              this.settings = _context30.t0.assign.call(_context30.t0, _context30.t1, _context30.t2, _context30.t3);

            case 7:
            case "end":
              return _context30.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "saveSettings",
    value: function saveSettings() {
      return regeneratorRuntime.async(function saveSettings$(_context31) {
        while (1) {
          switch (_context31.prev = _context31.next) {
            case 0:
              _context31.next = 2;
              return regeneratorRuntime.awrap(this.saveData(this.settings));

            case 2:
              this.updateApiService();

            case 3:
            case "end":
              return _context31.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "getOllamaApiUrl",
    value: function getOllamaApiUrl() {
      return this.settings.ollamaServerUrl || DEFAULT_SETTINGS.ollamaServerUrl;
    } // Функція для збереження історії повідомлень

  }, {
    key: "saveMessageHistory",
    value: function saveMessageHistory(messages) {
      var basePath, logPath, adapter, fileExists, fileSize, stat, backupPath, existingData, existingMessages, newMessages, merged, allMessages, trimmedMessages;
      return regeneratorRuntime.async(function saveMessageHistory$(_context32) {
        while (1) {
          switch (_context32.prev = _context32.next) {
            case 0:
              if (this.settings.saveMessageHistory) {
                _context32.next = 2;
                break;
              }

              return _context32.abrupt("return");

            case 2:
              _context32.prev = 2;
              basePath = this.app.vault.configDir + "/plugins/obsidian-ollama-duet";
              logPath = basePath + "/chat_history.json";
              adapter = this.app.vault.adapter;
              _context32.next = 8;
              return regeneratorRuntime.awrap(adapter.exists(logPath));

            case 8:
              fileExists = _context32.sent;
              fileSize = 0;

              if (!fileExists) {
                _context32.next = 15;
                break;
              }

              _context32.next = 13;
              return regeneratorRuntime.awrap(adapter.stat(logPath));

            case 13:
              stat = _context32.sent;
              fileSize = (stat == null ? void 0 : stat.size) ? stat.size / 1024 : 0;

            case 15:
              if (!(fileSize > this.settings.logFileSizeLimit)) {
                _context32.next = 29;
                break;
              }

              if (!fileExists) {
                _context32.next = 25;
                break;
              }

              backupPath = logPath + ".backup";
              _context32.next = 20;
              return regeneratorRuntime.awrap(adapter.exists(backupPath));

            case 20:
              if (!_context32.sent) {
                _context32.next = 23;
                break;
              }

              _context32.next = 23;
              return regeneratorRuntime.awrap(adapter.remove(backupPath));

            case 23:
              _context32.next = 25;
              return regeneratorRuntime.awrap(adapter.copy(logPath, backupPath));

            case 25:
              _context32.next = 27;
              return regeneratorRuntime.awrap(adapter.write(logPath, messages));

            case 27:
              _context32.next = 58;
              break;

            case 29:
              if (fileExists) {
                _context32.next = 34;
                break;
              }

              _context32.next = 32;
              return regeneratorRuntime.awrap(adapter.write(logPath, messages));

            case 32:
              _context32.next = 58;
              break;

            case 34:
              _context32.next = 36;
              return regeneratorRuntime.awrap(adapter.read(logPath));

            case 36:
              existingData = _context32.sent;
              _context32.prev = 37;
              existingMessages = JSON.parse(existingData);
              newMessages = JSON.parse(messages);
              merged = JSON.stringify([].concat(_toConsumableArray(existingMessages), _toConsumableArray(newMessages)));

              if (!(merged.length / 1024 > this.settings.logFileSizeLimit)) {
                _context32.next = 49;
                break;
              }

              allMessages = [].concat(_toConsumableArray(existingMessages), _toConsumableArray(newMessages));
              trimmedMessages = allMessages;

              while (JSON.stringify(trimmedMessages).length / 1024 > this.settings.logFileSizeLimit) {
                trimmedMessages = trimmedMessages.slice(1);
              }

              _context32.next = 47;
              return regeneratorRuntime.awrap(adapter.write(logPath, JSON.stringify(trimmedMessages)));

            case 47:
              _context32.next = 51;
              break;

            case 49:
              _context32.next = 51;
              return regeneratorRuntime.awrap(adapter.write(logPath, merged));

            case 51:
              _context32.next = 58;
              break;

            case 53:
              _context32.prev = 53;
              _context32.t0 = _context32["catch"](37);
              console.error("Error parsing message history:", _context32.t0);
              _context32.next = 58;
              return regeneratorRuntime.awrap(adapter.write(logPath, messages));

            case 58:
              _context32.next = 63;
              break;

            case 60:
              _context32.prev = 60;
              _context32.t1 = _context32["catch"](2);
              console.error("Failed to save message history:", _context32.t1);

            case 63:
            case "end":
              return _context32.stop();
          }
        }
      }, null, this, [[2, 60], [37, 53]]);
    }
  }, {
    key: "loadMessageHistory",
    value: function loadMessageHistory() {
      var logPath, adapter, data;
      return regeneratorRuntime.async(function loadMessageHistory$(_context33) {
        while (1) {
          switch (_context33.prev = _context33.next) {
            case 0:
              if (this.settings.saveMessageHistory) {
                _context33.next = 2;
                break;
              }

              return _context33.abrupt("return", []);

            case 2:
              _context33.prev = 2;
              logPath = this.app.vault.configDir + "/plugins/obsidian-ollama-duet/chat_history.json";
              adapter = this.app.vault.adapter;
              _context33.next = 7;
              return regeneratorRuntime.awrap(adapter.exists(logPath));

            case 7:
              if (!_context33.sent) {
                _context33.next = 12;
                break;
              }

              _context33.next = 10;
              return regeneratorRuntime.awrap(adapter.read(logPath));

            case 10:
              data = _context33.sent;
              return _context33.abrupt("return", JSON.parse(data));

            case 12:
              _context33.next = 17;
              break;

            case 14:
              _context33.prev = 14;
              _context33.t0 = _context33["catch"](2);
              console.error("Failed to load message history:", _context33.t0);

            case 17:
              return _context33.abrupt("return", []);

            case 18:
            case "end":
              return _context33.stop();
          }
        }
      }, null, this, [[2, 14]]);
    }
  }, {
    key: "clearMessageHistory",
    value: function clearMessageHistory() {
      var logPath, adapter;
      return regeneratorRuntime.async(function clearMessageHistory$(_context34) {
        while (1) {
          switch (_context34.prev = _context34.next) {
            case 0:
              _context34.prev = 0;
              logPath = this.app.vault.configDir + "/plugins/obsidian-ollama-duet/chat_history.json";
              adapter = this.app.vault.adapter;
              _context34.next = 5;
              return regeneratorRuntime.awrap(adapter.exists(logPath));

            case 5:
              if (!_context34.sent) {
                _context34.next = 9;
                break;
              }

              _context34.next = 8;
              return regeneratorRuntime.awrap(adapter.remove(logPath));

            case 8:
              if (this.view) {
                this.view.clearChatMessages();
              }

            case 9:
              _context34.next = 14;
              break;

            case 11:
              _context34.prev = 11;
              _context34.t0 = _context34["catch"](0);
              console.error("Failed to clear message history:", _context34.t0);

            case 14:
            case "end":
              return _context34.stop();
          }
        }
      }, null, this, [[0, 11]]);
    }
  }]);

  return OllamaPlugin;
}(import_obsidian3.Plugin);