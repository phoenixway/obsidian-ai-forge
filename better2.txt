import {
  ItemView,
  WorkspaceLeaf,
  setIcon,
  MarkdownRenderer,
} from "obsidian";
import OllamaPlugin from "./main";
import { MessageService } from "./messageService";

export const VIEW_TYPE_OLLAMA = "ollama-chat-view";

interface Message {
  role: "user" | "assistant";
  content: string;
  timestamp: Date;
}

interface RequestOptions {
  num_ctx?: number;
}

export class OllamaView extends ItemView {
  private plugin: OllamaPlugin;
  private chatContainerEl: HTMLElement;
  private inputEl: HTMLTextAreaElement;
  private chatContainer: HTMLElement;
  private sendButton: HTMLElement;
  private voiceButton: HTMLElement;
  private menuButton: HTMLElement;
  private menuDropdown: HTMLElement;
  private settingsOption: HTMLElement;
  private messages: Message[] = [];
  private isProcessing: boolean = false;
  private historyLoaded: boolean = false;
  private scrollTimeout: NodeJS.Timeout | null = null;
  static instance: OllamaView | null = null;
  private speechWorker: Worker;
  private mediaRecorder: MediaRecorder | null = null;
  private systemMessageInterval: number = 0;
  private messagesPairCount: number = 0;
  private messageService: MessageService;
  private emptyStateEl: HTMLElement | null = null;

  constructor(leaf: WorkspaceLeaf, plugin: OllamaPlugin) {
    super(leaf);
    this.plugin = plugin;

    if (OllamaView.instance) {
      return OllamaView.instance;
    }
    OllamaView.instance = this;
    if (this.plugin.apiService) {
      this.plugin.apiService.setOllamaView(this);
    }

    this.mediaRecorder = null;

    try {
      const workerCode = `
        onmessage = async (event) => {
          try {
            const { apiKey, audioBlob, languageCode = 'uk-UA' } = event.data;
            console.log("Worker received audioBlob:", audioBlob);

            if (!apiKey || apiKey.trim() === '') {
              postMessage({ error: true, message: 'Google API Key is not configured. Please add it in plugin settings.' });
              return;
            }

            const url = "https://speech.googleapis.com/v1/speech:recognize?key=" + apiKey;

            const arrayBuffer = await audioBlob.arrayBuffer();
            const base64Audio = btoa(
              new Uint8Array(arrayBuffer).reduce(
                (data, byte) => data + String.fromCharCode(byte), ''
              )
            );

            console.log("Audio converted to Base64");

            const response = await fetch(url, {
              method: 'POST',
              body: JSON.stringify({
                config: {
                  encoding: 'WEBM_OPUS',
                  sampleRateHertz: 48000,
                  languageCode: languageCode,
                  model: 'latest_long',
                  enableAutomaticPunctuation: true,
                },
                audio: {
                  content: base64Audio
                },
              }),
              headers: {
                'Content-Type': 'application/json',
              },
            });

            if (!response.ok) {
              const errorData = await response.json();
              console.error("API error details:", errorData);
              postMessage({ 
                error: true, 
                message: "Error from Google Speech API: " + (errorData.error?.message || response.status)
              });
              return;
            }

            const data = await response.json();
            console.log("Speech recognition data:", data);

            if (data.results && data.results.length > 0) {
              const transcript = data.results
                .map(result => result.alternatives[0].transcript)
                .join(' ')
                .trim();

              postMessage(transcript);
            } else {
              postMessage({ error: true, message: 'No speech detected' });
            }
          } catch (error) {
            console.error('Error in speech recognition:', error);
            postMessage({ 
              error: true, 
              message: 'Error processing speech recognition: ' + error.message 
            });
          }
        };

        onerror = (event) => {
          console.error('Worker error:', event);
        };
      `;
      const workerBlob = new Blob([workerCode], { type: 'application/javascript' });
      const workerUrl = URL.createObjectURL(workerBlob);
      this.speechWorker = new Worker(workerUrl);
    } catch (error) {
      console.error("Failed to initialize worker:", error);
    }

    this.speechWorker.onmessage = (event) => {
      const data = event.data;
      console.log("Received data from worker:", data);

      if (data && typeof data === 'object' && data.error) {
        console.error("Speech recognition error:", data.message);
        return;
      }

      const transcript = typeof data === 'string' ? data : '';
      console.log("Received transcript from worker:", transcript);

      if (!transcript) return;

      const cursorPosition = this.inputEl.selectionStart || 0;
      const currentValue = this.inputEl.value;
      let insertText = transcript;
      if (cursorPosition > 0 && currentValue.charAt(cursorPosition - 1) !== ' ' && insertText.charAt(0) !== ' ') {
        insertText = ' ' + insertText;
      }

      const newValue = currentValue.substring(0, cursorPosition) +
        insertText +
        currentValue.substring(cursorPosition);

      this.inputEl.value = newValue;

      const newCursorPosition = cursorPosition + insertText.length;
      this.inputEl.setSelectionRange(newCursorPosition, newCursorPosition);
      this.inputEl.focus();
    };

    this.speechWorker.onerror = (error) => {
      console.error("Worker error:", error);
    };

    this.messageService = new MessageService(plugin);
    this.messageService.setView(this);
  }

  public getChatContainer(): HTMLElement {
    return this.chatContainer;
  }

  public clearChatContainer(): void {
    this.chatContainer.empty();
  }

  public scrollToBottom(): void {
    this.guaranteedScrollToBottom();
  }

  public clearInputField(): void {
    this.inputEl.value = "";
    setTimeout(() => {
      const event = new Event('input');
      this.inputEl.dispatchEvent(event);
    }, 100);
  }

  public createGroupElement(className: string): HTMLElement {
    return this.chatContainer.createDiv({
      cls: className,
    });
  }

  public createMessageElement(parent: HTMLElement, className: string): HTMLElement {
    return parent.createDiv({
      cls: className,
    });
  }

  public createContentContainer(parent: HTMLElement): HTMLElement {
    return parent.createDiv({
      cls: "message-content-container",
    });
  }

  public createContentElement(parent: HTMLElement): HTMLElement {
    return parent.createDiv({
      cls: "message-content",
    });
  }

  public addLoadingMessage(): HTMLElement {
    const messageGroup = this.chatContainer.createDiv({
      cls: "message-group ollama-message-group",
    });

    const messageEl = messageGroup.createDiv({
      cls: "message ollama-message ollama-message-tail",
    });

    const dotsContainer = messageEl.createDiv({
      cls: "thinking-dots",
    });

    for (let i = 0; i < 3; i++) {
      dotsContainer.createDiv({
        cls: "thinking-dot",
      });
    }

    this.guaranteedScrollToBottom();

    return messageGroup;
  }

  getViewType(): string {
    return VIEW_TYPE_OLLAMA;
  }

  async onOpen() {
    await this.setupUI();
    await this.loadMessages();
  }

  private async setupUI() {
    this.chatContainerEl = this.containerEl.createDiv({ cls: "chat-container" });
    this.inputEl = this.containerEl.createEl('textarea', { cls: 'input-area' });

    const buttonsContainer = this.containerEl.createDiv({ cls: 'buttons-container' });
    this.sendButton = buttonsContainer.createEl('button', { text: 'Send' });
    this.voiceButton = buttonsContainer.createEl('button', { text: 'Voice' });
    this.menuButton = buttonsContainer.createEl('button', { text: 'Menu' });

    this.attachEventListeners();
  }

  private attachEventListeners() {
    this.sendButton.onClick(() => this.sendMessage());
    this.voiceButton.onClick(() => this.startVoiceRecognition());
    this.menuButton.onClick(() => this.toggleMenu());

    this.inputEl.onKeyDown((e) => {
      if (e.key === 'Enter') {
        this.sendMessage();
      }
    });
  }

  private async sendMessage() {
    const content = this.inputEl.value.trim();
    if (content.length > 0) {
      this.addMessage("user", content);
      this.clearInputField();
      await this.processWithOllama(content);
    }
  }

  // Other methods remain largely unchanged, but ensure they are efficient and well-structured.
}