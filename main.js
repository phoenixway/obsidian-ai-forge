/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => OllamaPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian9 = require("obsidian");

// src/OllamaView.ts
var import_obsidian3 = require("obsidian");

// src/ConfirmModal.ts
var import_obsidian = require("obsidian");
var ConfirmModal = class extends import_obsidian.Modal {
  constructor(app, title, message, onConfirm) {
    super(app);
    this.title = title;
    this.message = message;
    this.onConfirm = onConfirm;
    this.title = title;
    this.message = message;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl, titleEl } = this;
    titleEl.setText(this.title);
    contentEl.createEl("p", { text: this.message });
    new import_obsidian.Setting(contentEl).addButton((button) => button.setButtonText("Confirm").setCta().onClick(() => {
      this.onConfirm();
      this.close();
    })).addButton((button) => button.setButtonText("Cancel").onClick(() => {
      this.close();
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/PromptModal.ts
var import_obsidian2 = require("obsidian");
var PromptModal = class extends import_obsidian2.Modal {
  constructor(app, title, promptText, initialValue = "", onSubmit) {
    super(app);
    this.title = title;
    this.promptText = promptText;
    this.initialValue = initialValue;
    this.onSubmit = onSubmit;
    // Приватний метод для обробки відправки (щоб уникнути дублювання коду для кнопки та Enter)
    this.submitInput = () => {
      this.onSubmit(this.inputValue);
      this.close();
    };
    this.title = title;
    this.promptText = promptText;
    this.inputValue = initialValue;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl, titleEl } = this;
    let textInput;
    titleEl.setText(this.title);
    if (this.promptText) {
      contentEl.createEl("p", { text: this.promptText });
    }
    new import_obsidian2.Setting(contentEl).setName("New value:").addText((text) => {
      textInput = text;
      text.setValue(this.inputValue).onChange((value) => {
        this.inputValue = value;
      });
      text.inputEl.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          this.submitInput();
        }
      });
    });
    new import_obsidian2.Setting(contentEl).addButton((button) => button.setButtonText("Submit").setCta().onClick(this.submitInput)).addButton((button) => button.setButtonText("Cancel").onClick(() => {
      this.close();
    }));
    setTimeout(() => {
      var _a, _b;
      (_a = textInput == null ? void 0 : textInput.inputEl) == null ? void 0 : _a.focus();
      (_b = textInput == null ? void 0 : textInput.inputEl) == null ? void 0 : _b.select();
    }, 50);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/OllamaView.ts
var VIEW_TYPE_OLLAMA_PERSONAS = "ollama-personas-chat-view";
var CSS_CLASS_CONTAINER = "ollama-container";
var CSS_CLASS_CHAT_CONTAINER = "ollama-chat-container";
var CSS_CLASS_INPUT_CONTAINER = "chat-input-container";
var CSS_CLASS_BUTTONS_CONTAINER = "buttons-container";
var CSS_CLASS_SEND_BUTTON = "send-button";
var CSS_CLASS_VOICE_BUTTON = "voice-button";
var CSS_CLASS_TRANSLATE_INPUT_BUTTON = "translate-input-button";
var CSS_CLASS_TRANSLATING_INPUT = "translating-input";
var CSS_CLASS_MENU_BUTTON = "menu-button";
var CSS_CLASS_MENU_DROPDOWN = "menu-dropdown";
var CSS_CLASS_MENU_OPTION = "menu-option";
var CSS_CLASS_MENU_HEADER_ITEM = "menu-header-item";
var CSS_CLASS_SUBMENU_ICON = "submenu-icon";
var CSS_CLASS_SUBMENU_CONTENT = "submenu-content";
var CSS_CLASS_SUBMENU_CONTENT_HIDDEN = "submenu-content-hidden";
var CSS_CLASS_SETTINGS_OPTION = "settings-option";
var CSS_CLASS_EMPTY_STATE = "ollama-empty-state";
var CSS_CLASS_MESSAGE_GROUP = "message-group";
var CSS_CLASS_USER_GROUP = "user-message-group";
var CSS_CLASS_OLLAMA_GROUP = "ollama-message-group";
var CSS_CLASS_SYSTEM_GROUP = "system-message-group";
var CSS_CLASS_ERROR_GROUP = "error-message-group";
var CSS_CLASS_MESSAGE = "message";
var CSS_CLASS_USER_MESSAGE = "user-message";
var CSS_CLASS_OLLAMA_MESSAGE = "ollama-message";
var CSS_CLASS_SYSTEM_MESSAGE = "system-message";
var CSS_CLASS_ERROR_MESSAGE = "error-message";
var CSS_CLASS_SYSTEM_ICON = "system-icon";
var CSS_CLASS_ERROR_ICON = "error-icon";
var CSS_CLASS_SYSTEM_TEXT = "system-message-text";
var CSS_CLASS_ERROR_TEXT = "error-message-text";
var CSS_CLASS_CONTENT_CONTAINER = "message-content-container";
var CSS_CLASS_CONTENT = "message-content";
var CSS_CLASS_THINKING_DOTS = "thinking-dots";
var CSS_CLASS_THINKING_DOT = "thinking-dot";
var CSS_CLASS_THINKING_BLOCK = "thinking-block";
var CSS_CLASS_THINKING_HEADER = "thinking-header";
var CSS_CLASS_THINKING_TOGGLE = "thinking-toggle";
var CSS_CLASS_THINKING_TITLE = "thinking-title";
var CSS_CLASS_THINKING_CONTENT = "thinking-content";
var CSS_CLASS_TIMESTAMP = "message-timestamp";
var CSS_CLASS_COPY_BUTTON = "copy-button";
var CSS_CLASS_TRANSLATE_BUTTON = "translate-button";
var CSS_CLASS_TRANSLATION_CONTAINER = "translation-container";
var CSS_CLASS_TRANSLATION_CONTENT = "translation-content";
var CSS_CLASS_TRANSLATION_PENDING = "translation-pending";
var CSS_CLASS_TEXTAREA_EXPANDED = "expanded";
var CSS_CLASS_RECORDING = "recording";
var CSS_CLASS_DISABLED = "disabled";
var CSS_CLASS_MESSAGE_ARRIVING = "message-arriving";
var CSS_CLASS_DATE_SEPARATOR = "chat-date-separator";
var CSS_CLASS_AVATAR = "message-group-avatar";
var CSS_CLASS_AVATAR_USER = "user-avatar";
var CSS_CLASS_AVATAR_AI = "ai-avatar";
var CSS_CLASS_CODE_BLOCK_COPY_BUTTON = "code-block-copy-button";
var CSS_CLASS_CODE_BLOCK_LANGUAGE = "code-block-language";
var CSS_CLASS_NEW_MESSAGE_INDICATOR = "new-message-indicator";
var CSS_CLASS_VISIBLE = "visible";
var CSS_CLASS_MENU_SEPARATOR = "menu-separator";
var CSS_CLASS_CLEAR_CHAT_OPTION = "clear-chat-option";
var CSS_CLASS_EXPORT_CHAT_OPTION = "export-chat-option";
var CSS_CLASS_CONTENT_COLLAPSIBLE = "message-content-collapsible";
var CSS_CLASS_CONTENT_COLLAPSED = "message-content-collapsed";
var CSS_CLASS_SHOW_MORE_BUTTON = "show-more-button";
var CSS_CLASS_MODEL_OPTION = "model-option";
var CSS_CLASS_MODEL_LIST_CONTAINER = "model-list-container";
var CSS_CLASS_ROLE_OPTION = "role-option";
var CSS_CLASS_ROLE_LIST_CONTAINER = "role-list-container";
var CSS_CLASS_CHAT_OPTION = "chat-option";
var CSS_CLASS_CHAT_LIST_CONTAINER = "chat-list-container";
var CSS_CLASS_MENU_HEADER = "menu-header";
var CSS_CLASS_NEW_CHAT_OPTION = "new-chat-option";
var CSS_CLASS_RENAME_CHAT_OPTION = "rename-chat-option";
var CSS_CLASS_DELETE_CHAT_OPTION = "delete-chat-option";
var CSS_CLASS_CLONE_CHAT_OPTION = "clone-chat-option";
var CSS_CLASS_DANGER_OPTION = "danger-option";
var LANGUAGES = {
  "af": "Afrikaans",
  "sq": "Albanian",
  "am": "Amharic",
  "ar": "Arabic",
  "hy": "Armenian",
  "az": "Azerbaijani",
  "eu": "Basque",
  "be": "Belarusian",
  "bn": "Bengali",
  "bs": "Bosnian",
  "bg": "Bulgarian",
  "ca": "Catalan",
  "ceb": "Cebuano",
  "ny": "Chichewa",
  "zh-CN": "Chinese (Simplified)",
  "zh-TW": "Chinese (Traditional)",
  "co": "Corsican",
  "hr": "Croatian",
  "cs": "Czech",
  "da": "Danish",
  "nl": "Dutch",
  "en": "English",
  "eo": "Esperanto",
  "et": "Estonian",
  "tl": "Filipino",
  "fi": "Finnish",
  "fr": "French",
  "fy": "Frisian",
  "gl": "Galician",
  "ka": "Georgian",
  "de": "German",
  "el": "Greek",
  "gu": "Gujarati",
  "ht": "Haitian Creole",
  "ha": "Hausa",
  "haw": "Hawaiian",
  "iw": "Hebrew",
  "he": "Hebrew",
  "hi": "Hindi",
  "hmn": "Hmong",
  "hu": "Hungarian",
  "is": "Icelandic",
  "ig": "Igbo",
  "id": "Indonesian",
  "ga": "Irish",
  "it": "Italian",
  "ja": "Japanese",
  "jw": "Javanese",
  "kn": "Kannada",
  "kk": "Kazakh",
  "km": "Khmer",
  "rw": "Kinyarwanda",
  "ko": "Korean",
  "ku": "Kurdish (Kurmanji)",
  "ky": "Kyrgyz",
  "lo": "Lao",
  "la": "Latin",
  "lv": "Latvian",
  "lt": "Lithuanian",
  "lb": "Luxembourgish",
  "mk": "Macedonian",
  "mg": "Malagasy",
  "ms": "Malay",
  "ml": "Malayalam",
  "mt": "Maltese",
  "mi": "Maori",
  "mr": "Marathi",
  "mn": "Mongolian",
  "my": "Myanmar (Burmese)",
  "ne": "Nepali",
  "no": "Norwegian",
  "or": "Odia (Oriya)",
  "ps": "Pashto",
  "fa": "Persian",
  "pl": "Polish",
  "pt": "Portuguese",
  "pa": "Punjabi",
  "ro": "Romanian",
  "ru": "Russian",
  "sm": "Samoan",
  "gd": "Scots Gaelic",
  "sr": "Serbian",
  "st": "Sesotho",
  "sn": "Shona",
  "sd": "Sindhi",
  "si": "Sinhala",
  "sk": "Slovak",
  "sl": "Slovenian",
  "so": "Somali",
  "es": "Spanish",
  "su": "Sundanese",
  "sw": "Swahili",
  "sv": "Swedish",
  "tg": "Tajik",
  "ta": "Tamil",
  "tt": "Tatar",
  "te": "Telugu",
  "th": "Thai",
  "tr": "Turkish",
  "tk": "Turkmen",
  "uk": "Ukrainian",
  "ur": "Urdu",
  "ug": "Uyghur",
  "uz": "Uzbek",
  "vi": "Vietnamese",
  "cy": "Welsh",
  "xh": "Xhosa",
  "yi": "Yiddish",
  "yo": "Yoruba",
  "zu": "Zulu"
};
var OllamaView = class extends import_obsidian3.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    // --- State ---
    this.isProcessing = false;
    this.scrollTimeout = null;
    this.speechWorker = null;
    this.mediaRecorder = null;
    this.audioStream = null;
    this.emptyStateEl = null;
    this.resizeTimeout = null;
    this.currentMessages = [];
    this.lastRenderedMessageDate = null;
    this.newMessagesIndicatorEl = null;
    this.userScrolledUp = false;
    // --- Event Handlers ---
    // Input & Sending
    this.handleKeyDown = (e) => {
      var _a;
      console.log(`[OllamaView Debug] handleKeyDown FIRED: Key=<span class="math-inline">{e.key}, Shift=</span>{e.shiftKey}, isProcessing=<span class="math-inline">{this.isProcessing}, sendButtonDisabled=</span>{this.sendButton?.disabled}`);
      if (e.key === "Enter" && !e.shiftKey && !this.isProcessing && !((_a = this.sendButton) == null ? void 0 : _a.disabled)) {
        console.log("[OllamaView Debug] Enter condition met - sending.");
        e.preventDefault();
        this.sendMessage();
      }
    };
    this.handleSendClick = () => {
      var _a;
      console.log(`[OllamaView Debug] handleSendClick FIRED: isProcessing=<span class="math-inline">{this.isProcessing}, sendButtonDisabled=</span>{this.sendButton?.disabled}`);
      if (!this.isProcessing && !((_a = this.sendButton) == null ? void 0 : _a.disabled)) {
        console.log("[OllamaView Debug] Send button clicked - sending message.");
        this.sendMessage();
      } else {
        console.log("[OllamaView Debug] Send button clicked, but ignored (processing or disabled).");
      }
    };
    this.handleInputForResize = () => {
      if (this.resizeTimeout)
        clearTimeout(this.resizeTimeout);
      this.resizeTimeout = setTimeout(() => {
        this.adjustTextareaHeight();
        this.updateSendButtonState();
      }, 50);
    };
    // Input Area Buttons
    this.handleVoiceClick = () => {
      this.toggleVoiceRecognition();
    };
    this.handleTranslateInputClick = async () => {
      const currentText = this.inputEl.value;
      const targetLang = "en";
      if (!currentText.trim()) {
        new import_obsidian3.Notice("Input empty...");
        return;
      }
      if (!this.plugin.settings.enableTranslation) {
        new import_obsidian3.Notice("Translation disabled...");
        return;
      }
      const apiKey = this.plugin.settings.googleTranslationApiKey;
      if (!apiKey) {
        new import_obsidian3.Notice("Translation API Key not set...");
        return;
      }
      (0, import_obsidian3.setIcon)(this.translateInputButton, "loader");
      this.translateInputButton.disabled = true;
      this.translateInputButton.classList.add(CSS_CLASS_TRANSLATING_INPUT);
      this.translateInputButton.title = "Translating...";
      try {
        const translatedText = await this.plugin.translationService.translate(currentText, targetLang);
        if (translatedText !== null) {
          this.inputEl.value = translatedText;
          this.inputEl.dispatchEvent(new Event("input"));
          this.inputEl.focus();
          const end = translatedText.length;
          this.inputEl.setSelectionRange(end, end);
        } else {
          console.warn("Input translation failed.");
        }
      } catch (error) {
        console.error("Input translation error:", error);
        new import_obsidian3.Notice("Input translation error.");
      } finally {
        (0, import_obsidian3.setIcon)(this.translateInputButton, "replace");
        this.translateInputButton.disabled = this.isProcessing;
        this.translateInputButton.classList.remove(CSS_CLASS_TRANSLATING_INPUT);
        this.translateInputButton.title = "Translate input to English";
      }
    };
    // Menu Button Click (Toggles Custom Div)
    this.handleMenuClick = (e) => {
      e.stopPropagation();
      if (!this.menuDropdown) {
        console.error("menuDropdown missing!");
        return;
      }
      const isHidden = this.menuDropdown.style.display === "none";
      if (isHidden) {
        console.log("[OllamaView Debug] Opening menu...");
        this.menuDropdown.style.display = "block";
        this.collapseAllSubmenus(null);
      } else {
        console.log("[OllamaView Debug] Closing menu...");
        this.closeMenu();
      }
    };
    // --- Action Handlers (Must call closeMenu) ---
    this.handleNewChatClick = async () => {
      this.closeMenu();
      console.log("[OllamaView Debug] Action: New Chat");
      try {
        const newChat = await this.plugin.chatManager.createNewChat();
        if (newChat) {
          new import_obsidian3.Notice(`Created new chat: ${newChat.metadata.name}`);
          this.focusInput();
        } else {
          new import_obsidian3.Notice("Failed to create new chat.");
        }
      } catch (error) {
        new import_obsidian3.Notice("Error creating new chat.");
      }
    };
    this.handleRenameChatClick = async () => {
      var _a;
      this.closeMenu();
      console.log("[OllamaView Debug] Action: Rename Chat");
      const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
      if (!activeChat) {
        new import_obsidian3.Notice("No active chat to rename.");
        return;
      }
      const currentName = activeChat.metadata.name;
      new PromptModal(this.app, "Rename Chat", `Enter new name for "${currentName}":`, currentName, async (newName) => {
        let noticeMessage = "Rename cancelled or name unchanged.";
        if (newName && newName.trim() !== "" && newName.trim() !== currentName) {
          const success = await this.plugin.chatManager.renameChat(activeChat.metadata.id, newName.trim());
          if (success) {
            noticeMessage = `Chat renamed to "${newName.trim()}"`;
          } else {
            noticeMessage = "Failed to rename chat.";
          }
        } else if ((newName == null ? void 0 : newName.trim()) === currentName) {
          noticeMessage = "Name unchanged.";
        } else {
          noticeMessage = "Rename cancelled or invalid name entered.";
        }
        new import_obsidian3.Notice(noticeMessage);
        this.focusInput();
      }).open();
    };
    this.handleCloneChatClick = async () => {
      var _a;
      this.closeMenu();
      console.log("[OllamaView Debug] Action: Clone Chat");
      const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
      if (!activeChat) {
        new import_obsidian3.Notice("No active chat to clone.");
        return;
      }
      const originalName = activeChat.metadata.name;
      const cloningNotice = new import_obsidian3.Notice("Cloning chat...", 0);
      try {
        const clonedChat = await this.plugin.chatManager.cloneChat(activeChat.metadata.id);
        if (clonedChat) {
          new import_obsidian3.Notice(`Chat cloned as "${clonedChat.metadata.name}" and activated.`);
        } else {
          new import_obsidian3.Notice("Failed to clone chat.");
        }
      } catch (error) {
        new import_obsidian3.Notice("An error occurred while cloning the chat.");
      } finally {
        cloningNotice.hide();
      }
    };
    this.handleClearChatClick = async () => {
      var _a;
      this.closeMenu();
      console.log("[OllamaView Debug] Action: Clear Chat");
      const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
      if (activeChat) {
        const chatName = activeChat.metadata.name;
        new ConfirmModal(this.app, "Clear Chat Messages", `Are you sure you want to clear all messages in chat "${chatName}"?
This action cannot be undone.`, () => {
          this.plugin.chatManager.clearActiveChatMessages();
        }).open();
      } else {
        new import_obsidian3.Notice("No active chat to clear.");
      }
    };
    this.handleDeleteChatClick = async () => {
      var _a;
      this.closeMenu();
      console.log("[OllamaView Debug] Action: Delete Chat");
      const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
      if (activeChat) {
        const chatName = activeChat.metadata.name;
        new ConfirmModal(this.app, "Delete Chat", `Are you sure you want to delete chat "${chatName}"?
This action cannot be undone.`, async () => {
          const success = await this.plugin.chatManager.deleteChat(activeChat.metadata.id);
          if (success) {
            new import_obsidian3.Notice(`Chat "${chatName}" deleted.`);
          } else {
            new import_obsidian3.Notice(`Failed to delete chat "${chatName}".`);
          }
        }).open();
      } else {
        new import_obsidian3.Notice("No active chat to delete.");
      }
    };
    this.handleExportChatClick = async () => {
      var _a, _b;
      this.closeMenu();
      console.log("[OllamaView Debug] Action: Export Chat");
      const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
      if (!activeChat || activeChat.messages.length === 0) {
        new import_obsidian3.Notice("Chat empty, nothing to export.");
        return;
      }
      try {
        const md = this.formatChatToMarkdown(activeChat.messages);
        const ts = new Date().toISOString().replace(/[:.]/g, "-");
        const safeName = activeChat.metadata.name.replace(/[/\\?%*:|"<>]/g, "-");
        const fName = `ollama-chat-<span class="math-inline">{safeName}-</span>{ts}.md`;
        let targetFolderPath = (_b = this.plugin.settings.chatExportFolderPath) == null ? void 0 : _b.trim();
        let targetFolder = null;
        if (targetFolderPath) {
          targetFolderPath = (0, import_obsidian3.normalizePath)(targetFolderPath);
          const abstractFile = this.app.vault.getAbstractFileByPath(targetFolderPath);
          if (!abstractFile) {
            try {
              await this.app.vault.createFolder(targetFolderPath);
              targetFolder = this.app.vault.getAbstractFileByPath(targetFolderPath);
              if (targetFolder)
                new import_obsidian3.Notice(`Created export folder: ${targetFolderPath}`);
            } catch (err) {
              new import_obsidian3.Notice(`Error creating export folder. Saving to vault root.`);
              targetFolder = this.app.vault.getRoot();
            }
          } else if (abstractFile instanceof import_obsidian3.TFolder) {
            targetFolder = abstractFile;
          } else {
            new import_obsidian3.Notice(`Error: Export path not a folder. Saving to vault root.`);
            targetFolder = this.app.vault.getRoot();
          }
        } else {
          targetFolder = this.app.vault.getRoot();
        }
        if (!targetFolder) {
          new import_obsidian3.Notice("Error determining export folder.");
          return;
        }
        const filePath = (0, import_obsidian3.normalizePath)(`<span class="math-inline">{targetFolder.path}/</span>{fName}`);
        const file = await this.app.vault.create(filePath, md);
        new import_obsidian3.Notice(`Chat exported to ${file.path}`);
      } catch (error) {
        new import_obsidian3.Notice("Error exporting chat.");
        console.error(error);
      }
    };
    this.handleSettingsClick = async () => {
      var _a, _b, _c, _d;
      this.closeMenu();
      console.log("[OllamaView Debug] Action: Settings");
      (_b = (_a = this.app.setting) == null ? void 0 : _a.open) == null ? void 0 : _b.call(_a);
      (_d = (_c = this.app.setting) == null ? void 0 : _c.openTabById) == null ? void 0 : _d.call(_c, this.plugin.manifest.id);
    };
    this.handleDocumentClickForMenu = (e) => {
      var _a, _b;
      if (this.isMenuOpen() && !((_a = this.menuButton) == null ? void 0 : _a.contains(e.target)) && !((_b = this.menuDropdown) == null ? void 0 : _b.contains(e.target))) {
        this.closeMenu();
      }
    };
    // --- Plugin Event Handlers ---
    this.handleModelChange = (modelName) => {
      this.updateInputPlaceholder(modelName);
      if (this.currentMessages.length > 0)
        this.addMessageToDisplay("system", `Model changed to: ${modelName}`, new Date());
    };
    this.handleRoleChange = (roleName) => {
      const displayRole = roleName || "Default Assistant";
      if (this.currentMessages.length > 0)
        this.addMessageToDisplay("system", `Role changed to: ${displayRole}`, new Date());
      else
        new import_obsidian3.Notice(`Role set to: ${displayRole}`);
    };
    this.handleRolesUpdated = () => {
      var _a;
      (_a = this.plugin.promptService) == null ? void 0 : _a.clearRoleCache();
      console.log("[OllamaView] Roles updated: Cleared prompt service role cache.");
      if (this.isMenuOpen()) {
        this.renderRoleList();
      }
    };
    // Refresh list if open
    this.handleChatListUpdated = () => {
      console.log("[OllamaView] Chat list updated event received.");
      if (this.isMenuOpen()) {
        this.renderChatListMenu();
      }
    };
    // Refresh list if open
    this.handleActiveChatChanged = (data) => {
      console.log(`[OllamaView] Active chat changed event received. New ID: ${data.chatId}`);
      this.loadAndDisplayActiveChat();
    };
    this.handleMessageAdded = (data) => {
      var _a;
      if (data.chatId === ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChatId())) {
        this.addMessageToDisplay(data.message.role, data.message.content, data.message.timestamp);
        if (this.isMenuOpen()) {
          this.renderChatListMenu();
        }
      }
    };
    // Refresh list date if open
    this.handleMessagesCleared = (chatId) => {
      var _a;
      if (chatId === ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChatId())) {
        console.log("[OllamaView] Messages cleared event received.");
        this.clearChatContainerInternal();
        this.currentMessages = [];
        this.showEmptyState();
      }
    };
    // --- Window/Workspace State Handlers ---
    this.handleVisibilityChange = () => {
      if (document.visibilityState === "visible" && this.leaf.view === this) {
        requestAnimationFrame(() => {
          var _a;
          this.guaranteedScrollToBottom(50, true);
          this.adjustTextareaHeight();
          (_a = this.inputEl) == null ? void 0 : _a.focus();
        });
      }
    };
    this.handleActiveLeafChange = (leaf) => {
      var _a;
      if ((leaf == null ? void 0 : leaf.view) === this) {
        (_a = this.inputEl) == null ? void 0 : _a.focus();
        setTimeout(() => this.guaranteedScrollToBottom(150, true), 100);
      }
    };
    this.handleWindowResize = () => {
      if (this.resizeTimeout)
        clearTimeout(this.resizeTimeout);
      this.resizeTimeout = setTimeout(() => this.adjustTextareaHeight(), 100);
    };
    // --- Scroll Handling ---
    this.handleScroll = () => {
      if (!this.chatContainer || !this.newMessagesIndicatorEl)
        return;
      const threshold = 150;
      const atBottom = this.chatContainer.scrollHeight - this.chatContainer.scrollTop - this.chatContainer.clientHeight < threshold;
      const previousScrolledUp = this.userScrolledUp;
      this.userScrolledUp = !atBottom;
      if (previousScrolledUp && atBottom) {
        this.newMessagesIndicatorEl.classList.remove(CSS_CLASS_VISIBLE);
      }
    };
    this.handleNewMessageIndicatorClick = () => {
      var _a;
      if (this.chatContainer) {
        this.chatContainer.scrollTo({ top: this.chatContainer.scrollHeight, behavior: "smooth" });
      }
      (_a = this.newMessagesIndicatorEl) == null ? void 0 : _a.classList.remove(CSS_CLASS_VISIBLE);
      this.userScrolledUp = false;
    };
    this.adjustTextareaHeight = () => {
      requestAnimationFrame(() => {
        if (!this.inputEl || !this.buttonsContainer)
          return;
        const maxHeightPercentage = 0.5;
        const minHeight = 40;
        const viewHeight = this.contentEl.clientHeight;
        const maxHeight = Math.max(100, viewHeight * maxHeightPercentage);
        this.inputEl.style.height = "auto";
        const scrollHeight = this.inputEl.scrollHeight;
        const newHeight = Math.max(minHeight, Math.min(scrollHeight, maxHeight));
        this.inputEl.style.height = `${newHeight}px`;
        this.inputEl.classList.toggle(CSS_CLASS_TEXTAREA_EXPANDED, scrollHeight > maxHeight);
      });
    };
    this.plugin = plugin;
    this.initSpeechWorker();
    this.scrollListenerDebounced = (0, import_obsidian3.debounce)(this.handleScroll, 150, true);
    console.log("[OllamaView] Constructed.");
  }
  // --- Getters ---
  /** Checks if the custom menu dropdown is currently visible */
  isMenuOpen() {
    return !!this.menuDropdown && this.menuDropdown.style.display === "block";
  }
  // --- Obsidian View Methods ---
  getViewType() {
    return VIEW_TYPE_OLLAMA_PERSONAS;
  }
  getDisplayText() {
    return "Ollama Personas";
  }
  getIcon() {
    return "message-square";
  }
  async onOpen() {
    console.log("[OllamaView] onOpen START");
    this.createUIElements();
    this.updateInputPlaceholder(this.plugin.settings.modelName);
    this.attachEventListeners();
    this.autoResizeTextarea();
    this.updateSendButtonState();
    try {
      await this.loadAndDisplayActiveChat();
    } catch (error) {
      console.error("[OllamaView] Error during initial chat load:", error);
      this.showEmptyState();
    }
    setTimeout(() => {
      var _a;
      return (_a = this.inputEl) == null ? void 0 : _a.focus();
    }, 150);
    if (this.inputEl) {
      this.inputEl.dispatchEvent(new Event("input"));
    }
    console.log("[OllamaView] onOpen END");
  }
  async onClose() {
    console.log("[OllamaView] onClose: Cleaning up...");
    if (this.speechWorker) {
      this.speechWorker.terminate();
      this.speechWorker = null;
    }
    this.stopVoiceRecording(false);
    if (this.audioStream) {
      this.audioStream.getTracks().forEach((t) => t.stop());
      this.audioStream = null;
    }
    if (this.scrollTimeout)
      clearTimeout(this.scrollTimeout);
    if (this.resizeTimeout)
      clearTimeout(this.resizeTimeout);
  }
  // --- UI Creation (with Custom Div Menu & Accordion) ---
  createUIElements() {
    this.contentEl.empty();
    this.chatContainerEl = this.contentEl.createDiv({ cls: CSS_CLASS_CONTAINER });
    this.chatContainer = this.chatContainerEl.createDiv({ cls: CSS_CLASS_CHAT_CONTAINER });
    this.newMessagesIndicatorEl = this.chatContainerEl.createDiv({ cls: CSS_CLASS_NEW_MESSAGE_INDICATOR });
    (0, import_obsidian3.setIcon)(this.newMessagesIndicatorEl.createSpan({ cls: "indicator-icon" }), "arrow-down");
    this.newMessagesIndicatorEl.createSpan({ text: " New Messages" });
    const inputContainer = this.chatContainerEl.createDiv({ cls: CSS_CLASS_INPUT_CONTAINER });
    this.inputEl = inputContainer.createEl("textarea", { attr: { placeholder: `Text...`, rows: 1 } });
    this.buttonsContainer = inputContainer.createDiv({ cls: CSS_CLASS_BUTTONS_CONTAINER });
    this.sendButton = this.buttonsContainer.createEl("button", { cls: CSS_CLASS_SEND_BUTTON, attr: { "aria-label": "Send" } });
    (0, import_obsidian3.setIcon)(this.sendButton, "send");
    this.voiceButton = this.buttonsContainer.createEl("button", { cls: CSS_CLASS_VOICE_BUTTON, attr: { "aria-label": "Voice Input" } });
    (0, import_obsidian3.setIcon)(this.voiceButton, "mic");
    this.translateInputButton = this.buttonsContainer.createEl("button", { cls: CSS_CLASS_TRANSLATE_INPUT_BUTTON, attr: { "aria-label": "Translate input to English" } });
    (0, import_obsidian3.setIcon)(this.translateInputButton, "replace");
    this.translateInputButton.title = "Translate input to English";
    this.menuButton = this.buttonsContainer.createEl("button", { cls: CSS_CLASS_MENU_BUTTON, attr: { "aria-label": "Menu" } });
    (0, import_obsidian3.setIcon)(this.menuButton, "more-vertical");
    this.menuDropdown = inputContainer.createEl("div", { cls: [CSS_CLASS_MENU_DROPDOWN, "ollama-chat-menu"] });
    this.menuDropdown.style.display = "none";
    const createSubmenuSection = (title, icon, listContainerClass) => {
      const header = this.menuDropdown.createDiv({ cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_MENU_HEADER_ITEM}` });
      (0, import_obsidian3.setIcon)(header.createSpan({ cls: "menu-option-icon" }), icon);
      header.createSpan({ cls: "menu-option-text", text: title });
      (0, import_obsidian3.setIcon)(header.createSpan({ cls: CSS_CLASS_SUBMENU_ICON }), "chevron-right");
      const content = this.menuDropdown.createDiv({ cls: `${CSS_CLASS_SUBMENU_CONTENT} ${CSS_CLASS_SUBMENU_CONTENT_HIDDEN} ${listContainerClass}` });
      content.style.maxHeight = "0";
      content.style.overflow = "hidden";
      content.style.transition = "max-height 0.3s ease-out, padding 0.3s ease-out";
      content.style.paddingTop = "0";
      content.style.paddingBottom = "0";
      return { header, content };
    };
    const modelSection = createSubmenuSection("Models", "list-collapse", CSS_CLASS_MODEL_LIST_CONTAINER);
    this.modelSubmenuHeader = modelSection.header;
    this.modelSubmenuContent = modelSection.content;
    const roleSection = createSubmenuSection("Roles", "users", CSS_CLASS_ROLE_LIST_CONTAINER);
    this.roleSubmenuHeader = roleSection.header;
    this.roleSubmenuContent = roleSection.content;
    const chatSection = createSubmenuSection("Chats", "messages-square", CSS_CLASS_CHAT_LIST_CONTAINER);
    this.chatSubmenuHeader = chatSection.header;
    this.chatSubmenuContent = chatSection.content;
    this.menuDropdown.createEl("hr", { cls: CSS_CLASS_MENU_SEPARATOR });
    this.menuDropdown.createEl("div", { text: "Actions", cls: CSS_CLASS_MENU_HEADER });
    this.newChatOption = this.menuDropdown.createEl("div", { cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_NEW_CHAT_OPTION}` });
    (0, import_obsidian3.setIcon)(this.newChatOption.createSpan({ cls: "menu-option-icon" }), "plus-circle");
    this.newChatOption.createSpan({ cls: "menu-option-text", text: "New Chat" });
    this.renameChatOption = this.menuDropdown.createEl("div", { cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_RENAME_CHAT_OPTION}` });
    (0, import_obsidian3.setIcon)(this.renameChatOption.createSpan({ cls: "menu-option-icon" }), "pencil");
    this.renameChatOption.createSpan({ cls: "menu-option-text", text: "Rename Chat" });
    this.cloneChatOption = this.menuDropdown.createEl("div", { cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_CLONE_CHAT_OPTION}` });
    (0, import_obsidian3.setIcon)(this.cloneChatOption.createSpan({ cls: "menu-option-icon" }), "copy-plus");
    this.cloneChatOption.createSpan({ cls: "menu-option-text", text: "Clone Chat" });
    this.exportChatOption = this.menuDropdown.createEl("div", { cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_EXPORT_CHAT_OPTION}` });
    (0, import_obsidian3.setIcon)(this.exportChatOption.createSpan({ cls: "menu-option-icon" }), "download");
    this.exportChatOption.createSpan({ cls: "menu-option-text", text: "Export Chat" });
    this.menuDropdown.createEl("hr", { cls: CSS_CLASS_MENU_SEPARATOR });
    this.clearChatOption = this.menuDropdown.createEl("div", { cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_CLEAR_CHAT_OPTION} ${CSS_CLASS_DANGER_OPTION}` });
    (0, import_obsidian3.setIcon)(this.clearChatOption.createSpan({ cls: "menu-option-icon" }), "trash");
    this.clearChatOption.createSpan({ cls: "menu-option-text", text: "Clear Messages" });
    this.deleteChatOption = this.menuDropdown.createEl("div", { cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_DELETE_CHAT_OPTION} ${CSS_CLASS_DANGER_OPTION}` });
    (0, import_obsidian3.setIcon)(this.deleteChatOption.createSpan({ cls: "menu-option-icon" }), "trash-2");
    this.deleteChatOption.createSpan({ cls: "menu-option-text", text: "Delete Chat" });
    this.menuDropdown.createEl("hr", { cls: CSS_CLASS_MENU_SEPARATOR });
    this.settingsOption = this.menuDropdown.createEl("div", { cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_SETTINGS_OPTION}` });
    (0, import_obsidian3.setIcon)(this.settingsOption.createSpan({ cls: "menu-option-icon" }), "settings");
    this.settingsOption.createSpan({ cls: "menu-option-text", text: "Settings" });
  }
  // --- Event Listeners (with Custom Div Menu) ---
  attachEventListeners() {
    console.log("[OllamaView Debug] Attaching event listeners START");
    if (!this.inputEl)
      console.error("inputEl missing!");
    else
      console.log("[OllamaView Debug] inputEl FOUND");
    if (!this.sendButton)
      console.error("sendButton missing!");
    else
      console.log("[OllamaView Debug] sendButton FOUND");
    if (!this.menuButton)
      console.error("menuButton missing!");
    else
      console.log("[OllamaView Debug] menuButton FOUND");
    if (this.inputEl) {
      console.log("[OllamaView Debug] Attaching keydown to inputEl");
      this.inputEl.addEventListener("keydown", this.handleKeyDown);
      this.inputEl.addEventListener("input", this.handleInputForResize);
      console.log("[OllamaView Debug] Listeners attached to inputEl.");
    }
    if (this.sendButton) {
      console.log("[OllamaView Debug] Attaching click to sendButton");
      this.sendButton.addEventListener("click", this.handleSendClick);
      console.log("[OllamaView Debug] Listener attached to sendButton.");
    }
    if (this.voiceButton)
      this.voiceButton.addEventListener("click", this.handleVoiceClick);
    else
      console.error("voiceButton missing!");
    if (this.translateInputButton)
      this.translateInputButton.addEventListener("click", this.handleTranslateInputClick);
    else
      console.error("translateInputButton missing!");
    if (this.menuButton)
      this.menuButton.addEventListener("click", this.handleMenuClick);
    else
      console.error("menuButton missing!");
    if (this.modelSubmenuHeader)
      this.registerDomEvent(this.modelSubmenuHeader, "click", () => this.toggleSubmenu(this.modelSubmenuHeader, this.modelSubmenuContent, "models"));
    else
      console.error("modelSubmenuHeader missing!");
    if (this.roleSubmenuHeader)
      this.registerDomEvent(this.roleSubmenuHeader, "click", () => this.toggleSubmenu(this.roleSubmenuHeader, this.roleSubmenuContent, "roles"));
    else
      console.error("roleSubmenuHeader missing!");
    if (this.chatSubmenuHeader)
      this.registerDomEvent(this.chatSubmenuHeader, "click", () => this.toggleSubmenu(this.chatSubmenuHeader, this.chatSubmenuContent, "chats"));
    else
      console.error("chatSubmenuHeader missing!");
    if (this.settingsOption)
      this.settingsOption.addEventListener("click", this.handleSettingsClick);
    else
      console.error("settingsOption missing!");
    if (this.clearChatOption)
      this.clearChatOption.addEventListener("click", this.handleClearChatClick);
    else
      console.error("clearChatOption missing!");
    if (this.exportChatOption)
      this.exportChatOption.addEventListener("click", this.handleExportChatClick);
    else
      console.error("exportChatOption missing!");
    if (this.newChatOption)
      this.newChatOption.addEventListener("click", this.handleNewChatClick);
    else
      console.error("newChatOption missing!");
    if (this.renameChatOption)
      this.renameChatOption.addEventListener("click", this.handleRenameChatClick);
    else
      console.error("renameChatOption missing!");
    if (this.cloneChatOption)
      this.cloneChatOption.addEventListener("click", this.handleCloneChatClick);
    else
      console.error("cloneChatOption missing!");
    if (this.deleteChatOption)
      this.deleteChatOption.addEventListener("click", this.handleDeleteChatClick);
    else
      console.error("deleteChatOption missing!");
    this.registerDomEvent(window, "resize", this.handleWindowResize);
    this.registerEvent(this.app.workspace.on("resize", this.handleWindowResize));
    this.registerDomEvent(document, "click", this.handleDocumentClickForMenu);
    this.registerDomEvent(document, "visibilitychange", this.handleVisibilityChange);
    this.registerEvent(this.app.workspace.on("active-leaf-change", this.handleActiveLeafChange));
    if (this.chatContainer) {
      this.registerDomEvent(this.chatContainer, "scroll", this.scrollListenerDebounced);
      console.log("[OllamaView] Attached listener to chatContainer scroll");
    } else {
      console.error("chatContainer missing!");
    }
    if (this.newMessagesIndicatorEl) {
      this.registerDomEvent(this.newMessagesIndicatorEl, "click", this.handleNewMessageIndicatorClick);
    }
    this.register(this.plugin.on("model-changed", this.handleModelChange));
    this.register(this.plugin.on("role-changed", this.handleRoleChange));
    this.register(this.plugin.on("roles-updated", this.handleRolesUpdated));
    this.register(this.plugin.on("active-chat-changed", this.handleActiveChatChanged));
    this.register(this.plugin.on("message-added", this.handleMessageAdded));
    this.register(this.plugin.on("messages-cleared", this.handleMessagesCleared));
    this.register(this.plugin.on("chat-list-updated", this.handleChatListUpdated));
    console.log("[OllamaView Debug] Attaching event listeners END");
  }
  // Handles clicks on submenu headers (Model, Role, Chat)
  async toggleSubmenu(headerEl, contentEl, type) {
    if (!headerEl || !contentEl) {
      console.error(`[OllamaView Debug] Missing header or content element for submenu type: ${type}`);
      return;
    }
    const iconEl = headerEl.querySelector(`.${CSS_CLASS_SUBMENU_ICON}`);
    const isHidden = contentEl.style.maxHeight === "0px" || contentEl.classList.contains(CSS_CLASS_SUBMENU_CONTENT_HIDDEN);
    console.log(`[OllamaView Debug] Toggling submenu '${type}'. Currently hidden: ${isHidden}`);
    if (isHidden) {
      this.collapseAllSubmenus(contentEl);
    }
    if (isHidden) {
      if (iconEl instanceof HTMLElement) {
        (0, import_obsidian3.setIcon)(iconEl, "chevron-down");
      }
      contentEl.empty();
      const loadingEl = contentEl.createDiv({ cls: "menu-loading", text: `Loading ${type}...` });
      contentEl.classList.remove(CSS_CLASS_SUBMENU_CONTENT_HIDDEN);
      contentEl.style.paddingTop = "5px";
      contentEl.style.paddingBottom = "5px";
      contentEl.style.maxHeight = "40px";
      try {
        console.log(`[OllamaView Debug] Rendering submenu content for '${type}'...`);
        switch (type) {
          case "models":
            await this.renderModelList();
            break;
          case "roles":
            await this.renderRoleList();
            break;
          case "chats":
            await this.renderChatListMenu();
            break;
        }
        console.log(`[OllamaView Debug] Finished rendering submenu content for '${type}'.`);
        requestAnimationFrame(() => {
          if (!contentEl.classList.contains(CSS_CLASS_SUBMENU_CONTENT_HIDDEN)) {
            console.log(`[OllamaView Debug] Setting maxHeight for '${type}' to scrollHeight: ${contentEl.scrollHeight}px`);
            contentEl.style.maxHeight = contentEl.scrollHeight + "px";
          }
        });
      } catch (error) {
        console.error(`[OllamaView] Error rendering ${type} list:`, error);
        contentEl.empty();
        contentEl.createDiv({ cls: "menu-error-text", text: `Error loading ${type}.` });
        contentEl.style.maxHeight = "50px";
      }
    } else {
      console.log(`[OllamaView Debug] Collapsing submenu '${type}'.`);
      contentEl.classList.add(CSS_CLASS_SUBMENU_CONTENT_HIDDEN);
      contentEl.style.maxHeight = "0";
      contentEl.style.paddingTop = "0";
      contentEl.style.paddingBottom = "0";
      if (iconEl instanceof HTMLElement) {
        (0, import_obsidian3.setIcon)(iconEl, "chevron-right");
      }
    }
  }
  // Helper to collapse all submenus except the one potentially being opened
  collapseAllSubmenus(exceptContent) {
    const submenus = [
      { header: this.modelSubmenuHeader, content: this.modelSubmenuContent },
      { header: this.roleSubmenuHeader, content: this.roleSubmenuContent },
      { header: this.chatSubmenuHeader, content: this.chatSubmenuContent }
    ];
    submenus.forEach((submenu) => {
      if (submenu.content && submenu.header && submenu.content !== exceptContent) {
        if (!submenu.content.classList.contains(CSS_CLASS_SUBMENU_CONTENT_HIDDEN)) {
          submenu.content.classList.add(CSS_CLASS_SUBMENU_CONTENT_HIDDEN);
          submenu.content.style.maxHeight = "0";
          submenu.content.style.paddingTop = "0";
          submenu.content.style.paddingBottom = "0";
          const iconEl = submenu.header.querySelector(`.${CSS_CLASS_SUBMENU_ICON}`);
          if (iconEl instanceof HTMLElement) {
            (0, import_obsidian3.setIcon)(iconEl, "chevron-right");
          }
        }
      }
    });
  }
  // --- UI Update Methods ---
  updateInputPlaceholder(modelName) {
    if (this.inputEl) {
      this.inputEl.placeholder = modelName ? `Text to ${modelName}...` : "Select a model...";
    }
  }
  closeMenu() {
    if (this.menuDropdown) {
      this.menuDropdown.style.display = "none";
      this.collapseAllSubmenus(null);
    }
  }
  autoResizeTextarea() {
    this.adjustTextareaHeight();
  }
  updateSendButtonState() {
    if (!this.inputEl || !this.sendButton)
      return;
    const isDisabled = this.inputEl.value.trim() === "" || this.isProcessing;
    this.sendButton.disabled = isDisabled;
    this.sendButton.classList.toggle(CSS_CLASS_DISABLED, isDisabled);
  }
  showEmptyState() {
    var _a, _b;
    if (this.currentMessages.length === 0 && !this.emptyStateEl && this.chatContainer) {
      this.chatContainer.empty();
      this.emptyStateEl = this.chatContainer.createDiv({ cls: CSS_CLASS_EMPTY_STATE });
      this.emptyStateEl.createDiv({ cls: "empty-state-message", text: "No messages yet" });
      const modelName = ((_b = (_a = this.plugin) == null ? void 0 : _a.settings) == null ? void 0 : _b.modelName) || "the AI";
      this.emptyStateEl.createDiv({ cls: "empty-state-tip", text: `Type a message or use the menu options to start interacting with ${modelName}.` });
    }
  }
  hideEmptyState() {
    if (this.emptyStateEl) {
      this.emptyStateEl.remove();
      this.emptyStateEl = null;
    }
  }
  setLoadingState(isLoading) {
    console.log(`[OllamaView Debug] setLoadingState CALLED with: ${isLoading}`);
    this.isProcessing = isLoading;
    if (this.inputEl)
      this.inputEl.disabled = isLoading;
    this.updateSendButtonState();
    if (this.voiceButton) {
      this.voiceButton.disabled = isLoading;
      this.voiceButton.classList.toggle(CSS_CLASS_DISABLED, isLoading);
    }
    if (this.translateInputButton) {
      this.translateInputButton.disabled = isLoading;
      this.translateInputButton.classList.toggle(CSS_CLASS_DISABLED, isLoading);
    }
    if (this.menuButton) {
      this.menuButton.disabled = isLoading;
      this.menuButton.classList.toggle(CSS_CLASS_DISABLED, isLoading);
    }
    console.log(`[OllamaView Debug] isProcessing is now: ${this.isProcessing}`);
  }
  async loadAndDisplayActiveChat() {
    var _a;
    this.clearChatContainerInternal();
    this.currentMessages = [];
    this.lastRenderedMessageDate = null;
    try {
      const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
      if (activeChat && activeChat.messages.length > 0) {
        this.hideEmptyState();
        this.renderMessages(activeChat.messages);
        this.updateInputPlaceholder(activeChat.metadata.modelName || this.plugin.settings.modelName);
        this.checkAllMessagesForCollapsing();
        setTimeout(() => {
          this.guaranteedScrollToBottom(100, true);
        }, 150);
      } else if (activeChat) {
        this.showEmptyState();
        this.updateInputPlaceholder(activeChat.metadata.modelName || this.plugin.settings.modelName);
      } else {
        this.showEmptyState();
        this.updateInputPlaceholder(this.plugin.settings.modelName);
      }
    } catch (error) {
      this.showEmptyState();
      new import_obsidian3.Notice("Error loading chat history.");
    }
  }
  /** Renders a list of messages to the chat container */
  renderMessages(messagesToRender) {
    this.clearChatContainerInternal();
    this.currentMessages = [...messagesToRender];
    this.lastRenderedMessageDate = null;
    messagesToRender.forEach((message) => {
      this.renderMessageInternal(message, messagesToRender);
    });
  }
  /** Appends a single message to the display */
  addMessageToDisplay(role, content, timestamp) {
    if (!this.chatContainer)
      return;
    const newMessage = { role, content, timestamp };
    const currentContext = [...this.currentMessages];
    const messageEl = this.renderMessageInternal(newMessage, [...currentContext, newMessage]);
    this.currentMessages.push(newMessage);
    if (messageEl) {
      this.checkMessageForCollapsing(messageEl);
    }
    const isUserOrError = role === "user" || role === "error";
    if (!isUserOrError && this.userScrolledUp && this.newMessagesIndicatorEl) {
      this.newMessagesIndicatorEl.classList.add(CSS_CLASS_VISIBLE);
    } else if (!this.userScrolledUp) {
      const forceScroll = !isUserOrError;
      this.guaranteedScrollToBottom(forceScroll ? 100 : 50, forceScroll);
    }
    this.hideEmptyState();
  }
  /** Sends the user's input as a message and gets a response */
  async sendMessage() {
    var _a;
    const content = this.inputEl.value.trim();
    if (!content || this.isProcessing || this.sendButton.disabled)
      return;
    const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
    if (!activeChat) {
      new import_obsidian3.Notice("Error: No active chat session found.");
      return;
    }
    const userMessageContent = this.inputEl.value;
    this.clearInputField();
    this.setLoadingState(true);
    this.hideEmptyState();
    let loadingEl = null;
    try {
      const userMessage = await this.plugin.chatManager.addMessageToActiveChat("user", userMessageContent);
      if (!userMessage)
        throw new Error("Failed to add user message to history.");
      loadingEl = this.addLoadingIndicator();
      this.guaranteedScrollToBottom(50, true);
      const assistantMessage = await this.plugin.ollamaService.generateChatResponse(activeChat);
      if (loadingEl) {
        this.removeLoadingIndicator(loadingEl);
        loadingEl = null;
      }
      if (assistantMessage) {
        await this.plugin.chatManager.addMessageToActiveChat(assistantMessage.role, assistantMessage.content);
      } else {
        this.addMessageToDisplay("error", "Assistant did not provide a response.", new Date());
      }
    } catch (error) {
      if (loadingEl) {
        this.removeLoadingIndicator(loadingEl);
        loadingEl = null;
      }
      this.addMessageToDisplay("error", `Error: ${error.message || "Unknown error."}`, new Date());
    } finally {
      if (loadingEl) {
        this.removeLoadingIndicator(loadingEl);
      }
      this.setLoadingState(false);
      this.focusInput();
    }
  }
  // --- Core Rendering Logic ---
  /** Renders a single message bubble based on the message object and context */
  renderMessageInternal(message, messageContext) {
    const messageIndex = messageContext.findIndex((m) => m === message);
    if (messageIndex === -1)
      return null;
    const prevMessage = messageIndex > 0 ? messageContext[messageIndex - 1] : null;
    const isNewDay = !this.lastRenderedMessageDate || !this.isSameDay(this.lastRenderedMessageDate, message.timestamp);
    if (isNewDay) {
      this.renderDateSeparator(message.timestamp);
      this.lastRenderedMessageDate = message.timestamp;
    } else if (messageIndex === 0 && !this.lastRenderedMessageDate) {
      this.lastRenderedMessageDate = message.timestamp;
    }
    let messageGroup = null;
    let groupClass = CSS_CLASS_MESSAGE_GROUP;
    let messageClass = `${CSS_CLASS_MESSAGE} ${CSS_CLASS_MESSAGE_ARRIVING}`;
    let showAvatar = true;
    let isUser = false;
    const isFirstInGroup = !prevMessage || prevMessage.role !== message.role || isNewDay;
    switch (message.role) {
      case "user":
        groupClass += ` ${CSS_CLASS_USER_GROUP}`;
        messageClass += ` ${CSS_CLASS_USER_MESSAGE}`;
        isUser = true;
        break;
      case "assistant":
        groupClass += ` ${CSS_CLASS_OLLAMA_GROUP}`;
        messageClass += ` ${CSS_CLASS_OLLAMA_MESSAGE}`;
        break;
      case "system":
        groupClass += ` ${CSS_CLASS_SYSTEM_GROUP}`;
        messageClass += ` ${CSS_CLASS_SYSTEM_MESSAGE}`;
        showAvatar = false;
        break;
      case "error":
        groupClass += ` ${CSS_CLASS_ERROR_GROUP}`;
        messageClass += ` ${CSS_CLASS_ERROR_MESSAGE}`;
        showAvatar = false;
        break;
    }
    const lastElement = this.chatContainer.lastElementChild;
    if (isFirstInGroup || !lastElement || !lastElement.matches(`.${groupClass.split(" ")[1]}`)) {
      messageGroup = this.chatContainer.createDiv({ cls: groupClass });
      if (showAvatar)
        this.renderAvatar(messageGroup, isUser);
    } else {
      messageGroup = lastElement;
    }
    const messageEl = messageGroup.createDiv({ cls: messageClass });
    const contentContainer = messageEl.createDiv({ cls: CSS_CLASS_CONTENT_CONTAINER });
    const contentEl = contentContainer.createDiv({ cls: CSS_CLASS_CONTENT });
    switch (message.role) {
      case "assistant":
      case "user":
        contentEl.addClass(CSS_CLASS_CONTENT_COLLAPSIBLE);
        if (message.role === "assistant") {
          this.renderAssistantContent(contentEl, message.content);
        } else {
          message.content.split("\n").forEach((line, i, arr) => {
            contentEl.appendText(line);
            if (i < arr.length - 1)
              contentEl.createEl("br");
          });
        }
        break;
      case "system":
        (0, import_obsidian3.setIcon)(contentEl.createSpan({ cls: CSS_CLASS_SYSTEM_ICON }), "info");
        contentEl.createSpan({ cls: CSS_CLASS_SYSTEM_TEXT, text: message.content });
        break;
      case "error":
        (0, import_obsidian3.setIcon)(contentEl.createSpan({ cls: CSS_CLASS_ERROR_ICON }), "alert-triangle");
        contentEl.createSpan({ cls: CSS_CLASS_ERROR_TEXT, text: message.content });
        break;
    }
    const buttonsWrapper = contentContainer.createDiv({ cls: "message-actions-wrapper" });
    if (message.role !== "system" && message.role !== "error") {
      const copyBtn = buttonsWrapper.createEl("button", { cls: CSS_CLASS_COPY_BUTTON, attr: { title: "Copy", "aria-label": "Copy message content" } });
      (0, import_obsidian3.setIcon)(copyBtn, "copy");
      this.registerDomEvent(copyBtn, "click", (e) => {
        e.stopPropagation();
        this.handleCopyClick(message.content, copyBtn);
      });
    }
    if (this.plugin.settings.enableTranslation && this.plugin.settings.translationTargetLanguage && (message.role === "user" || message.role === "assistant")) {
      const targetLangName = LANGUAGES[this.plugin.settings.translationTargetLanguage] || this.plugin.settings.translationTargetLanguage;
      const translateBtn = buttonsWrapper.createEl("button", { cls: CSS_CLASS_TRANSLATE_BUTTON, attr: { title: `Translate to ${targetLangName}`, "aria-label": "Translate message" } });
      (0, import_obsidian3.setIcon)(translateBtn, "languages");
      this.registerDomEvent(translateBtn, "click", (e) => {
        e.stopPropagation();
        this.handleTranslateClick(message.content, contentEl, translateBtn);
      });
    }
    messageEl.createDiv({ cls: CSS_CLASS_TIMESTAMP, text: this.formatTime(message.timestamp) });
    setTimeout(() => messageEl.classList.remove(CSS_CLASS_MESSAGE_ARRIVING), 500);
    return messageEl;
  }
  // --- Action Button Handlers ---
  handleCopyClick(content, buttonEl) {
    let textToCopy = content;
    if (this.detectThinkingTags(this.decodeHtmlEntities(content)).hasThinkingTags) {
      textToCopy = this.decodeHtmlEntities(content).replace(/<think>[\s\S]*?<\/think>/g, "").trim();
    }
    navigator.clipboard.writeText(textToCopy).then(() => {
      (0, import_obsidian3.setIcon)(buttonEl, "check");
      buttonEl.setAttribute("title", "Copied!");
      setTimeout(() => {
        (0, import_obsidian3.setIcon)(buttonEl, "copy");
        buttonEl.setAttribute("title", "Copy");
      }, 2e3);
    }).catch((err) => {
    });
  }
  async handleTranslateClick(originalContent, contentEl, buttonEl) {
    var _a;
    const targetLang = this.plugin.settings.translationTargetLanguage;
    const apiKey = this.plugin.settings.googleTranslationApiKey;
    if (!targetLang || !apiKey) {
      new import_obsidian3.Notice("Translation not configured. Please check language and API key in settings.");
      return;
    }
    let textToTranslate = originalContent;
    if (this.detectThinkingTags(this.decodeHtmlEntities(originalContent)).hasThinkingTags) {
      textToTranslate = this.decodeHtmlEntities(originalContent).replace(/<think>[\s\S]*?<\/think>/g, "").trim();
    }
    if (!textToTranslate)
      return;
    (_a = contentEl.querySelector(`.${CSS_CLASS_TRANSLATION_CONTAINER}`)) == null ? void 0 : _a.remove();
    (0, import_obsidian3.setIcon)(buttonEl, "loader");
    buttonEl.disabled = true;
    buttonEl.classList.add(CSS_CLASS_TRANSLATION_PENDING);
    buttonEl.setAttribute("title", "Translating...");
    try {
      const translatedText = await this.plugin.translationService.translate(textToTranslate, targetLang);
      if (translatedText !== null) {
        const translationContainer = contentEl.createDiv({ cls: CSS_CLASS_TRANSLATION_CONTAINER });
        translationContainer.createDiv({ cls: CSS_CLASS_TRANSLATION_CONTENT, text: translatedText });
        const targetLangName = LANGUAGES[targetLang] || targetLang;
        translationContainer.createEl("div", { cls: "translation-indicator", text: `[Translated to ${targetLangName}]` });
        this.guaranteedScrollToBottom(50, false);
      }
    } catch (error) {
      new import_obsidian3.Notice("An unexpected error occurred during translation.");
    } finally {
      (0, import_obsidian3.setIcon)(buttonEl, "languages");
      buttonEl.disabled = false;
      buttonEl.classList.remove(CSS_CLASS_TRANSLATION_PENDING);
      const targetLangName = LANGUAGES[targetLang] || targetLang;
      buttonEl.setAttribute("title", `Translate to ${targetLangName}`);
    }
  }
  // --- Rendering Helpers ---
  renderAvatar(groupEl, isUser) {
    const settings = this.plugin.settings;
    const avatarType = isUser ? settings.userAvatarType : settings.aiAvatarType;
    const avatarContent = isUser ? settings.userAvatarContent : settings.aiAvatarContent;
    const avatarClass = isUser ? CSS_CLASS_AVATAR_USER : CSS_CLASS_AVATAR_AI;
    const avatarEl = groupEl.createDiv({ cls: `${CSS_CLASS_AVATAR} ${avatarClass}` });
    if (avatarType === "initials") {
      avatarEl.textContent = avatarContent || (isUser ? "U" : "A");
    } else if (avatarType === "icon") {
      try {
        (0, import_obsidian3.setIcon)(avatarEl, avatarContent || (isUser ? "user" : "bot"));
      } catch (e) {
        avatarEl.textContent = isUser ? "U" : "A";
      }
    } else {
      avatarEl.textContent = isUser ? "U" : "A";
    }
  }
  renderDateSeparator(date) {
    if (!this.chatContainer)
      return;
    this.chatContainer.createDiv({ cls: CSS_CLASS_DATE_SEPARATOR, text: this.formatDateSeparator(date) });
  }
  renderAssistantContent(containerEl, content) {
    var _a, _b;
    const decodedContent = this.decodeHtmlEntities(content);
    const thinkingInfo = this.detectThinkingTags(decodedContent);
    containerEl.empty();
    if (thinkingInfo.hasThinkingTags) {
      const processedHtml = this.processThinkingTags(decodedContent);
      containerEl.innerHTML = processedHtml;
      this.addThinkingToggleListeners(containerEl);
      this.addCodeBlockEnhancements(containerEl);
    } else {
      import_obsidian3.MarkdownRenderer.renderMarkdown(
        decodedContent,
        // Use decoded content for rendering
        containerEl,
        (_b = (_a = this.app.vault.getRoot()) == null ? void 0 : _a.path) != null ? _b : "",
        // Source path context
        this
        // Component context for links etc.
      );
      this.addCodeBlockEnhancements(containerEl);
    }
  }
  addCodeBlockEnhancements(contentEl) {
    contentEl.querySelectorAll("pre").forEach((pre) => {
      if (pre.querySelector(`.${CSS_CLASS_CODE_BLOCK_COPY_BUTTON}`))
        return;
      const code = pre.querySelector("code");
      if (!code)
        return;
      const codeText = code.textContent || "";
      const langClass = Array.from(code.classList).find((cls) => cls.startsWith("language-"));
      if (langClass) {
        const lang = langClass.replace("language-", "");
        if (lang) {
          if (!pre.querySelector(`.${CSS_CLASS_CODE_BLOCK_LANGUAGE}`)) {
            pre.createEl("span", { cls: CSS_CLASS_CODE_BLOCK_LANGUAGE, text: lang });
          }
        }
      }
      const copyBtn = pre.createEl("button", { cls: CSS_CLASS_CODE_BLOCK_COPY_BUTTON });
      (0, import_obsidian3.setIcon)(copyBtn, "copy");
      copyBtn.setAttribute("title", "Copy Code");
      copyBtn.setAttribute("aria-label", "Copy code block");
      this.registerDomEvent(copyBtn, "click", (e) => {
        e.stopPropagation();
        navigator.clipboard.writeText(codeText).then(() => {
          (0, import_obsidian3.setIcon)(copyBtn, "check");
          copyBtn.setAttribute("title", "Copied!");
          setTimeout(() => {
            (0, import_obsidian3.setIcon)(copyBtn, "copy");
            copyBtn.setAttribute("title", "Copy Code");
          }, 1500);
        }).catch((err) => {
          new import_obsidian3.Notice("Failed to copy code.");
        });
      });
    });
  }
  // --- Menu List Rendering (Accordion Style) ---
  async renderModelList() {
    var _a, _b;
    const container = this.modelSubmenuContent;
    if (!container)
      return;
    container.empty();
    const modelIconMap = {
      "llama": "box-minimal",
      "mistral": "wind"
      /*...*/
    };
    const defaultIcon = "box";
    try {
      const models = await this.plugin.ollamaService.getModels();
      const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
      const currentModelName = ((_b = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _b.modelName) || this.plugin.settings.modelName;
      if (models.length === 0) {
        container.createEl("div", { cls: "menu-info-text", text: "No models." });
        return;
      }
      models.forEach((modelName) => {
        const optionEl = container.createDiv({ cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_MODEL_OPTION}` });
        const iconSpan = optionEl.createEl("span", { cls: "menu-option-icon" });
        let iconToUse = defaultIcon;
        if (modelName === currentModelName) {
          iconToUse = "check";
          optionEl.addClass("is-selected");
        } else {
          const l = modelName.toLowerCase();
          let f = false;
          for (const k in modelIconMap) {
            if (l.includes(k)) {
              iconToUse = modelIconMap[k];
              f = true;
              break;
            }
          }
          if (!f)
            iconToUse = defaultIcon;
        }
        try {
          (0, import_obsidian3.setIcon)(iconSpan, iconToUse);
        } catch (e) {
          iconSpan.style.minWidth = "18px";
        }
        optionEl.createEl("span", { cls: "menu-option-text", text: modelName });
        this.registerDomEvent(optionEl, "click", async () => {
          var _a2;
          if (modelName !== currentModelName) {
            const chat = await ((_a2 = this.plugin.chatManager) == null ? void 0 : _a2.getActiveChat());
            if (chat)
              await this.plugin.chatManager.updateActiveChatMetadata({ modelName });
            else
              new import_obsidian3.Notice("No active chat.");
          }
          this.closeMenu();
        });
      });
      this.updateSubmenuHeight(container);
    } catch (error) {
      container.empty();
      container.createEl("div", { cls: "menu-error-text", text: "Error models." });
      this.updateSubmenuHeight(container);
    }
  }
  async renderRoleList() {
    var _a, _b, _c;
    const container = this.roleSubmenuContent;
    if (!container)
      return;
    container.empty();
    try {
      const roles = await this.plugin.listRoleFiles(true);
      const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
      const currentChatRolePath = (_c = (_b = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _b.selectedRolePath) != null ? _c : this.plugin.settings.selectedRolePath;
      const noRoleOptionEl = container.createDiv({ cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_ROLE_OPTION}` });
      const noRoleIconSpan = noRoleOptionEl.createEl("span", { cls: "menu-option-icon" });
      if (!currentChatRolePath) {
        (0, import_obsidian3.setIcon)(noRoleIconSpan, "check");
        noRoleOptionEl.addClass("is-selected");
      } else {
        (0, import_obsidian3.setIcon)(noRoleIconSpan, "slash");
        noRoleIconSpan.style.minWidth = "18px";
      }
      noRoleOptionEl.createEl("span", { cls: "menu-option-text", text: "None (Default)" });
      this.registerDomEvent(noRoleOptionEl, "click", async () => {
        var _a2, _b2, _c2;
        const nrp = "";
        if (this.plugin.settings.selectedRolePath !== nrp || currentChatRolePath !== nrp) {
          this.plugin.settings.selectedRolePath = nrp;
          await this.plugin.saveSettings();
          const chat = await ((_a2 = this.plugin.chatManager) == null ? void 0 : _a2.getActiveChat());
          if (chat && chat.metadata.selectedRolePath !== nrp) {
            await this.plugin.chatManager.updateActiveChatMetadata({ selectedRolePath: nrp });
            (_c2 = (_b2 = this.plugin.promptService) == null ? void 0 : _b2.clearRoleCache) == null ? void 0 : _c2.call(_b2);
          }
          this.plugin.emit("role-changed", "Default Assistant");
        }
        this.closeMenu();
      });
      if (roles.length > 0)
        container.createEl("hr", { cls: CSS_CLASS_MENU_SEPARATOR });
      roles.forEach((roleInfo) => {
        const roleOptionEl = container.createDiv({ cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_ROLE_OPTION}` });
        if (roleInfo.isCustom)
          roleOptionEl.addClass("is-custom");
        const iconSpan = roleOptionEl.createEl("span", { cls: "menu-option-icon" });
        if (roleInfo.path === currentChatRolePath) {
          (0, import_obsidian3.setIcon)(iconSpan, "check");
          roleOptionEl.addClass("is-selected");
        } else {
          (0, import_obsidian3.setIcon)(iconSpan, roleInfo.isCustom ? "user" : "box");
          iconSpan.style.minWidth = "18px";
        }
        roleOptionEl.createEl("span", { cls: "menu-option-text", text: roleInfo.name });
        this.registerDomEvent(roleOptionEl, "click", async () => {
          var _a2, _b2, _c2;
          const nrp = roleInfo.path;
          if (this.plugin.settings.selectedRolePath !== nrp || currentChatRolePath !== nrp) {
            this.plugin.settings.selectedRolePath = nrp;
            await this.plugin.saveSettings();
            const chat = await ((_a2 = this.plugin.chatManager) == null ? void 0 : _a2.getActiveChat());
            if (chat && chat.metadata.selectedRolePath !== nrp) {
              await this.plugin.chatManager.updateActiveChatMetadata({ selectedRolePath: nrp });
              (_c2 = (_b2 = this.plugin.promptService) == null ? void 0 : _b2.clearRoleCache) == null ? void 0 : _c2.call(_b2);
            }
            this.plugin.emit("role-changed", roleInfo.name);
          }
          this.closeMenu();
        });
      });
      this.updateSubmenuHeight(container);
    } catch (error) {
      container.empty();
      container.createEl("div", { cls: "menu-error-text", text: "Error roles." });
      this.updateSubmenuHeight(container);
    }
  }
  async renderChatListMenu() {
    var _a, _b;
    const container = this.chatSubmenuContent;
    if (!container)
      return;
    container.empty();
    try {
      const chats = ((_a = this.plugin.chatManager) == null ? void 0 : _a.listAvailableChats()) || [];
      const currentActiveId = (_b = this.plugin.chatManager) == null ? void 0 : _b.getActiveChatId();
      if (chats.length === 0) {
        container.createEl("div", { cls: "menu-info-text", text: "No saved chats." });
        return;
      }
      chats.forEach((chatMeta) => {
        const chatOptionEl = container.createDiv({ cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_CHAT_OPTION}` });
        const iconSpan = chatOptionEl.createEl("span", { cls: "menu-option-icon" });
        if (chatMeta.id === currentActiveId) {
          (0, import_obsidian3.setIcon)(iconSpan, "check");
          chatOptionEl.addClass("is-selected");
        } else {
          (0, import_obsidian3.setIcon)(iconSpan, "message-square");
        }
        const textSpan = chatOptionEl.createEl("span", { cls: "menu-option-text" });
        textSpan.createEl("div", { cls: "chat-option-name", text: chatMeta.name });
        const dateText = this.formatRelativeDate(new Date(chatMeta.lastModified));
        textSpan.createEl("div", { cls: "chat-option-date", text: dateText });
        this.registerDomEvent(chatOptionEl, "click", async () => {
          var _a2;
          if (chatMeta.id !== ((_a2 = this.plugin.chatManager) == null ? void 0 : _a2.getActiveChatId())) {
            await this.plugin.chatManager.setActiveChat(chatMeta.id);
          }
          this.closeMenu();
        });
      });
      this.updateSubmenuHeight(container);
    } catch (error) {
      container.empty();
      container.createEl("div", { cls: "menu-error-text", text: "Error chats." });
      this.updateSubmenuHeight(container);
    }
  }
  updateSubmenuHeight(contentEl) {
    if (contentEl && !contentEl.classList.contains(CSS_CLASS_SUBMENU_CONTENT_HIDDEN)) {
      requestAnimationFrame(() => {
        contentEl.style.maxHeight = contentEl.scrollHeight + "px";
      });
    }
  }
  // --- Speech Recognition Methods ---
  // --- Speech Recognition Placeholders ---
  initSpeechWorker() {
    try {
      const bufferToBase64 = (buffer) => {
        let binary = "";
        const bytes = new Uint8Array(buffer);
        const len = bytes.byteLength;
        for (let i = 0; i < len; i++) {
          binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
      };
      const workerCode = `
          // Worker Scope
          self.onmessage = async (event) => {
            const { apiKey, audioBlob, languageCode = 'uk-UA' } = event.data;

            if (!apiKey || apiKey.trim() === '') {
              self.postMessage({ error: true, message: 'Google API Key is not configured. Please add it in plugin settings.' });
              return;
            }

            const url = "https://speech.googleapis.com/v1/speech:recognize?key=" + apiKey;

            try {
              const arrayBuffer = await audioBlob.arrayBuffer();

              // Optimized Base64 Conversion (using helper if needed, or direct if worker supports TextDecoder efficiently)
              // Simpler approach: pass buffer directly if API allows, or use efficient base64:
              let base64Audio;
              if (typeof TextDecoder !== 'undefined') { // Browser environment check
                   // Modern approach (often faster if native)
                   const base64String = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
                   base64Audio = base64String;

              } else {
                   // Fallback (similar to original, ensure correctness)
                   base64Audio = btoa(
                     new Uint8Array(arrayBuffer).reduce((data, byte) => data + String.fromCharCode(byte), '')
                   );
              }


              const response = await fetch(url, {
                method: 'POST',
                body: JSON.stringify({
                  config: {
                    encoding: 'WEBM_OPUS', // Ensure this matches MediaRecorder output
                    sampleRateHertz: 48000, // Match sample rate if possible
                    languageCode: languageCode,
                    model: 'latest_long', // Consider other models if needed
                    enableAutomaticPunctuation: true,
                  },
                  audio: { content: base64Audio },
                }),
                headers: { 'Content-Type': 'application/json' },
              });

              const responseData = await response.json();

              if (!response.ok) {
                //console.error("Google Speech API Error:", responseData);
                self.postMessage({
                  error: true,
                  message: "Error from Google Speech API: " + (responseData.error?.message || response.statusText || 'Unknown error')
                });
                return;
              }

              if (responseData.results && responseData.results.length > 0) {
                const transcript = responseData.results
                  .map(result => result.alternatives[0].transcript)
                  .join(' ')
                  .trim();
                self.postMessage(transcript); // Send back only the transcript string
              } else {
                 // Handle cases where API returns ok but no results (e.g., silence)
                 self.postMessage({ error: true, message: 'No speech detected or recognized.' });
              }
            } catch (error) {
               //console.error("Error in speech worker processing:", error);
               self.postMessage({
                 error: true,
                 message: 'Error processing speech recognition: ' + (error instanceof Error ? error.message : String(error))
               });
            }
          };
        `;
      const workerBlob = new Blob([workerCode], { type: "application/javascript" });
      const workerUrl = URL.createObjectURL(workerBlob);
      this.speechWorker = new Worker(workerUrl);
      URL.revokeObjectURL(workerUrl);
      this.setupSpeechWorkerHandlers();
    } catch (error) {
      new import_obsidian3.Notice("Speech recognition feature failed to initialize.");
      this.speechWorker = null;
    }
  }
  setupSpeechWorkerHandlers() {
    if (!this.speechWorker)
      return;
    this.speechWorker.onmessage = (event) => {
      const data = event.data;
      if (data && typeof data === "object" && data.error) {
        new import_obsidian3.Notice(`Speech Recognition Error: ${data.message}`);
        this.updateInputPlaceholder(this.plugin.settings.modelName);
        this.updateSendButtonState();
        return;
      }
      if (typeof data === "string" && data.trim()) {
        const transcript = data.trim();
        this.insertTranscript(transcript);
      } else if (typeof data !== "string") {
      }
      this.updateSendButtonState();
    };
    this.speechWorker.onerror = (error) => {
      new import_obsidian3.Notice("An unexpected error occurred in the speech recognition worker.");
      this.updateInputPlaceholder(this.plugin.settings.modelName);
      this.stopVoiceRecording(false);
    };
  }
  insertTranscript(transcript) {
    var _a, _b;
    if (!this.inputEl)
      return;
    const currentVal = this.inputEl.value;
    const start = (_a = this.inputEl.selectionStart) != null ? _a : currentVal.length;
    const end = (_b = this.inputEl.selectionEnd) != null ? _b : currentVal.length;
    let textToInsert = transcript;
    const precedingChar = start > 0 ? currentVal[start - 1] : null;
    const followingChar = end < currentVal.length ? currentVal[end] : null;
    if (precedingChar && precedingChar !== " " && precedingChar !== "\n") {
      textToInsert = " " + textToInsert;
    }
    if (followingChar && followingChar !== " " && followingChar !== "\n" && !textToInsert.endsWith(" ")) {
      textToInsert += " ";
    }
    const newValue = currentVal.substring(0, start) + textToInsert + currentVal.substring(end);
    this.inputEl.value = newValue;
    const newCursorPos = start + textToInsert.length;
    this.inputEl.setSelectionRange(newCursorPos, newCursorPos);
    this.inputEl.focus();
    this.inputEl.dispatchEvent(new Event("input"));
  }
  async toggleVoiceRecognition() {
    if (this.mediaRecorder && this.mediaRecorder.state === "recording") {
      this.stopVoiceRecording(true);
    } else {
      await this.startVoiceRecognition();
    }
  }
  async startVoiceRecognition() {
    var _a;
    if (!this.speechWorker) {
      new import_obsidian3.Notice("\u0424\u0443\u043D\u043A\u0446\u0456\u044F \u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u0432\u0430\u043D\u043D\u044F \u043C\u043E\u0432\u043B\u0435\u043D\u043D\u044F \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u0430 (worker \u043D\u0435 \u0456\u043D\u0456\u0446\u0456\u0430\u043B\u0456\u0437\u043E\u0432\u0430\u043D\u043E).");
      return;
    }
    if (!this.plugin.settings.googleApiKey) {
      new import_obsidian3.Notice("\u041A\u043B\u044E\u0447 Google API \u043D\u0435 \u043D\u0430\u043B\u0430\u0448\u0442\u043E\u0432\u0430\u043D\u043E. \u0411\u0443\u0434\u044C \u043B\u0430\u0441\u043A\u0430, \u0434\u043E\u0434\u0430\u0439\u0442\u0435 \u0439\u043E\u0433\u043E \u0432 \u043D\u0430\u043B\u0430\u0448\u0442\u0443\u0432\u0430\u043D\u043D\u044F\u0445 \u043F\u043B\u0430\u0433\u0456\u043D\u0430 \u0434\u043B\u044F \u0432\u0438\u043A\u043E\u0440\u0438\u0441\u0442\u0430\u043D\u043D\u044F \u0433\u043E\u043B\u043E\u0441\u043E\u0432\u043E\u0433\u043E \u0432\u0432\u043E\u0434\u0443.");
      return;
    }
    try {
      this.audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      let recorderOptions;
      const preferredMimeType = "audio/webm;codecs=opus";
      if (MediaRecorder.isTypeSupported(preferredMimeType)) {
        recorderOptions = { mimeType: preferredMimeType };
      } else {
        recorderOptions = void 0;
      }
      this.mediaRecorder = new MediaRecorder(this.audioStream, recorderOptions);
      const audioChunks = [];
      (_a = this.voiceButton) == null ? void 0 : _a.classList.add(CSS_CLASS_RECORDING);
      (0, import_obsidian3.setIcon)(this.voiceButton, "stop-circle");
      this.inputEl.placeholder = "Recording... Speak now.";
      this.mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          audioChunks.push(event.data);
        }
      };
      this.mediaRecorder.onstop = () => {
        var _a2;
        if (this.speechWorker && audioChunks.length > 0) {
          const audioBlob = new Blob(audioChunks, { type: ((_a2 = this.mediaRecorder) == null ? void 0 : _a2.mimeType) || "audio/webm" });
          this.inputEl.placeholder = "Processing speech...";
          this.speechWorker.postMessage({
            apiKey: this.plugin.settings.googleApiKey,
            audioBlob,
            languageCode: this.plugin.settings.speechLanguage || "uk-UA"
          });
        } else if (audioChunks.length === 0) {
          this.updateInputPlaceholder(this.plugin.settings.modelName);
          this.updateSendButtonState();
        }
      };
      this.mediaRecorder.onerror = (event) => {
        new import_obsidian3.Notice("An error occurred during recording.");
        this.stopVoiceRecording(false);
      };
      this.mediaRecorder.start();
    } catch (error) {
      if (error instanceof DOMException && error.name === "NotAllowedError") {
        new import_obsidian3.Notice("Microphone access denied. Please grant permission.");
      } else if (error instanceof DOMException && error.name === "NotFoundError") {
        new import_obsidian3.Notice("Microphone not found. Please ensure it's connected and enabled.");
      } else {
        new import_obsidian3.Notice("Could not start voice recording.");
      }
      this.stopVoiceRecording(false);
    }
  }
  stopVoiceRecording(processAudio) {
    var _a, _b;
    if (this.mediaRecorder && this.mediaRecorder.state === "recording") {
      this.mediaRecorder.stop();
    } else if (!processAudio && ((_a = this.mediaRecorder) == null ? void 0 : _a.state) === "inactive") {
    }
    (_b = this.voiceButton) == null ? void 0 : _b.classList.remove(CSS_CLASS_RECORDING);
    (0, import_obsidian3.setIcon)(this.voiceButton, "microphone");
    this.updateInputPlaceholder(this.plugin.settings.modelName);
    this.updateSendButtonState();
    if (this.audioStream) {
      this.audioStream.getTracks().forEach((track) => track.stop());
      this.audioStream = null;
    }
    this.mediaRecorder = null;
  }
  // --- Thinking Tag Handling ---
  processThinkingTags(content) {
    const r = /<think>([\s\S]*?)<\/think>/g;
    let i = 0;
    const p = [];
    let m;
    while ((m = r.exec(content)) !== null) {
      if (m.index > i)
        p.push(this.markdownToHtml(content.substring(i, m.index)));
      const c = m[1];
      const h = `<div class="${CSS_CLASS_THINKING_BLOCK}"><div class="${CSS_CLASS_THINKING_HEADER}" data-fold-state="folded"><div class="${CSS_CLASS_THINKING_TOGGLE}">\u25BA</div><div class="${CSS_CLASS_THINKING_TITLE}">Thinking</div></div><div class="${CSS_CLASS_THINKING_CONTENT}" style="display: none;">${this.markdownToHtml(c)}</div></div>`;
      p.push(h);
      i = r.lastIndex;
    }
    if (i < content.length)
      p.push(this.markdownToHtml(content.substring(i)));
    return p.join("");
  }
  markdownToHtml(markdown) {
    var _a, _b;
    if (!(markdown == null ? void 0 : markdown.trim()))
      return "";
    const d = document.createElement("div");
    import_obsidian3.MarkdownRenderer.renderMarkdown(markdown, d, (_b = (_a = this.app.workspace.getActiveFile()) == null ? void 0 : _a.path) != null ? _b : "", this);
    return d.innerHTML;
  }
  addThinkingToggleListeners(contentEl) {
    const h = contentEl.querySelectorAll(`.${CSS_CLASS_THINKING_HEADER}`);
    h.forEach((hdr) => {
      this.registerDomEvent(hdr, "click", () => {
        const c = hdr.nextElementSibling;
        const t = hdr.querySelector(`.${CSS_CLASS_THINKING_TOGGLE}`);
        if (!c || !t)
          return;
        const f = hdr.getAttribute("data-fold-state") === "folded";
        if (f) {
          c.style.display = "block";
          t.textContent = "\u25BC";
          hdr.setAttribute("data-fold-state", "expanded");
        } else {
          c.style.display = "none";
          t.textContent = "\u25BA";
          hdr.setAttribute("data-fold-state", "folded");
        }
      });
    });
  }
  decodeHtmlEntities(text) {
    if (typeof document === "undefined") {
      return text.replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&#39;/g, "'");
    }
    const ta = document.createElement("textarea");
    ta.innerHTML = text;
    return ta.value;
  }
  detectThinkingTags(content) {
    return /<think>[\s\S]*?<\/think>/gi.test(content) ? { hasThinkingTags: true, format: "standard" } : { hasThinkingTags: false, format: "none" };
  }
  // --- Message Collapsing ---
  checkMessageForCollapsing(messageEl) {
    const c = messageEl.querySelector(`.${CSS_CLASS_CONTENT_COLLAPSIBLE}`);
    const h = this.plugin.settings.maxMessageHeight;
    if (!c || h <= 0)
      return;
    requestAnimationFrame(() => {
      const b = messageEl.querySelector(`.${CSS_CLASS_SHOW_MORE_BUTTON}`);
      b == null ? void 0 : b.remove();
      c.style.maxHeight = "";
      c.classList.remove(CSS_CLASS_CONTENT_COLLAPSED);
      const sh = c.scrollHeight;
      if (sh > h) {
        c.style.maxHeight = `${h}px`;
        c.classList.add(CSS_CLASS_CONTENT_COLLAPSED);
        const smb = messageEl.createEl("button", { cls: CSS_CLASS_SHOW_MORE_BUTTON, text: "Show More \u25BC" });
        this.registerDomEvent(smb, "click", () => this.toggleMessageCollapse(c, smb));
      }
    });
  }
  checkAllMessagesForCollapsing() {
    var _a;
    (_a = this.chatContainer) == null ? void 0 : _a.querySelectorAll(`.${CSS_CLASS_MESSAGE}`).forEach((msgEl) => {
      this.checkMessageForCollapsing(msgEl);
    });
  }
  toggleMessageCollapse(contentEl, buttonEl) {
    const i = contentEl.classList.contains(CSS_CLASS_CONTENT_COLLAPSED);
    const h = this.plugin.settings.maxMessageHeight;
    if (i) {
      contentEl.style.maxHeight = "";
      contentEl.classList.remove(CSS_CLASS_CONTENT_COLLAPSED);
      buttonEl.setText("Show Less \u25B2");
    } else {
      contentEl.style.maxHeight = `${h}px`;
      contentEl.classList.add(CSS_CLASS_CONTENT_COLLAPSED);
      buttonEl.setText("Show More \u25BC");
    }
  }
  // --- Helpers & Utilities ---
  getChatContainer() {
    return this.chatContainer;
  }
  clearChatContainerInternal() {
    this.currentMessages = [];
    this.lastRenderedMessageDate = null;
    if (this.chatContainer)
      this.chatContainer.empty();
    this.hideEmptyState();
  }
  clearDisplayAndState() {
    this.clearChatContainerInternal();
    this.showEmptyState();
    this.updateSendButtonState();
    setTimeout(() => this.focusInput(), 50);
  }
  addLoadingIndicator() {
    this.hideEmptyState();
    const group = this.chatContainer.createDiv({ cls: `${CSS_CLASS_MESSAGE_GROUP} ${CSS_CLASS_OLLAMA_GROUP}` });
    this.renderAvatar(group, false);
    const message = group.createDiv({ cls: `${CSS_CLASS_MESSAGE} ${CSS_CLASS_OLLAMA_MESSAGE}` });
    const dots = message.createDiv({ cls: CSS_CLASS_THINKING_DOTS });
    for (let i = 0; i < 3; i++)
      dots.createDiv({ cls: CSS_CLASS_THINKING_DOT });
    this.guaranteedScrollToBottom(50, true);
    return group;
  }
  removeLoadingIndicator(loadingEl) {
    if (loadingEl == null ? void 0 : loadingEl.parentNode) {
      loadingEl.remove();
    }
  }
  scrollToBottom() {
    this.guaranteedScrollToBottom(50, true);
  }
  clearInputField() {
    if (this.inputEl) {
      this.inputEl.value = "";
      this.inputEl.dispatchEvent(new Event("input"));
    }
  }
  // Trigger resize/button update
  focusInput() {
    setTimeout(() => {
      var _a;
      (_a = this.inputEl) == null ? void 0 : _a.focus();
    }, 0);
  }
  // Use setTimeout to ensure focus happens after potential UI updates
  /** Guarantees scroll to bottom after a delay, respecting user scroll position unless forced */
  guaranteedScrollToBottom(delay = 50, forceScroll = false) {
    if (this.scrollTimeout) {
      clearTimeout(this.scrollTimeout);
      this.scrollTimeout = null;
    }
    this.scrollTimeout = setTimeout(() => {
      requestAnimationFrame(() => {
        var _a, _b;
        if (this.chatContainer) {
          const threshold = 100;
          const isScrolledUp = this.chatContainer.scrollHeight - this.chatContainer.scrollTop - this.chatContainer.clientHeight > threshold;
          if (isScrolledUp !== this.userScrolledUp) {
            this.userScrolledUp = isScrolledUp;
            if (!isScrolledUp)
              (_a = this.newMessagesIndicatorEl) == null ? void 0 : _a.classList.remove(CSS_CLASS_VISIBLE);
          }
          if (forceScroll || !this.userScrolledUp || this.isProcessing) {
            const behavior = this.isProcessing ? "auto" : "smooth";
            this.chatContainer.scrollTo({ top: this.chatContainer.scrollHeight, behavior });
            if (forceScroll) {
              this.userScrolledUp = false;
              (_b = this.newMessagesIndicatorEl) == null ? void 0 : _b.classList.remove(CSS_CLASS_VISIBLE);
            }
          }
        } else {
        }
      });
      this.scrollTimeout = null;
    }, delay);
  }
  // Formatting Helpers
  formatTime(date) {
    return date.toLocaleTimeString(void 0, { hour: "numeric", minute: "2-digit" });
  }
  // Use locale default time format
  formatDateSeparator(date) {
    const now = new Date();
    const yesterday = new Date(now);
    yesterday.setDate(now.getDate() - 1);
    if (this.isSameDay(date, now))
      return "Today";
    else if (this.isSameDay(date, yesterday))
      return "Yesterday";
    else
      return date.toLocaleDateString(void 0, { weekday: "long", year: "numeric", month: "long", day: "numeric" });
  }
  formatRelativeDate(date) {
    const now = new Date();
    const diffSeconds = Math.round((now.getTime() - date.getTime()) / 1e3);
    const diffDays = Math.floor(diffSeconds / (60 * 60 * 24));
    if (diffDays === 0) {
      const diffHours = Math.floor(diffSeconds / (60 * 60));
      if (diffHours < 1)
        return "Just now";
      if (diffHours === 1)
        return "1 hour ago";
      if (diffHours < now.getHours())
        return `${diffHours} hours ago`;
      else
        return "Today";
    } else if (diffDays === 1) {
      return "Yesterday";
    } else if (diffDays < 7) {
      return `${diffDays} days ago`;
    } else {
      return date.toLocaleDateString(void 0, { month: "short", day: "numeric" });
    }
  }
  isSameDay(date1, date2) {
    return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate();
  }
  // /** Sets the loading state for the UI (disables/enables input elements) */
  // public setLoadingState(isLoading: boolean): void {
  //   this.isProcessing = isLoading;
  //   if (this.inputEl) this.inputEl.disabled = isLoading;
  //   this.updateSendButtonState(); // Send button depends on both text and processing state
  //   if (this.voiceButton) { this.voiceButton.disabled = isLoading; this.voiceButton.classList.toggle(CSS_CLASS_DISABLED, isLoading); }
  //   if (this.translateInputButton) { this.translateInputButton.disabled = isLoading; this.translateInputButton.classList.toggle(CSS_CLASS_DISABLED, isLoading); }
  //   if (this.menuButton) { this.menuButton.disabled = isLoading; this.menuButton.classList.toggle(CSS_CLASS_DISABLED, isLoading); }
  // }
  // Formatting function used by export
  formatChatToMarkdown(messagesToFormat) {
    let localLastDate = null;
    const exportTimestamp = new Date();
    let markdown = `# Ollama Chat Export
> Exported on: ${exportTimestamp.toLocaleString(void 0)}

`;
    messagesToFormat.forEach((message) => {
      if (localLastDate === null || !this.isSameDay(localLastDate, message.timestamp)) {
        if (localLastDate !== null)
          markdown += `***
`;
        markdown += `**${this.formatDateSeparator(message.timestamp)}**
***

`;
      }
      localLastDate = message.timestamp;
      const time = this.formatTime(message.timestamp);
      let prefix = "";
      let contentPrefix = "";
      switch (message.role) {
        case "user":
          prefix = `**User (${time}):**
`;
          break;
        case "assistant":
          prefix = `**Assistant (${time}):**
`;
          break;
        case "system":
          prefix = `> _[System (${time})]_ 
> `;
          contentPrefix = "> ";
          break;
        case "error":
          prefix = `> [!ERROR] Error (${time}):
> `;
          contentPrefix = "> ";
          break;
      }
      markdown += prefix;
      let content = message.content.trim();
      if (contentPrefix) {
        markdown += content.split("\n").join(`
${contentPrefix}`) + "\n\n";
      } else if (content.includes("```")) {
        content = content.replace(/(\n*)```/g, "\n\n```").replace(/```(\n*)/g, "```\n\n");
        markdown += content.trim() + "\n\n";
      } else {
        markdown += content + "\n\n";
      }
    });
    return markdown.trim();
  }
  // private handleRenameChatClick = async (): Promise<void> => {
  //   this.closeMenu();
  //   const activeChat = await this.plugin.chatManager?.getActiveChat();
  //   if (!activeChat) {
  //     new Notice("No active chat to rename.");
  //     return;
  //   }
  //   const currentName = activeChat.metadata.name;
  //   // --- Використання PromptModal ---
  //   new PromptModal(
  //     this.app,
  //     'Rename Chat', // Заголовок вікна
  //     `Enter new name for "${currentName}":`, // Текст підказки
  //     currentName, // Початкове значення
  //     async (newName) => { // Функція, що виконається при Submit
  //       if (newName && newName.trim() !== "" && newName.trim() !== currentName) {
  //         //console.log(`[OllamaView] Renaming chat <span class="math-inline">\{activeChat\.metadata\.id\} to "</span>{newName.trim()}"`);
  //         const success = await this.plugin.chatManager.renameChat(activeChat.metadata.id, newName.trim());
  //         if (success) { new Notice(`Chat renamed to "${newName.trim()}"`); }
  //         else { new Notice("Failed to rename chat."); }
  //       } else {
  //         // Порожнє ім'я або не змінилося (або користувач нічого не ввів і натиснув Submit)
  //         // Можна додати перевірку на порожнє значення в самому PromptModal перед onSubmit
  //         if (newName?.trim() === currentName) {
  //           new Notice("Name unchanged.");
  //         } else {
  //           new Notice("Rename cancelled or invalid name entered.");
  //         }
  //       }
  //     }
  //   ).open(); // Відкриваємо модальне вікно
  //   // --- Кінець використання PromptModal ---
  // }
  // private handleDeleteChatClick = async (): Promise<void> => {
  //   this.closeMenu();
  //   const activeChat = await this.plugin.chatManager?.getActiveChat();
  //   if (!activeChat) {
  //     new Notice("No active chat to delete.");
  //     return;
  //   }
  //   const chatName = activeChat.metadata.name;
  //   // --- Використання ConfirmModal ---
  //   new ConfirmModal(
  //     this.app,
  //     'Delete Chat', // Заголовок
  //     `Are you sure you want to delete chat "${chatName}"?\nThis action cannot be undone.`, // Повідомлення
  //     async () => { // Функція, що виконається при Confirm
  //       //console.log(`[OllamaView] Deleting chat <span class="math-inline">\{activeChat\.metadata\.id\} \("</span>{chatName}")`);
  //       const success = await this.plugin.chatManager.deleteChat(activeChat.metadata.id);
  //       if (success) { new Notice(`Chat "${chatName}" deleted.`); }
  //       else { new Notice(`Failed to delete chat "${chatName}".`); }
  //     }
  //   ).open(); // Відкриваємо модальне вікно
  //   // --- Кінець використання ConfirmModal ---
  // }
  // private handleCloneChatClick = async (): Promise<void> => {
  //   this.closeMenu();
  //   const activeChat = await this.plugin.chatManager?.getActiveChat();
  //   if (!activeChat) {
  //     new Notice("No active chat to clone.");
  //     return;
  //   }
  //   const originalName = activeChat.metadata.name;
  //   //console.log(`[OllamaView] Cloning chat ${activeChat.metadata.id} ("${originalName}")`);
  //   const cloningNotice = new Notice("Cloning chat...", 0); // Повідомлення без автозникання
  //   try {
  //     // Викликаємо новий метод в ChatManager
  //     const clonedChat = await this.plugin.chatManager.cloneChat(activeChat.metadata.id);
  //     if (clonedChat) {
  //       cloningNotice.hide(); // Ховаємо повідомлення про клонування
  //       new Notice(`Chat cloned as "${clonedChat.metadata.name}" and activated.`);
  //       // View оновить себе через подію 'active-chat-changed',
  //       // яку викличе setActiveChat всередині cloneChat.
  //     } else {
  //       cloningNotice.hide();
  //       new Notice("Failed to clone chat.");
  //     }
  //   } catch (error) {
  //     cloningNotice.hide();
  //     //console.error("Error cloning chat:", error);
  //     new Notice("An error occurred while cloning the chat.");
  //   }
  // }
};

// src/settings.ts
var import_obsidian4 = require("obsidian");
var LANGUAGES2 = {
  /* ... ваш довгий список мов ... */
  "af": "Afrikaans",
  "sq": "Albanian",
  "am": "Amharic",
  "ar": "Arabic",
  "hy": "Armenian",
  "az": "Azerbaijani",
  "eu": "Basque",
  "be": "Belarusian",
  "bn": "Bengali",
  "bs": "Bosnian",
  "bg": "Bulgarian",
  "ca": "Catalan",
  "ceb": "Cebuano",
  "ny": "Chichewa",
  "zh-CN": "Chinese (Simplified)",
  "zh-TW": "Chinese (Traditional)",
  "co": "Corsican",
  "hr": "Croatian",
  "cs": "Czech",
  "da": "Danish",
  "nl": "Dutch",
  "en": "English",
  "eo": "Esperanto",
  "et": "Estonian",
  "tl": "Filipino",
  "fi": "Finnish",
  "fr": "French",
  "fy": "Frisian",
  "gl": "Galician",
  "ka": "Georgian",
  "de": "German",
  "el": "Greek",
  "gu": "Gujarati",
  "ht": "Haitian Creole",
  "ha": "Hausa",
  "haw": "Hawaiian",
  "iw": "Hebrew",
  "he": "Hebrew",
  "hi": "Hindi",
  "hmn": "Hmong",
  "hu": "Hungarian",
  "is": "Icelandic",
  "ig": "Igbo",
  "id": "Indonesian",
  "ga": "Irish",
  "it": "Italian",
  "ja": "Japanese",
  "jw": "Javanese",
  "kn": "Kannada",
  "kk": "Kazakh",
  "km": "Khmer",
  "rw": "Kinyarwanda",
  "ko": "Korean",
  "ku": "Kurdish (Kurmanji)",
  "ky": "Kyrgyz",
  "lo": "Lao",
  "la": "Latin",
  "lv": "Latvian",
  "lt": "Lithuanian",
  "lb": "Luxembourgish",
  "mk": "Macedonian",
  "mg": "Malagasy",
  "ms": "Malay",
  "ml": "Malayalam",
  "mt": "Maltese",
  "mi": "Maori",
  "mr": "Marathi",
  "mn": "Mongolian",
  "my": "Myanmar (Burmese)",
  "ne": "Nepali",
  "no": "Norwegian",
  "or": "Odia (Oriya)",
  "ps": "Pashto",
  "fa": "Persian",
  "pl": "Polish",
  "pt": "Portuguese",
  "pa": "Punjabi",
  "ro": "Romanian",
  "ru": "Russian",
  "sm": "Samoan",
  "gd": "Scots Gaelic",
  "sr": "Serbian",
  "st": "Sesotho",
  "sn": "Shona",
  "sd": "Sindhi",
  "si": "Sinhala",
  "sk": "Slovak",
  "sl": "Slovenian",
  "so": "Somali",
  "es": "Spanish",
  "su": "Sundanese",
  "sw": "Swahili",
  "sv": "Swedish",
  "tg": "Tajik",
  "ta": "Tamil",
  "tt": "Tatar",
  "te": "Telugu",
  "th": "Thai",
  "tr": "Turkish",
  "tk": "Turkmen",
  "uk": "Ukrainian",
  "ur": "Urdu",
  "ug": "Uyghur",
  "uz": "Uzbek",
  "vi": "Vietnamese",
  "cy": "Welsh",
  "xh": "Xhosa",
  "yi": "Yiddish",
  "yo": "Yoruba",
  "zu": "Zulu"
};
var DEFAULT_SETTINGS = {
  ollamaServerUrl: "http://localhost:11434",
  modelName: "",
  temperature: 0.7,
  contextWindow: 4096,
  userRolesFolderPath: "",
  selectedRolePath: "",
  saveMessageHistory: true,
  ragEnabled: false,
  ragFolderPath: "",
  googleApiKey: "",
  speechLanguage: "uk-UA",
  userAvatarType: "initials",
  userAvatarContent: "U",
  aiAvatarType: "icon",
  aiAvatarContent: "bot",
  maxMessageHeight: 300,
  enableTranslation: false,
  translationTargetLanguage: "uk",
  googleTranslationApiKey: "",
  chatHistoryFolderPath: "Ollama Chats",
  chatExportFolderPath: "",
  enableProductivityFeatures: false,
  // <-- За замовчуванням вимкнено
  dailyTaskFileName: "Tasks_Today.md",
  // <-- Ім'я файлу за замовчуванням  useAdvancedContextStrategy: false, // За замовчуванням - вимкнено
  useAdvancedContextStrategy: false,
  enableSummarization: false,
  // За замовчуванням - вимкнено
  summarizationPrompt: "Summarize the key points of the preceding conversation concisely, focusing on information relevant for future interactions:\n{text_to_summarize}",
  // Приклад промпту
  keepLastNMessagesBeforeSummary: 10,
  // Зберігати останні 10 повідомлень
  summarizationChunkSize: 1500,
  // Розмір блоку для підсумовування (токени)
  followRole: true
  // За замовчуванням - використовувати роль
  // --------------------------------------
};
var OllamaSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.debouncedUpdateChatPath = (0, import_obsidian4.debounce)(async () => {
      console.log("Debounced: Updating chat path and ensuring folder exists...");
      if (this.plugin.chatManager) {
        this.plugin.chatManager.updateChatsFolderPath();
        await this.plugin.chatManager.ensureChatsFolderExists();
      }
    }, 1e3, true);
    this.debouncedUpdateRolePath = (0, import_obsidian4.debounce)(async () => {
      console.log("Debounced: Refreshing role list due to path change...");
      await this.plugin.listRoleFiles(true);
      this.plugin.emit("roles-updated");
    }, 1e3, true);
    this.debouncedUpdateRagPath = (0, import_obsidian4.debounce)(async () => {
      console.log("Debounced: Re-indexing RAG due to path change...");
      if (this.plugin.settings.ragEnabled && this.plugin.ragService) {
        await this.plugin.ragService.indexDocuments();
      }
    }, 1e3, true);
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Ollama Chat Settings" });
    containerEl.createEl("h3", { text: "Connection & Model" });
    new import_obsidian4.Setting(containerEl).setName("Ollama Server URL").setDesc("The URL of your running Ollama server.").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.ollamaServerUrl).setValue(this.plugin.settings.ollamaServerUrl).onChange(async (value) => {
      this.plugin.settings.ollamaServerUrl = value.trim() || DEFAULT_SETTINGS.ollamaServerUrl;
      await this.plugin.saveSettings();
      this.plugin.updateOllamaServiceConfig();
    }));
    new import_obsidian4.Setting(containerEl).setName("Default Model Name").setDesc("The default Ollama model to use for new chats (e.g., 'llama3:latest', 'mistral'). Needs to be available on your server.").addText((text) => text.setPlaceholder("Enter model name").setValue(this.plugin.settings.modelName).onChange(async (value) => {
      this.plugin.settings.modelName = value.trim();
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Default Temperature").setDesc("Controls randomness. Lower values (e.g., 0.2) make output more deterministic, higher values (e.g., 0.8) make it more creative.").addSlider((slider) => slider.setLimits(0, 1, 0.1).setValue(this.plugin.settings.temperature).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.temperature = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Context Window Size (Tokens)").setDesc("Maximum number of tokens (input + output) the model considers. Adjust based on model and available memory.").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.contextWindow.toString()).setValue(this.plugin.settings.contextWindow.toString()).onChange(async (value) => {
      const num = parseInt(value.trim(), 10);
      if (!isNaN(num) && num > 0) {
        this.plugin.settings.contextWindow = num;
      } else {
        this.plugin.settings.contextWindow = DEFAULT_SETTINGS.contextWindow;
      }
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Roles & Personas" });
    new import_obsidian4.Setting(containerEl).setName("Custom Roles Folder Path").setDesc("Folder within your vault containing custom role definition (.md) files.").addText((text) => text.setPlaceholder("Example: System Prompts/Ollama Roles").setValue(this.plugin.settings.userRolesFolderPath).onChange(async (value) => {
      this.plugin.settings.userRolesFolderPath = value.trim();
      await this.plugin.saveSettings();
      this.debouncedUpdateRolePath();
    }));
    new import_obsidian4.Setting(containerEl).setName("Always Apply Selected Role").setDesc("If enabled, the globally selected role (or chat-specific role) will always be used as the system prompt.").addToggle((toggle) => toggle.setValue(this.plugin.settings.followRole).onChange(async (value) => {
      this.plugin.settings.followRole = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Storage & History" });
    new import_obsidian4.Setting(containerEl).setName("Save Message History").setDesc("Automatically save chat conversations to files.").addToggle((toggle) => toggle.setValue(this.plugin.settings.saveMessageHistory).onChange(async (value) => {
      this.plugin.settings.saveMessageHistory = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Chat History Folder Path").setDesc("Folder within your vault to store chat history (.json files). Leave empty to save in the vault root.").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.chatHistoryFolderPath || "Vault Root").setValue(this.plugin.settings.chatHistoryFolderPath).onChange(async (value) => {
      this.plugin.settings.chatHistoryFolderPath = value.trim();
      await this.plugin.saveSettings();
      this.debouncedUpdateChatPath();
    }));
    containerEl.createEl("h3", { text: "Retrieval-Augmented Generation (RAG)" });
    new import_obsidian4.Setting(containerEl).setName("Enable RAG").setDesc("Allow the chat to retrieve information from your notes for context (requires indexing).").addToggle((toggle) => toggle.setValue(this.plugin.settings.ragEnabled).onChange(async (value) => {
      this.plugin.settings.ragEnabled = value;
      await this.plugin.saveSettings();
      this.display();
      if (value)
        this.debouncedUpdateRagPath();
    }));
    if (this.plugin.settings.ragEnabled) {
      new import_obsidian4.Setting(containerEl).setName("RAG Documents Folder Path").setDesc("Folder within your vault containing notes to use for RAG context.").addText((text) => text.setPlaceholder("Example: Knowledge Base/RAG Docs").setValue(this.plugin.settings.ragFolderPath).onChange(async (value) => {
        var _a, _b, _c, _d;
        this.plugin.settings.ragFolderPath = value.trim();
        await this.plugin.saveSettings();
        this.debouncedUpdateRagPath();
        (_b = (_a = this.plugin).updateDailyTaskFilePath) == null ? void 0 : _b.call(_a);
        (_d = (_c = this.plugin).loadAndProcessInitialTasks) == null ? void 0 : _d.call(_c);
      }));
    }
    containerEl.createEl("h3", { text: "Productivity Assistant Features" });
    new import_obsidian4.Setting(containerEl).setName("Enable Productivity Features").setDesc("Activate features like daily task integration and advanced context management for planning-oriented personas.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableProductivityFeatures).onChange(async (value) => {
      this.plugin.settings.enableProductivityFeatures = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.enableProductivityFeatures) {
      new import_obsidian4.Setting(containerEl).setName("Daily Task File Name").setDesc("The exact filename (including .md) of your daily task list within the RAG folder.").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.dailyTaskFileName).setValue(this.plugin.settings.dailyTaskFileName).onChange(async (value) => {
        var _a, _b, _c, _d;
        this.plugin.settings.dailyTaskFileName = value.trim() || DEFAULT_SETTINGS.dailyTaskFileName;
        await this.plugin.saveSettings();
        (_b = (_a = this.plugin).updateDailyTaskFilePath) == null ? void 0 : _b.call(_a);
        (_d = (_c = this.plugin).loadAndProcessInitialTasks) == null ? void 0 : _d.call(_c);
      }));
      new import_obsidian4.Setting(containerEl).setName("Use Advanced Context Strategy").setDesc("Enables summarization and chunking for long conversations (requires Productivity Features enabled).").addToggle((toggle) => toggle.setValue(this.plugin.settings.useAdvancedContextStrategy).onChange(async (value) => {
        this.plugin.settings.useAdvancedContextStrategy = value;
        await this.plugin.saveSettings();
        this.display();
      }));
      if (this.plugin.settings.useAdvancedContextStrategy) {
        new import_obsidian4.Setting(containerEl).setName("Enable Context Summarization").setDesc("Allow summarizing older parts of the chat history.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableSummarization).onChange(async (value) => {
          this.plugin.settings.enableSummarization = value;
          await this.plugin.saveSettings();
          this.display();
        }));
        if (this.plugin.settings.enableSummarization) {
          new import_obsidian4.Setting(containerEl).setName("Summarization Prompt").setDesc("Prompt for summarizing history. Use {text_to_summarize}.").addTextArea(
            (text) => text.setPlaceholder(DEFAULT_SETTINGS.summarizationPrompt).setValue(this.plugin.settings.summarizationPrompt).onChange(async (value) => {
              this.plugin.settings.summarizationPrompt = value || DEFAULT_SETTINGS.summarizationPrompt;
              await this.plugin.saveSettings();
            }).inputEl.setAttrs({ rows: 4 })
          );
        }
        new import_obsidian4.Setting(containerEl).setName("Keep Last N Messages Before Summary").setDesc("Number of recent messages kept verbatim before considering summarization.").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.keepLastNMessagesBeforeSummary.toString()).setValue(this.plugin.settings.keepLastNMessagesBeforeSummary.toString()).onChange(async (value) => {
          const num = parseInt(value.trim(), 10);
          this.plugin.settings.keepLastNMessagesBeforeSummary = !isNaN(num) && num >= 0 ? num : DEFAULT_SETTINGS.keepLastNMessagesBeforeSummary;
          await this.plugin.saveSettings();
        }));
        new import_obsidian4.Setting(containerEl).setName("Summarization Chunk Size (Tokens)").setDesc("Approximate token size of message chunks processed for summarization.").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.summarizationChunkSize.toString()).setValue(this.plugin.settings.summarizationChunkSize.toString()).onChange(async (value) => {
          const num = parseInt(value.trim(), 10);
          this.plugin.settings.summarizationChunkSize = !isNaN(num) && num > 100 ? num : DEFAULT_SETTINGS.summarizationChunkSize;
          await this.plugin.saveSettings();
        }));
      }
    }
    containerEl.createEl("h3", { text: "Appearance" });
    new import_obsidian4.Setting(containerEl).setName("User Avatar Style").addDropdown((dropdown) => dropdown.addOption("initials", "Initials").addOption("icon", "Icon").setValue(this.plugin.settings.userAvatarType).onChange(async (value) => {
      this.plugin.settings.userAvatarType = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.userAvatarType === "initials") {
      new import_obsidian4.Setting(containerEl).setName("User Initials").setDesc("Max 2 characters.").addText((text) => text.setValue(this.plugin.settings.userAvatarContent).onChange(async (value) => {
        this.plugin.settings.userAvatarContent = value.trim().substring(0, 2) || "U";
        await this.plugin.saveSettings();
      }));
    } else {
      new import_obsidian4.Setting(containerEl).setName("User Icon ID").setDesc('Enter an Obsidian icon ID (e.g., "user", "lucide-user").').addText((text) => text.setPlaceholder("user").setValue(this.plugin.settings.userAvatarContent).onChange(async (value) => {
        this.plugin.settings.userAvatarContent = value.trim() || "user";
        await this.plugin.saveSettings();
      }));
    }
    new import_obsidian4.Setting(containerEl).setName("AI Avatar Style").addDropdown((dropdown) => dropdown.addOption("initials", "Initials").addOption("icon", "Icon").setValue(this.plugin.settings.aiAvatarType).onChange(async (value) => {
      this.plugin.settings.aiAvatarType = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.aiAvatarType === "initials") {
      new import_obsidian4.Setting(containerEl).setName("AI Initials").setDesc("Max 2 characters.").addText((text) => text.setValue(this.plugin.settings.aiAvatarContent).onChange(async (value) => {
        this.plugin.settings.aiAvatarContent = value.trim().substring(0, 2) || "AI";
        await this.plugin.saveSettings();
      }));
    } else {
      new import_obsidian4.Setting(containerEl).setName("AI Icon ID").setDesc('Enter an Obsidian icon ID (e.g., "bot", "lucide-bot").').addText((text) => text.setPlaceholder("bot").setValue(this.plugin.settings.aiAvatarContent).onChange(async (value) => {
        this.plugin.settings.aiAvatarContent = value.trim() || "bot";
        await this.plugin.saveSettings();
      }));
    }
    new import_obsidian4.Setting(containerEl).setName("Max Message Height (pixels)").setDesc("Collapse longer messages, showing a 'Show More' button. Set to 0 to disable collapsing.").addText((text) => text.setPlaceholder("Example: 300").setValue(this.plugin.settings.maxMessageHeight.toString()).onChange(async (value) => {
      const num = parseInt(value.trim(), 10);
      if (!isNaN(num) && num >= 0) {
        this.plugin.settings.maxMessageHeight = num;
      } else {
        this.plugin.settings.maxMessageHeight = DEFAULT_SETTINGS.maxMessageHeight;
      }
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Speech & Translation" });
    new import_obsidian4.Setting(containerEl).setName("Google API Key (Speech-to-Text)").setDesc("Required for the voice input feature. Keep this confidential.").addText((text) => text.setPlaceholder("Enter your API Key").setValue(this.plugin.settings.googleApiKey).onChange(async (value) => {
      this.plugin.settings.googleApiKey = value.trim();
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Speech Recognition Language").setDesc("Select the language for voice input.").addDropdown((dropdown) => {
      const speechLangs = { "uk-UA": "Ukrainian", "en-US": "English (US)", "en-GB": "English (UK)", "de-DE": "German", "fr-FR": "French", "es-ES": "Spanish", "it-IT": "Italian", "ja-JP": "Japanese", "ko-KR": "Korean", "pt-BR": "Portuguese (Brazil)", "ru-RU": "Russian", "zh-CN": "Chinese (Mandarin, Simplified)" };
      for (const code in speechLangs) {
        dropdown.addOption(code, speechLangs[code]);
      }
      dropdown.setValue(this.plugin.settings.speechLanguage).onChange(async (value) => {
        this.plugin.settings.speechLanguage = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian4.Setting(containerEl).setName("Enable Translation Feature").setDesc("Show buttons to translate messages or input using Google Translate API.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableTranslation).onChange(async (value) => {
      this.plugin.settings.enableTranslation = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.enableTranslation) {
      new import_obsidian4.Setting(containerEl).setName("Target Translation Language").setDesc("Select the language to translate messages/input into.").addDropdown((dropdown) => {
        for (const code in LANGUAGES2) {
          dropdown.addOption(code, LANGUAGES2[code]);
        }
        dropdown.setValue(this.plugin.settings.translationTargetLanguage).onChange(async (value) => {
          this.plugin.settings.translationTargetLanguage = value;
          await this.plugin.saveSettings();
        });
      });
      new import_obsidian4.Setting(containerEl).setName("Google Cloud Translation API Key").setDesc("Required for the translation feature. Keep this confidential.").addText((text) => text.setPlaceholder("Enter your API Key").setValue(this.plugin.settings.googleTranslationApiKey).onChange(async (value) => {
        this.plugin.settings.googleTranslationApiKey = value.trim();
        await this.plugin.saveSettings();
      }));
    }
    containerEl.createEl("h3", { text: "Export Settings" });
    new import_obsidian4.Setting(containerEl).setName("Chat Export Folder Path").setDesc("Folder within your vault to save exported Markdown chats. Leave empty to save in the vault root.").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.chatExportFolderPath || "Vault Root").setValue(this.plugin.settings.chatExportFolderPath).onChange(async (value) => {
      this.plugin.settings.chatExportFolderPath = value.trim();
      await this.plugin.saveSettings();
    }));
  }
};

// src/ragService.ts
var RagService = class {
  constructor(plugin) {
    this.documents = [];
    this.isIndexing = false;
    this.plugin = plugin;
  }
  /**
   * Index all markdown files in the specified folder path
   */
  async indexDocuments() {
    var _a, _b;
    if (this.isIndexing)
      return;
    this.isIndexing = true;
    try {
      const folderPath = this.plugin.settings.ragFolderPath;
      const vault = this.plugin.app.vault;
      console.log(`AI Assistant path: "${folderPath}" (RAG documents will be loaded from here)`);
      const allFiles = vault.getFiles();
      console.log(`Total files in vault: ${allFiles.length}`);
      const files = await this.getMarkdownFiles(vault, folderPath);
      console.log(`Found ${files.length} markdown files from "${folderPath}"`);
      console.log(`Indexing ${files.length} markdown files from ${folderPath}`);
      this.documents = [];
      for (const file of files) {
        try {
          const content = await vault.read(file);
          this.documents.push({
            path: file.path,
            content,
            metadata: {
              filename: file.name,
              created: (_a = file.stat) == null ? void 0 : _a.ctime,
              modified: (_b = file.stat) == null ? void 0 : _b.mtime
            }
          });
        } catch (error) {
          console.error(`Error reading file ${file.path}:`, error);
        }
      }
      console.log(`Indexed ${this.documents.length} documents for RAG`);
    } catch (error) {
      console.error("Error indexing documents:", error);
    } finally {
      this.isIndexing = false;
    }
  }
  /**
   * Get all markdown files in the specified folder path
   */
  async getMarkdownFiles(vault, folderPath) {
    const files = [];
    if (!folderPath) {
      return files;
    }
    let normalizedFolderPath = folderPath;
    if (!normalizedFolderPath.endsWith("/")) {
      normalizedFolderPath += "/";
    }
    const dataFolderPath = normalizedFolderPath;
    console.log(`Looking for markdown files in: "${dataFolderPath}"`);
    const allFiles = vault.getFiles();
    for (const file of allFiles) {
      if (file.extension === "md" && file.path.startsWith(dataFolderPath)) {
        console.log(`Adding file: ${file.path}`);
        files.push(file);
      }
    }
    return files;
  }
  /**
   * Simple search implementation to find relevant documents for a query
   * Later this could be replaced with a more sophisticated vector search
   */
  findRelevantDocuments(query, limit = 5) {
    if (!this.documents.length) {
      return [];
    }
    const scoredDocs = this.documents.map((doc) => {
      const lowerContent = doc.content.toLowerCase();
      const lowerQuery = query.toLowerCase();
      const terms = lowerQuery.split(/\s+/);
      let score = 0;
      for (const term of terms) {
        if (term.length > 2) {
          const regex = new RegExp(term, "gi");
          const matches = lowerContent.match(regex);
          if (matches) {
            score += matches.length;
          }
        }
      }
      return { doc, score };
    });
    return scoredDocs.sort((a, b) => b.score - a.score).slice(0, limit).map((item) => item.doc);
  }
  /**
   * Prepare context from relevant documents
   */
  prepareContext(query) {
    if (!this.plugin.settings.ragEnabled || this.documents.length === 0) {
      return "";
    }
    const limit = this.plugin.settings.contextWindow;
    const relevantDocs = this.findRelevantDocuments(query, limit);
    if (relevantDocs.length === 0) {
      return "";
    }
    let context = "### Context:\n\n";
    relevantDocs.forEach((doc, index) => {
      var _a;
      context += `Document ${index + 1} (${(_a = doc.metadata) == null ? void 0 : _a.filename}):
`;
      const maxChars = 1500;
      const content = doc.content.length > maxChars ? doc.content.substring(0, maxChars) + "..." : doc.content;
      context += content + "\n\n";
    });
    context += "### End of context\n\n";
    return context;
  }
};

// src/OllamaService.ts
var OllamaService = class {
  // Keep event emitter for connection errors
  constructor(plugin) {
    // private promptService: PromptService;
    // No direct view reference needed now
    // private ollamaView: OllamaView | null = null;
    this.eventHandlers = {};
    this.plugin = plugin;
  }
  // --- Event Emitter for internal errors (like connection) ---
  on(event, callback) {
    if (!this.eventHandlers[event])
      this.eventHandlers[event] = [];
    this.eventHandlers[event].push(callback);
    return () => {
      var _a, _b;
      this.eventHandlers[event] = (_a = this.eventHandlers[event]) == null ? void 0 : _a.filter((h) => h !== callback);
      if (((_b = this.eventHandlers[event]) == null ? void 0 : _b.length) === 0)
        delete this.eventHandlers[event];
    };
  }
  emit(event, data) {
    const h = this.eventHandlers[event];
    if (h)
      h.slice().forEach((handler) => {
        try {
          handler(data);
        } catch (e) {
          console.error(`Error in OllamaService event handler for ${event}:`, e);
        }
      });
  }
  // --- End Event Emitter ---
  // setOllamaView(view: OllamaView): void { // No longer needed
  //   this.ollamaView = view;
  // }
  setBaseUrl(url) {
  }
  // --- NEW: Low-level method for /api/generate ---
  /**
   * Sends a raw request body to the Ollama /api/generate endpoint.
   * @param requestBody The complete request body including model, prompt, options, etc.
   * @returns The parsed OllamaGenerateResponse.
   */
  async generateRaw(requestBody) {
    var _a;
    console.log("[OllamaService] Sending RAW request to /api/generate:", JSON.stringify({ ...requestBody, prompt: ((_a = requestBody.prompt) == null ? void 0 : _a.substring(0, 100)) + "..." }));
    if (!requestBody.model || !requestBody.prompt) {
      throw new Error("generateRaw requires 'model' and 'prompt' in requestBody");
    }
    if (!requestBody.system) {
      delete requestBody.system;
    }
    return await this._ollamaFetch("/api/generate", {
      method: "POST",
      body: JSON.stringify(requestBody)
    });
  }
  // --- END NEW METHOD ---
  /**
   * Generates a chat response based on the current chat state.
   * Orchestrates prompt preparation and API call using generateRaw.
   */
  async generateChatResponse(chat) {
    var _a;
    if (!chat) {
      console.error("[OllamaService] generateChatResponse called with null chat.");
      return null;
    }
    const currentSettings = this.plugin.settings;
    const modelName = chat.metadata.modelName || currentSettings.modelName;
    const temperature = (_a = chat.metadata.temperature) != null ? _a : currentSettings.temperature;
    const selectedRolePath = chat.metadata.selectedRolePath || currentSettings.selectedRolePath;
    try {
      const history = chat.getMessages();
      const lastUserMessage = history.findLast((m) => m.role === "user");
      if (!lastUserMessage) {
        console.warn("[OllamaService] No user message in history for response.");
        return null;
      }
      const formattedPrompt = await this.plugin.promptService.prepareFullPrompt(history, chat.metadata);
      const systemPrompt = await this.plugin.promptService.getSystemPromptForAPI(chat.metadata);
      const requestBody = {
        model: modelName,
        prompt: formattedPrompt,
        stream: false,
        temperature,
        options: { num_ctx: currentSettings.contextWindow },
        system: systemPrompt != null ? systemPrompt : void 0
      };
      console.log(`[OllamaService] Calling generateRaw for chat response: Model:"${modelName}", Temp:${temperature}`);
      const responseData = await this.generateRaw(requestBody);
      if (responseData && typeof responseData.response === "string") {
        const assistantMessage = {
          role: "assistant",
          content: responseData.response.trim(),
          timestamp: new Date(responseData.created_at || Date.now())
        };
        return assistantMessage;
      } else {
        console.warn("[OllamaService] generateRaw returned unexpected structure:", responseData);
        throw new Error("Received unexpected or empty response from the model.");
      }
    } catch (error) {
      console.error("[OllamaService] Error during chat response generation cycle:", error);
      let errorMessage = error instanceof Error ? error.message : "Unknown error generating response.";
      if (errorMessage.includes("model not found")) {
        errorMessage = `Model '${modelName}' not found. Check Ollama server or model name in settings/chat.`;
      } else if (errorMessage.includes("context window")) {
        errorMessage = `Context window error (${currentSettings.contextWindow} tokens): ${error.message}. Adjust context settings.`;
      } else if (errorMessage.includes("connect") || errorMessage.includes("fetch") || errorMessage.includes("NetworkError")) {
        errorMessage = `Connection Error: Failed to reach Ollama at ${currentSettings.ollamaServerUrl}. Is it running?`;
      }
      throw new Error(errorMessage);
    }
  }
  /**
   * Gets available models from Ollama (/api/tags).
   */
  async getModels() {
    try {
      const data = await this._ollamaFetch("/api/tags", { method: "GET" });
      if (Array.isArray(data == null ? void 0 : data.models)) {
        return data.models.map((m) => typeof m === "object" ? m.name : m).sort();
      }
      return [];
    } catch (e) {
      console.error("Err fetch models:", e);
      return [];
    }
  }
  /**
   * Gets detailed information about a specific model (/api/show).
   */
  async getModelDetails(modelName) {
    console.log(`Workspaceing details for: ${modelName}`);
    try {
      const data = await this._ollamaFetch("/api/show", { method: "POST", body: JSON.stringify({ name: modelName }) });
      return data;
    } catch (e) {
      console.warn(`Fail get details for ${modelName}:`, e);
      return null;
    }
  }
  /**
   * Private helper for fetch requests to Ollama API.
   */
  async _ollamaFetch(endpoint, options) {
    const url = `${this.plugin.settings.ollamaServerUrl}${endpoint}`;
    const headers = { ...options.headers, "Content-Type": "application/json" };
    try {
      const response = await fetch(url, { ...options, headers });
      if (!response.ok) {
        let errorText = `Ollama API error! Status: ${response.status} at ${endpoint}`;
        try {
          const bodyText = await response.text();
          try {
            const errorJson = JSON.parse(bodyText);
            errorText += `: ${errorJson.error || bodyText}`;
          } catch (e) {
            errorText += `: ${bodyText}`;
          }
        } catch (e) {
        }
        console.error(errorText);
        throw new Error(errorText);
      }
      const text = await response.text();
      if (!text) {
        return null;
      }
      return JSON.parse(text);
    } catch (error) {
      console.error(`Workspace error calling Ollama (${url}):`, error);
      const connectionErrorMsg = `Failed to connect to Ollama server at ${this.plugin.settings.ollamaServerUrl}. Is it running? (Endpoint: ${endpoint})`;
      this.emit("connection-error", new Error(connectionErrorMsg));
      throw new Error(connectionErrorMsg);
    }
  }
};

// src/PromptService.ts
var import_obsidian5 = require("obsidian");
var PromptService = class {
  constructor(plugin) {
    this.currentSystemPrompt = null;
    this.currentRolePath = null;
    this.roleCache = {};
    this.modelDetailsCache = {};
    this.plugin = plugin;
    this.app = plugin.app;
  }
  // --- Приватний метод для підрахунку токенів ---
  _countTokens(text) {
    if (!text)
      return 0;
    return Math.ceil(text.length / 4);
  }
  // ---------------------------------------------
  clearRoleCache() {
    console.log("[PromptService] Clearing role definition cache.");
    this.roleCache = {};
    this.currentSystemPrompt = null;
    this.currentRolePath = null;
  }
  clearModelDetailsCache() {
    console.log("[PromptService] Clearing model details cache.");
    this.modelDetailsCache = {};
  }
  /**
   * Повертає поточний *тіло* системного промпту (без frontmatter).
   * Гарантує, що роль завантажена для поточного шляху.
   * @returns Тіло системного промпту або null.
   */
  async getSystemPromptForAPI(chatMetadata) {
    const selectedRolePath = chatMetadata.selectedRolePath || this.plugin.settings.selectedRolePath;
    const roleDefinition = await this.getRoleDefinition(selectedRolePath);
    let systemPrompt = (roleDefinition == null ? void 0 : roleDefinition.systemPrompt) || null;
    if ((roleDefinition == null ? void 0 : roleDefinition.isProductivityPersona) && systemPrompt) {
      const now = new Date();
      const formattedDate = now.toLocaleDateString(void 0, { weekday: "long", year: "numeric", month: "long", day: "numeric" });
      const formattedTime = now.toLocaleTimeString(void 0, { hour: "numeric", minute: "2-digit" });
      systemPrompt = systemPrompt.replace(/\[Current Time\]/gi, formattedTime);
      systemPrompt = systemPrompt.replace(/\[Current Date\]/gi, formattedDate);
    }
    return systemPrompt;
  }
  async getRoleDefinition(rolePath) {
    var _a;
    const normalizedPath = rolePath ? (0, import_obsidian5.normalizePath)(rolePath) : null;
    if (normalizedPath !== this.currentRolePath) {
      console.log(`[PromptService] Role path changed from ${this.currentRolePath} to ${normalizedPath}. Clearing cache for this path.`);
      if (normalizedPath && this.roleCache[normalizedPath]) {
        delete this.roleCache[normalizedPath];
      }
      this.currentRolePath = normalizedPath;
      this.currentSystemPrompt = null;
    } else if (normalizedPath && this.roleCache[normalizedPath]) {
      this.currentSystemPrompt = this.roleCache[normalizedPath].systemPrompt;
      return this.roleCache[normalizedPath];
    }
    if (!normalizedPath || !this.plugin.settings.followRole) {
      this.currentSystemPrompt = null;
      return { systemPrompt: null, isProductivityPersona: false };
    }
    console.log(`[PromptService] Loading role definition using metadataCache for: ${normalizedPath}`);
    const file = this.app.vault.getAbstractFileByPath(normalizedPath);
    if (file instanceof import_obsidian5.TFile) {
      try {
        const fileCache = this.app.metadataCache.getFileCache(file);
        const frontmatter = fileCache == null ? void 0 : fileCache.frontmatter;
        const frontmatterPos = fileCache == null ? void 0 : fileCache.frontmatterPosition;
        const content = await this.app.vault.cachedRead(file);
        const systemPromptBody = (frontmatterPos == null ? void 0 : frontmatterPos.end) ? content.substring(frontmatterPos.end.offset).trim() : content.trim();
        const assistantType = (_a = frontmatter == null ? void 0 : frontmatter.assistant_type) == null ? void 0 : _a.toLowerCase();
        const isProductivity = assistantType === "productivity" || (frontmatter == null ? void 0 : frontmatter.is_planner) === true;
        const definition = {
          systemPrompt: systemPromptBody || null,
          // Тіло промпту
          isProductivityPersona: isProductivity
        };
        console.log(`[PromptService] Role loaded: ${normalizedPath}. Is Productivity Persona: ${isProductivity}`);
        this.roleCache[normalizedPath] = definition;
        this.currentSystemPrompt = definition.systemPrompt;
        return definition;
      } catch (error) {
        console.error(`[PromptService] Error processing role file ${normalizedPath}:`, error);
        new import_obsidian5.Notice(`Error loading role: ${file.basename}.`);
        this.currentSystemPrompt = null;
        return null;
      }
    } else {
      console.warn(`[PromptService] Role file not found or not a file: ${normalizedPath}`);
      this.currentSystemPrompt = null;
      return null;
    }
  }
  async _isProductivityPersonaActive(rolePath) {
    var _a;
    if (!this.plugin.settings.enableProductivityFeatures) {
      return false;
    }
    const roleDefinition = await this.getRoleDefinition(rolePath);
    return (_a = roleDefinition == null ? void 0 : roleDefinition.isProductivityPersona) != null ? _a : false;
  }
  async prepareFullPrompt(history, chatMetadata) {
    var _a, _b, _c;
    console.log("[PromptService] Preparing full prompt...");
    const settings = this.plugin.settings;
    const selectedRolePath = chatMetadata.selectedRolePath || settings.selectedRolePath;
    const isProductivityActive = await this._isProductivityPersonaActive(selectedRolePath);
    console.log(`[PromptService] Productivity features active for this request: ${isProductivityActive}`);
    let taskContext = "";
    let tasksWereUpdated = false;
    if (isProductivityActive) {
      const needsUpdateBefore = this.plugin.isTaskFileUpdated();
      await ((_b = (_a = this.plugin).checkAndProcessTaskUpdate) == null ? void 0 : _b.call(_a));
      tasksWereUpdated = needsUpdateBefore && !this.plugin.isTaskFileUpdated();
      if ((_c = this.plugin.chatManager) == null ? void 0 : _c.filePlanExists) {
        taskContext = tasksWereUpdated ? "\n--- Updated Tasks Context ---\n" : "\n--- Today's Tasks Context ---\n";
        taskContext += `Urgent: ${this.plugin.chatManager.fileUrgentTasks.length > 0 ? this.plugin.chatManager.fileUrgentTasks.join(", ") : "None"}
`;
        taskContext += `Other: ${this.plugin.chatManager.fileRegularTasks.length > 0 ? this.plugin.chatManager.fileRegularTasks.join(", ") : "None"}
`;
        taskContext += "--- End Tasks Context ---";
        console.log(`[PromptService] Injecting task context (Updated: ${tasksWereUpdated}).`);
      }
    }
    let processedHistoryString = "";
    const approxContextTokens = this._countTokens(taskContext);
    const maxHistoryTokens = settings.contextWindow - approxContextTokens - 200;
    if (isProductivityActive && settings.useAdvancedContextStrategy) {
      processedHistoryString = await this._buildAdvancedContext(history, chatMetadata, maxHistoryTokens);
    } else {
      processedHistoryString = this._buildSimpleContext(history, maxHistoryTokens);
    }
    let ragContext = "";
    if (settings.ragEnabled && this.plugin.ragService) {
      const lastUserMessage = history.findLast((m) => m.role === "user");
      if (lastUserMessage == null ? void 0 : lastUserMessage.content) {
        try {
          const ragResult = await this.plugin.ragService.findRelevantDocuments(lastUserMessage.content, 5);
          if (ragResult && ragResult.length > 0) {
            ragContext = "\n--- Relevant Notes Context ---\n" + ragResult.map((r) => {
              var _a2, _b2;
              return `[${((_a2 = r.metadata) == null ? void 0 : _a2.filename) || ((_b2 = r.metadata) == null ? void 0 : _b2.source) || "Note"}]:
${r.content}`;
            }).join("\n\n") + "\n--- End Notes Context ---";
          } else {
          }
        } catch (error) {
        }
      } else {
      }
    }
    const finalPrompt = `${ragContext}${taskContext}
${processedHistoryString}`.trim();
    console.log(`[PromptService] Final prompt body length (approx tokens): ${this._countTokens(finalPrompt)}`);
    return finalPrompt;
  }
  // --- Методи обробки контексту та підсумовування ---
  // (Залишаються без змін, але використовують this._countTokens)
  _buildSimpleContext(history, maxTokens) {
    let context = "";
    let currentTokens = 0;
    for (let i = history.length - 1; i >= 0; i--) {
      const message = history[i];
      const formattedMessage = `${message.role === "user" ? "User" : "Assistant"}: ${message.content.trim()}`;
      const messageTokens = this._countTokens(formattedMessage) + 5;
      if (currentTokens + messageTokens <= maxTokens) {
        context = formattedMessage + "\n\n" + context;
        currentTokens += messageTokens;
      } else {
        console.log(`[PromptService] Simple context limit reached (${currentTokens}/${maxTokens} tokens).`);
        break;
      }
    }
    return context.trim();
  }
  async _buildAdvancedContext(history, chatMetadata, maxTokens) {
    console.log("[PromptService] Building advanced context...");
    const settings = this.plugin.settings;
    const processedParts = [];
    let currentTokens = 0;
    const keepN = Math.min(history.length, settings.keepLastNMessagesBeforeSummary);
    const messagesToKeep = history.slice(-keepN);
    const messagesToProcess = history.slice(0, -keepN);
    console.log(`[PromptService] Advanced Context: Keeping last ${messagesToKeep.length}, processing ${messagesToProcess.length} older messages.`);
    if (messagesToProcess.length > 0) {
      if (settings.enableSummarization) {
        console.log("[PromptService] Summarization enabled...");
        let remainingMessages = [...messagesToProcess];
        while (remainingMessages.length > 0) {
          let chunkTokens = 0;
          let chunkMessages = [];
          while (remainingMessages.length > 0 && chunkTokens < settings.summarizationChunkSize) {
            const msg = remainingMessages.pop();
            const msgText = `${msg.role === "user" ? "User" : "Assistant"}: ${msg.content.trim()}`;
            const msgTokens = this._countTokens(msgText) + 5;
            if (chunkTokens + msgTokens <= settings.summarizationChunkSize) {
              chunkMessages.unshift(msg);
              chunkTokens += msgTokens;
            } else {
              remainingMessages.push(msg);
              break;
            }
          }
          if (chunkMessages.length > 0) {
            const chunkCombinedText = chunkMessages.map((m) => `${m.role === "user" ? "User" : "Assistant"}: ${m.content.trim()}`).join("\n\n");
            const actualChunkTokens = this._countTokens(chunkCombinedText);
            if (currentTokens + actualChunkTokens <= maxTokens) {
              console.log(`[PromptService] Adding chunk (${actualChunkTokens} tokens) directly.`);
              processedParts.unshift(chunkCombinedText);
              currentTokens += actualChunkTokens;
            } else {
              console.log(`[PromptService] Chunk (${actualChunkTokens} tokens) too large. Summarizing.`);
              const summary = await this._summarizeMessages(chunkMessages, chatMetadata);
              if (summary) {
                const summaryTokens = this._countTokens(summary) + 10;
                const summaryText = `[Summary of previous messages]:
${summary}`;
                if (currentTokens + summaryTokens <= maxTokens) {
                  console.log(`[PromptService] Adding summary (${summaryTokens} tokens).`);
                  processedParts.unshift(summaryText);
                  currentTokens += summaryTokens;
                } else {
                  console.warn(`[PromptService] Summary too large. Skipping.`);
                  break;
                }
              } else {
                console.warn("[PromptService] Summarization failed. Skipping.");
                break;
              }
            }
          }
        }
      } else {
        console.log("[PromptService] Summarization disabled. Including older messages directly.");
        let olderHistoryString = this._buildSimpleContext(messagesToProcess, maxTokens - currentTokens);
        if (olderHistoryString) {
          processedParts.unshift(olderHistoryString);
          currentTokens += this._countTokens(olderHistoryString);
        }
      }
    }
    const keepHistoryString = messagesToKeep.map((m) => `${m.role === "user" ? "User" : "Assistant"}: ${m.content.trim()}`).join("\n\n");
    const keepHistoryTokens = this._countTokens(keepHistoryString);
    if (currentTokens + keepHistoryTokens <= maxTokens) {
      processedParts.push(keepHistoryString);
      currentTokens += keepHistoryTokens;
    } else {
      console.warn(`[PromptService] Cannot fit all 'keepLastNMessages'. Truncating.`);
      const truncatedKeepHistory = this._buildSimpleContext(messagesToKeep, maxTokens - currentTokens);
      if (truncatedKeepHistory) {
        processedParts.push(truncatedKeepHistory);
        currentTokens += this._countTokens(truncatedKeepHistory);
      }
    }
    console.log(`[PromptService] Advanced context built. Total approx tokens: ${currentTokens}`);
    return processedParts.join("\n\n").trim();
  }
  async _summarizeMessages(messagesToSummarize, chatMetadata) {
    if (!this.plugin.settings.enableSummarization || messagesToSummarize.length === 0)
      return null;
    console.log(`[PromptService] Summarizing chunk of ${messagesToSummarize.length} messages...`);
    const textToSummarize = messagesToSummarize.map((m) => `${m.role === "user" ? "User" : "Assistant"}: ${m.content.trim()}`).join("\n");
    const summarizationFullPrompt = this.plugin.settings.summarizationPrompt.replace("{text_to_summarize}", textToSummarize);
    const modelName = chatMetadata.modelName || this.plugin.settings.modelName;
    const contextWindow = this.plugin.settings.contextWindow;
    const requestBody = { model: modelName, prompt: summarizationFullPrompt, stream: false, temperature: 0.3, options: { num_ctx: contextWindow }, system: "You are a helpful assistant that summarizes conversation history concisely." };
    try {
      if (!this.plugin.ollamaService) {
        console.error("[PromptService] OllamaService is not available for summarization.");
        return null;
      }
      const responseData = await this.plugin.ollamaService.generateRaw(requestBody);
      if (responseData && typeof responseData.response === "string") {
        const summary = responseData.response.trim();
        console.log(`[PromptService] Summarization successful (${this._countTokens(summary)} tokens).`);
        return summary;
      } else {
        console.warn("[PromptService] Summarization request returned unexpected structure:", responseData);
        return null;
      }
    } catch (error) {
      console.error("[PromptService] Error during summarization request:", error);
      return null;
    }
  }
};

// src/ChatManager.ts
var import_obsidian7 = require("obsidian");

// src/Chat.ts
var import_obsidian6 = require("obsidian");
var Chat = class {
  // Debounced function for saving
  /**
   * Creates an instance of Chat. Should be called by ChatManager.
   * @param adapter - Obsidian's DataAdapter.
   * @param settings - Plugin settings relevant for chat operation.
   * @param data - The initial chat data (metadata and messages).
   * @param filePath - The full, normalized path where this chat should be saved/loaded from within the vault. **Required**.
   */
  constructor(adapter, settings, data, filePath) {
    var _a, _b, _c;
    this.adapter = adapter;
    this.pluginSettings = settings;
    if (!filePath || typeof filePath !== "string" || filePath.trim() === "") {
      const errorMsg = "[Chat] Critical Error: Chat constructor called without a valid filePath.";
      console.error(errorMsg, { settings, data });
      this.filePath = `INVALID_PATH_${((_a = data == null ? void 0 : data.metadata) == null ? void 0 : _a.id) || Date.now()}.json`;
      new import_obsidian6.Notice("Critical Error: Chat created without a valid save path!");
    } else {
      this.filePath = (0, import_obsidian6.normalizePath)(filePath);
    }
    console.log(`[Chat ${(_c = (_b = data == null ? void 0 : data.metadata) == null ? void 0 : _b.id) != null ? _c : "initializing"}] Initialized. File path set to: ${this.filePath}`);
    this.metadata = data.metadata;
    this.messages = data.messages.map((m) => ({
      ...m,
      timestamp: new Date(m.timestamp)
      // Ensure timestamp is a Date object
    }));
    this.debouncedSave = (0, import_obsidian6.debounce)(this._saveToFile.bind(this), 1500, true);
  }
  // --- Message Management ---
  /**
   * Adds a new message to the chat history.
   * Updates the lastModified timestamp and triggers a debounced save.
   * @param role - The role of the message sender ('user', 'assistant', etc.).
   * @param content - The text content of the message.
   * @param timestamp - The timestamp for the message (defaults to now).
   * @returns The newly added message object.
   */
  addMessage(role, content, timestamp = new Date()) {
    const newMessage = { role, content, timestamp };
    this.messages.push(newMessage);
    this.metadata.lastModified = timestamp.toISOString();
    this.save();
    return newMessage;
  }
  /** Returns a copy of the chat messages array. */
  getMessages() {
    return [...this.messages];
  }
  /** Clears all messages from the chat history. Updates lastModified and saves. */
  clearMessages() {
    console.log(`[Chat ${this.metadata.id}] Clearing messages.`);
    this.messages = [];
    this.metadata.lastModified = new Date().toISOString();
    this.save();
  }
  /**
   * Updates specified metadata fields for the chat.
   * Automatically updates the lastModified timestamp and triggers a save.
   * @param updates - An object containing metadata fields to update (cannot update 'id' or 'createdAt').
   */
  updateMetadata(updates) {
    const originalId = this.metadata.id;
    const originalCreatedAt = this.metadata.createdAt;
    this.metadata = {
      ...this.metadata,
      ...updates,
      id: originalId,
      // Preserve original ID
      createdAt: originalCreatedAt,
      // Preserve original creation date
      lastModified: new Date().toISOString()
      // Always update last modified
    };
    console.log(`[Chat ${this.metadata.id}] Metadata updated:`, updates);
    this.save();
  }
  // --- Persistence ---
  /** Triggers a debounced save if message history saving is enabled. */
  save() {
    if (this.pluginSettings.saveMessageHistory) {
      this.debouncedSave();
    } else {
    }
  }
  /**
   * Saves the current chat state to its file immediately.
   * Bypasses the debounce timer. Returns true on success, false on failure.
   */
  async saveImmediately() {
    if (!this.pluginSettings.saveMessageHistory) {
      console.log(`[Chat ${this.metadata.id}] Save disabled, immediate save skipped for ${this.filePath}.`);
      return true;
    }
    return await this._saveToFile();
  }
  /**
   * Internal method to perform the actual file writing operation.
   * Creates necessary directories if they don't exist.
   */
  async _saveToFile() {
    const chatData = {
      metadata: this.metadata,
      messages: this.messages.map((m) => ({
        ...m,
        timestamp: m.timestamp.toISOString()
        // Cast to any to satisfy type, it's a string
      }))
    };
    const jsonString = JSON.stringify(chatData, null, 2);
    try {
      const dirPath = this.filePath.substring(0, this.filePath.lastIndexOf("/"));
      if (dirPath && !await this.adapter.exists(dirPath)) {
        console.log(`[Chat ${this.metadata.id}] Directory ${dirPath} does not exist. Creating...`);
        await this.adapter.mkdir(dirPath);
        console.log(`[Chat ${this.metadata.id}] Directory ${dirPath} created.`);
      }
      await this.adapter.write(this.filePath, jsonString);
      return true;
    } catch (error) {
      console.error(`[Chat ${this.metadata.id}] Error saving chat to ${this.filePath}:`, error);
      new import_obsidian6.Notice(`Error saving chat: ${this.metadata.name}. Check console.`);
      return false;
    }
  }
  /**
   * Static method to load chat data from a specified file path within the vault.
   * Called by ChatManager.
   * @param filePath - The full, normalized path to the chat file.
   * @param adapter - Obsidian's DataAdapter.
   * @param settings - Plugin settings.
   * @returns A new Chat instance or null if loading fails.
   */
  static async loadFromFile(filePath, adapter, settings) {
    var _a;
    const normPath = (0, import_obsidian6.normalizePath)(filePath);
    console.log(`[Chat] Static loadFromFile attempting for vault path: ${normPath}`);
    try {
      if (!await adapter.exists(normPath)) {
        console.warn(`[Chat] File not found for loading: ${normPath}`);
        return null;
      }
      const json = await adapter.read(normPath);
      const data = JSON.parse(json);
      if (((_a = data == null ? void 0 : data.metadata) == null ? void 0 : _a.id) && Array.isArray(data.messages)) {
        console.log(`[Chat] Successfully parsed data for static load, creating Chat instance for ID: ${data.metadata.id}`);
        return new Chat(adapter, settings, data, normPath);
      } else {
        console.error(`[Chat] Invalid data structure in file for static load: ${normPath}`, data);
        new import_obsidian6.Notice(`Error loading chat: Invalid data structure in ${filePath}`);
        return null;
      }
    } catch (e) {
      console.error(`[Chat] Error loading or parsing file for static load: ${normPath}`, e);
      new import_obsidian6.Notice(`Error loading chat file: ${filePath}. ${e.message}`);
      return null;
    }
  }
  /**
   * Deletes the chat's associated `.json` file from the vault.
   * @returns true if the file was deleted or didn't exist, false on error.
   */
  async deleteFile() {
    console.log(`[Chat ${this.metadata.id}] Attempting to delete file: ${this.filePath}`);
    try {
      if (await this.adapter.exists(this.filePath)) {
        await this.adapter.remove(this.filePath);
        console.log(`[Chat ${this.metadata.id}] Successfully deleted file: ${this.filePath}`);
        return true;
      }
      console.log(`[Chat ${this.metadata.id}] File already deleted or never existed: ${this.filePath}`);
      return true;
    } catch (e) {
      console.error(`[Chat ${this.metadata.id}] Error deleting file ${this.filePath}:`, e);
      new import_obsidian6.Notice(`Error deleting chat file: ${this.metadata.name}. Check console.`);
      return false;
    }
  }
};

// src/ChatManager.ts
var SESSIONS_INDEX_KEY = "chatSessionsIndex_v1";
var ACTIVE_SESSION_ID_KEY = "activeChatSessionId_v1";
var ChatManager = class {
  constructor(plugin) {
    // Obsidian Vault Adapter
    this.chatsFolderPath = "/";
    // Шлях до папки чатів В СХОВИЩІ (ініціалізується як корінь)
    this.sessionIndex = {};
    // In-memory index of available chats {id: metadata}
    this.activeChatId = null;
    this.loadedChats = {};
    // Cache for loaded Chat objects
    this.filePlanExists = false;
    this.fileUrgentTasks = [];
    this.fileRegularTasks = [];
    this.plugin = plugin;
    this.app = plugin.app;
    this.adapter = plugin.app.vault.adapter;
    this.updateChatsFolderPath();
  }
  /**
   * Оновлює внутрішній шлях `chatsFolderPath` на основі поточних налаштувань плагіна.
   * Шлях вказує на папку всередині сховища Obsidian.
   */
  updateChatsFolderPath() {
    var _a;
    const settingsPath = (_a = this.plugin.settings.chatHistoryFolderPath) == null ? void 0 : _a.trim();
    if (settingsPath) {
      this.chatsFolderPath = (0, import_obsidian7.normalizePath)(settingsPath);
    } else {
      this.chatsFolderPath = "/";
    }
  }
  // Метод для оновлення стану з плагіна
  updateTaskState(tasks) {
    if (tasks) {
      this.filePlanExists = tasks.hasContent;
      this.fileUrgentTasks = [...tasks.urgent];
      this.fileRegularTasks = [...tasks.regular];
    } else {
      this.filePlanExists = false;
      this.fileUrgentTasks = [];
      this.fileRegularTasks = [];
    }
  }
  /**
   * Ініціалізує ChatManager: оновлює шлях, перевіряє існування папки,
   * завантажує індекс чатів та ID активного чату.
   */
  async initialize() {
    this.updateChatsFolderPath();
    await this.ensureChatsFolderExists();
    await this.loadChatIndex(true);
    this.activeChatId = await this.plugin.loadDataKey(ACTIVE_SESSION_ID_KEY) || null;
    if (this.activeChatId && !this.sessionIndex[this.activeChatId]) {
      this.activeChatId = null;
      await this.plugin.saveDataKey(ACTIVE_SESSION_ID_KEY, null);
    } else if (this.activeChatId) {
    }
  }
  /**
   * Перевіряє існування папки для історії чатів у сховищі (згідно з `chatsFolderPath`).
   * Якщо папка не існує (і шлях не є коренем), намагається її створити.
   */
  async ensureChatsFolderExists() {
    if (this.chatsFolderPath === "/" || !this.chatsFolderPath) {
      return;
    }
    try {
      if (!await this.adapter.exists(this.chatsFolderPath)) {
        await this.adapter.mkdir(this.chatsFolderPath);
      } else {
        const stat = await this.adapter.stat(this.chatsFolderPath);
        if ((stat == null ? void 0 : stat.type) !== "folder") {
          new import_obsidian7.Notice(`Error: Chat history path '${this.chatsFolderPath}' is not a folder. Please check settings.`);
        } else {
        }
      }
    } catch (error) {
      new import_obsidian7.Notice(`Error: Could not create chat history directory '${this.chatsFolderPath}'. Please check settings or folder permissions.`);
    }
  }
  /**
   * Завантажує або оновлює індекс чатів.
   * @param forceScanFromFile Якщо true, індекс буде перебудовано шляхом сканування файлів у папці історії.
   * Якщо false (або не вказано), завантажує індекс зі сховища плагіна.
   */
  async loadChatIndex(forceScanFromFile = false) {
    var _a;
    if (!forceScanFromFile) {
      const loadedIndex = await this.plugin.loadDataKey(SESSIONS_INDEX_KEY);
      this.sessionIndex = loadedIndex || {};
      return;
    }
    const newIndex = {};
    let filesScanned = 0;
    let chatsLoaded = 0;
    try {
      if (!await this.adapter.exists(this.chatsFolderPath) && this.chatsFolderPath !== "/") {
        this.sessionIndex = {};
        await this.saveChatIndex();
        return;
      }
      const listResult = await this.adapter.list(this.chatsFolderPath);
      const chatFiles = listResult.files.filter(
        (filePath) => filePath.toLowerCase().endsWith(".json")
        // Тільки .json файли
        // ВИДАЛЕНО: && !filePath.includes('/')
      );
      filesScanned = chatFiles.length;
      const constructorSettings = { ...this.plugin.settings };
      for (const filePath of chatFiles) {
        const fullPath = (0, import_obsidian7.normalizePath)(filePath);
        const fileName = fullPath.split("/").pop() || "";
        const chatId = fileName.endsWith(".json") ? fileName.slice(0, -5) : null;
        if (!chatId) {
          continue;
        }
        try {
          const jsonContent = await this.adapter.read(fullPath);
          const data = JSON.parse(jsonContent);
          if (((_a = data == null ? void 0 : data.metadata) == null ? void 0 : _a.id) && data.metadata.id === chatId) {
            const metadata = data.metadata;
            newIndex[chatId] = {
              name: metadata.name,
              modelName: metadata.modelName,
              selectedRolePath: metadata.selectedRolePath,
              temperature: metadata.temperature,
              createdAt: metadata.createdAt,
              lastModified: metadata.lastModified
            };
            chatsLoaded++;
          } else {
          }
        } catch (e) {
        }
      }
      this.sessionIndex = newIndex;
      await this.saveChatIndex();
    } catch (error) {
      this.sessionIndex = {};
      await this.saveChatIndex();
      new import_obsidian7.Notice("Error rebuilding chat index. List might be empty.");
    }
  }
  /** Зберігає поточний індекс чатів у сховище плагіна. */
  async saveChatIndex() {
    await this.plugin.saveDataKey(SESSIONS_INDEX_KEY, this.sessionIndex);
  }
  /**
   * Генерує повний, нормалізований шлях до файлу чату `.json` всередині сховища.
   * @param id Унікальний ідентифікатор чату.
   * @returns Нормалізований шлях до файлу.
   */
  getChatFilePath(id) {
    const fileName = `${id}.json`;
    if (this.chatsFolderPath === "/" || !this.chatsFolderPath) {
      return (0, import_obsidian7.normalizePath)(fileName);
    }
    return (0, import_obsidian7.normalizePath)(`${this.chatsFolderPath}/${fileName}`);
  }
  /**
   * Створює новий чат: генерує ID, визначає шлях у сховищі, створює об'єкт Chat,
   * зберігає початковий файл, оновлює індекс, кеш та встановлює новий чат як активний.
   * @param name Необов'язкова початкова назва чату.
   * @returns Створений об'єкт Chat або null у разі помилки.
   */
  async createNewChat(name) {
    try {
      const now = new Date();
      const newId = `chat_${now.getTime()}_${Math.random().toString(36).substring(2, 8)}`;
      const filePath = this.getChatFilePath(newId);
      const initialMetadata = {
        id: newId,
        name: name || `Chat ${now.toLocaleDateString("en-US")} ${now.toLocaleTimeString("en-US", { hour: "2-digit", minute: "2-digit" })}`,
        modelName: this.plugin.settings.modelName,
        // Беремо з глобальних налаштувань
        selectedRolePath: this.plugin.settings.selectedRolePath,
        // Беремо з глобальних налаштувань
        temperature: this.plugin.settings.temperature,
        // Беремо з глобальних налаштувань
        createdAt: now.toISOString(),
        lastModified: now.toISOString()
      };
      const constructorSettings = { ...this.plugin.settings };
      const newChat = new Chat(this.adapter, constructorSettings, { metadata: initialMetadata, messages: [] }, filePath);
      const saved = await newChat.saveImmediately();
      if (!saved) {
        throw new Error("Failed to save initial chat file.");
      }
      this.sessionIndex[newChat.metadata.id] = { ...newChat.metadata };
      delete this.sessionIndex[newChat.metadata.id].id;
      await this.saveChatIndex();
      this.loadedChats[newChat.metadata.id] = newChat;
      await this.setActiveChat(newChat.metadata.id);
      this.plugin.emit("chat-list-updated");
      return newChat;
    } catch (error) {
      new import_obsidian7.Notice("Error creating new chat session.");
      return null;
    }
  }
  /**
   * Повертає масив метаданих всіх доступних чатів, відсортований за датою зміни (новіші перші).
   */
  listAvailableChats() {
    return Object.entries(this.sessionIndex).map(([id, meta]) => ({
      id,
      ...meta
    })).sort((a, b) => new Date(b.lastModified).getTime() - new Date(a.lastModified).getTime());
  }
  /** Повертає ID поточного активного чату. */
  getActiveChatId() {
    return this.activeChatId;
  }
  /**
   * Встановлює активний чат за його ID.
   * Зберігає ID активного чату, завантажує дані чату (якщо потрібно),
   * оновлює кеш та викликає подію 'active-chat-changed'.
   * @param id ID чату для активації, або null для скидання активного чату.
   */
  async setActiveChat(id) {
    if (id && !this.sessionIndex[id]) {
      id = null;
    }
    if (id === this.activeChatId) {
      if (id)
        await this.getChat(id);
      return;
    }
    this.activeChatId = id;
    await this.plugin.saveDataKey(ACTIVE_SESSION_ID_KEY, id);
    let loadedChat = null;
    if (id) {
      loadedChat = await this.getChat(id);
      if (!loadedChat) {
        await this.setActiveChat(null);
        return;
      }
    }
    this.plugin.emit("active-chat-changed", { chatId: id, chat: loadedChat });
  }
  /**
   * Отримує конкретний чат за ID, завантажуючи його з файлу у сховищі, якщо він ще не в кеші.
   * @param id Ідентифікатор чату.
   * @returns Об'єкт Chat або null, якщо чат не знайдено або сталася помилка завантаження.
   */
  async getChat(id) {
    if (this.loadedChats[id]) {
      return this.loadedChats[id];
    }
    if (this.sessionIndex[id]) {
      const filePath = this.getChatFilePath(id);
      const constructorSettings = { ...this.plugin.settings };
      const chat = await Chat.loadFromFile(filePath, this.adapter, constructorSettings);
      if (chat) {
        this.loadedChats[id] = chat;
        return chat;
      } else {
        delete this.sessionIndex[id];
        await this.saveChatIndex();
        if (this.activeChatId === id) {
          await this.setActiveChat(null);
        }
        this.plugin.emit("chat-list-updated");
        return null;
      }
    }
    return null;
  }
  /**
   * Отримує поточний активний чат. Якщо активний чат не встановлено,
   * намагається завантажити останній змінений чат. Якщо чатів немає, створює новий.
   * @returns Активний об'єкт Chat або null у разі помилки створення/завантаження.
   */
  async getActiveChat() {
    if (!this.activeChatId) {
      const availableChats = this.listAvailableChats();
      if (availableChats.length > 0) {
        const mostRecentId = availableChats[0].id;
        await this.setActiveChat(mostRecentId);
        if (this.activeChatId && this.loadedChats[this.activeChatId]) {
          return this.loadedChats[this.activeChatId];
        } else {
          return await this.createNewChat();
        }
      } else {
        return await this.createNewChat();
      }
    }
    return this.getChat(this.activeChatId);
  }
  /**
   * Додає повідомлення до поточного активного чату.
   * Обробляє збереження чату (через Chat.addMessage -> debouncedSave).
   * @param role Роль відправника ('user' або 'assistant').
   * @param content Вміст повідомлення.
   * @returns Додане повідомлення або null у разі помилки.
   */
  async addMessageToActiveChat(role, content) {
    const activeChat = await this.getActiveChat();
    if (activeChat) {
      const newMessage = activeChat.addMessage(role, content);
      this.sessionIndex[activeChat.metadata.id] = { ...activeChat.metadata };
      delete this.sessionIndex[activeChat.metadata.id].id;
      this.saveChatIndex();
      this.plugin.emit("message-added", { chatId: activeChat.metadata.id, message: newMessage });
      return newMessage;
    } else {
      new import_obsidian7.Notice("Error: No active chat session to add message to.");
      return null;
    }
  }
  /** Очищує історію повідомлень у поточному активному чаті. */
  async clearActiveChatMessages() {
    const activeChat = await this.getActiveChat();
    if (activeChat) {
      activeChat.clearMessages();
      this.plugin.emit("messages-cleared", activeChat.metadata.id);
    } else {
      new import_obsidian7.Notice("No active chat to clear.");
    }
  }
  /**
   * Оновлює метадані поточного активного чату.
   * @param updates Об'єкт з полями метаданих для оновлення (крім id, createdAt).
   */
  async updateActiveChatMetadata(updates) {
    const activeChat = await this.getActiveChat();
    if (activeChat) {
      activeChat.updateMetadata(updates);
      this.sessionIndex[activeChat.metadata.id] = { ...activeChat.metadata };
      delete this.sessionIndex[activeChat.metadata.id].id;
      await this.saveChatIndex();
      this.plugin.emit("chat-list-updated");
      if (updates.modelName) {
        this.plugin.emit("model-changed", updates.modelName);
      }
    } else {
      new import_obsidian7.Notice("No active chat to update metadata for.");
    }
  }
  /**
   * Видаляє чат за його ID: видаляє файл, оновлює індекс та кеш,
   * встановлює новий активний чат, якщо видалено поточний.
   * @param id Ідентифікатор чату для видалення.
   * @returns true, якщо видалення (або відсутність файлу) пройшло успішно, інакше false.
   */
  async deleteChat(id) {
    let chatToDelete = null;
    if (this.sessionIndex[id]) {
      const filePath = this.getChatFilePath(id);
      const constructorSettings = { ...this.plugin.settings };
      chatToDelete = await Chat.loadFromFile(filePath, this.adapter, constructorSettings);
      if (!chatToDelete) {
      }
    } else {
      return false;
    }
    let deletedFile = false;
    if (chatToDelete) {
      deletedFile = await chatToDelete.deleteFile();
    } else {
      deletedFile = true;
    }
    if (deletedFile) {
      delete this.sessionIndex[id];
      delete this.loadedChats[id];
      await this.saveChatIndex();
      if (this.activeChatId === id) {
        const available = this.listAvailableChats();
        const nextActiveId = available.length > 0 ? available[0].id : null;
        await this.setActiveChat(nextActiveId);
      }
      this.plugin.emit("chat-list-updated");
      return true;
    } else {
      return false;
    }
  }
  /**
   * Перейменовує чат за його ID.
   * Оновлює назву в індексі та в метаданих завантаженого чату (якщо є),
   * і зберігає зміни в файлі чату.
   * @param id Ідентифікатор чату.
   * @param newName Нова назва чату.
   * @returns true, якщо перейменування успішне, інакше false.
   */
  async renameChat(id, newName) {
    const trimmedName = newName.trim();
    if (!trimmedName) {
      new import_obsidian7.Notice("Chat name cannot be empty.");
      return false;
    }
    if (this.sessionIndex[id]) {
      this.sessionIndex[id].name = trimmedName;
      this.sessionIndex[id].lastModified = new Date().toISOString();
      await this.saveChatIndex();
      const chatToRename = await this.getChat(id);
      if (chatToRename) {
        chatToRename.metadata.name = trimmedName;
        chatToRename.metadata.lastModified = this.sessionIndex[id].lastModified;
        const saved = await chatToRename.saveImmediately();
        if (!saved) {
          new import_obsidian7.Notice(`Error saving renamed chat ${trimmedName}.`);
          return false;
        }
      } else {
        new import_obsidian7.Notice(`Error saving renamed chat ${trimmedName}: Could not load chat data.`);
        return false;
      }
      this.plugin.emit("chat-list-updated");
      return true;
    }
    new import_obsidian7.Notice(`Chat with ID ${id} not found.`);
    return false;
  }
  /**
   * Створює копію (клон) існуючого чату з новим ID та назвою.
   * @param chatIdToClone ID чату, який потрібно клонувати.
   * @returns Новий об'єкт Chat (клон) або null у разі помилки.
   */
  async cloneChat(chatIdToClone) {
    const originalChat = await this.getChat(chatIdToClone);
    if (!originalChat) {
      new import_obsidian7.Notice("Original chat not found for cloning.");
      return null;
    }
    try {
      const now = new Date();
      const newId = `chat_${now.getTime()}_${Math.random().toString(36).substring(2, 8)}`;
      const newFilePath = this.getChatFilePath(newId);
      const originalMetadata = originalChat.metadata;
      const clonedMetadata = {
        ...originalMetadata,
        // Копіюємо налаштування (модель, роль, температура)
        id: newId,
        // Встановлюємо новий ID
        name: `Copy of ${originalMetadata.name}`,
        // Додаємо префікс до назви
        createdAt: now.toISOString(),
        // Нова дата створення
        lastModified: now.toISOString()
        // Нова дата модифікації
      };
      const clonedChatData = {
        metadata: clonedMetadata,
        // Створюємо копію масиву повідомлень
        // Важливо: Date об'єкти копіюються за посиланням, але це ОК
        messages: originalChat.getMessages().map((msg) => ({ ...msg }))
      };
      const constructorSettings = { ...this.plugin.settings };
      const clonedChat = new Chat(this.adapter, constructorSettings, clonedChatData, newFilePath);
      const saved = await clonedChat.saveImmediately();
      if (!saved) {
        throw new Error("Failed to save the cloned chat file.");
      }
      this.sessionIndex[clonedChat.metadata.id] = { ...clonedChat.metadata };
      delete this.sessionIndex[clonedChat.metadata.id].id;
      await this.saveChatIndex();
      this.loadedChats[clonedChat.metadata.id] = clonedChat;
      await this.setActiveChat(clonedChat.metadata.id);
      this.plugin.emit("chat-list-updated");
      return clonedChat;
    } catch (error) {
      new import_obsidian7.Notice("An error occurred while cloning the chat.");
      return null;
    }
  }
};

// src/main.ts
var import_child_process = require("child_process");
var path = __toESM(require("path"));

// src/TranslationService.ts
var import_obsidian8 = require("obsidian");
var GOOGLE_TRANSLATE_API_URL = "https://translation.googleapis.com/language/translate/v2";
var TranslationService = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  /**
   * Translates text using the Google Translate API.
   * @param text The text to translate.
   * @param targetLang The target language code (e.g., 'uk', 'en', 'de').
   * @returns The translated text or null if translation fails.
   */
  async translate(text, targetLang) {
    var _a, _b;
    const apiKey = this.plugin.settings.googleTranslationApiKey;
    if (!this.plugin.settings.enableTranslation) {
      console.warn("Translation feature is disabled in settings.");
      return null;
    }
    if (!apiKey) {
      console.error("Google Translation API Key is missing.");
      new import_obsidian8.Notice("Translation Error: Google Cloud Translation API Key is not configured in settings.");
      return null;
    }
    if (!text) {
      console.warn("Translate called with empty text.");
      return "";
    }
    if (!targetLang) {
      console.error("Target language is not set for translation.");
      new import_obsidian8.Notice("Translation Error: Target language not configured.");
      return null;
    }
    console.log(`[TranslationService] Translating to ${targetLang}...`);
    try {
      const response = await fetch(`${GOOGLE_TRANSLATE_API_URL}?key=${apiKey}`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          q: text,
          target: targetLang,
          format: "text"
          // Request plain text translation
        })
      });
      const data = await response.json();
      if (!response.ok) {
        const errorMsg = ((_a = data.error) == null ? void 0 : _a.message) || `HTTP error ${response.status}`;
        console.error(`Google Translate API error: ${errorMsg}`, data);
        new import_obsidian8.Notice(`Translation Error: ${errorMsg}`);
        return null;
      }
      if (((_b = data.data) == null ? void 0 : _b.translations) && data.data.translations.length > 0) {
        const translatedText = this.decodeHtmlEntities(data.data.translations[0].translatedText);
        console.log("[TranslationService] Translation successful.");
        return translatedText;
      } else {
        console.error("Google Translate API returned unexpected response structure:", data);
        new import_obsidian8.Notice("Translation Error: Unexpected response from API.");
        return null;
      }
    } catch (error) {
      console.error("Error calling Google Translate API:", error);
      new import_obsidian8.Notice(`Translation Error: Failed to fetch. ${error.message}`);
      return null;
    }
  }
  // Helper to decode HTML entities (like &amp;, &lt;, etc.)
  decodeHtmlEntities(text) {
    if (typeof document !== "undefined") {
      const textArea = document.createElement("textarea");
      textArea.innerHTML = text;
      return textArea.value;
    } else {
      return text.replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&#39;/g, "'");
    }
  }
};

// src/main.ts
var ACTIVE_SESSION_ID_KEY2 = "activeChatSessionId_v1";
var OllamaPlugin = class extends import_obsidian9.Plugin {
  constructor() {
    super(...arguments);
    this.view = null;
    // Події та кеш
    this.eventHandlers = {};
    this.roleListCache = null;
    this.roleCacheClearTimeout = null;
    this.indexUpdateTimeout = null;
    // --- Логіка файлу завдань ---
    this.dailyTaskFilePath = null;
    this.taskFileContentCache = null;
    this.taskFileNeedsUpdate = false;
    // Прапорець про оновлення
    // --- RAG data (приклад) ---
    // Можливо, ці дані мають зберігатися в RagService?
    this.documents = [];
    this.embeddings = [];
    this.handleTaskFileModify = (file) => {
      if (this.settings.enableProductivityFeatures && file.path === this.dailyTaskFilePath) {
        console.log(`[Plugin] Detected modification in task file: ${file.path}`);
        this.taskFileNeedsUpdate = true;
      }
    };
  }
  // ------------------------
  // --- Event Emitter Methods ---
  on(event, callback) {
    if (!this.eventHandlers[event])
      this.eventHandlers[event] = [];
    this.eventHandlers[event].push(callback);
    return () => {
      var _a, _b;
      this.eventHandlers[event] = (_a = this.eventHandlers[event]) == null ? void 0 : _a.filter((h) => h !== callback);
      if (((_b = this.eventHandlers[event]) == null ? void 0 : _b.length) === 0) {
        delete this.eventHandlers[event];
      }
    };
  }
  emit(event, data) {
    const h = this.eventHandlers[event];
    if (h)
      h.slice().forEach((handler) => {
        try {
          handler(data);
        } catch (e) {
          console.error(`[OllamaPlugin] Error in event handler for ${event}:`, e);
        }
      });
  }
  // --- Гетер для прапорця оновлення файлу завдань ---
  isTaskFileUpdated() {
    return this.taskFileNeedsUpdate;
  }
  async onload() {
    console.log("Loading Ollama Personas Plugin...");
    await this.loadSettings();
    this.ollamaService = new OllamaService(this);
    this.translationService = new TranslationService(this);
    this.promptService = new PromptService(this);
    this.ragService = new RagService(this);
    this.chatManager = new ChatManager(this);
    await this.chatManager.initialize();
    this.registerView(
      VIEW_TYPE_OLLAMA_PERSONAS,
      (leaf) => {
        console.log("OllamaPersonasPlugin: Registering view.");
        this.view = new OllamaView(leaf, this);
        return this.view;
      }
    );
    this.ollamaService.on("connection-error", (error) => {
      console.error("[OllamaPlugin] Connection error event:", error);
      this.emit("ollama-connection-error", error.message);
      if (!this.view) {
        new import_obsidian9.Notice(`Failed to connect to Ollama: ${error.message}`);
      }
    });
    this.register(this.on("ollama-connection-error", (message) => {
      var _a, _b;
      (_b = (_a = this.view) == null ? void 0 : _a.addMessageToDisplay) == null ? void 0 : _b.call(_a, "error", message, new Date());
    }));
    this.register(this.on("active-chat-changed", this.handleActiveChatChangedLocally.bind(this)));
    this.register(this.on("chat-list-updated", () => {
      console.log("[OllamaPlugin] Event 'chat-list-updated' received.");
    }));
    this.register(this.on("settings-updated", () => {
      var _a;
      console.log("[OllamaPlugin] Event 'settings-updated' received.");
      this.updateDailyTaskFilePath();
      this.loadAndProcessInitialTasks();
      this.updateOllamaServiceConfig();
      this.roleListCache = null;
      (_a = this.promptService) == null ? void 0 : _a.clearRoleCache();
      this.emit("roles-updated");
    }));
    this.addRibbonIcon("message-square", "Open Ollama Personas Chat", () => {
      this.activateView();
    });
    this.addCommand({ id: "open-chat-view", name: "Open Ollama Personas Chat", callback: () => {
      this.activateView();
    } });
    this.addCommand({ id: "index-rag-documents", name: "Ollama: Index documents for RAG", callback: async () => {
      await this.ragService.indexDocuments();
    } });
    this.addCommand({ id: "clear-active-chat-history", name: "Ollama: Clear Active Chat History", callback: async () => {
      await this.clearMessageHistory();
    } });
    this.addCommand({ id: "refresh-roles", name: "Ollama: Refresh Roles List", callback: async () => {
      await this.listRoleFiles(true);
      this.emit("roles-updated");
      new import_obsidian9.Notice("Role list refreshed.");
    } });
    this.addCommand({ id: "new-chat", name: "Ollama: New Chat", callback: async () => {
      const newChat = await this.chatManager.createNewChat();
      if (newChat) {
        new import_obsidian9.Notice(`Created new chat: ${newChat.metadata.name}`);
      }
    } });
    this.addCommand({ id: "switch-chat", name: "Ollama: Switch Chat", callback: async () => {
      await this.showChatSwitcher();
    } });
    this.addCommand({ id: "rename-active-chat", name: "Ollama: Rename Active Chat", callback: async () => {
      await this.renameActiveChat();
    } });
    this.addCommand({ id: "delete-active-chat", name: "Ollama: Delete Active Chat", callback: async () => {
      await this.deleteActiveChatWithConfirmation();
    } });
    this.settingTab = new OllamaSettingTab(this.app, this);
    this.addSettingTab(this.settingTab);
    this.app.workspace.onLayoutReady(async () => {
      if (this.settings.ragEnabled) {
        setTimeout(() => {
          var _a;
          (_a = this.ragService) == null ? void 0 : _a.indexDocuments();
        }, 5e3);
      }
    });
    const debouncedRoleClear = (0, import_obsidian9.debounce)(() => {
      var _a, _b;
      console.log("[OllamaPlugin] Role change detected, clearing cache & emitting.");
      this.roleListCache = null;
      (_b = (_a = this.promptService) == null ? void 0 : _a.clearRoleCache) == null ? void 0 : _b.call(_a);
      this.emit("roles-updated");
    }, 1500, true);
    const fileChangeHandler = (file) => {
      if (!file)
        return;
      this.handleRoleOrRagFileChange(file.path, debouncedRoleClear);
    };
    const handleModify = (file) => {
      fileChangeHandler(file);
      this.handleTaskFileModify(file);
    };
    const handleDelete = (file) => {
      var _a;
      console.log("Delete event:", file.path);
      fileChangeHandler(file);
      if (file.path === this.dailyTaskFilePath) {
        console.log(`[Plugin] Task file ${this.dailyTaskFilePath} deleted.`);
        this.dailyTaskFilePath = null;
        this.taskFileContentCache = null;
        this.taskFileNeedsUpdate = false;
        (_a = this.chatManager) == null ? void 0 : _a.updateTaskState(null);
      }
    };
    const handleRename = (file, oldPath) => {
      console.log("Rename event:", oldPath, "->", file.path);
      fileChangeHandler(file);
      this.handleRoleOrRagFileChange(oldPath, debouncedRoleClear);
      if (oldPath === this.dailyTaskFilePath) {
        console.log(`[Plugin] Task file potentially renamed from ${oldPath} to ${file.path}`);
        this.updateDailyTaskFilePath();
        this.loadAndProcessInitialTasks();
      } else if (file.path === this.dailyTaskFilePath) {
        console.log(`[Plugin] A file was renamed to become the task file: ${file.path}`);
        this.taskFileNeedsUpdate = true;
        this.checkAndProcessTaskUpdate();
      }
    };
    const handleCreate = (file) => {
      console.log("Create event:", file.path);
      fileChangeHandler(file);
      if (file.path === this.dailyTaskFilePath) {
        console.log(`[Plugin] Task file ${this.dailyTaskFilePath} created.`);
        this.taskFileNeedsUpdate = true;
        this.checkAndProcessTaskUpdate();
      }
    };
    this.registerEvent(this.app.vault.on("modify", handleModify));
    this.registerEvent(this.app.vault.on("delete", handleDelete));
    this.registerEvent(this.app.vault.on("rename", handleRename));
    this.registerEvent(this.app.vault.on("create", handleCreate));
    this.updateDailyTaskFilePath();
    await this.loadAndProcessInitialTasks();
  }
  // --- Логіка файлу завдань (залишається в main.ts) ---
  updateDailyTaskFilePath() {
    var _a, _b;
    const folderPath = (_a = this.settings.ragFolderPath) == null ? void 0 : _a.trim();
    const fileName = (_b = this.settings.dailyTaskFileName) == null ? void 0 : _b.trim();
    const newPath = folderPath && fileName ? (0, import_obsidian9.normalizePath)(`${folderPath}/${fileName}`) : null;
    if (newPath !== this.dailyTaskFilePath) {
      console.log(`[Plugin] Daily task file path changed to: ${newPath}`);
      this.dailyTaskFilePath = newPath;
      this.taskFileContentCache = null;
      this.taskFileNeedsUpdate = true;
    } else if (!newPath) {
      this.dailyTaskFilePath = null;
      console.log(`[Plugin] Daily task file path is not configured.`);
    }
  }
  async loadAndProcessInitialTasks() {
    var _a, _b, _c, _d, _e;
    if (!this.settings.enableProductivityFeatures) {
      this.taskFileContentCache = null;
      (_a = this.chatManager) == null ? void 0 : _a.updateTaskState(null);
      this.taskFileNeedsUpdate = false;
      return;
    }
    if (!this.dailyTaskFilePath) {
      this.taskFileContentCache = null;
      (_b = this.chatManager) == null ? void 0 : _b.updateTaskState(null);
      this.taskFileNeedsUpdate = false;
      return;
    }
    try {
      if (await this.app.vault.adapter.exists(this.dailyTaskFilePath)) {
        const content = await this.app.vault.adapter.read(this.dailyTaskFilePath);
        if (content !== this.taskFileContentCache) {
          console.log(`[Plugin] Loading and processing tasks from ${this.dailyTaskFilePath}`);
          this.taskFileContentCache = content;
          const tasks = this.parseTasks(content);
          (_c = this.chatManager) == null ? void 0 : _c.updateTaskState(tasks);
          this.taskFileNeedsUpdate = false;
        } else {
          this.taskFileNeedsUpdate = false;
        }
      } else {
        console.log(`[Plugin] Task file ${this.dailyTaskFilePath} not found.`);
        this.taskFileContentCache = null;
        (_d = this.chatManager) == null ? void 0 : _d.updateTaskState(null);
        this.taskFileNeedsUpdate = false;
      }
    } catch (error) {
      console.error(`[Plugin] Error loading/processing task file ${this.dailyTaskFilePath}:`, error);
      this.taskFileContentCache = null;
      (_e = this.chatManager) == null ? void 0 : _e.updateTaskState(null);
      this.taskFileNeedsUpdate = false;
    }
  }
  parseTasks(content) {
    const lines = content.split("\n");
    const urgent = [];
    const regular = [];
    let hasContent = false;
    for (const line of lines) {
      const trimmedLine = line.trim();
      if (!trimmedLine)
        continue;
      hasContent = true;
      if (trimmedLine.startsWith("!") || trimmedLine.toLowerCase().includes("[urgent]")) {
        urgent.push(trimmedLine.replace(/^!/, "").replace(/\[urgent\]/i, "").trim());
      } else if (trimmedLine.startsWith("- [ ]") || trimmedLine.startsWith("- [x]")) {
        regular.push(trimmedLine.substring(trimmedLine.indexOf("]") + 1).trim());
      } else {
        regular.push(trimmedLine);
      }
    }
    return { urgent, regular, hasContent };
  }
  async checkAndProcessTaskUpdate() {
    if (this.taskFileNeedsUpdate) {
      console.log("[Plugin] checkAndProcessTaskUpdate: taskFileNeedsUpdate is true, reloading...");
      await this.loadAndProcessInitialTasks();
    }
  }
  // --- Кінець логіки файлу завдань ---
  // Обробник змін для ролей та RAG
  handleRoleOrRagFileChange(changedPath, debouncedRoleClear) {
    const normPath = (0, import_obsidian9.normalizePath)(changedPath);
    const userRolesPath = this.settings.userRolesFolderPath ? (0, import_obsidian9.normalizePath)(this.settings.userRolesFolderPath) : null;
    const defaultRolesPath = (0, import_obsidian9.normalizePath)(this.manifest.dir + "/roles");
    if (normPath.toLowerCase().endsWith(".md")) {
      if (userRolesPath && normPath.startsWith(userRolesPath + "/") || normPath.startsWith(defaultRolesPath + "/")) {
        console.log(`[Plugin] Role file change detected: ${normPath}`);
        debouncedRoleClear();
      }
    }
    const ragFolderPath = this.settings.ragFolderPath ? (0, import_obsidian9.normalizePath)(this.settings.ragFolderPath) : null;
    if (this.settings.ragEnabled && ragFolderPath && normPath.startsWith(ragFolderPath + "/")) {
      console.log(`[Plugin] RAG file change detected: ${normPath}`);
      this.debounceIndexUpdate();
    }
  }
  async onunload() {
    var _a, _b, _c, _d;
    console.log("Unloading Ollama Personas Plugin...");
    this.app.workspace.getLeavesOfType(VIEW_TYPE_OLLAMA_PERSONAS).forEach((l) => l.detach());
    if (this.indexUpdateTimeout)
      clearTimeout(this.indexUpdateTimeout);
    if (this.roleCacheClearTimeout)
      clearTimeout(this.roleCacheClearTimeout);
    try {
      if (this.chatManager && this.settings.saveMessageHistory) {
        const lastActiveId = this.chatManager.getActiveChatId();
        if (lastActiveId !== void 0 && lastActiveId !== null) {
          console.log(`[OllamaPlugin] Saving activeChatId (${lastActiveId}) on unload.`);
          await this.saveDataKey(ACTIVE_SESSION_ID_KEY2, lastActiveId);
        } else {
          console.log(`[OllamaPlugin] No active chat ID found to save on unload.`);
          await this.saveDataKey(ACTIVE_SESSION_ID_KEY2, null);
        }
      }
    } catch (error) {
      console.error("[OllamaPlugin] Error saving active chat ID on unload:", error);
    }
    (_b = (_a = this.promptService) == null ? void 0 : _a.clearModelDetailsCache) == null ? void 0 : _b.call(_a);
    (_d = (_c = this.promptService) == null ? void 0 : _c.clearRoleCache) == null ? void 0 : _d.call(_c);
    this.roleListCache = null;
    console.log("Ollama Personas Plugin unloaded.");
  }
  updateOllamaServiceConfig() {
    var _a;
    if (this.ollamaService) {
      console.log("[OllamaPlugin] Settings changed, potentially updating Ollama service config and clearing model cache.");
      (_a = this.promptService) == null ? void 0 : _a.clearModelDetailsCache();
    }
  }
  debounceIndexUpdate() {
    if (this.indexUpdateTimeout)
      clearTimeout(this.indexUpdateTimeout);
    this.indexUpdateTimeout = setTimeout(async () => {
      console.log("[OllamaPlugin] Debounced RAG index update starting...");
      if (this.settings.ragEnabled && this.ragService) {
        await this.ragService.indexDocuments();
      }
      this.indexUpdateTimeout = null;
    }, 3e4);
  }
  async activateView() {
    var _a;
    const { workspace: e } = this.app;
    let l = null;
    const s = e.getLeavesOfType(VIEW_TYPE_OLLAMA_PERSONAS);
    if (s.length > 0) {
      l = s[0];
    } else {
      l = (_a = e.getRightLeaf(false)) != null ? _a : e.getLeaf(true);
      if (l) {
        await l.setViewState({ type: VIEW_TYPE_OLLAMA_PERSONAS, active: true });
      }
    }
    if (l) {
      e.revealLeaf(l);
      const v = l.view;
      if (v instanceof OllamaView) {
        this.view = v;
        console.log("Ollama Personas View activated/revealed.");
      } else {
        console.error("Activated view is not an instance of OllamaView?");
      }
    } else {
      console.error("Failed to create or find leaf for Ollama Personas View.");
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    console.log("OllamaPlugin: Settings saved.");
    this.emit("settings-updated");
  }
  // Data Helpers
  async saveDataKey(key, value) {
    const d = await this.loadData() || {};
    d[key] = value;
    await this.saveData(d);
  }
  async loadDataKey(key) {
    const d = await this.loadData() || {};
    return d[key];
  }
  // History Persistence (Delegated)
  async clearMessageHistory() {
    console.log("[OllamaPlugin] Clearing active chat via ChatManager.");
    if (this.chatManager) {
      await this.chatManager.clearActiveChatMessages();
    } else {
      console.error("ChatManager not ready when clearMessageHistory called.");
      new import_obsidian9.Notice("Error: Chat Manager not ready.");
    }
  }
  // List Role Files Method
  /**
     * Отримує список доступних ролей, включаючи вбудовану роль "Productivity Assistant".
     * @param forceRefresh Якщо true, кеш буде проігноровано і список буде зчитано з файлів.
     * @returns Масив об'єктів RoleInfo.
     */
  async listRoleFiles(forceRefresh = false) {
    var _a;
    if (this.roleListCache && !forceRefresh) {
      console.log("[OllamaPlugin] Returning cached roles.");
      return this.roleListCache;
    }
    console.log("[OllamaPlugin] Fetching roles (including built-in)...");
    const roles = [];
    const addedNamesLowerCase = /* @__PURE__ */ new Set();
    const adapter = this.app.vault.adapter;
    const pluginDir = this.manifest.dir;
    const builtInRoleName = "Productivity Assistant";
    const builtInRoleFileName = "Productivity_Assistant.md";
    const builtInRolePath = (0, import_obsidian9.normalizePath)(`${pluginDir}/roles/${builtInRoleFileName}`);
    console.log(`[OllamaPlugin] Checking for built-in role at: ${builtInRolePath}`);
    try {
      if (await adapter.exists(builtInRolePath)) {
        const stat = await adapter.stat(builtInRolePath);
        if ((stat == null ? void 0 : stat.type) === "file") {
          console.log(`[OllamaPlugin] Found built-in role: ${builtInRoleName}`);
          roles.push({
            name: builtInRoleName,
            path: builtInRolePath,
            // Зберігаємо шлях відносно кореня сховища
            isCustom: false
            // Позначаємо як не користувацьку
            // isBuiltIn: true // Можна додати окремий прапорець
          });
          addedNamesLowerCase.add(builtInRoleName.toLowerCase());
        } else {
          console.warn(`[OllamaPlugin] Built-in role path exists but is not a file: ${builtInRolePath}`);
        }
      } else {
        console.warn(`[OllamaPlugin] Built-in role file NOT FOUND at: ${builtInRolePath}. Productivity features might rely on it.`);
      }
    } catch (error) {
      console.error(`[OllamaPlugin] Error checking/adding built-in role at ${builtInRolePath}:`, error);
    }
    const userRolesFolderPath = this.settings.userRolesFolderPath ? (0, import_obsidian9.normalizePath)(this.settings.userRolesFolderPath) : null;
    if (userRolesFolderPath) {
      console.log(`[OllamaPlugin] Processing user roles from: ${userRolesFolderPath}`);
      try {
        if (await adapter.exists(userRolesFolderPath) && ((_a = await adapter.stat(userRolesFolderPath)) == null ? void 0 : _a.type) === "folder") {
          const listResult = await adapter.list(userRolesFolderPath);
          for (const filePath of listResult.files) {
            if (filePath.toLowerCase().endsWith(".md") && (userRolesFolderPath === "/" || filePath.split("/").length === userRolesFolderPath.split("/").length + 1) && filePath !== builtInRolePath) {
              const fileName = path.basename(filePath);
              const roleName = fileName.substring(0, fileName.length - 3);
              if (!addedNamesLowerCase.has(roleName.toLowerCase())) {
                console.log(`[OllamaPlugin] Adding user role: ${roleName}`);
                roles.push({ name: roleName, path: filePath, isCustom: true });
                addedNamesLowerCase.add(roleName.toLowerCase());
              } else {
                console.warn(`[OllamaPlugin] Skipping user role "${roleName}" from "${userRolesFolderPath}" due to name conflict.`);
              }
            }
          }
        } else if (userRolesFolderPath !== "/") {
          console.warn(`[OllamaPlugin] User roles path not found or not a folder: ${userRolesFolderPath}`);
        }
      } catch (e) {
        console.error(`Error listing user roles in ${userRolesFolderPath}:`, e);
      }
    }
    roles.sort((a, b) => {
      return a.name.localeCompare(b.name);
    });
    this.roleListCache = roles;
    console.log(`[OllamaPlugin] Found total ${roles.length} roles (including built-in if present).`);
    return roles;
  }
  // Execute System Command Method
  async executeSystemCommand(command) {
    var _a;
    console.log(`Executing: ${command}`);
    if (!(command == null ? void 0 : command.trim())) {
      return { stdout: "", stderr: "Empty cmd.", error: new Error("Empty cmd") };
    }
    if (typeof process === "undefined" || !((_a = process == null ? void 0 : process.versions) == null ? void 0 : _a.node)) {
      console.error("Node.js environment not available. Cannot execute system command.");
      new import_obsidian9.Notice("Cannot execute system command.");
      return { stdout: "", stderr: "Node.js required.", error: new Error("Node.js required") };
    }
    return new Promise((resolve) => {
      (0, import_child_process.exec)(command, (error, stdout, stderr) => {
        if (error)
          console.error(`Exec error for "${command}": ${error}`);
        if (stderr)
          console.error(`Exec stderr for "${command}": ${stderr}`);
        if (stdout)
          console.log(`Exec stdout for "${command}": ${stdout}`);
        resolve({ stdout: stdout.toString(), stderr: stderr.toString(), error });
      });
    });
  }
  // --- Session Management Command Helpers ---
  // Ці методи зараз не використовуються View, але можуть бути корисними для команд
  async showChatSwitcher() {
    new import_obsidian9.Notice("Switch Chat UI not implemented yet.");
  }
  async renameActiveChat() {
    var _a;
    const activeChat = await ((_a = this.chatManager) == null ? void 0 : _a.getActiveChat());
    if (!activeChat) {
      new import_obsidian9.Notice("No active chat.");
      return;
    }
    const currentName = activeChat.metadata.name;
    new PromptModal(
      this.app,
      "Rename Chat",
      `Enter new name for "${currentName}":`,
      currentName,
      async (newName) => {
        if (newName && newName.trim() !== "" && newName.trim() !== currentName) {
          await this.chatManager.renameChat(activeChat.metadata.id, newName.trim());
        } else if (newName !== null) {
          new import_obsidian9.Notice("Rename cancelled or name unchanged.");
        }
      }
    ).open();
  }
  async deleteActiveChatWithConfirmation() {
    var _a;
    const activeChat = await ((_a = this.chatManager) == null ? void 0 : _a.getActiveChat());
    if (!activeChat) {
      new import_obsidian9.Notice("No active chat.");
      return;
    }
    const chatName = activeChat.metadata.name;
    new ConfirmModal(
      this.app,
      "Delete Chat",
      `Delete chat "${chatName}"? This cannot be undone.`,
      async () => {
        await this.chatManager.deleteChat(activeChat.metadata.id);
      }
    ).open();
  }
  // Обробник зміни активного чату (локальний)
  async handleActiveChatChangedLocally(data) {
    console.log(`[OllamaPlugin] Handled 'active-chat-changed' locally. New active ID: ${data.chatId}. View will update itself.`);
  }
  // Допоміжний метод для пошуку імені ролі за шляхом
  findRoleNameByPath(rolePath) {
    var _a;
    if (!rolePath)
      return "Default Assistant";
    const cachedRole = (_a = this.roleListCache) == null ? void 0 : _a.find((rl) => rl.path === rolePath);
    if (cachedRole)
      return cachedRole.name;
    try {
      return path.basename(rolePath, ".md");
    } catch (e) {
      console.warn(`[OllamaPlugin] Could not determine role name for path: ${rolePath}`, e);
      return "Unknown Role";
    }
  }
};
