/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => OllamaPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// ollamaView.ts
var import_obsidian = require("obsidian");
var VIEW_TYPE_OLLAMA = "ollama-chat-view";
var CSS_CLASS_CONTAINER = "ollama-container";
var CSS_CLASS_CHAT_CONTAINER = "ollama-chat-container";
var CSS_CLASS_INPUT_CONTAINER = "chat-input-container";
var CSS_CLASS_BUTTONS_CONTAINER = "buttons-container";
var CSS_CLASS_SEND_BUTTON = "send-button";
var CSS_CLASS_VOICE_BUTTON = "voice-button";
var CSS_CLASS_MENU_BUTTON = "menu-button";
var CSS_CLASS_MENU_DROPDOWN = "menu-dropdown";
var CSS_CLASS_MENU_OPTION = "menu-option";
var CSS_CLASS_SETTINGS_OPTION = "settings-option";
var CSS_CLASS_EMPTY_STATE = "ollama-empty-state";
var CSS_CLASS_MESSAGE_GROUP = "message-group";
var CSS_CLASS_USER_GROUP = "user-message-group";
var CSS_CLASS_OLLAMA_GROUP = "ollama-message-group";
var CSS_CLASS_SYSTEM_GROUP = "system-message-group";
var CSS_CLASS_ERROR_GROUP = "error-message-group";
var CSS_CLASS_MESSAGE = "message";
var CSS_CLASS_USER_MESSAGE = "user-message";
var CSS_CLASS_OLLAMA_MESSAGE = "ollama-message";
var CSS_CLASS_SYSTEM_MESSAGE = "system-message";
var CSS_CLASS_ERROR_MESSAGE = "error-message";
var CSS_CLASS_SYSTEM_ICON = "system-icon";
var CSS_CLASS_ERROR_ICON = "error-icon";
var CSS_CLASS_SYSTEM_TEXT = "system-message-text";
var CSS_CLASS_ERROR_TEXT = "error-message-text";
var CSS_CLASS_CONTENT_CONTAINER = "message-content-container";
var CSS_CLASS_CONTENT = "message-content";
var CSS_CLASS_THINKING_DOTS = "thinking-dots";
var CSS_CLASS_THINKING_DOT = "thinking-dot";
var CSS_CLASS_THINKING_BLOCK = "thinking-block";
var CSS_CLASS_THINKING_HEADER = "thinking-header";
var CSS_CLASS_THINKING_TOGGLE = "thinking-toggle";
var CSS_CLASS_THINKING_TITLE = "thinking-title";
var CSS_CLASS_THINKING_CONTENT = "thinking-content";
var CSS_CLASS_TIMESTAMP = "message-timestamp";
var CSS_CLASS_COPY_BUTTON = "copy-button";
var CSS_CLASS_TEXTAREA_EXPANDED = "expanded";
var CSS_CLASS_DISABLED = "disabled";
var CSS_CLASS_MESSAGE_ARRIVING = "message-arriving";
var CSS_CLASS_DATE_SEPARATOR = "chat-date-separator";
var CSS_CLASS_AVATAR = "message-group-avatar";
var CSS_CLASS_AVATAR_USER = "user-avatar";
var CSS_CLASS_AVATAR_AI = "ai-avatar";
var CSS_CLASS_CODE_BLOCK_COPY_BUTTON = "code-block-copy-button";
var CSS_CLASS_NEW_MESSAGE_INDICATOR = "new-message-indicator";
var CSS_CLASS_VISIBLE = "visible";
var CSS_CLASS_MENU_SEPARATOR = "menu-separator";
var CSS_CLASS_CLEAR_CHAT_OPTION = "clear-chat-option";
var _OllamaView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    // --- Єдине джерело правди для повідомлень ---
    this.messages = [];
    this.isProcessing = false;
    this.scrollTimeout = null;
    // Speech Recognition related
    this.speechWorker = null;
    this.mediaRecorder = null;
    this.audioStream = null;
    // --- Стан, що керується в View ---
    this.messagesPairCount = 0;
    this.emptyStateEl = null;
    // MessageService більше не потрібен як поле класу
    // private readonly messageService: MessageService;
    // Debounce/Throttle timers
    this.resizeTimeout = null;
    // State Variables for UI Improvements
    this.lastMessageDate = null;
    this.newMessagesIndicatorEl = null;
    this.userScrolledUp = false;
    // --- Event Handlers ---
    // (Без змін, крім handleClearChatClick, який тепер не викликає messageService)
    this.handleKeyDown = (e) => {
      if (e.key === "Enter" && !e.shiftKey && !this.isProcessing && !this.sendButton.disabled) {
        e.preventDefault();
        this.sendMessage();
      }
    };
    this.handleSendClick = () => {
      if (!this.isProcessing && !this.sendButton.disabled) {
        this.sendMessage();
      }
    };
    this.handleVoiceClick = () => {
      this.toggleVoiceRecognition();
    };
    this.handleMenuClick = (e) => {
      e.stopPropagation();
      const isHidden = this.menuDropdown.style.display === "none";
      this.menuDropdown.style.display = isHidden ? "block" : "none";
    };
    this.handleSettingsClick = async () => {
      this.closeMenu();
      const setting = this.app.setting;
      if (setting) {
        await setting.open();
        setting.openTabById("obsidian-ollama-duet");
      } else {
        new import_obsidian.Notice("Could not open settings.");
      }
    };
    this.handleClearChatClick = () => {
      this.closeMenu();
      this.clearChatContainer();
      new import_obsidian.Notice("Chat history cleared.");
    };
    // Більше не викликає messageService
    this.handleDocumentClickForMenu = (e) => {
      if (this.menuDropdown.style.display === "block" && !this.menuButton.contains(e.target) && !this.menuDropdown.contains(e.target)) {
        this.closeMenu();
      }
    };
    this.handleModelChange = (modelName) => {
      this.updateInputPlaceholder(modelName);
      if (this.messages.length > 0) {
        this.plugin.messageService.addSystemMessage(`Model changed to: ${modelName}`);
      }
    };
    // Виклик через plugin.messageService
    this.handleVisibilityChange = () => {
      if (document.visibilityState === "visible") {
        requestAnimationFrame(() => {
          this.guaranteedScrollToBottom(50);
          this.adjustTextareaHeight();
        });
      }
    };
    this.handleActiveLeafChange = () => {
      var _a;
      if (this.app.workspace.getActiveViewOfType(_OllamaView) === this) {
        setTimeout(() => this.guaranteedScrollToBottom(100), 100);
        (_a = this.inputEl) == null ? void 0 : _a.focus();
      }
    };
    this.handleInputForResize = () => {
      if (this.resizeTimeout)
        clearTimeout(this.resizeTimeout);
      this.resizeTimeout = setTimeout(() => this.adjustTextareaHeight(), 50);
      this.updateSendButtonState();
    };
    this.handleWindowResize = () => {
      if (this.resizeTimeout)
        clearTimeout(this.resizeTimeout);
      this.resizeTimeout = setTimeout(() => this.adjustTextareaHeight(), 100);
    };
    this.handleScroll = () => {
      var _a;
      if (!this.chatContainer)
        return;
      const scrollThreshold = 150;
      const isScrolledToBottom = this.chatContainer.scrollHeight - this.chatContainer.scrollTop - this.chatContainer.clientHeight < scrollThreshold;
      if (!isScrolledToBottom) {
        this.userScrolledUp = true;
      } else {
        this.userScrolledUp = false;
        (_a = this.newMessagesIndicatorEl) == null ? void 0 : _a.classList.remove(CSS_CLASS_VISIBLE);
      }
    };
    this.handleNewMessageIndicatorClick = () => {
      var _a;
      this.guaranteedScrollToBottom(50, true);
      (_a = this.newMessagesIndicatorEl) == null ? void 0 : _a.classList.remove(CSS_CLASS_VISIBLE);
    };
    this.adjustTextareaHeight = () => {
      requestAnimationFrame(() => {
        if (!this.inputEl || !this.buttonsContainer)
          return;
        const viewHeight = this.contentEl.clientHeight;
        const maxHeight = Math.max(100, viewHeight * 0.5);
        this.inputEl.style.height = "auto";
        const scrollHeight = this.inputEl.scrollHeight;
        const newHeight = Math.min(scrollHeight, maxHeight);
        this.inputEl.style.height = `${newHeight}px`;
        this.inputEl.classList.toggle(CSS_CLASS_TEXTAREA_EXPANDED, scrollHeight > maxHeight);
      });
    };
    this.plugin = plugin;
    if (_OllamaView.instance && _OllamaView.instance !== this) {
      console.warn("Replacing existing OllamaView instance.");
    }
    _OllamaView.instance = this;
    if (this.plugin.apiService) {
      this.plugin.apiService.setOllamaView(this);
    }
    this.initSpeechWorker();
    this.scrollListenerDebounced = (0, import_obsidian.debounce)(this.handleScroll, 150, true);
  }
  // --- Getters for State (можуть знадобитися для MessageService) ---
  getMessagesCount() {
    return this.messages.length;
  }
  getMessagesPairCount() {
    return this.messagesPairCount;
  }
  // --- Obsidian View Lifecycle Methods ---
  getViewType() {
    return VIEW_TYPE_OLLAMA;
  }
  getDisplayText() {
    return "Ollama Chat";
  }
  getIcon() {
    return "message-square";
  }
  async onOpen() {
    var _a, _b;
    this.createUIElements();
    this.updateInputPlaceholder(this.plugin.settings.modelName);
    this.attachEventListeners();
    this.autoResizeTextarea();
    this.updateSendButtonState();
    this.lastMessageDate = null;
    await this.loadAndRenderHistory();
    (_a = this.inputEl) == null ? void 0 : _a.focus();
    this.guaranteedScrollToBottom(150, true);
    (_b = this.inputEl) == null ? void 0 : _b.dispatchEvent(new Event("input"));
  }
  async onClose() {
    console.log("OllamaView onClose: Cleaning up resources.");
    if (this.speechWorker) {
      this.speechWorker.terminate();
      this.speechWorker = null;
    }
    this.stopVoiceRecording(false);
    if (this.audioStream) {
      this.audioStream.getTracks().forEach((track) => track.stop());
      this.audioStream = null;
    }
    if (this.scrollTimeout)
      clearTimeout(this.scrollTimeout);
    if (this.resizeTimeout)
      clearTimeout(this.resizeTimeout);
    if (_OllamaView.instance === this) {
      _OllamaView.instance = null;
    }
  }
  // --- UI Creation and Management ---
  createUIElements() {
    this.contentEl.empty();
    this.chatContainerEl = this.contentEl.createDiv({ cls: CSS_CLASS_CONTAINER });
    this.chatContainer = this.chatContainerEl.createDiv({ cls: CSS_CLASS_CHAT_CONTAINER });
    this.newMessagesIndicatorEl = this.chatContainerEl.createDiv({ cls: CSS_CLASS_NEW_MESSAGE_INDICATOR });
    const indicatorIcon = this.newMessagesIndicatorEl.createSpan({ cls: "indicator-icon" });
    (0, import_obsidian.setIcon)(indicatorIcon, "arrow-down");
    this.newMessagesIndicatorEl.createSpan({ text: " New Messages" });
    const inputContainer = this.chatContainerEl.createDiv({ cls: CSS_CLASS_INPUT_CONTAINER });
    this.inputEl = inputContainer.createEl("textarea", { attr: { placeholder: `Text to ${this.plugin.settings.modelName}...` } });
    this.buttonsContainer = inputContainer.createDiv({ cls: CSS_CLASS_BUTTONS_CONTAINER });
    this.sendButton = this.buttonsContainer.createEl("button", { cls: CSS_CLASS_SEND_BUTTON });
    (0, import_obsidian.setIcon)(this.sendButton, "send");
    this.voiceButton = this.buttonsContainer.createEl("button", { cls: CSS_CLASS_VOICE_BUTTON });
    (0, import_obsidian.setIcon)(this.voiceButton, "microphone");
    this.menuButton = this.buttonsContainer.createEl("button", { cls: CSS_CLASS_MENU_BUTTON });
    (0, import_obsidian.setIcon)(this.menuButton, "more-vertical");
    this.menuDropdown = inputContainer.createEl("div", { cls: CSS_CLASS_MENU_DROPDOWN });
    this.menuDropdown.style.display = "none";
    this.clearChatOption = this.menuDropdown.createEl("div", { cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_CLEAR_CHAT_OPTION}` });
    const clearIcon = this.clearChatOption.createEl("span", { cls: "menu-option-icon" });
    (0, import_obsidian.setIcon)(clearIcon, "trash-2");
    this.clearChatOption.createEl("span", { cls: "menu-option-text", text: "Clear Chat" });
    this.menuDropdown.createEl("hr", { cls: CSS_CLASS_MENU_SEPARATOR });
    this.settingsOption = this.menuDropdown.createEl("div", { cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_SETTINGS_OPTION}` });
    const settingsIcon = this.settingsOption.createEl("span", { cls: "menu-option-icon" });
    (0, import_obsidian.setIcon)(settingsIcon, "settings");
    this.settingsOption.createEl("span", { cls: "menu-option-text", text: "Settings" });
  }
  attachEventListeners() {
    this.inputEl.addEventListener("keydown", this.handleKeyDown);
    this.inputEl.addEventListener("input", this.handleInputForResize);
    this.sendButton.addEventListener("click", this.handleSendClick);
    this.voiceButton.addEventListener("click", this.handleVoiceClick);
    this.menuButton.addEventListener("click", this.handleMenuClick);
    this.settingsOption.addEventListener("click", this.handleSettingsClick);
    this.clearChatOption.addEventListener("click", this.handleClearChatClick);
    this.registerDomEvent(window, "resize", this.handleWindowResize);
    this.registerEvent(this.app.workspace.on("resize", this.handleWindowResize));
    this.registerDomEvent(document, "click", this.handleDocumentClickForMenu);
    this.register(this.plugin.on("model-changed", this.handleModelChange));
    this.registerDomEvent(document, "visibilitychange", this.handleVisibilityChange);
    this.registerEvent(this.app.workspace.on("active-leaf-change", this.handleActiveLeafChange));
    this.registerDomEvent(this.chatContainer, "scroll", this.scrollListenerDebounced);
    if (this.newMessagesIndicatorEl) {
      this.registerDomEvent(this.newMessagesIndicatorEl, "click", this.handleNewMessageIndicatorClick);
    }
  }
  // --- UI Update Methods ---
  // (Без змін)
  updateInputPlaceholder(modelName) {
    if (this.inputEl) {
      this.inputEl.placeholder = `Text to ${modelName}...`;
    }
  }
  closeMenu() {
    if (this.menuDropdown) {
      this.menuDropdown.style.display = "none";
    }
  }
  autoResizeTextarea() {
    this.adjustTextareaHeight();
  }
  updateSendButtonState() {
    if (!this.inputEl || !this.sendButton)
      return;
    const isDisabled = this.inputEl.value.trim() === "" || this.isProcessing;
    this.sendButton.disabled = isDisabled;
    this.sendButton.classList.toggle(CSS_CLASS_DISABLED, isDisabled);
  }
  showEmptyState() {
    if (this.messages.length === 0 && !this.emptyStateEl && this.chatContainer) {
      this.chatContainer.empty();
      this.emptyStateEl = this.chatContainer.createDiv({ cls: CSS_CLASS_EMPTY_STATE });
      this.emptyStateEl.createDiv({ cls: "empty-state-message", text: "No messages yet" });
      this.emptyStateEl.createDiv({ cls: "empty-state-tip", text: `Type a message or use voice input to chat with ${this.plugin.settings.modelName}` });
    }
  }
  hideEmptyState() {
    if (this.emptyStateEl) {
      this.emptyStateEl.remove();
      this.emptyStateEl = null;
    }
  }
  // --- Message Handling ---
  async loadAndRenderHistory() {
    this.lastMessageDate = null;
    try {
      await this.plugin.messageService.loadMessageHistory();
      if (this.messages.length === 0) {
        this.showEmptyState();
      } else {
        this.hideEmptyState();
      }
    } catch (error) {
      console.error("Error loading message history:", error);
      this.clearChatContainerInternal();
      this.showEmptyState();
    }
  }
  // Зберігає ПОТОЧНИЙ стан this.messages
  async saveMessageHistory() {
    if (!this.plugin.settings.saveMessageHistory)
      return;
    const messagesToSave = this.messages.map((msg) => ({
      role: msg.role,
      content: msg.content,
      timestamp: msg.timestamp.toISOString()
    }));
    const dataToSave = JSON.stringify(messagesToSave);
    try {
      await this.plugin.saveMessageHistory(dataToSave);
    } catch (error) {
      console.error("OllamaView: Error saving message history:", error);
      new import_obsidian.Notice("Failed to save chat history.");
    }
  }
  // Відправка повідомлення користувача
  async sendMessage() {
    const content = this.inputEl.value.trim();
    if (!content || this.isProcessing || this.sendButton.disabled)
      return;
    const messageContent = this.inputEl.value;
    this.clearInputField();
    this.setLoadingState(true);
    this.hideEmptyState();
    this.internalAddMessage("user", messageContent);
    try {
      await this.plugin.messageService.sendMessage(content);
    } catch (error) {
      console.error("OllamaView: Error sending message via MessageService:", error);
      this.internalAddMessage("error", "Failed to send message. Please try again.");
      this.setLoadingState(false);
    }
  }
  /**
   * Внутрішній метод для додавання повідомлення до стану View, рендерингу та збереження.
   * Викликається як для повідомлень користувача, так і для повідомлень від MessageService.
   * @param role Роль повідомлення
   * @param content Вміст повідомлення
   * @param options Додаткові опції (напр., чи зберігати історію після цього додавання)
   */
  internalAddMessage(role, content, options = { saveHistory: true }) {
    const message = {
      role,
      content,
      timestamp: new Date()
    };
    this.messages.push(message);
    if (role === "assistant" && this.messages.length >= 2) {
      const prevMessage = this.messages[this.messages.length - 2];
      if (prevMessage && prevMessage.role === "user") {
        this.messagesPairCount++;
      }
    }
    this.renderMessage(message);
    this.hideEmptyState();
    if (options.saveHistory) {
      (0, import_obsidian.debounce)(this.saveMessageHistory, 300, true).call(this);
    }
    if (role !== "user" && this.userScrolledUp && this.newMessagesIndicatorEl) {
      this.newMessagesIndicatorEl.classList.add(CSS_CLASS_VISIBLE);
    } else if (!this.userScrolledUp) {
      const forceScroll = role !== "user";
      this.guaranteedScrollToBottom(forceScroll ? 100 : 50, forceScroll);
    }
  }
  // --- Rendering Logic (Розширено для system/error) ---
  renderMessage(message) {
    const messageIndex = this.messages.indexOf(message);
    if (messageIndex === -1)
      return;
    const prevMessage = messageIndex > 0 ? this.messages[messageIndex - 1] : null;
    const isFirstInGroup = !prevMessage || prevMessage.role !== message.role;
    const isNewDay = !this.lastMessageDate || !this.isSameDay(this.lastMessageDate, message.timestamp);
    if (isNewDay && (messageIndex === 0 || isFirstInGroup)) {
      this.renderDateSeparator(message.timestamp);
      this.lastMessageDate = message.timestamp;
    }
    let messageGroup = null;
    let groupClass = CSS_CLASS_MESSAGE_GROUP;
    let messageClass = `${CSS_CLASS_MESSAGE} ${CSS_CLASS_MESSAGE_ARRIVING}`;
    let showAvatar = false;
    let isUser = false;
    switch (message.role) {
      case "user":
        groupClass += ` ${CSS_CLASS_USER_GROUP}`;
        messageClass += ` ${CSS_CLASS_USER_MESSAGE}`;
        showAvatar = true;
        isUser = true;
        break;
      case "assistant":
        groupClass += ` ${CSS_CLASS_OLLAMA_GROUP}`;
        messageClass += ` ${CSS_CLASS_OLLAMA_MESSAGE}`;
        showAvatar = true;
        break;
      case "system":
        groupClass += ` ${CSS_CLASS_SYSTEM_GROUP}`;
        messageClass += ` ${CSS_CLASS_SYSTEM_MESSAGE}`;
        break;
      case "error":
        groupClass += ` ${CSS_CLASS_ERROR_GROUP}`;
        messageClass += ` ${CSS_CLASS_ERROR_MESSAGE}`;
        break;
    }
    const lastElement = this.chatContainer.lastElementChild;
    if (isFirstInGroup || !lastElement || !lastElement.classList.contains(groupClass.split(" ")[1])) {
      messageGroup = this.chatContainer.createDiv({ cls: groupClass });
      if (showAvatar) {
        this.renderAvatar(messageGroup, isUser);
      }
    } else {
      messageGroup = lastElement;
    }
    const messageEl = messageGroup.createDiv({ cls: messageClass });
    const contentContainer = messageEl.createDiv({ cls: CSS_CLASS_CONTENT_CONTAINER });
    const contentEl = contentContainer.createDiv({ cls: CSS_CLASS_CONTENT });
    switch (message.role) {
      case "assistant":
        this.renderAssistantContent(contentEl, message.content);
        break;
      case "user":
        message.content.split("\n").forEach((line, index, array) => {
          contentEl.appendText(line);
          if (index < array.length - 1) {
            contentEl.createEl("br");
          }
        });
        break;
      case "system":
        const sysIcon = contentEl.createSpan({ cls: CSS_CLASS_SYSTEM_ICON });
        (0, import_obsidian.setIcon)(sysIcon, "info");
        contentEl.createSpan({ cls: CSS_CLASS_SYSTEM_TEXT, text: message.content });
        break;
      case "error":
        const errIcon = contentEl.createSpan({ cls: CSS_CLASS_ERROR_ICON });
        (0, import_obsidian.setIcon)(errIcon, "alert-triangle");
        contentEl.createSpan({ cls: CSS_CLASS_ERROR_TEXT, text: message.content });
        break;
    }
    if (message.role !== "system") {
      const copyButton = contentContainer.createEl("button", { cls: CSS_CLASS_COPY_BUTTON, attr: { title: "Copy" } });
      (0, import_obsidian.setIcon)(copyButton, "copy");
      copyButton.addEventListener("click", () => this.handleCopyClick(message.content, copyButton));
    }
    messageEl.createDiv({
      cls: CSS_CLASS_TIMESTAMP,
      text: this.formatTime(message.timestamp)
    });
  }
  // --- Методи рендерингу (Date Separator, Avatar, Assistant Content, Code Buttons) ---
  // (Залишаються без змін від попередньої версії)
  renderDateSeparator(date) {
    if (!this.chatContainer)
      return;
    this.chatContainer.createDiv({ cls: CSS_CLASS_DATE_SEPARATOR, text: this.formatDateSeparator(date) });
  }
  renderAvatar(groupEl, isUser) {
    const avatarEl = groupEl.createDiv({ cls: `${CSS_CLASS_AVATAR} ${isUser ? CSS_CLASS_AVATAR_USER : CSS_CLASS_AVATAR_AI}` });
    avatarEl.textContent = isUser ? "U" : "A";
  }
  renderAssistantContent(containerEl, content) {
    const decodedContent = this.decodeHtmlEntities(content);
    const hasThinking = this.detectThinkingTags(decodedContent);
    containerEl.empty();
    if (hasThinking.hasThinkingTags) {
      const processedHtml = this.processThinkingTags(decodedContent);
      containerEl.innerHTML = processedHtml;
      this.addThinkingToggleListeners(containerEl);
      this.addCodeBlockCopyButtons(containerEl);
    } else {
      import_obsidian.MarkdownRenderer.renderMarkdown(content, containerEl, this.plugin.app.vault.getRoot().path, this);
      this.addCodeBlockCopyButtons(containerEl);
    }
  }
  addCodeBlockCopyButtons(contentEl) {
    const preElements = contentEl.querySelectorAll("pre");
    preElements.forEach((pre) => {
      if (pre.querySelector(`.${CSS_CLASS_CODE_BLOCK_COPY_BUTTON}`))
        return;
      const codeContent = pre.textContent || "";
      const copyBtn = pre.createEl("button", { cls: CSS_CLASS_CODE_BLOCK_COPY_BUTTON });
      (0, import_obsidian.setIcon)(copyBtn, "copy");
      copyBtn.setAttribute("title", "Copy Code");
      copyBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        navigator.clipboard.writeText(codeContent).then(() => {
          (0, import_obsidian.setIcon)(copyBtn, "check");
          copyBtn.setAttribute("title", "Copied!");
          setTimeout(() => {
            (0, import_obsidian.setIcon)(copyBtn, "copy");
            copyBtn.setAttribute("title", "Copy Code");
          }, 1500);
        }).catch((err) => {
          console.error("Failed to copy code block:", err);
          new import_obsidian.Notice("Failed to copy code.");
        });
      });
    });
  }
  handleCopyClick(content, buttonEl) {
    let textToCopy = content;
    if (this.detectThinkingTags(this.decodeHtmlEntities(content)).hasThinkingTags) {
      textToCopy = this.decodeHtmlEntities(content).replace(/<think>[\s\S]*?<\/think>/g, "").trim();
    }
    navigator.clipboard.writeText(textToCopy).then(() => {
      (0, import_obsidian.setIcon)(buttonEl, "check");
      buttonEl.setAttribute("title", "Copied!");
      setTimeout(() => {
        (0, import_obsidian.setIcon)(buttonEl, "copy");
        buttonEl.setAttribute("title", "Copy");
      }, 2e3);
    }).catch((err) => {
      console.error("Failed to copy text: ", err);
      new import_obsidian.Notice("Failed to copy text.");
    });
  }
  processThinkingTags(content) {
    const thinkingRegex = /<think>([\s\S]*?)<\/think>/g;
    let lastIndex = 0;
    const parts = [];
    let match;
    while ((match = thinkingRegex.exec(content)) !== null) {
      if (match.index > lastIndex) {
        parts.push(this.markdownToHtml(content.substring(lastIndex, match.index)));
      }
      const thinkingContent = match[1];
      const foldableHtml = `<div class="${CSS_CLASS_THINKING_BLOCK}"><div class="${CSS_CLASS_THINKING_HEADER}" data-fold-state="folded"><div class="${CSS_CLASS_THINKING_TOGGLE}">\u25BA</div><div class="${CSS_CLASS_THINKING_TITLE}">Thinking</div></div><div class="${CSS_CLASS_THINKING_CONTENT}" style="display: none;">${this.markdownToHtml(thinkingContent)}</div></div>`;
      parts.push(foldableHtml);
      lastIndex = thinkingRegex.lastIndex;
    }
    if (lastIndex < content.length) {
      parts.push(this.markdownToHtml(content.substring(lastIndex)));
    }
    return parts.join("");
  }
  markdownToHtml(markdown) {
    var _a, _b;
    if (!markdown || markdown.trim() === "")
      return "";
    const tempDiv = document.createElement("div");
    const contextFilePath = (_b = (_a = this.app.workspace.getActiveFile()) == null ? void 0 : _a.path) != null ? _b : "";
    import_obsidian.MarkdownRenderer.renderMarkdown(markdown, tempDiv, contextFilePath, this);
    return tempDiv.innerHTML;
  }
  addThinkingToggleListeners(contentEl) {
    const thinkingHeaders = contentEl.querySelectorAll(`.${CSS_CLASS_THINKING_HEADER}`);
    thinkingHeaders.forEach((header) => {
      header.addEventListener("click", () => {
        const content = header.nextElementSibling;
        const toggleIcon = header.querySelector(`.${CSS_CLASS_THINKING_TOGGLE}`);
        if (!content || !toggleIcon)
          return;
        const isFolded = header.getAttribute("data-fold-state") === "folded";
        if (isFolded) {
          content.style.display = "block";
          toggleIcon.textContent = "\u25BC";
          header.setAttribute("data-fold-state", "expanded");
        } else {
          content.style.display = "none";
          toggleIcon.textContent = "\u25BA";
          header.setAttribute("data-fold-state", "folded");
        }
      });
    });
  }
  decodeHtmlEntities(text) {
    if (typeof document === "undefined")
      return text;
    const textArea = document.createElement("textarea");
    textArea.innerHTML = text;
    return textArea.value;
  }
  detectThinkingTags(content) {
    if (/<think>[\s\S]*?<\/think>/gi.test(content)) {
      return { hasThinkingTags: true, format: "standard" };
    }
    return { hasThinkingTags: false, format: "none" };
  }
  // --- Speech Recognition ---
  // (Без змін)
  initSpeechWorker() {
  }
  setupSpeechWorkerHandlers() {
  }
  insertTranscript(transcript) {
  }
  async toggleVoiceRecognition() {
  }
  async startVoiceRecognition() {
  }
  stopVoiceRecording(processAudio) {
  }
  // --- Helpers & Utilities ---
  // (Без змін, крім clearChatContainer)
  getChatContainer() {
    return this.chatContainer;
  }
  clearChatContainer() {
    this.clearChatContainerInternal();
    this.saveMessageHistory();
    this.updateSendButtonState();
  }
  clearChatContainerInternal() {
    this.messages = [];
    this.messagesPairCount = 0;
    this.lastMessageDate = null;
    if (this.chatContainer) {
      this.chatContainer.empty();
    }
  }
  addLoadingIndicator() {
    this.hideEmptyState();
    const messageGroup = this.chatContainer.createDiv({ cls: `${CSS_CLASS_MESSAGE_GROUP} ${CSS_CLASS_OLLAMA_GROUP}` });
    this.renderAvatar(messageGroup, false);
    const messageEl = messageGroup.createDiv({ cls: `${CSS_CLASS_MESSAGE} ${CSS_CLASS_OLLAMA_MESSAGE}` });
    const dotsContainer = messageEl.createDiv({ cls: CSS_CLASS_THINKING_DOTS });
    for (let i = 0; i < 3; i++) {
      dotsContainer.createDiv({ cls: CSS_CLASS_THINKING_DOT });
    }
    this.guaranteedScrollToBottom(50, true);
    return messageGroup;
  }
  removeLoadingIndicator(loadingEl) {
    if (loadingEl && loadingEl.parentNode) {
      loadingEl.remove();
    }
  }
  scrollToBottom() {
    this.guaranteedScrollToBottom(50, true);
  }
  clearInputField() {
    if (this.inputEl) {
      this.inputEl.value = "";
      this.inputEl.dispatchEvent(new Event("input"));
    }
  }
  guaranteedScrollToBottom(delay = 50, forceScroll = false) {
    if (this.scrollTimeout) {
      clearTimeout(this.scrollTimeout);
    }
    this.scrollTimeout = setTimeout(() => {
      requestAnimationFrame(() => {
        var _a, _b;
        if (this.chatContainer) {
          const scrollThreshold = 100;
          const isScrolledUpCheck = this.chatContainer.scrollHeight - this.chatContainer.scrollTop - this.chatContainer.clientHeight > scrollThreshold;
          if (isScrolledUpCheck !== this.userScrolledUp) {
            this.userScrolledUp = isScrolledUpCheck;
            if (!this.userScrolledUp) {
              (_a = this.newMessagesIndicatorEl) == null ? void 0 : _a.classList.remove(CSS_CLASS_VISIBLE);
            }
          }
          if (forceScroll || !this.userScrolledUp || this.isProcessing) {
            this.chatContainer.scrollTop = this.chatContainer.scrollHeight;
            if (forceScroll || this.isProcessing) {
              this.userScrolledUp = false;
              (_b = this.newMessagesIndicatorEl) == null ? void 0 : _b.classList.remove(CSS_CLASS_VISIBLE);
            }
          }
        }
      });
    }, delay);
  }
  formatTime(date) {
    return date.toLocaleTimeString(void 0, { hour: "2-digit", minute: "2-digit" });
  }
  formatDateSeparator(date) {
    const now = new Date();
    const yesterday = new Date(now);
    yesterday.setDate(now.getDate() - 1);
    if (this.isSameDay(date, now)) {
      return "Today";
    } else if (this.isSameDay(date, yesterday)) {
      return "Yesterday";
    } else {
      return date.toLocaleDateString(void 0, { weekday: "long", year: "numeric", month: "long", day: "numeric" });
    }
  }
  isSameDay(date1, date2) {
    return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate();
  }
  setLoadingState(isLoading) {
    this.isProcessing = isLoading;
    if (this.inputEl)
      this.inputEl.disabled = isLoading;
    this.updateSendButtonState();
    if (this.voiceButton) {
      this.voiceButton.disabled = isLoading;
      this.voiceButton.classList.toggle(CSS_CLASS_DISABLED, isLoading);
    }
    if (this.menuButton) {
      this.menuButton.disabled = isLoading;
      this.menuButton.classList.toggle(CSS_CLASS_DISABLED, isLoading);
    }
  }
};
var OllamaView = _OllamaView;
OllamaView.instance = null;

// settings.ts
var import_obsidian2 = require("obsidian");
var DEFAULT_SETTINGS = {
  modelName: "mistral",
  ollamaServerUrl: "http://localhost:11434",
  logFileSizeLimit: 1024,
  saveMessageHistory: true,
  ragEnabled: false,
  ragFolderPath: "data",
  contextWindowSize: 5,
  googleApiKey: "",
  speechLanguage: "uk-UA",
  maxRecordingTime: 15,
  silenceDetection: true,
  followRole: true,
  useDefaultRoleDefinition: true,
  customRoleFilePath: "",
  systemPromptInterval: 0,
  temperature: 0.1,
  contextWindow: 8192
};
var OllamaSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  getDisplayText() {
    return "Ollama";
  }
  getId() {
    return "ollama-plugin";
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian2.Setting(containerEl).setName("Ollama Server URL").setDesc(
      "IP address and port where Ollama is running (e.g. http://192.168.1.10:11434)"
    ).addText(
      (text) => text.setPlaceholder("http://localhost:11434").setValue(this.plugin.settings.ollamaServerUrl).onChange(async (value) => {
        this.plugin.settings.ollamaServerUrl = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Server Connection").setDesc("Reconnect to local model server and refresh available models").addButton(
      (button) => button.setButtonText("Reconnect").setIcon("refresh-cw").onClick(async () => {
        try {
          new import_obsidian2.Notice("Connecting to Ollama server...");
          const response = await fetch(
            `${this.plugin.settings.ollamaServerUrl}/api/tags`,
            {
              method: "GET",
              headers: { "Content-Type": "application/json" }
            }
          );
          if (response.ok) {
            new import_obsidian2.Notice("Successfully connected to Ollama server!");
            containerEl.empty();
            this.display();
          } else {
            new import_obsidian2.Notice(
              "Failed to connect to Ollama server. Check the URL and ensure the server is running."
            );
            this.plugin.apiService.emit("connection-error");
          }
        } catch (error) {
          new import_obsidian2.Notice(
            "Connection error. Please check the server URL and your network connection."
          );
          this.plugin.apiService.emit("connection-error");
        }
      })
    );
    let availableModels = [];
    try {
      availableModels = await this.plugin.apiService.getModels();
    } catch (error) {
      console.error("Error fetching available models:", error);
      this.plugin.apiService.emit("connection-error");
    }
    const selectedModel = availableModels.includes(
      this.plugin.settings.modelName
    ) ? this.plugin.settings.modelName : availableModels.length > 0 ? availableModels[0] : "";
    const modelSetting = new import_obsidian2.Setting(containerEl).setName("Model Name").setDesc("Select the language model to use");
    const dropdown = modelSetting.addDropdown((dropdown2) => {
      const selectEl = dropdown2.selectEl;
      while (selectEl.firstChild) {
        selectEl.removeChild(selectEl.firstChild);
      }
      availableModels.forEach((model) => {
        dropdown2.addOption(model, model);
      });
      if (availableModels.length === 0) {
        dropdown2.addOption("", "No models available");
      }
      dropdown2.setValue(selectedModel);
      dropdown2.onChange(async (value) => {
        this.plugin.settings.modelName = value;
        this.plugin.emit("model-changed", value);
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(containerEl).setName("Save Message History").setDesc("Save chat message history between sessions").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.saveMessageHistory).onChange(async (value) => {
        this.plugin.settings.saveMessageHistory = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Log File Size Limit").setDesc(
      "Maximum size of message history log file in KB (1024 KB = 1 MB)"
    ).addSlider(
      (slider) => slider.setLimits(256, 10240, 256).setValue(this.plugin.settings.logFileSizeLimit).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.logFileSizeLimit = value;
        await this.plugin.saveSettings();
      })
    ).addExtraButton(
      (button) => button.setIcon("reset").setTooltip("Reset to default (1024 KB)").onClick(async () => {
        this.plugin.settings.logFileSizeLimit = DEFAULT_SETTINGS.logFileSizeLimit;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Clear History").setDesc("Delete all chat history").addButton(
      (button) => button.setButtonText("Clear").onClick(async () => {
        await this.plugin.clearMessageHistory();
        new import_obsidian2.Notice("Chat history cleared.");
      })
    );
    containerEl.createEl("h3", { text: "Role Configuration" });
    new import_obsidian2.Setting(containerEl).setName("Enable Role Definition").setDesc("Make Ollama follow a defined role from a file").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.followRole).onChange(async (value) => {
        this.plugin.settings.followRole = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Use Default Role Definition").setDesc("Use the default role definition file from the plugin folder").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.useDefaultRoleDefinition).onChange(async (value) => {
        this.plugin.settings.useDefaultRoleDefinition = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Custom Role Definition Path").setDesc(
      "Path to a custom role definition file (relative to vault root)"
    ).addText(
      (text) => text.setPlaceholder("folder/role.md").setValue(this.plugin.settings.customRoleFilePath).onChange(async (value) => {
        this.plugin.settings.customRoleFilePath = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("System Prompt Interval").setDesc("Number of message pairs between system prompt resends. 0 - with every request, negative - never send").addText(
      (text) => text.setValue(String(this.plugin.settings.systemPromptInterval || 0)).onChange(async (value) => {
        this.plugin.settings.systemPromptInterval = parseInt(value) || 0;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "RAG Configuration" });
    new import_obsidian2.Setting(containerEl).setName("Enable RAG").setDesc("Use Retrieval Augmented Generation with your notes").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.ragEnabled).onChange(async (value) => {
        this.plugin.settings.ragEnabled = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("AI Assistant Path").setDesc(
      "Path to the folder containing assistant settings. RAG documents will be loaded from 'data' subfolder (relative to vault root)"
    ).addText(
      (text) => text.setPlaceholder("").setValue(this.plugin.settings.ragFolderPath).onChange(async (value) => {
        this.plugin.settings.ragFolderPath = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Context Window Size").setDesc("Number of relevant documents to include in context").addSlider(
      (slider) => slider.setLimits(1, 10, 1).setValue(this.plugin.settings.contextWindowSize).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.contextWindowSize = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Speech Recognition" });
    new import_obsidian2.Setting(containerEl).setName("Google API Key").setDesc("API key for Google Speech-to-Text service").addText(
      (text) => text.setPlaceholder("Enter your Google API key").setValue(this.plugin.settings.googleApiKey).onChange(async (value) => {
        this.plugin.settings.googleApiKey = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Speech Recognition Language").setDesc(
      "Language code for Google Speech-to-Text (e.g., uk-UA, en-US, ru-RU)"
    ).addText(
      (text) => text.setPlaceholder("uk-UA").setValue(this.plugin.settings.speechLanguage).onChange(async (value) => {
        this.plugin.settings.speechLanguage = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Maximum Recording Time").setDesc(
      "Maximum time (in seconds) to record before automatically stopping"
    ).addSlider(
      (slider) => slider.setLimits(5, 60, 5).setValue(this.plugin.settings.maxRecordingTime).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.maxRecordingTime = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Advanced Configuration" });
    new import_obsidian2.Setting(containerEl).setName("AI context window").setDesc("Model context window size (recommended > 8192)").addText(
      (text) => text.setValue(String(this.plugin.settings.contextWindow || 8192)).onChange(async (value) => {
        this.plugin.settings.contextWindow = parseInt(value) || 8192;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Temperature").setDesc("Controls randomness in model responses (0.0-1.0)").addSlider(
      (slider) => slider.setLimits(0, 1, 0.1).setValue(this.plugin.settings.temperature).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.temperature = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

// ragService.ts
var RagService = class {
  constructor(plugin) {
    this.documents = [];
    this.isIndexing = false;
    this.plugin = plugin;
  }
  /**
   * Index all markdown files in the specified folder path
   */
  async indexDocuments() {
    var _a, _b;
    if (this.isIndexing)
      return;
    this.isIndexing = true;
    try {
      const folderPath = this.plugin.settings.ragFolderPath;
      const vault = this.plugin.app.vault;
      console.log(`AI Assistant path: "${folderPath}" (RAG documents will be loaded from 'data' subfolder)`);
      const allFiles = vault.getFiles();
      console.log(`Total files in vault: ${allFiles.length}`);
      const files = await this.getMarkdownFiles(vault, folderPath);
      console.log(`Found ${files.length} markdown files from "${folderPath}"`);
      console.log(`Indexing ${files.length} markdown files from ${folderPath}`);
      this.documents = [];
      for (const file of files) {
        try {
          const content = await vault.read(file);
          this.documents.push({
            path: file.path,
            content,
            metadata: {
              filename: file.name,
              created: (_a = file.stat) == null ? void 0 : _a.ctime,
              modified: (_b = file.stat) == null ? void 0 : _b.mtime
            }
          });
        } catch (error) {
          console.error(`Error reading file ${file.path}:`, error);
        }
      }
      console.log(`Indexed ${this.documents.length} documents for RAG`);
    } catch (error) {
      console.error("Error indexing documents:", error);
    } finally {
      this.isIndexing = false;
    }
  }
  /**
   * Get all markdown files in the specified folder path
   */
  async getMarkdownFiles(vault, folderPath) {
    const files = [];
    if (!folderPath) {
      return files;
    }
    let normalizedFolderPath = folderPath;
    if (!normalizedFolderPath.endsWith("/")) {
      normalizedFolderPath += "/";
    }
    const dataFolderPath = normalizedFolderPath + "data/";
    console.log(`Looking for markdown files in: "${dataFolderPath}"`);
    const allFiles = vault.getFiles();
    for (const file of allFiles) {
      if (file.extension === "md" && file.path.startsWith(dataFolderPath)) {
        console.log(`Adding file: ${file.path}`);
        files.push(file);
      }
    }
    return files;
  }
  /**
   * Simple search implementation to find relevant documents for a query
   * Later this could be replaced with a more sophisticated vector search
   */
  findRelevantDocuments(query, limit = 5) {
    if (!this.documents.length) {
      return [];
    }
    const scoredDocs = this.documents.map((doc) => {
      const lowerContent = doc.content.toLowerCase();
      const lowerQuery = query.toLowerCase();
      const terms = lowerQuery.split(/\s+/);
      let score = 0;
      for (const term of terms) {
        if (term.length > 2) {
          const regex = new RegExp(term, "gi");
          const matches = lowerContent.match(regex);
          if (matches) {
            score += matches.length;
          }
        }
      }
      return { doc, score };
    });
    return scoredDocs.sort((a, b) => b.score - a.score).slice(0, limit).map((item) => item.doc);
  }
  /**
   * Prepare context from relevant documents
   */
  prepareContext(query) {
    if (!this.plugin.settings.ragEnabled || this.documents.length === 0) {
      return "";
    }
    const limit = this.plugin.settings.contextWindowSize;
    const relevantDocs = this.findRelevantDocuments(query, limit);
    if (relevantDocs.length === 0) {
      return "";
    }
    let context = "### Context:\n\n";
    relevantDocs.forEach((doc, index) => {
      var _a;
      context += `Document ${index + 1} (${(_a = doc.metadata) == null ? void 0 : _a.filename}):
`;
      const maxChars = 1500;
      const content = doc.content.length > maxChars ? doc.content.substring(0, maxChars) + "..." : doc.content;
      context += content + "\n\n";
    });
    context += "### End of context\n\n";
    return context;
  }
};

// stateManager.ts
var StateManager = class {
  constructor() {
    this.state = {
      currentPhase: "next goal choosing",
      currentGoal: "Identify if there are any urgent tasks",
      userActivity: "talking with AI",
      hasUrgentTasks: "unknown",
      urgentTasksList: [],
      currentUrgentTask: null,
      planExists: "unknown",
      lastUpdateTime: new Date()
    };
  }
  // Singleton паттерн для доступа к состоянию
  static getInstance() {
    if (!StateManager.instance) {
      StateManager.instance = new StateManager();
    }
    return StateManager.instance;
  }
  // Получить текущее состояние
  getState() {
    this.state.lastUpdateTime = new Date();
    return { ...this.state };
  }
  // Обновить состояние
  updateState(newState) {
    this.state = {
      ...this.state,
      ...newState,
      lastUpdateTime: new Date()
    };
  }
  // Добавление задачи в список срочных задач
  addUrgentTask(task) {
    if (!this.state.urgentTasksList.includes(task)) {
      this.state.urgentTasksList.push(task);
      if (!this.state.currentUrgentTask && this.state.urgentTasksList.length > 0) {
        this.state.currentUrgentTask = this.state.urgentTasksList[0];
      }
      this.state.hasUrgentTasks = true;
    }
  }
  // Удаление задачи из списка и обновление текущей задачи
  completeUrgentTask(task) {
    const index = this.state.urgentTasksList.indexOf(task);
    if (index !== -1) {
      this.state.urgentTasksList.splice(index, 1);
      if (this.state.urgentTasksList.length > 0) {
        this.state.currentUrgentTask = this.state.urgentTasksList[0];
      } else {
        this.state.currentUrgentTask = null;
        this.state.hasUrgentTasks = false;
      }
    }
  }
  // Получить состояние в формате для вставки в сообщение
  getStateFormatted() {
    const currentTime = new Date().toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
    return `- **[day phase]** ${this.state.currentPhase}
  - **[next goal]** ${this.state.currentGoal}
  - **[user activity]** ${this.state.userActivity}
  - **[AI time]** ${currentTime}`;
  }
  // Анализ сообщения пользователя для обновления состояния
  processUserMessage(message) {
  }
  // Сохранение состояния в локальное хранилище
  saveStateToStorage() {
    localStorage.setItem("assistantState", JSON.stringify(this.state));
  }
  // Загрузка состояния из локального хранилища
  loadStateFromStorage() {
    const savedState = localStorage.getItem("assistantState");
    if (savedState) {
      try {
        const parsedState = JSON.parse(savedState);
        parsedState.lastUpdateTime = new Date(parsedState.lastUpdateTime);
        this.state = parsedState;
        return true;
      } catch (e) {
        console.error("Error parsing saved state:", e);
      }
    }
    return false;
  }
};

// promptService.ts
var import_obsidian3 = require("obsidian");
var path = __toESM(require("path"));
var PromptService = class {
  // Reference to the plugin for accessing services
  constructor(plugin) {
    this.systemPrompt = null;
    this.stateManager = StateManager.getInstance();
    this.plugin = plugin;
  }
  /**
   * Set plugin reference for accessing services
   */
  setPlugin(plugin) {
    this.plugin = plugin;
  }
  /**
   * Set system prompt to be used with each request
   */
  setSystemPrompt(prompt) {
    this.systemPrompt = prompt;
  }
  /**
   * Get system prompt if set
   */
  getSystemPrompt() {
    return this.systemPrompt;
  }
  /**
   * Format user prompt with necessary context and state information
   */
  formatPrompt(userInput, isNewConversation = false) {
    this.stateManager.processUserMessage(userInput);
    if (isNewConversation) {
      return userInput;
    }
    return userInput;
  }
  /**
   * Enhance prompt with RAG context if available
   */
  enhanceWithRagContext(prompt, ragContext) {
    if (!ragContext) {
      return prompt;
    }
    return `Context information:
${ragContext}

User message: ${prompt}`;
  }
  /**
   * Prepare request body for model API call
   */
  prepareRequestBody(modelName, prompt, temperature = 0.2) {
    const requestBody = {
      model: modelName,
      prompt,
      stream: false,
      temperature
    };
    if (this.systemPrompt) {
      requestBody.system = this.systemPrompt;
    }
    return requestBody;
  }
  /**
   * Process response from language model
   */
  processModelResponse(response) {
    const textArea = document.createElement("textarea");
    textArea.innerHTML = response;
    const decodedResponse = textArea.value;
    return decodedResponse.includes("<think>") ? decodedResponse : response;
  }
  /**
   * Get default role definition from plugin folder
   */
  async getDefaultRoleDefinition() {
    if (!this.plugin) {
      return null;
    }
    try {
      const pluginFolder = this.plugin.manifest.dir;
      const rolePath = "default-role.md";
      const fullPath = path.join(pluginFolder, rolePath);
      let content;
      try {
        content = await this.plugin.app.vault.adapter.read(fullPath);
      } catch (readError) {
        console.log("Couldn't read file, attempting to create it");
        try {
          const defaultContent = "# Default AI Role\n\nYou are a helpful assistant.";
          const exists = await this.plugin.app.vault.adapter.exists(fullPath);
          if (!exists) {
            await this.plugin.app.vault.adapter.write(fullPath, defaultContent);
            content = defaultContent;
          } else {
            console.error("File exists but couldn't be read:", fullPath);
            return null;
          }
        } catch (createError) {
          console.error("Error creating default role file:", createError);
          return null;
        }
      }
      if (content) {
        const currentTime = new Date().toLocaleTimeString();
        content += `
AI time is ${currentTime} now`;
        return content;
      }
      return null;
    } catch (error) {
      console.error("Error handling default role definition:", error);
      return null;
    }
  }
  /**
   * Get custom role definition from specified path
   */
  async getCustomRoleDefinition() {
    if (!this.plugin || !this.plugin.settings.customRoleFilePath) {
      return null;
    }
    try {
      const customPath = this.plugin.settings.customRoleFilePath;
      const file = this.plugin.app.vault.getAbstractFileByPath(customPath);
      if (file instanceof import_obsidian3.TFile) {
        let content = await this.plugin.app.vault.read(file);
        const currentTime = new Date().toLocaleTimeString();
        content += `
AI time is ${currentTime} now`;
        return content;
      }
      return null;
    } catch (error) {
      console.error("Error reading custom role definition:", error);
      return null;
    }
  }
  /**
   * Get role definition based on settings
   */
  async getRoleDefinition() {
    if (!this.plugin || !this.plugin.settings.followRole) {
      return null;
    }
    try {
      if (this.plugin.settings.useDefaultRoleDefinition) {
        return await this.getDefaultRoleDefinition();
      } else if (this.plugin.settings.customRoleFilePath) {
        return await this.getCustomRoleDefinition();
      }
      return null;
    } catch (error) {
      console.error("Error reading role definition:", error);
      return null;
    }
  }
  /**
   * Prepare a complete prompt with all enhancements (RAG, role definition, etc.)
   */
  async prepareFullPrompt(content, isNewConversation = false) {
    if (!this.plugin) {
      return this.formatPrompt(content, isNewConversation);
    }
    try {
      const roleDefinition = await this.getRoleDefinition();
      if (roleDefinition) {
        this.setSystemPrompt(roleDefinition);
      }
    } catch (error) {
      console.error("Error getting role definition:", error);
    }
    let formattedPrompt = this.formatPrompt(content, isNewConversation);
    if (this.plugin.settings.ragEnabled && this.plugin.ragService) {
      try {
        if (this.plugin.ragService.findRelevantDocuments("test").length === 0) {
          await this.plugin.ragService.indexDocuments();
        }
        const ragContext = this.plugin.ragService.prepareContext(content);
        if (ragContext) {
          formattedPrompt = this.enhanceWithRagContext(formattedPrompt, ragContext);
        }
      } catch (error) {
        console.error("Error processing RAG:", error);
      }
    }
    return formattedPrompt;
  }
};

// apiServices.ts
var ApiService = class {
  constructor(baseUrl, plugin) {
    this.ollamaView = null;
    this.eventHandlers = {};
    this.baseUrl = baseUrl;
    this.stateManager = StateManager.getInstance();
    this.promptService = new PromptService(plugin);
    this.stateManager.loadStateFromStorage();
  }
  on(event, callback) {
    if (!this.eventHandlers[event]) {
      this.eventHandlers[event] = [];
    }
    this.eventHandlers[event].push(callback);
    return () => {
      this.eventHandlers[event] = this.eventHandlers[event].filter(
        (handler) => handler !== callback
      );
    };
  }
  emit(event, data) {
    const handlers = this.eventHandlers[event];
    if (handlers) {
      handlers.forEach((handler) => handler(data));
    }
  }
  getPromptService() {
    return this.promptService;
  }
  setOllamaView(view) {
    this.ollamaView = view;
  }
  /**
   * Set system prompt to be used with each request
   */
  setSystemPrompt(prompt) {
    this.promptService.setSystemPrompt(prompt);
  }
  /**
   * Set base URL for the API
   */
  setBaseUrl(url) {
    this.baseUrl = url;
  }
  /**
   * Set plugin reference for prompt service
   */
  setPlugin(plugin) {
    this.promptService.setPlugin(plugin);
  }
  /**
   * Generate response from Ollama
   */
  async generateResponse(requestBody) {
    const response = await fetch(`${this.baseUrl}/api/generate`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(requestBody)
    });
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`HTTP error! Status: ${response.status}, ${errorText}`);
    }
    const data = await response.json();
    data.response = this.promptService.processModelResponse(data.response);
    this.stateManager.saveStateToStorage();
    return {
      model: requestBody.model,
      response: this.promptService.processModelResponse(data.response)
    };
  }
  /**
   * Get available models from Ollama
   */
  async getModels() {
    try {
      const response = await fetch(`${this.baseUrl}/api/tags`, {
        method: "GET",
        headers: { "Content-Type": "application/json" }
      });
      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
      const data = await response.json();
      if (Array.isArray(data.models)) {
        return data.models.map(
          (model) => typeof model === "object" ? model.name : model
        );
      }
      return [];
    } catch (error) {
      console.error("Error fetching models:", error);
      return [];
    }
  }
  /**
   * Reset assistant state to initial values
   */
  resetState() {
    const initialState = {
      currentPhase: "next goal choosing",
      currentGoal: "Identify if there are any urgent tasks",
      userActivity: "talking with AI",
      hasUrgentTasks: "unknown",
      urgentTasksList: [],
      currentUrgentTask: null,
      planExists: "unknown"
    };
    this.stateManager.updateState(initialState);
    this.stateManager.saveStateToStorage();
    if (this.ollamaView) {
      this.ollamaView.messagesPairCount = 0;
    }
  }
};

// messageService.ts
var MessageService = class {
  // private messagesPairCount: number = 0; // Тепер керується в OllamaView
  constructor(plugin) {
    this.view = null;
    // --- Видалено внутрішній стан ---
    // private messages: Message[] = [];
    this.isProcessing = false;
    this.plugin = plugin;
  }
  setView(view) {
    this.view = view;
  }
  // Load message history and populate the VIEW
  async loadMessageHistory() {
    if (!this.view)
      return;
    try {
      const history = await this.plugin.loadMessageHistory();
      if (Array.isArray(history) && history.length > 0) {
        this.view.clearChatContainer();
        for (const msg of history) {
          const role = msg.role;
          if (role) {
            this.view.internalAddMessage(
              role,
              msg.content
              /*, new Date(msg.timestamp)*/
            );
          } else {
            console.warn("Skipping message with unknown role during history load:", msg);
          }
        }
        this.view.guaranteedScrollToBottom(100, true);
      } else {
        this.view.showEmptyState();
      }
    } catch (error) {
      console.error("Error loading message history:", error);
      this.view.clearChatContainer();
      this.view.showEmptyState();
    }
  }
  // --- Видалено saveMessageHistory з MessageService ---
  // Send a message from the user to Ollama
  async sendMessage(content) {
    if (this.isProcessing || !content.trim() || !this.view)
      return;
    await this.processWithOllama(content);
  }
  // --- Видалено addMessage з MessageService ---
  // --- Видалено renderMessage та пов'язані хелпери з MessageService ---
  // --- Видалено clearChatMessages з MessageService (використовуємо OllamaView.clearChatContainer) ---
  // Process request with Ollama
  async processWithOllama(content) {
    if (!this.view)
      return;
    this.view.setLoadingState(true);
    const loadingMessageEl = this.view.addLoadingIndicator();
    setTimeout(async () => {
      var _a, _b, _c, _d, _e;
      try {
        let useSystemPrompt = false;
        const isNewConversation = true;
        const formattedPrompt = await this.plugin.promptService.prepareFullPrompt(
          content,
          isNewConversation
        );
        const requestBody = {
          /* ... без змін ... */
        };
        if (useSystemPrompt) {
        }
        const data = await this.plugin.apiService.generateResponse(requestBody);
        (_a = this.view) == null ? void 0 : _a.removeLoadingIndicator(loadingMessageEl);
        (_b = this.view) == null ? void 0 : _b.internalAddMessage("assistant", data.response);
      } catch (error) {
        console.error("Error processing request with Ollama:", error);
        (_c = this.view) == null ? void 0 : _c.removeLoadingIndicator(loadingMessageEl);
        const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
        (_d = this.view) == null ? void 0 : _d.internalAddMessage(
          "error",
          // Використовуємо рядковий літерал
          `Connection error with Ollama: ${errorMessage}. Please check the settings and ensure the server is running.`
        );
      } finally {
        (_e = this.view) == null ? void 0 : _e.setLoadingState(false);
      }
    }, 0);
  }
  // Додавання системного повідомлення тепер теж через View
  addSystemMessage(content) {
    if (this.view) {
      this.view.internalAddMessage("system", content);
    }
  }
  // --- Видалено приватні хелпери для рендерингу ---
};

// main.ts
var OllamaPlugin = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    this.view = null;
    // Simple event emitter
    this.eventHandlers = {};
    // RAG data (consider moving to RagService or separate storage later)
    this.documents = [];
    this.embeddings = [];
    // --- Debounce Indexing ---
    this.indexUpdateTimeout = null;
  }
  // --- Event Emitter Methods ---
  on(event, callback) {
    if (!this.eventHandlers[event]) {
      this.eventHandlers[event] = [];
    }
    this.eventHandlers[event].push(callback);
    return () => {
      this.eventHandlers[event] = this.eventHandlers[event].filter(
        (handler) => handler !== callback
      );
    };
  }
  emit(event, data) {
    const handlers = this.eventHandlers[event];
    if (handlers) {
      handlers.slice().forEach((handler) => {
        try {
          handler(data);
        } catch (e) {
          console.error(`Error in event handler for ${event}:`, e);
        }
      });
    }
  }
  // --- End Event Emitter Methods ---
  async onload() {
    console.log("Ollama Plugin Loaded!");
    await this.loadSettings();
    this.apiService = new ApiService(this.settings.ollamaServerUrl);
    this.ragService = new RagService(this);
    this.promptService = new PromptService(this);
    this.messageService = new MessageService(this);
    this.registerView(VIEW_TYPE_OLLAMA, (leaf) => {
      console.log("OllamaPlugin: Registering new view instance.");
      this.view = new OllamaView(leaf, this);
      this.messageService.setView(this.view);
      if (this.apiService) {
        this.apiService.setOllamaView(this.view);
      }
      return this.view;
    });
    this.apiService.on("connection-error", (error) => {
      console.error("Ollama connection error event received:", error);
      if (this.view) {
        this.view.internalAddMessage(
          // <-- FIX: Call view's method
          "error",
          // Use string literal for role
          `Failed to connect to Ollama: ${error.message}. Please check settings.`
        );
      } else {
        new import_obsidian4.Notice(`Failed to connect to Ollama: ${error.message}`);
        console.log("Ollama connection error: View not available to display message.");
      }
    });
    this.addRibbonIcon("message-square", "Open Ollama Chat", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-ollama-view",
      name: "Open Ollama Chat",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "change-model",
      // Example command
      name: "Change Ollama Model (Example)",
      callback: async () => {
        const newModel = "llama3:latest";
        console.log(`Changing model to ${newModel}`);
        this.settings.modelName = newModel;
        await this.saveSettings();
        this.emit("model-changed", newModel);
      }
    });
    this.addCommand({
      id: "index-rag-documents",
      name: "Index documents for RAG",
      callback: async () => {
        await this.ragService.indexDocuments();
      }
    });
    this.addCommand({
      id: "clear-ollama-history",
      name: "Clear Ollama Chat History",
      callback: async () => {
        await this.clearMessageHistory();
        new import_obsidian4.Notice("Ollama chat history cleared.");
      }
    });
    this.settingTab = new OllamaSettingTab(this.app, this);
    this.addSettingTab(this.settingTab);
    this.app.workspace.onLayoutReady(async () => {
      if (this.settings.ragEnabled) {
        setTimeout(() => {
          console.log("OllamaPlugin: RAG enabled, starting initial index.");
          this.ragService.indexDocuments();
        }, 5e3);
      }
    });
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        if (this.settings.ragEnabled) {
          this.debounceIndexUpdate();
        }
      })
    );
  }
  // Called when plugin is unloaded
  onunload() {
    console.log("Ollama Plugin Unloaded!");
    this.app.workspace.getLeavesOfType(VIEW_TYPE_OLLAMA).forEach((leaf) => {
      leaf.detach();
    });
    if (this.indexUpdateTimeout) {
      clearTimeout(this.indexUpdateTimeout);
    }
  }
  // --- Service Updates ---
  // Update API service when settings change (called from saveSettings)
  updateApiService() {
    if (this.apiService) {
      this.apiService.setBaseUrl(this.settings.ollamaServerUrl);
    }
  }
  debounceIndexUpdate() {
    if (this.indexUpdateTimeout) {
      clearTimeout(this.indexUpdateTimeout);
    }
    this.indexUpdateTimeout = setTimeout(() => {
      console.log("OllamaPlugin: Debounced RAG index update triggered.");
      this.ragService.indexDocuments();
      this.indexUpdateTimeout = null;
    }, 3e4);
  }
  // --- View Activation ---
  async activateView() {
    var _a;
    const { workspace } = this.app;
    let leaf = null;
    const existingLeaves = workspace.getLeavesOfType(VIEW_TYPE_OLLAMA);
    if (existingLeaves.length > 0) {
      leaf = existingLeaves[0];
      console.log("OllamaPlugin: Found existing view leaf.");
    } else {
      console.log("OllamaPlugin: No existing view leaf found, creating new one.");
      leaf = (_a = workspace.getRightLeaf(false)) != null ? _a : workspace.getLeaf(true);
      await leaf.setViewState({ type: VIEW_TYPE_OLLAMA, active: true });
      console.log("OllamaPlugin: New view leaf created.");
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
      const viewInstance = leaf.view;
      if (viewInstance instanceof OllamaView) {
        this.view = viewInstance;
        this.messageService.setView(this.view);
        if (this.apiService) {
          this.apiService.setOllamaView(this.view);
        }
        console.log("OllamaPlugin: View activated and services linked.");
      } else {
        console.error("OllamaPlugin: Leaf revealed, but view instance is not of type OllamaView?");
      }
    } else {
      console.error("OllamaPlugin: Failed to get or create a leaf for the view.");
    }
  }
  // --- Settings Management ---
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.updateApiService();
    console.log("OllamaPlugin: Settings saved.");
  }
  // --- History Persistence --- (Using corrected logic)
  // Overwrites the history file with the provided complete history string (or clears it)
  async saveMessageHistory(messagesJsonString) {
    if (!this.settings.saveMessageHistory) {
      return;
    }
    const adapter = this.app.vault.adapter;
    const pluginConfigDir = this.manifest.dir;
    if (!pluginConfigDir) {
      console.error("OllamaPlugin: Could not determine plugin directory path.");
      return;
    }
    const logPath = `${pluginConfigDir}/chat_history.json`;
    console.log(`OllamaPlugin: Preparing to save history to ${logPath}`);
    console.log(`OllamaPlugin: Received data string (length ${messagesJsonString.length}):`, messagesJsonString.substring(0, 200) + "...");
    try {
      let dataToWrite = messagesJsonString;
      let finalSizeKB = dataToWrite.length / 1024;
      if (dataToWrite.trim() === "[]") {
        console.log("OllamaPlugin: Clear operation detected. Writing empty array.");
      } else if (finalSizeKB > this.settings.logFileSizeLimit) {
        console.log(`OllamaPlugin: New history size (${finalSizeKB}KB) exceeds limit (${this.settings.logFileSizeLimit}KB). Trimming oldest messages.`);
        try {
          let parsedMessages = JSON.parse(dataToWrite);
          if (!Array.isArray(parsedMessages)) {
            throw new Error("History data is not an array.");
          }
          while (JSON.stringify(parsedMessages).length / 1024 > this.settings.logFileSizeLimit && parsedMessages.length > 1) {
            parsedMessages.shift();
          }
          dataToWrite = parsedMessages.length > 0 ? JSON.stringify(parsedMessages) : "[]";
          finalSizeKB = dataToWrite.length / 1024;
          console.log(`OllamaPlugin: History trimmed. New size: ${finalSizeKB}KB`);
        } catch (e) {
          console.error("OllamaPlugin: Error parsing history for trimming. Resetting history:", e);
          dataToWrite = "[]";
          finalSizeKB = dataToWrite.length / 1024;
        }
      }
      const fileExists = await adapter.exists(logPath);
      if (fileExists) {
        try {
          console.log("OllamaPlugin: Backing up old history file before overwriting.");
          const backupPath = logPath + ".backup";
          if (await adapter.exists(backupPath)) {
            await adapter.remove(backupPath);
          }
          await adapter.copy(logPath, backupPath);
        } catch (backupError) {
          console.error("OllamaPlugin: Failed to create history backup:", backupError);
        }
      }
      console.log(`OllamaPlugin: Writing history (size: ${finalSizeKB}KB) to ${logPath}`);
      console.log(`OllamaPlugin: Final data to write (length ${dataToWrite.length}):`, dataToWrite.substring(0, 200) + "...");
      await adapter.write(logPath, dataToWrite);
      console.log("OllamaPlugin: Write operation completed.");
    } catch (error) {
      console.error("OllamaPlugin: Failed to save message history:", error);
      new import_obsidian4.Notice("Error saving chat history.");
    }
  }
  // Loads history, returns array of objects or empty array
  async loadMessageHistory() {
    if (!this.settings.saveMessageHistory) {
      return [];
    }
    const adapter = this.app.vault.adapter;
    const pluginConfigDir = this.manifest.dir;
    if (!pluginConfigDir) {
      console.error("OllamaPlugin: Could not determine plugin directory path for loading.");
      return [];
    }
    const logPath = `${pluginConfigDir}/chat_history.json`;
    console.log(`OllamaPlugin: Attempting to load history from ${logPath}`);
    try {
      if (!await adapter.exists(logPath)) {
        console.log("OllamaPlugin: History file does not exist.");
        return [];
      }
      const data = await adapter.read(logPath);
      if (!data || data.trim() === "" || data.trim() === "[]") {
        console.log("OllamaPlugin: History file is empty or contains only '[]'.");
        return [];
      }
      console.log(`OllamaPlugin: Loaded history data (length ${data.length}):`, data.substring(0, 200) + "...");
      const parsedData = JSON.parse(data);
      if (Array.isArray(parsedData)) {
        console.log(`OllamaPlugin: Successfully parsed ${parsedData.length} messages from history.`);
        return parsedData;
      } else {
        console.warn("OllamaPlugin: Parsed history data is not an array. Returning empty history.");
        return [];
      }
    } catch (error) {
      console.error("OllamaPlugin: Failed to load/parse message history:", error);
      return [];
    }
  }
  // --- Refined Clear History Method ---
  // Clears history in view AND triggers save of empty state
  async clearMessageHistory() {
    console.log("OllamaPlugin: Clearing message history initiated.");
    try {
      await this.saveMessageHistory("[]");
      if (this.view) {
        this.view.clearChatContainer();
        console.log("OllamaPlugin: Called view.clearChatContainer.");
      } else {
        console.log("OllamaPlugin: View not active, history file cleared/reset.");
      }
      new import_obsidian4.Notice("Ollama chat history cleared.");
    } catch (error) {
      console.error("OllamaPlugin: Failed to clear message history:", error);
      new import_obsidian4.Notice("Error clearing chat history.");
    }
  }
  // --- End History Persistence ---
};
