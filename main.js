/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => OllamaPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// ollamaView.ts
var import_obsidian = require("obsidian");
var VIEW_TYPE_OLLAMA = "ollama-chat-view";
var CSS_CLASS_CONTAINER = "ollama-container";
var CSS_CLASS_CHAT_CONTAINER = "ollama-chat-container";
var CSS_CLASS_INPUT_CONTAINER = "chat-input-container";
var CSS_CLASS_BUTTONS_CONTAINER = "buttons-container";
var CSS_CLASS_SEND_BUTTON = "send-button";
var CSS_CLASS_VOICE_BUTTON = "voice-button";
var CSS_CLASS_MENU_BUTTON = "menu-button";
var CSS_CLASS_MENU_DROPDOWN = "menu-dropdown";
var CSS_CLASS_MENU_OPTION = "menu-option";
var CSS_CLASS_SETTINGS_OPTION = "settings-option";
var CSS_CLASS_EMPTY_STATE = "ollama-empty-state";
var CSS_CLASS_MESSAGE_GROUP = "message-group";
var CSS_CLASS_USER_GROUP = "user-message-group";
var CSS_CLASS_OLLAMA_GROUP = "ollama-message-group";
var CSS_CLASS_SYSTEM_GROUP = "system-message-group";
var CSS_CLASS_ERROR_GROUP = "error-message-group";
var CSS_CLASS_MESSAGE = "message";
var CSS_CLASS_USER_MESSAGE = "user-message";
var CSS_CLASS_OLLAMA_MESSAGE = "ollama-message";
var CSS_CLASS_SYSTEM_MESSAGE = "system-message";
var CSS_CLASS_ERROR_MESSAGE = "error-message";
var CSS_CLASS_SYSTEM_ICON = "system-icon";
var CSS_CLASS_ERROR_ICON = "error-icon";
var CSS_CLASS_SYSTEM_TEXT = "system-message-text";
var CSS_CLASS_ERROR_TEXT = "error-message-text";
var CSS_CLASS_CONTENT_CONTAINER = "message-content-container";
var CSS_CLASS_CONTENT = "message-content";
var CSS_CLASS_THINKING_DOTS = "thinking-dots";
var CSS_CLASS_THINKING_DOT = "thinking-dot";
var CSS_CLASS_THINKING_BLOCK = "thinking-block";
var CSS_CLASS_THINKING_HEADER = "thinking-header";
var CSS_CLASS_THINKING_TOGGLE = "thinking-toggle";
var CSS_CLASS_THINKING_TITLE = "thinking-title";
var CSS_CLASS_THINKING_CONTENT = "thinking-content";
var CSS_CLASS_TIMESTAMP = "message-timestamp";
var CSS_CLASS_COPY_BUTTON = "copy-button";
var CSS_CLASS_TEXTAREA_EXPANDED = "expanded";
var CSS_CLASS_DISABLED = "disabled";
var CSS_CLASS_MESSAGE_ARRIVING = "message-arriving";
var CSS_CLASS_DATE_SEPARATOR = "chat-date-separator";
var CSS_CLASS_AVATAR = "message-group-avatar";
var CSS_CLASS_AVATAR_USER = "user-avatar";
var CSS_CLASS_AVATAR_AI = "ai-avatar";
var CSS_CLASS_CODE_BLOCK_COPY_BUTTON = "code-block-copy-button";
var CSS_CLASS_CODE_BLOCK_LANGUAGE = "code-block-language";
var CSS_CLASS_NEW_MESSAGE_INDICATOR = "new-message-indicator";
var CSS_CLASS_VISIBLE = "visible";
var CSS_CLASS_MENU_SEPARATOR = "menu-separator";
var CSS_CLASS_CLEAR_CHAT_OPTION = "clear-chat-option";
var CSS_CLASS_CONTENT_COLLAPSIBLE = "message-content-collapsible";
var CSS_CLASS_CONTENT_COLLAPSED = "message-content-collapsed";
var CSS_CLASS_SHOW_MORE_BUTTON = "show-more-button";
var _OllamaView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.messages = [];
    this.isProcessing = false;
    this.scrollTimeout = null;
    this.speechWorker = null;
    this.mediaRecorder = null;
    this.audioStream = null;
    this.messagesPairCount = 0;
    this.emptyStateEl = null;
    this.resizeTimeout = null;
    this.lastMessageDate = null;
    this.newMessagesIndicatorEl = null;
    this.userScrolledUp = false;
    this.debouncedSaveMessageHistory = (0, import_obsidian.debounce)(this.saveMessageHistory, 300, true);
    // --- Event Handlers ---
    // (Без змін, крім handleClearChatClick, який тепер не викликає messageService)
    this.handleKeyDown = (e) => {
      if (e.key === "Enter" && !e.shiftKey && !this.isProcessing && !this.sendButton.disabled) {
        e.preventDefault();
        this.sendMessage();
      }
    };
    this.handleSendClick = () => {
      if (!this.isProcessing && !this.sendButton.disabled) {
        this.sendMessage();
      }
    };
    this.handleVoiceClick = () => {
      this.toggleVoiceRecognition();
    };
    this.handleMenuClick = (e) => {
      e.stopPropagation();
      const isHidden = this.menuDropdown.style.display === "none";
      this.menuDropdown.style.display = isHidden ? "block" : "none";
      if (!isHidden)
        this.menuDropdown.style.animation = "menu-fade-in 0.15s ease-out";
    };
    // Додано анімацію
    this.handleSettingsClick = async () => {
      this.closeMenu();
      const setting = this.app.setting;
      if (setting) {
        await setting.open();
        setting.openTabById("ollama-plugin");
      } else {
        new import_obsidian.Notice("\u041D\u0435 \u0432\u0434\u0430\u043B\u043E\u0441\u044F \u0432\u0456\u0434\u043A\u0440\u0438\u0442\u0438 \u043D\u0430\u043B\u0430\u0448\u0442\u0443\u0432\u0430\u043D\u043D\u044F.");
      }
    };
    // ID вкладки з settings.ts
    this.handleClearChatClick = () => {
      this.closeMenu();
      if (confirm("\u0412\u0438 \u0432\u043F\u0435\u0432\u043D\u0435\u043D\u0456, \u0449\u043E \u0445\u043E\u0447\u0435\u0442\u0435 \u0432\u0438\u0434\u0430\u043B\u0438\u0442\u0438 \u0432\u0441\u044E \u0456\u0441\u0442\u043E\u0440\u0456\u044E \u0447\u0430\u0442\u0443? \u0426\u044E \u0434\u0456\u044E \u043D\u0435\u043C\u043E\u0436\u043B\u0438\u0432\u043E \u0441\u043A\u0430\u0441\u0443\u0432\u0430\u0442\u0438.")) {
        this.plugin.clearMessageHistory();
      }
    };
    this.handleDocumentClickForMenu = (e) => {
      if (this.menuDropdown.style.display === "block" && !this.menuButton.contains(e.target) && !this.menuDropdown.contains(e.target)) {
        this.closeMenu();
      }
    };
    this.handleModelChange = (modelName) => {
      this.updateInputPlaceholder(modelName);
      if (this.messages.length > 0) {
        this.plugin.messageService.addSystemMessage(`\u041C\u043E\u0434\u0435\u043B\u044C \u0437\u043C\u0456\u043D\u0435\u043D\u043E \u043D\u0430: ${modelName}`);
      }
    };
    this.handleVisibilityChange = () => {
      if (document.visibilityState === "visible") {
        requestAnimationFrame(() => {
          this.guaranteedScrollToBottom(50);
          this.adjustTextareaHeight();
        });
      }
    };
    this.handleActiveLeafChange = (leaf) => {
      var _a;
      if ((leaf == null ? void 0 : leaf.view) === this) {
        setTimeout(() => this.guaranteedScrollToBottom(100), 100);
        (_a = this.inputEl) == null ? void 0 : _a.focus();
      }
    };
    // Перевіряємо конкретний view
    this.handleInputForResize = () => {
      if (this.resizeTimeout)
        clearTimeout(this.resizeTimeout);
      this.resizeTimeout = setTimeout(() => this.adjustTextareaHeight(), 50);
      this.updateSendButtonState();
    };
    this.handleWindowResize = () => {
      if (this.resizeTimeout)
        clearTimeout(this.resizeTimeout);
      this.resizeTimeout = setTimeout(() => this.adjustTextareaHeight(), 100);
    };
    this.handleScroll = () => {
      var _a;
      if (!this.chatContainer)
        return;
      const scrollThreshold = 150;
      const isScrolledToBottom = this.chatContainer.scrollHeight - this.chatContainer.scrollTop - this.chatContainer.clientHeight < scrollThreshold;
      if (!isScrolledToBottom) {
        this.userScrolledUp = true;
      } else {
        this.userScrolledUp = false;
        (_a = this.newMessagesIndicatorEl) == null ? void 0 : _a.classList.remove(CSS_CLASS_VISIBLE);
      }
    };
    this.handleNewMessageIndicatorClick = () => {
      var _a;
      this.guaranteedScrollToBottom(50, true);
      (_a = this.newMessagesIndicatorEl) == null ? void 0 : _a.classList.remove(CSS_CLASS_VISIBLE);
    };
    this.adjustTextareaHeight = () => {
      requestAnimationFrame(() => {
        if (!this.inputEl || !this.buttonsContainer)
          return;
        const viewHeight = this.contentEl.clientHeight;
        const maxHeight = Math.max(100, viewHeight * 0.5);
        this.inputEl.style.height = "auto";
        const scrollHeight = this.inputEl.scrollHeight;
        const newHeight = Math.min(scrollHeight, maxHeight);
        this.inputEl.style.height = `${newHeight}px`;
        this.inputEl.classList.toggle(CSS_CLASS_TEXTAREA_EXPANDED, scrollHeight > maxHeight);
      });
    };
    this.plugin = plugin;
    if (_OllamaView.instance && _OllamaView.instance !== this) {
      console.warn("\u0417\u0430\u043C\u0456\u043D\u0430 \u0456\u0441\u043D\u0443\u044E\u0447\u043E\u0433\u043E \u0435\u043A\u0437\u0435\u043C\u043F\u043B\u044F\u0440\u0430 OllamaView.");
    }
    _OllamaView.instance = this;
    if (!import_obsidian.requireApiVersion || !(0, import_obsidian.requireApiVersion)("1.0.0")) {
      console.warn("Ollama Plugin: \u041F\u043E\u0442\u043E\u0447\u043D\u0430 \u0432\u0435\u0440\u0441\u0456\u044F Obsidian API \u043C\u043E\u0436\u0435 \u0431\u0443\u0442\u0438 \u0437\u0430\u0441\u0442\u0430\u0440\u0456\u043B\u043E\u044E. \u0414\u0435\u044F\u043A\u0456 \u0444\u0443\u043D\u043A\u0446\u0456\u0457 \u043C\u043E\u0436\u0443\u0442\u044C \u043D\u0435 \u043F\u0440\u0430\u0446\u044E\u0432\u0430\u0442\u0438.");
    }
    this.initSpeechWorker();
    this.scrollListenerDebounced = (0, import_obsidian.debounce)(this.handleScroll, 150, true);
  }
  // --- Геттери ---
  getMessagesCount() {
    return this.messages.length;
  }
  getMessagesPairCount() {
    return this.messagesPairCount;
  }
  // Додаємо геттер для історії повідомлень
  getMessages() {
    return [...this.messages];
  }
  // ... (getViewType, getDisplayText, getIcon без змін) ...
  getViewType() {
    return VIEW_TYPE_OLLAMA;
  }
  getDisplayText() {
    return "Ollama Chat";
  }
  getIcon() {
    return "message-square";
  }
  // Або інша іконка
  async onOpen() {
    var _a, _b;
    this.createUIElements();
    this.updateInputPlaceholder(this.plugin.settings.modelName);
    this.attachEventListeners();
    this.autoResizeTextarea();
    this.updateSendButtonState();
    this.lastMessageDate = null;
    await this.loadAndRenderHistory();
    (_a = this.inputEl) == null ? void 0 : _a.focus();
    this.guaranteedScrollToBottom(150, true);
    (_b = this.inputEl) == null ? void 0 : _b.dispatchEvent(new Event("input"));
  }
  async onClose() {
    console.log("OllamaView onClose: \u041E\u0447\u0438\u0449\u0435\u043D\u043D\u044F \u0440\u0435\u0441\u0443\u0440\u0441\u0456\u0432.");
    if (this.speechWorker) {
      this.speechWorker.terminate();
      this.speechWorker = null;
    }
    this.stopVoiceRecording(false);
    if (this.audioStream) {
      this.audioStream.getTracks().forEach((track) => track.stop());
      this.audioStream = null;
    }
    if (this.scrollTimeout)
      clearTimeout(this.scrollTimeout);
    if (this.resizeTimeout)
      clearTimeout(this.resizeTimeout);
    if (_OllamaView.instance === this) {
      _OllamaView.instance = null;
    }
  }
  // --- UI Creation ---
  createUIElements() {
    this.contentEl.empty();
    this.chatContainerEl = this.contentEl.createDiv({ cls: CSS_CLASS_CONTAINER });
    this.chatContainer = this.chatContainerEl.createDiv({ cls: CSS_CLASS_CHAT_CONTAINER });
    this.newMessagesIndicatorEl = this.chatContainerEl.createDiv({ cls: CSS_CLASS_NEW_MESSAGE_INDICATOR });
    const indicatorIcon = this.newMessagesIndicatorEl.createSpan({ cls: "indicator-icon" });
    (0, import_obsidian.setIcon)(indicatorIcon, "arrow-down");
    this.newMessagesIndicatorEl.createSpan({ text: " \u041D\u043E\u0432\u0456 \u043F\u043E\u0432\u0456\u0434\u043E\u043C\u043B\u0435\u043D\u043D\u044F" });
    const inputContainer = this.chatContainerEl.createDiv({ cls: CSS_CLASS_INPUT_CONTAINER });
    this.inputEl = inputContainer.createEl("textarea", { attr: { placeholder: `\u041D\u0430\u043F\u0438\u0448\u0456\u0442\u044C \u0434\u043E ${this.plugin.settings.modelName}...`, rows: 1 } });
    this.buttonsContainer = inputContainer.createDiv({ cls: CSS_CLASS_BUTTONS_CONTAINER });
    this.sendButton = this.buttonsContainer.createEl("button", { cls: CSS_CLASS_SEND_BUTTON, attr: { "aria-label": "\u041D\u0430\u0434\u0456\u0441\u043B\u0430\u0442\u0438" } });
    (0, import_obsidian.setIcon)(this.sendButton, "send");
    this.voiceButton = this.buttonsContainer.createEl("button", { cls: CSS_CLASS_VOICE_BUTTON, attr: { "aria-label": "\u0413\u043E\u043B\u043E\u0441\u043E\u0432\u0438\u0439 \u0432\u0432\u0456\u0434" } });
    (0, import_obsidian.setIcon)(this.voiceButton, "mic");
    this.menuButton = this.buttonsContainer.createEl("button", { cls: CSS_CLASS_MENU_BUTTON, attr: { "aria-label": "\u041C\u0435\u043D\u044E" } });
    (0, import_obsidian.setIcon)(this.menuButton, "more-vertical");
    this.menuDropdown = inputContainer.createEl("div", { cls: CSS_CLASS_MENU_DROPDOWN });
    this.menuDropdown.style.display = "none";
    this.clearChatOption = this.menuDropdown.createEl("div", { cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_CLEAR_CHAT_OPTION}` });
    const clearIcon = this.clearChatOption.createEl("span", { cls: "menu-option-icon" });
    (0, import_obsidian.setIcon)(clearIcon, "trash-2");
    this.clearChatOption.createEl("span", { cls: "menu-option-text", text: "\u041E\u0447\u0438\u0441\u0442\u0438\u0442\u0438 \u0447\u0430\u0442" });
    this.menuDropdown.createEl("hr", { cls: CSS_CLASS_MENU_SEPARATOR });
    this.settingsOption = this.menuDropdown.createEl("div", { cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_SETTINGS_OPTION}` });
    const settingsIcon = this.settingsOption.createEl("span", { cls: "menu-option-icon" });
    (0, import_obsidian.setIcon)(settingsIcon, "settings");
    this.settingsOption.createEl("span", { cls: "menu-option-text", text: "\u041D\u0430\u043B\u0430\u0448\u0442\u0443\u0432\u0430\u043D\u043D\u044F" });
  }
  // --- Event Listeners ---
  attachEventListeners() {
    this.inputEl.addEventListener("keydown", this.handleKeyDown);
    this.inputEl.addEventListener("input", this.handleInputForResize);
    this.sendButton.addEventListener("click", this.handleSendClick);
    this.voiceButton.addEventListener("click", this.handleVoiceClick);
    this.menuButton.addEventListener("click", this.handleMenuClick);
    this.settingsOption.addEventListener("click", this.handleSettingsClick);
    this.clearChatOption.addEventListener("click", this.handleClearChatClick);
    this.registerDomEvent(window, "resize", this.handleWindowResize);
    this.registerEvent(this.app.workspace.on("resize", this.handleWindowResize));
    this.registerDomEvent(document, "click", this.handleDocumentClickForMenu);
    this.register(this.plugin.on("model-changed", this.handleModelChange));
    this.registerDomEvent(document, "visibilitychange", this.handleVisibilityChange);
    this.registerEvent(this.app.workspace.on("active-leaf-change", this.handleActiveLeafChange));
    this.registerDomEvent(this.chatContainer, "scroll", this.scrollListenerDebounced);
    if (this.newMessagesIndicatorEl) {
      this.registerDomEvent(this.newMessagesIndicatorEl, "click", this.handleNewMessageIndicatorClick);
    }
  }
  // --- UI Update Methods ---
  updateInputPlaceholder(modelName) {
    if (this.inputEl) {
      this.inputEl.placeholder = `\u041D\u0430\u043F\u0438\u0448\u0456\u0442\u044C \u0434\u043E ${modelName}...`;
    }
  }
  closeMenu() {
    if (this.menuDropdown) {
      this.menuDropdown.style.display = "none";
    }
  }
  autoResizeTextarea() {
    this.adjustTextareaHeight();
  }
  updateSendButtonState() {
    if (!this.inputEl || !this.sendButton)
      return;
    const isDisabled = this.inputEl.value.trim() === "" || this.isProcessing;
    this.sendButton.disabled = isDisabled;
    this.sendButton.classList.toggle(CSS_CLASS_DISABLED, isDisabled);
  }
  showEmptyState() {
    if (this.messages.length === 0 && !this.emptyStateEl && this.chatContainer) {
      this.chatContainer.empty();
      this.emptyStateEl = this.chatContainer.createDiv({ cls: CSS_CLASS_EMPTY_STATE });
      this.emptyStateEl.createDiv({ cls: "empty-state-message", text: "\u041F\u043E\u0432\u0456\u0434\u043E\u043C\u043B\u0435\u043D\u044C \u0449\u0435 \u043D\u0435\u043C\u0430\u0454" });
      this.emptyStateEl.createDiv({ cls: "empty-state-tip", text: `\u041D\u0430\u043F\u0438\u0448\u0456\u0442\u044C \u043F\u043E\u0432\u0456\u0434\u043E\u043C\u043B\u0435\u043D\u043D\u044F \u0430\u0431\u043E \u0432\u0438\u043A\u043E\u0440\u0438\u0441\u0442\u0430\u0439\u0442\u0435 \u0433\u043E\u043B\u043E\u0441\u043E\u0432\u0438\u0439 \u0432\u0432\u0456\u0434 \u0434\u043B\u044F \u0441\u043F\u0456\u043B\u043A\u0443\u0432\u0430\u043D\u043D\u044F \u0437 ${this.plugin.settings.modelName}` });
    }
  }
  hideEmptyState() {
    if (this.emptyStateEl) {
      this.emptyStateEl.remove();
      this.emptyStateEl = null;
    }
  }
  // --- Message Handling ---
  async loadAndRenderHistory() {
    this.lastMessageDate = null;
    this.clearChatContainerInternal();
    try {
      await this.plugin.messageService.loadMessageHistory();
      if (this.messages.length === 0) {
        this.showEmptyState();
      } else {
        this.hideEmptyState();
        this.checkAllMessagesForCollapsing();
        this.guaranteedScrollToBottom(100, true);
      }
    } catch (error) {
      console.error("OllamaView: \u041F\u043E\u043C\u0438\u043B\u043A\u0430 \u043F\u0456\u0434 \u0447\u0430\u0441 \u0437\u0430\u0432\u0430\u043D\u0442\u0430\u0436\u0435\u043D\u043D\u044F \u0456\u0441\u0442\u043E\u0440\u0456\u0457:", error);
      this.clearChatContainerInternal();
      this.showEmptyState();
    }
  }
  async saveMessageHistory() {
    if (!this.plugin.settings.saveMessageHistory)
      return;
    const messagesToSave = this.messages.map((msg) => ({
      role: msg.role,
      content: msg.content,
      timestamp: msg.timestamp.toISOString()
    }));
    const dataToSave = JSON.stringify(messagesToSave);
    try {
      await this.plugin.saveMessageHistory(dataToSave);
    } catch (error) {
      console.error("OllamaView: \u041F\u043E\u043C\u0438\u043B\u043A\u0430 \u0437\u0431\u0435\u0440\u0435\u0436\u0435\u043D\u043D\u044F \u0456\u0441\u0442\u043E\u0440\u0456\u0457:", error);
      new import_obsidian.Notice("\u041D\u0435 \u0432\u0434\u0430\u043B\u043E\u0441\u044F \u0437\u0431\u0435\u0440\u0435\u0433\u0442\u0438 \u0456\u0441\u0442\u043E\u0440\u0456\u044E \u0447\u0430\u0442\u0443.");
    }
  }
  async sendMessage() {
    const content = this.inputEl.value.trim();
    if (!content || this.isProcessing || this.sendButton.disabled)
      return;
    const messageContent = this.inputEl.value;
    this.clearInputField();
    this.setLoadingState(true);
    this.hideEmptyState();
    this.internalAddMessage("user", messageContent);
    try {
      await this.plugin.messageService.sendMessage(content);
    } catch (error) {
      console.error("OllamaView: \u041F\u043E\u043C\u0438\u043B\u043A\u0430 \u043D\u0430\u0434\u0441\u0438\u043B\u0430\u043D\u043D\u044F \u043F\u043E\u0432\u0456\u0434\u043E\u043C\u043B\u0435\u043D\u043D\u044F \u0447\u0435\u0440\u0435\u0437 MessageService:", error);
      this.internalAddMessage("error", `\u041D\u0435 \u0432\u0434\u0430\u043B\u043E\u0441\u044F \u043D\u0430\u0434\u0456\u0441\u043B\u0430\u0442\u0438 \u043F\u043E\u0432\u0456\u0434\u043E\u043C\u043B\u0435\u043D\u043D\u044F: ${error.message || "\u041D\u0435\u0432\u0456\u0434\u043E\u043C\u0430 \u043F\u043E\u043C\u0438\u043B\u043A\u0430"}`);
      this.setLoadingState(false);
    }
  }
  internalAddMessage(role, content, options = {}) {
    const { saveHistory = true, timestamp } = options;
    let messageTimestamp;
    if (timestamp) {
      try {
        messageTimestamp = typeof timestamp === "string" ? new Date(timestamp) : timestamp;
        if (isNaN(messageTimestamp.getTime()))
          throw new Error("Invalid Date");
      } catch (e) {
        console.warn("\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043C\u0456\u0442\u043A\u0430 \u0447\u0430\u0441\u0443, \u0432\u0438\u043A\u043E\u0440\u0438\u0441\u0442\u043E\u0432\u0443\u0454\u0442\u044C\u0441\u044F \u043F\u043E\u0442\u043E\u0447\u043D\u0438\u0439 \u0447\u0430\u0441:", timestamp, e);
        messageTimestamp = new Date();
      }
    } else {
      messageTimestamp = new Date();
    }
    const message = { role, content, timestamp: messageTimestamp };
    this.messages.push(message);
    if (role === "assistant" && this.messages.length >= 2) {
      const prevMessage = this.messages[this.messages.length - 2];
      if ((prevMessage == null ? void 0 : prevMessage.role) === "user")
        this.messagesPairCount++;
    }
    const messageEl = this.renderMessage(message);
    this.hideEmptyState();
    if (messageEl) {
      this.checkMessageForCollapsing(messageEl);
    }
    if (saveHistory && this.plugin.settings.saveMessageHistory) {
      this.debouncedSaveMessageHistory();
    }
    if (role !== "user" && this.userScrolledUp && this.newMessagesIndicatorEl) {
      this.newMessagesIndicatorEl.classList.add(CSS_CLASS_VISIBLE);
    } else if (!this.userScrolledUp) {
      const forceScroll = role !== "user";
      this.guaranteedScrollToBottom(forceScroll ? 100 : 50, forceScroll);
    }
  }
  // --- Оновлений рендеринг повідомлення ---
  renderMessage(message) {
    const messageIndex = this.messages.indexOf(message);
    if (messageIndex === -1)
      return null;
    const prevMessage = messageIndex > 0 ? this.messages[messageIndex - 1] : null;
    const isNewDay = !this.lastMessageDate || !this.isSameDay(this.lastMessageDate, message.timestamp);
    if (isNewDay) {
      this.renderDateSeparator(message.timestamp);
      this.lastMessageDate = message.timestamp;
    } else if (messageIndex === 0) {
      this.lastMessageDate = message.timestamp;
    }
    let messageGroup = null;
    let groupClass = CSS_CLASS_MESSAGE_GROUP;
    let messageClass = `${CSS_CLASS_MESSAGE} ${CSS_CLASS_MESSAGE_ARRIVING}`;
    let showAvatar = false;
    let isUser = false;
    const isFirstInGroup = !prevMessage || prevMessage.role !== message.role || isNewDay;
    switch (message.role) {
      case "user":
        groupClass += ` ${CSS_CLASS_USER_GROUP}`;
        messageClass += ` ${CSS_CLASS_USER_MESSAGE}`;
        showAvatar = true;
        isUser = true;
        break;
      case "assistant":
        groupClass += ` ${CSS_CLASS_OLLAMA_GROUP}`;
        messageClass += ` ${CSS_CLASS_OLLAMA_MESSAGE}`;
        showAvatar = true;
        break;
      case "system":
        groupClass += ` ${CSS_CLASS_SYSTEM_GROUP}`;
        messageClass += ` ${CSS_CLASS_SYSTEM_MESSAGE}`;
        break;
      case "error":
        groupClass += ` ${CSS_CLASS_ERROR_GROUP}`;
        messageClass += ` ${CSS_CLASS_ERROR_MESSAGE}`;
        break;
    }
    const lastElement = this.chatContainer.lastElementChild;
    if (isFirstInGroup || !lastElement || !lastElement.matches(`.${groupClass.split(" ")[1]}`)) {
      messageGroup = this.chatContainer.createDiv({ cls: groupClass });
      if (showAvatar) {
        this.renderAvatar(messageGroup, isUser);
      }
    } else {
      messageGroup = lastElement;
    }
    const messageEl = messageGroup.createDiv({ cls: messageClass });
    const contentContainer = messageEl.createDiv({ cls: CSS_CLASS_CONTENT_CONTAINER });
    const contentEl = contentContainer.createDiv({ cls: CSS_CLASS_CONTENT });
    switch (message.role) {
      case "assistant":
      case "user":
        contentEl.addClass(CSS_CLASS_CONTENT_COLLAPSIBLE);
        if (message.role === "assistant") {
          this.renderAssistantContent(contentEl, message.content);
        } else {
          message.content.split("\n").forEach((line, index, array) => {
            contentEl.appendText(line);
            if (index < array.length - 1)
              contentEl.createEl("br");
          });
        }
        break;
      case "system":
        const sysIcon = contentEl.createSpan({ cls: CSS_CLASS_SYSTEM_ICON });
        (0, import_obsidian.setIcon)(sysIcon, "info");
        contentEl.createSpan({ cls: CSS_CLASS_SYSTEM_TEXT, text: message.content });
        break;
      case "error":
        const errIcon = contentEl.createSpan({ cls: CSS_CLASS_ERROR_ICON });
        (0, import_obsidian.setIcon)(errIcon, "alert-triangle");
        contentEl.createSpan({ cls: CSS_CLASS_ERROR_TEXT, text: message.content });
        break;
    }
    if (message.role !== "system") {
      const copyButton = contentContainer.createEl("button", { cls: CSS_CLASS_COPY_BUTTON, attr: { title: "\u041A\u043E\u043F\u0456\u044E\u0432\u0430\u0442\u0438" } });
      (0, import_obsidian.setIcon)(copyButton, "copy");
      copyButton.addEventListener("click", () => this.handleCopyClick(message.content, copyButton));
    }
    messageEl.createDiv({
      cls: CSS_CLASS_TIMESTAMP,
      text: this.formatTime(message.timestamp)
    });
    setTimeout(() => messageEl.classList.remove(CSS_CLASS_MESSAGE_ARRIVING), 500);
    return messageEl;
  }
  // --- Оновлений рендеринг аватара ---
  renderAvatar(groupEl, isUser) {
    const settings = this.plugin.settings;
    const avatarType = isUser ? settings.userAvatarType : settings.aiAvatarType;
    const avatarContent = isUser ? settings.userAvatarContent : settings.aiAvatarContent;
    const avatarClass = isUser ? CSS_CLASS_AVATAR_USER : CSS_CLASS_AVATAR_AI;
    const avatarEl = groupEl.createDiv({ cls: `${CSS_CLASS_AVATAR} ${avatarClass}` });
    if (avatarType === "initials") {
      avatarEl.textContent = avatarContent || (isUser ? "U" : "A");
    } else if (avatarType === "icon") {
      try {
        (0, import_obsidian.setIcon)(avatarEl, avatarContent || (isUser ? "user" : "bot"));
      } catch (e) {
        console.warn(`\u041D\u0435 \u0432\u0434\u0430\u043B\u043E\u0441\u044F \u0432\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u0438 \u0456\u043A\u043E\u043D\u043A\u0443 "${avatarContent}", \u0432\u0438\u043A\u043E\u0440\u0438\u0441\u0442\u043E\u0432\u0443\u0454\u0442\u044C\u0441\u044F \u0441\u0442\u0430\u043D\u0434\u0430\u0440\u0442\u043D\u0430.`);
        avatarEl.textContent = isUser ? "U" : "A";
      }
    } else {
      avatarEl.textContent = isUser ? "U" : "A";
    }
  }
  // --- Методи рендерингу Markdown, кнопок коду, thinking tags (з додаванням назви мови) ---
  renderDateSeparator(date) {
    if (!this.chatContainer)
      return;
    this.chatContainer.createDiv({ cls: CSS_CLASS_DATE_SEPARATOR, text: this.formatDateSeparator(date) });
  }
  // renderAvatar оновлено вище
  renderAssistantContent(containerEl, content) {
    var _a, _b;
    const decodedContent = this.decodeHtmlEntities(content);
    const hasThinking = this.detectThinkingTags(decodedContent);
    containerEl.empty();
    if (hasThinking.hasThinkingTags) {
      const processedHtml = this.processThinkingTags(decodedContent);
      containerEl.innerHTML = processedHtml;
      this.addThinkingToggleListeners(containerEl);
      this.addCodeBlockEnhancements(containerEl);
    } else {
      import_obsidian.MarkdownRenderer.renderMarkdown(content, containerEl, (_b = (_a = this.plugin.app.vault.getRoot()) == null ? void 0 : _a.path) != null ? _b : "", this);
      this.addCodeBlockEnhancements(containerEl);
    }
  }
  // Оновлено: додає і назву мови, і кнопку копіювання
  addCodeBlockEnhancements(contentEl) {
    const preElements = contentEl.querySelectorAll("pre");
    preElements.forEach((pre) => {
      if (pre.querySelector(`.${CSS_CLASS_CODE_BLOCK_COPY_BUTTON}`))
        return;
      const codeEl = pre.querySelector("code");
      if (!codeEl)
        return;
      const codeContent = codeEl.textContent || "";
      const languageClass = Array.from(codeEl.classList).find((cls) => cls.startsWith("language-"));
      if (languageClass) {
        const language = languageClass.replace("language-", "");
        if (language) {
          pre.createEl("span", { cls: CSS_CLASS_CODE_BLOCK_LANGUAGE, text: language });
        }
      }
      const copyBtn = pre.createEl("button", { cls: CSS_CLASS_CODE_BLOCK_COPY_BUTTON });
      (0, import_obsidian.setIcon)(copyBtn, "copy");
      copyBtn.setAttribute("title", "\u041A\u043E\u043F\u0456\u044E\u0432\u0430\u0442\u0438 \u041A\u043E\u0434");
      copyBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        navigator.clipboard.writeText(codeContent).then(() => {
          (0, import_obsidian.setIcon)(copyBtn, "check");
          copyBtn.setAttribute("title", "\u0421\u043A\u043E\u043F\u0456\u0439\u043E\u0432\u0430\u043D\u043E!");
          setTimeout(() => {
            (0, import_obsidian.setIcon)(copyBtn, "copy");
            copyBtn.setAttribute("title", "\u041A\u043E\u043F\u0456\u044E\u0432\u0430\u0442\u0438 \u041A\u043E\u0434");
          }, 1500);
        }).catch((err) => {
          console.error("\u041D\u0435 \u0432\u0434\u0430\u043B\u043E\u0441\u044F \u0441\u043A\u043E\u043F\u0456\u044E\u0432\u0430\u0442\u0438 \u0431\u043B\u043E\u043A \u043A\u043E\u0434\u0443:", err);
          new import_obsidian.Notice("\u041D\u0435 \u0432\u0434\u0430\u043B\u043E\u0441\u044F \u0441\u043A\u043E\u043F\u0456\u044E\u0432\u0430\u0442\u0438 \u043A\u043E\u0434.");
        });
      });
    });
  }
  // --- Методи для обробки довгих повідомлень ---
  checkMessageForCollapsing(messageEl) {
    const contentEl = messageEl.querySelector(`.${CSS_CLASS_CONTENT_COLLAPSIBLE}`);
    const maxHeight = this.plugin.settings.maxMessageHeight;
    if (!contentEl || maxHeight <= 0)
      return;
    requestAnimationFrame(() => {
      const existingButton = messageEl.querySelector(`.${CSS_CLASS_SHOW_MORE_BUTTON}`);
      existingButton == null ? void 0 : existingButton.remove();
      contentEl.style.maxHeight = "";
      contentEl.classList.remove(CSS_CLASS_CONTENT_COLLAPSED);
      const actualHeight = contentEl.scrollHeight;
      if (actualHeight > maxHeight) {
        contentEl.style.maxHeight = `${maxHeight}px`;
        contentEl.classList.add(CSS_CLASS_CONTENT_COLLAPSED);
        const showMoreButton = messageEl.createEl("button", {
          cls: CSS_CLASS_SHOW_MORE_BUTTON,
          text: "\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u0438 \u0431\u0456\u043B\u044C\u0448\u0435 \u25BC"
          // Текст кнопки
        });
        this.registerDomEvent(showMoreButton, "click", () => {
          this.toggleMessageCollapse(contentEl, showMoreButton);
        });
      }
    });
  }
  checkAllMessagesForCollapsing() {
    this.chatContainer.querySelectorAll(`.${CSS_CLASS_MESSAGE}`).forEach((msgEl) => {
      this.checkMessageForCollapsing(msgEl);
    });
  }
  toggleMessageCollapse(contentEl, buttonEl) {
    const isCollapsed = contentEl.classList.contains(CSS_CLASS_CONTENT_COLLAPSED);
    if (isCollapsed) {
      contentEl.style.maxHeight = "";
      contentEl.classList.remove(CSS_CLASS_CONTENT_COLLAPSED);
      buttonEl.setText("\u0417\u0433\u043E\u0440\u043D\u0443\u0442\u0438 \u25B2");
    } else {
      const maxHeight = this.plugin.settings.maxMessageHeight;
      contentEl.style.maxHeight = `${maxHeight}px`;
      contentEl.classList.add(CSS_CLASS_CONTENT_COLLAPSED);
      buttonEl.setText("\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u0438 \u0431\u0456\u043B\u044C\u0448\u0435 \u25BC");
    }
  }
  // --- Інші методи (handleCopyClick, processThinkingTags, etc. - без змін) ---
  handleCopyClick(content, buttonEl) {
    let textToCopy = content;
    if (this.detectThinkingTags(this.decodeHtmlEntities(content)).hasThinkingTags) {
      textToCopy = this.decodeHtmlEntities(content).replace(/<think>[\s\S]*?<\/think>/g, "").trim();
    }
    navigator.clipboard.writeText(textToCopy).then(() => {
      (0, import_obsidian.setIcon)(buttonEl, "check");
      buttonEl.setAttribute("title", "\u0421\u043A\u043E\u043F\u0456\u0439\u043E\u0432\u0430\u043D\u043E!");
      setTimeout(() => {
        (0, import_obsidian.setIcon)(buttonEl, "copy");
        buttonEl.setAttribute("title", "\u041A\u043E\u043F\u0456\u044E\u0432\u0430\u0442\u0438");
      }, 2e3);
    }).catch((err) => {
      console.error("\u041D\u0435 \u0432\u0434\u0430\u043B\u043E\u0441\u044F \u0441\u043A\u043E\u043F\u0456\u044E\u0432\u0430\u0442\u0438 \u0442\u0435\u043A\u0441\u0442: ", err);
      new import_obsidian.Notice("\u041D\u0435 \u0432\u0434\u0430\u043B\u043E\u0441\u044F \u0441\u043A\u043E\u043F\u0456\u044E\u0432\u0430\u0442\u0438 \u0442\u0435\u043A\u0441\u0442.");
    });
  }
  processThinkingTags(content) {
    const thinkingRegex = /<think>([\s\S]*?)<\/think>/g;
    let lastIndex = 0;
    const parts = [];
    let match;
    while ((match = thinkingRegex.exec(content)) !== null) {
      if (match.index > lastIndex) {
        parts.push(this.markdownToHtml(content.substring(lastIndex, match.index)));
      }
      const thinkingContent = match[1];
      const foldableHtml = `<div class="${CSS_CLASS_THINKING_BLOCK}"><div class="${CSS_CLASS_THINKING_HEADER}" data-fold-state="folded"><div class="${CSS_CLASS_THINKING_TOGGLE}">\u25BA</div><div class="${CSS_CLASS_THINKING_TITLE}">\u0420\u043E\u0437\u0434\u0443\u043C\u0438</div></div><div class="${CSS_CLASS_THINKING_CONTENT}" style="display: none;">${this.markdownToHtml(thinkingContent)}</div></div>`;
      parts.push(foldableHtml);
      lastIndex = thinkingRegex.lastIndex;
    }
    if (lastIndex < content.length) {
      parts.push(this.markdownToHtml(content.substring(lastIndex)));
    }
    return parts.join("");
  }
  markdownToHtml(markdown) {
    var _a, _b;
    if (!markdown || markdown.trim() === "")
      return "";
    const tempDiv = document.createElement("div");
    const contextFilePath = (_b = (_a = this.app.workspace.getActiveFile()) == null ? void 0 : _a.path) != null ? _b : "";
    import_obsidian.MarkdownRenderer.renderMarkdown(markdown, tempDiv, contextFilePath, this);
    return tempDiv.innerHTML;
  }
  addThinkingToggleListeners(contentEl) {
    const thinkingHeaders = contentEl.querySelectorAll(`.${CSS_CLASS_THINKING_HEADER}`);
    thinkingHeaders.forEach((header) => {
      header.addEventListener("click", () => {
        const content = header.nextElementSibling;
        const toggleIcon = header.querySelector(`.${CSS_CLASS_THINKING_TOGGLE}`);
        if (!content || !toggleIcon)
          return;
        const isFolded = header.getAttribute("data-fold-state") === "folded";
        if (isFolded) {
          content.style.display = "block";
          toggleIcon.textContent = "\u25BC";
          header.setAttribute("data-fold-state", "expanded");
        } else {
          content.style.display = "none";
          toggleIcon.textContent = "\u25BA";
          header.setAttribute("data-fold-state", "folded");
        }
      });
    });
  }
  decodeHtmlEntities(text) {
    if (typeof document === "undefined")
      return text;
    const textArea = document.createElement("textarea");
    textArea.innerHTML = text;
    return textArea.value;
  }
  detectThinkingTags(content) {
    if (/<think>[\s\S]*?<\/think>/gi.test(content)) {
      return { hasThinkingTags: true, format: "standard" };
    }
    return { hasThinkingTags: false, format: "none" };
  }
  // --- Speech Recognition Placeholder Methods ---
  initSpeechWorker() {
  }
  setupSpeechWorkerHandlers() {
  }
  insertTranscript(transcript) {
  }
  async toggleVoiceRecognition() {
  }
  async startVoiceRecognition() {
  }
  stopVoiceRecording(processAudio) {
  }
  // --- Helpers & Utilities ---
  getChatContainer() {
    return this.chatContainer;
  }
  clearChatContainerInternal() {
    this.messages = [];
    this.messagesPairCount = 0;
    this.lastMessageDate = null;
    if (this.chatContainer) {
      this.chatContainer.empty();
    }
    this.hideEmptyState();
  }
  // --- Доданий метод для очищення ззовні (з main.ts) ---
  clearDisplayAndState() {
    var _a;
    this.clearChatContainerInternal();
    this.showEmptyState();
    this.updateSendButtonState();
    (_a = this.inputEl) == null ? void 0 : _a.focus();
    console.log("OllamaView: \u0414\u0438\u0441\u043F\u043B\u0435\u0439 \u0442\u0430 \u0432\u043D\u0443\u0442\u0440\u0456\u0448\u043D\u0456\u0439 \u0441\u0442\u0430\u043D \u043E\u0447\u0438\u0449\u0435\u043D\u043E.");
  }
  // --- Інші хелпери (addLoadingIndicator, etc. - без змін) ---
  addLoadingIndicator() {
    this.hideEmptyState();
    const messageGroup = this.chatContainer.createDiv({ cls: `${CSS_CLASS_MESSAGE_GROUP} ${CSS_CLASS_OLLAMA_GROUP}` });
    this.renderAvatar(messageGroup, false);
    const messageEl = messageGroup.createDiv({ cls: `${CSS_CLASS_MESSAGE} ${CSS_CLASS_OLLAMA_MESSAGE}` });
    const dotsContainer = messageEl.createDiv({ cls: CSS_CLASS_THINKING_DOTS });
    for (let i = 0; i < 3; i++) {
      dotsContainer.createDiv({ cls: CSS_CLASS_THINKING_DOT });
    }
    this.guaranteedScrollToBottom(50, true);
    return messageGroup;
  }
  removeLoadingIndicator(loadingEl) {
    if (loadingEl == null ? void 0 : loadingEl.parentNode) {
      loadingEl.remove();
    }
  }
  // Додано перевірку loadingEl
  scrollToBottom() {
    this.guaranteedScrollToBottom(50, true);
  }
  clearInputField() {
    if (this.inputEl) {
      this.inputEl.value = "";
      this.inputEl.dispatchEvent(new Event("input"));
    }
  }
  guaranteedScrollToBottom(delay = 50, forceScroll = false) {
    if (this.scrollTimeout) {
      clearTimeout(this.scrollTimeout);
    }
    this.scrollTimeout = setTimeout(() => {
      requestAnimationFrame(() => {
        var _a, _b;
        if (this.chatContainer) {
          const scrollThreshold = 100;
          const isScrolledUpCheck = this.chatContainer.scrollHeight - this.chatContainer.scrollTop - this.chatContainer.clientHeight > scrollThreshold;
          if (isScrolledUpCheck !== this.userScrolledUp) {
            this.userScrolledUp = isScrolledUpCheck;
            if (!this.userScrolledUp) {
              (_a = this.newMessagesIndicatorEl) == null ? void 0 : _a.classList.remove(CSS_CLASS_VISIBLE);
            }
          }
          if (forceScroll || !this.userScrolledUp || this.isProcessing) {
            this.chatContainer.scrollTop = this.chatContainer.scrollHeight;
            if (forceScroll || this.isProcessing) {
              this.userScrolledUp = false;
              (_b = this.newMessagesIndicatorEl) == null ? void 0 : _b.classList.remove(CSS_CLASS_VISIBLE);
            }
          }
        }
      });
    }, delay);
  }
  formatTime(date) {
    return date.toLocaleTimeString("uk-UA", { hour: "2-digit", minute: "2-digit" });
  }
  // Український формат
  formatDateSeparator(date) {
    const now = new Date();
    const yesterday = new Date(now);
    yesterday.setDate(now.getDate() - 1);
    if (this.isSameDay(date, now)) {
      return "\u0421\u044C\u043E\u0433\u043E\u0434\u043D\u0456";
    } else if (this.isSameDay(date, yesterday)) {
      return "\u0412\u0447\u043E\u0440\u0430";
    } else {
      return date.toLocaleDateString("uk-UA", { weekday: "long", year: "numeric", month: "long", day: "numeric" });
    }
  }
  // Український формат
  isSameDay(date1, date2) {
    return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate();
  }
  setLoadingState(isLoading) {
    this.isProcessing = isLoading;
    if (this.inputEl)
      this.inputEl.disabled = isLoading;
    this.updateSendButtonState();
    if (this.voiceButton) {
      this.voiceButton.disabled = isLoading;
      this.voiceButton.classList.toggle(CSS_CLASS_DISABLED, isLoading);
    }
    if (this.menuButton) {
      this.menuButton.disabled = isLoading;
      this.menuButton.classList.toggle(CSS_CLASS_DISABLED, isLoading);
    }
  }
};
var OllamaView = _OllamaView;
OllamaView.instance = null;

// settings.ts
var import_obsidian2 = require("obsidian");
var DEFAULT_SETTINGS = {
  modelName: "mistral",
  ollamaServerUrl: "http://localhost:11434",
  logFileSizeLimit: 1024,
  saveMessageHistory: true,
  ragEnabled: false,
  ragFolderPath: "data",
  contextWindowSize: 5,
  // RAG docs
  googleApiKey: "",
  speechLanguage: "uk-UA",
  maxRecordingTime: 15,
  silenceDetection: true,
  followRole: true,
  useDefaultRoleDefinition: true,
  customRoleFilePath: "",
  systemPromptInterval: 0,
  temperature: 0.1,
  contextWindow: 8192,
  // Model context window
  // --- Нові значення за замовчуванням ---
  userAvatarType: "initials",
  userAvatarContent: "U",
  aiAvatarType: "icon",
  aiAvatarContent: "bot",
  // Іконка Obsidian
  maxMessageHeight: 300
  // Згортати повідомлення довші за 300px
};
var OllamaSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  getDisplayText() {
    return "Ollama";
  }
  getId() {
    return "ollama-plugin";
  }
  // Допоміжна функція для пошуку іконок
  createIconSearch(containerEl, settingType) {
    const searchContainer = containerEl.createDiv({ cls: "ollama-icon-search-container" });
    let searchInput;
    let resultsEl;
    const performSearch = () => {
      var _a, _b;
      const query = searchInput.getValue().toLowerCase().trim();
      resultsEl.empty();
      if (!query)
        return;
      const allIcons = ((_b = (_a = window.require("obsidian")) == null ? void 0 : _a.getIconIds) == null ? void 0 : _b.call(_a)) || [];
      const filteredIcons = allIcons.filter((icon) => icon.includes(query)).slice(0, 50);
      if (filteredIcons.length > 0) {
        filteredIcons.forEach((icon) => {
          const iconEl = resultsEl.createEl("button", { cls: "ollama-icon-search-result" });
          window.require("obsidian").setIcon(iconEl, icon);
          iconEl.setAttribute("aria-label", icon);
          iconEl.onClickEvent(() => {
            if (settingType === "user") {
              this.plugin.settings.userAvatarContent = icon;
            } else {
              this.plugin.settings.aiAvatarContent = icon;
            }
            this.plugin.saveSettings();
            this.display();
          });
        });
      } else {
        resultsEl.setText("No icons found.");
      }
    };
    searchInput = new import_obsidian2.TextComponent(searchContainer).setPlaceholder("Search Obsidian icons...").onChange(performSearch);
    resultsEl = searchContainer.createDiv({ cls: "ollama-icon-search-results" });
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.addClass("ollama-settings");
    containerEl.createEl("h2", { text: "\u041E\u0441\u043D\u043E\u0432\u043D\u0456 \u041D\u0430\u043B\u0430\u0448\u0442\u0443\u0432\u0430\u043D\u043D\u044F" });
    new import_obsidian2.Setting(containerEl).setName("Ollama Server URL").setDesc(
      "IP \u0430\u0434\u0440\u0435\u0441\u0430 \u0442\u0430 \u043F\u043E\u0440\u0442, \u0434\u0435 \u0437\u0430\u043F\u0443\u0449\u0435\u043D\u043E Ollama (\u043D\u0430\u043F\u0440. http://192.168.1.10:11434)"
    ).addText(
      (text) => text.setPlaceholder("http://localhost:11434").setValue(this.plugin.settings.ollamaServerUrl).onChange(async (value) => {
        this.plugin.settings.ollamaServerUrl = value.trim();
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("\u0417'\u0454\u0434\u043D\u0430\u043D\u043D\u044F \u0437 \u0441\u0435\u0440\u0432\u0435\u0440\u043E\u043C").setDesc("\u041F\u0435\u0440\u0435\u043F\u0456\u0434\u043A\u043B\u044E\u0447\u0438\u0442\u0438\u0441\u044F \u0434\u043E \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u043B\u043E\u043A\u0430\u043B\u044C\u043D\u043E\u0457 \u043C\u043E\u0434\u0435\u043B\u0456 \u0442\u0430 \u043E\u043D\u043E\u0432\u0438\u0442\u0438 \u0441\u043F\u0438\u0441\u043E\u043A \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u0438\u0445 \u043C\u043E\u0434\u0435\u043B\u0435\u0439").addButton(
      (button) => button.setButtonText("\u041F\u0435\u0440\u0435\u043F\u0456\u0434\u043A\u043B\u044E\u0447\u0438\u0442\u0438\u0441\u044C").setIcon("refresh-cw").onClick(async () => {
        try {
          new import_obsidian2.Notice("\u041F\u0456\u0434\u043A\u043B\u044E\u0447\u0435\u043D\u043D\u044F \u0434\u043E \u0441\u0435\u0440\u0432\u0435\u0440\u0430 Ollama...");
          await this.plugin.apiService.getModels();
          new import_obsidian2.Notice("\u0423\u0441\u043F\u0456\u0448\u043D\u043E \u043F\u0456\u0434\u043A\u043B\u044E\u0447\u0435\u043D\u043E \u0434\u043E \u0441\u0435\u0440\u0432\u0435\u0440\u0430 Ollama!");
          this.display();
        } catch (error) {
          new import_obsidian2.Notice(`\u041F\u043E\u043C\u0438\u043B\u043A\u0430 \u043F\u0456\u0434\u043A\u043B\u044E\u0447\u0435\u043D\u043D\u044F: ${error.message}. \u041F\u0435\u0440\u0435\u0432\u0456\u0440\u0442\u0435 URL \u0442\u0430 \u0441\u0442\u0430\u043D \u0441\u0435\u0440\u0432\u0435\u0440\u0430.`);
          if (this.plugin.view) {
            this.plugin.view.internalAddMessage(
              "error",
              `\u041F\u043E\u043C\u0438\u043B\u043A\u0430 \u043F\u0456\u0434\u043A\u043B\u044E\u0447\u0435\u043D\u043D\u044F \u0434\u043E Ollama: ${error.message}. \u041F\u0435\u0440\u0435\u0432\u0456\u0440\u0442\u0435 \u043D\u0430\u043B\u0430\u0448\u0442\u0443\u0432\u0430\u043D\u043D\u044F.`
            );
          }
        }
      })
    );
    let availableModels = [];
    try {
      availableModels = await this.plugin.apiService.getModels();
    } catch (error) {
      console.error("\u041F\u043E\u043C\u0438\u043B\u043A\u0430 \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043D\u044F \u043C\u043E\u0434\u0435\u043B\u0435\u0439:", error);
      if (this.plugin.view) {
        this.plugin.view.internalAddMessage(
          "error",
          `\u041D\u0435 \u0432\u0434\u0430\u043B\u043E\u0441\u044F \u043E\u0442\u0440\u0438\u043C\u0430\u0442\u0438 \u0441\u043F\u0438\u0441\u043E\u043A \u043C\u043E\u0434\u0435\u043B\u0435\u0439: ${error.message}.`
        );
      }
    }
    const modelSetting = new import_obsidian2.Setting(containerEl).setName("\u041D\u0430\u0437\u0432\u0430 \u041C\u043E\u0434\u0435\u043B\u0456").setDesc("\u041E\u0431\u0435\u0440\u0456\u0442\u044C \u043C\u043E\u0432\u043D\u0443 \u043C\u043E\u0434\u0435\u043B\u044C \u0434\u043B\u044F \u0432\u0438\u043A\u043E\u0440\u0438\u0441\u0442\u0430\u043D\u043D\u044F");
    modelSetting.addDropdown((dropdown) => {
      const selectEl = dropdown.selectEl;
      selectEl.empty();
      if (availableModels.length > 0) {
        availableModels.forEach((model) => {
          dropdown.addOption(model, model);
        });
        const currentModel = this.plugin.settings.modelName;
        if (availableModels.includes(currentModel)) {
          dropdown.setValue(currentModel);
        } else if (availableModels.length > 0) {
          dropdown.setValue(availableModels[0]);
          this.plugin.settings.modelName = availableModels[0];
          this.plugin.saveSettings();
        }
      } else {
        dropdown.addOption("", "\u041C\u043E\u0434\u0435\u043B\u0456 \u043D\u0435 \u0437\u043D\u0430\u0439\u0434\u0435\u043D\u043E");
        dropdown.setDisabled(true);
      }
      dropdown.onChange(async (value) => {
        this.plugin.settings.modelName = value;
        this.plugin.emit("model-changed", value);
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(containerEl).setName("\u0422\u0435\u043C\u043F\u0435\u0440\u0430\u0442\u0443\u0440\u0430").setDesc("\u041A\u043E\u043D\u0442\u0440\u043E\u043B\u044E\u0454 \u0432\u0438\u043F\u0430\u0434\u043A\u043E\u0432\u0456\u0441\u0442\u044C \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0435\u0439 \u043C\u043E\u0434\u0435\u043B\u0456 (0.0 - 1.0)").addSlider(
      (slider) => slider.setLimits(0, 1, 0.1).setValue(this.plugin.settings.temperature).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.temperature = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("\u041A\u043E\u043D\u0442\u0435\u043A\u0441\u0442\u043D\u0435 \u0432\u0456\u043A\u043D\u043E \u043C\u043E\u0434\u0435\u043B\u0456").setDesc("\u0420\u043E\u0437\u043C\u0456\u0440 \u043A\u043E\u043D\u0442\u0435\u043A\u0441\u0442\u043D\u043E\u0433\u043E \u0432\u0456\u043A\u043D\u0430 \u043C\u043E\u0434\u0435\u043B\u0456 (\u0440\u0435\u043A\u043E\u043C\u0435\u043D\u0434\u043E\u0432\u0430\u043D\u043E > 8192). \u0412\u043F\u043B\u0438\u0432\u0430\u0454 \u043D\u0430 \u043E\u0431\u0441\u044F\u0433 \u0456\u0441\u0442\u043E\u0440\u0456\u0457 \u0442\u0430 RAG, \u044F\u043A\u0438\u0439 \u043C\u043E\u0436\u043D\u0430 \u043F\u0435\u0440\u0435\u0434\u0430\u0442\u0438.").addText(
      (text) => (
        // Змінено на Text для гнучкості
        text.setPlaceholder("8192").setValue(String(this.plugin.settings.contextWindow)).onChange(async (value) => {
          const num = parseInt(value, 10);
          if (!isNaN(num) && num > 0) {
            this.plugin.settings.contextWindow = num;
            await this.plugin.saveSettings();
          } else {
            new import_obsidian2.Notice("\u0411\u0443\u0434\u044C \u043B\u0430\u0441\u043A\u0430, \u0432\u0432\u0435\u0434\u0456\u0442\u044C \u043F\u043E\u0437\u0438\u0442\u0438\u0432\u043D\u0435 \u0447\u0438\u0441\u043B\u043E\u0432\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F.");
            text.setValue(String(this.plugin.settings.contextWindow));
          }
        })
      )
    );
    containerEl.createEl("h2", { text: "\u0406\u0441\u0442\u043E\u0440\u0456\u044F \u0427\u0430\u0442\u0443" });
    new import_obsidian2.Setting(containerEl).setName("\u0417\u0431\u0435\u0440\u0456\u0433\u0430\u0442\u0438 \u0456\u0441\u0442\u043E\u0440\u0456\u044E \u043F\u043E\u0432\u0456\u0434\u043E\u043C\u043B\u0435\u043D\u044C").setDesc("\u0417\u0431\u0435\u0440\u0456\u0433\u0430\u0442\u0438 \u0456\u0441\u0442\u043E\u0440\u0456\u044E \u0447\u0430\u0442\u0443 \u043C\u0456\u0436 \u0441\u0435\u0441\u0456\u044F\u043C\u0438").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.saveMessageHistory).onChange(async (value) => {
        this.plugin.settings.saveMessageHistory = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("\u041B\u0456\u043C\u0456\u0442 \u0440\u043E\u0437\u043C\u0456\u0440\u0443 \u0444\u0430\u0439\u043B\u0443 \u0456\u0441\u0442\u043E\u0440\u0456\u0457").setDesc(
      "\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u0438\u0439 \u0440\u043E\u0437\u043C\u0456\u0440 \u0444\u0430\u0439\u043B\u0443 \u0456\u0441\u0442\u043E\u0440\u0456\u0457 \u043F\u043E\u0432\u0456\u0434\u043E\u043C\u043B\u0435\u043D\u044C \u0432 KB (1024 KB = 1 MB)"
    ).addSlider(
      (slider) => slider.setLimits(256, 10240, 256).setValue(this.plugin.settings.logFileSizeLimit).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.logFileSizeLimit = value;
        await this.plugin.saveSettings();
      })
    ).addExtraButton(
      (button) => button.setIcon("reset").setTooltip("\u0421\u043A\u0438\u043D\u0443\u0442\u0438 \u0434\u043E \u0441\u0442\u0430\u043D\u0434\u0430\u0440\u0442\u043D\u043E\u0433\u043E (1024 KB)").onClick(async () => {
        this.plugin.settings.logFileSizeLimit = DEFAULT_SETTINGS.logFileSizeLimit;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("\u041E\u0447\u0438\u0441\u0442\u0438\u0442\u0438 \u0406\u0441\u0442\u043E\u0440\u0456\u044E").setDesc("\u0412\u0438\u0434\u0430\u043B\u0438\u0442\u0438 \u0432\u0441\u044E \u0456\u0441\u0442\u043E\u0440\u0456\u044E \u0447\u0430\u0442\u0443").addButton(
      (button) => button.setButtonText("\u041E\u0447\u0438\u0441\u0442\u0438\u0442\u0438").onClick(async () => {
        if (confirm("\u0412\u0438 \u0432\u043F\u0435\u0432\u043D\u0435\u043D\u0456, \u0449\u043E \u0445\u043E\u0447\u0435\u0442\u0435 \u0432\u0438\u0434\u0430\u043B\u0438\u0442\u0438 \u0432\u0441\u044E \u0456\u0441\u0442\u043E\u0440\u0456\u044E \u0447\u0430\u0442\u0443? \u0426\u044E \u0434\u0456\u044E \u043D\u0435\u043C\u043E\u0436\u043B\u0438\u0432\u043E \u0441\u043A\u0430\u0441\u0443\u0432\u0430\u0442\u0438.")) {
          await this.plugin.clearMessageHistory();
          new import_obsidian2.Notice("\u0406\u0441\u0442\u043E\u0440\u0456\u044E \u0447\u0430\u0442\u0443 \u043E\u0447\u0438\u0449\u0435\u043D\u043E.");
        }
      })
    );
    containerEl.createEl("h2", { text: "\u0417\u043E\u0432\u043D\u0456\u0448\u043D\u0456\u0439 \u0412\u0438\u0433\u043B\u044F\u0434" });
    containerEl.createEl("h4", { text: "\u0410\u0432\u0430\u0442\u0430\u0440 \u041A\u043E\u0440\u0438\u0441\u0442\u0443\u0432\u0430\u0447\u0430" });
    new import_obsidian2.Setting(containerEl).setName("\u0422\u0438\u043F \u0430\u0432\u0430\u0442\u0430\u0440\u0430 \u043A\u043E\u0440\u0438\u0441\u0442\u0443\u0432\u0430\u0447\u0430").addDropdown(
      (dd) => dd.addOption("initials", "\u0406\u043D\u0456\u0446\u0456\u0430\u043B\u0438").addOption("icon", "\u0406\u043A\u043E\u043D\u043A\u0430 Obsidian").setValue(this.plugin.settings.userAvatarType).onChange(async (value) => {
        this.plugin.settings.userAvatarType = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (this.plugin.settings.userAvatarType === "initials") {
      new import_obsidian2.Setting(containerEl).setName("\u0406\u043D\u0456\u0446\u0456\u0430\u043B\u0438 \u043A\u043E\u0440\u0438\u0441\u0442\u0443\u0432\u0430\u0447\u0430").setDesc("\u0412\u0432\u0435\u0434\u0456\u0442\u044C 1-2 \u043B\u0456\u0442\u0435\u0440\u0438").addText(
        (text) => text.setValue(this.plugin.settings.userAvatarContent).onChange(async (value) => {
          this.plugin.settings.userAvatarContent = value.substring(0, 2).toUpperCase();
          await this.plugin.saveSettings();
        })
      );
    } else {
      new import_obsidian2.Setting(containerEl).setName("\u0406\u043A\u043E\u043D\u043A\u0430 \u043A\u043E\u0440\u0438\u0441\u0442\u0443\u0432\u0430\u0447\u0430").setDesc("\u0412\u0432\u0435\u0434\u0456\u0442\u044C \u043D\u0430\u0437\u0432\u0443 \u0456\u043A\u043E\u043D\u043A\u0438 Obsidian").addText(
        (text) => text.setValue(this.plugin.settings.userAvatarContent).setPlaceholder("\u041D\u0430\u043F\u0440. user, smile, etc.").onChange(async (value) => {
          this.plugin.settings.userAvatarContent = value.trim();
          await this.plugin.saveSettings();
        })
      );
      this.createIconSearch(containerEl, "user");
    }
    containerEl.createEl("h4", { text: "\u0410\u0432\u0430\u0442\u0430\u0440 AI" });
    new import_obsidian2.Setting(containerEl).setName("\u0422\u0438\u043F \u0430\u0432\u0430\u0442\u0430\u0440\u0430 AI").addDropdown(
      (dd) => dd.addOption("initials", "\u0406\u043D\u0456\u0446\u0456\u0430\u043B\u0438").addOption("icon", "\u0406\u043A\u043E\u043D\u043A\u0430 Obsidian").setValue(this.plugin.settings.aiAvatarType).onChange(async (value) => {
        this.plugin.settings.aiAvatarType = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (this.plugin.settings.aiAvatarType === "initials") {
      new import_obsidian2.Setting(containerEl).setName("\u0406\u043D\u0456\u0446\u0456\u0430\u043B\u0438 AI").setDesc("\u0412\u0432\u0435\u0434\u0456\u0442\u044C 1-2 \u043B\u0456\u0442\u0435\u0440\u0438").addText(
        (text) => text.setValue(this.plugin.settings.aiAvatarContent).onChange(async (value) => {
          this.plugin.settings.aiAvatarContent = value.substring(0, 2).toUpperCase();
          await this.plugin.saveSettings();
        })
      );
    } else {
      new import_obsidian2.Setting(containerEl).setName("\u0406\u043A\u043E\u043D\u043A\u0430 AI").setDesc("\u0412\u0432\u0435\u0434\u0456\u0442\u044C \u043D\u0430\u0437\u0432\u0443 \u0456\u043A\u043E\u043D\u043A\u0438 Obsidian").addText(
        (text) => text.setValue(this.plugin.settings.aiAvatarContent).setPlaceholder("\u041D\u0430\u043F\u0440. bot, cpu, brain, etc.").onChange(async (value) => {
          this.plugin.settings.aiAvatarContent = value.trim();
          await this.plugin.saveSettings();
        })
      );
      this.createIconSearch(containerEl, "ai");
    }
    new import_obsidian2.Setting(containerEl).setName("\u041C\u0430\u043A\u0441. \u0432\u0438\u0441\u043E\u0442\u0430 \u043F\u043E\u0432\u0456\u0434\u043E\u043C\u043B\u0435\u043D\u043D\u044F \u043F\u0435\u0440\u0435\u0434 \u0437\u0433\u043E\u0440\u0442\u0430\u043D\u043D\u044F\u043C").setDesc("\u0412\u0432\u0435\u0434\u0456\u0442\u044C \u0432\u0438\u0441\u043E\u0442\u0443 \u0432 \u043F\u0456\u043A\u0441\u0435\u043B\u044F\u0445. \u0414\u043E\u0432\u0448\u0456 \u043F\u043E\u0432\u0456\u0434\u043E\u043C\u043B\u0435\u043D\u043D\u044F \u043C\u0430\u0442\u0438\u043C\u0443\u0442\u044C \u043A\u043D\u043E\u043F\u043A\u0443 '\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u0438 \u0431\u0456\u043B\u044C\u0448\u0435'. \u0412\u0432\u0435\u0434\u0456\u0442\u044C 0, \u0449\u043E\u0431 \u0432\u0438\u043C\u043A\u043D\u0443\u0442\u0438 \u0437\u0433\u043E\u0440\u0442\u0430\u043D\u043D\u044F.").addText(
      (text) => text.setPlaceholder("300").setValue(String(this.plugin.settings.maxMessageHeight)).onChange(async (value) => {
        const num = parseInt(value, 10);
        if (!isNaN(num) && num >= 0) {
          this.plugin.settings.maxMessageHeight = num;
          await this.plugin.saveSettings();
        } else {
          new import_obsidian2.Notice("\u0411\u0443\u0434\u044C \u043B\u0430\u0441\u043A\u0430, \u0432\u0432\u0435\u0434\u0456\u0442\u044C \u043D\u0435\u0432\u0456\u0434'\u0454\u043C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E\u0432\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F.");
          text.setValue(String(this.plugin.settings.maxMessageHeight));
        }
      })
    );
    containerEl.createEl("h2", { text: "\u041A\u043E\u043D\u0444\u0456\u0433\u0443\u0440\u0430\u0446\u0456\u044F \u0420\u043E\u043B\u0456 AI" });
    new import_obsidian2.Setting(containerEl).setName("\u0412\u0432\u0456\u043C\u043A\u043D\u0443\u0442\u0438 \u0432\u0438\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0440\u043E\u043B\u0456").setDesc("\u0417\u043C\u0443\u0441\u0438\u0442\u0438 Ollama \u0441\u043B\u0456\u0434\u0443\u0432\u0430\u0442\u0438 \u0432\u0438\u0437\u043D\u0430\u0447\u0435\u043D\u0456\u0439 \u0440\u043E\u043B\u0456 \u0437 \u0444\u0430\u0439\u043B\u0443").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.followRole).onChange(async (value) => {
        this.plugin.settings.followRole = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("\u0412\u0438\u043A\u043E\u0440\u0438\u0441\u0442\u043E\u0432\u0443\u0432\u0430\u0442\u0438 \u0441\u0442\u0430\u043D\u0434\u0430\u0440\u0442\u043D\u0435 \u0432\u0438\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0440\u043E\u043B\u0456").setDesc("\u0412\u0438\u043A\u043E\u0440\u0438\u0441\u0442\u043E\u0432\u0443\u0432\u0430\u0442\u0438 \u0444\u0430\u0439\u043B default-role.md \u0437 \u043F\u0430\u043F\u043A\u0438 \u043F\u043B\u0430\u0433\u0456\u043D\u0430").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.useDefaultRoleDefinition).onChange(async (value) => {
        this.plugin.settings.useDefaultRoleDefinition = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("\u0428\u043B\u044F\u0445 \u0434\u043E \u0432\u043B\u0430\u0441\u043D\u043E\u0433\u043E \u0432\u0438\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0440\u043E\u043B\u0456").setDesc(
      "\u0428\u043B\u044F\u0445 \u0434\u043E \u0444\u0430\u0439\u043B\u0443 \u0437 \u0432\u043B\u0430\u0441\u043D\u0438\u043C \u0432\u0438\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F\u043C \u0440\u043E\u043B\u0456 (\u0432\u0456\u0434\u043D\u043E\u0441\u043D\u043E \u043A\u043E\u0440\u0435\u043D\u044F \u0441\u0445\u043E\u0432\u0438\u0449\u0430)"
    ).addText(
      (text) => text.setPlaceholder("\u0448\u043B\u044F\u0445/\u0434\u043E/\u0444\u0430\u0439\u043B\u0443_\u0440\u043E\u043B\u0456.md").setValue(this.plugin.settings.customRoleFilePath).onChange(async (value) => {
        this.plugin.settings.customRoleFilePath = value.trim();
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("\u0406\u043D\u0442\u0435\u0440\u0432\u0430\u043B \u0441\u0438\u0441\u0442\u0435\u043C\u043D\u043E\u0433\u043E \u043F\u0440\u043E\u043C\u043F\u0442\u0443").setDesc("\u041A\u0456\u043B\u044C\u043A\u0456\u0441\u0442\u044C \u043F\u0430\u0440 \u043F\u043E\u0432\u0456\u0434\u043E\u043C\u043B\u0435\u043D\u044C \u043C\u0456\u0436 \u043F\u043E\u0432\u0442\u043E\u0440\u043D\u0438\u043C\u0438 \u043D\u0430\u0434\u0441\u0438\u043B\u0430\u043D\u043D\u044F\u043C\u0438 \u0441\u0438\u0441\u0442\u0435\u043C\u043D\u043E\u0433\u043E \u043F\u0440\u043E\u043C\u043F\u0442\u0443. 0 - \u0437 \u043A\u043E\u0436\u043D\u0438\u043C \u0437\u0430\u043F\u0438\u0442\u043E\u043C, \u0432\u0456\u0434'\u0454\u043C\u043D\u0435 - \u043D\u0456\u043A\u043E\u043B\u0438").addText(
      (text) => (
        // Використовуємо Text для введення чисел
        text.setValue(String(this.plugin.settings.systemPromptInterval)).onChange(async (value) => {
          this.plugin.settings.systemPromptInterval = parseInt(value) || 0;
          await this.plugin.saveSettings();
        })
      )
    );
    containerEl.createEl("h2", { text: "\u041A\u043E\u043D\u0444\u0456\u0433\u0443\u0440\u0430\u0446\u0456\u044F RAG" });
    new import_obsidian2.Setting(containerEl).setName("\u0412\u0432\u0456\u043C\u043A\u043D\u0443\u0442\u0438 RAG").setDesc("\u0412\u0438\u043A\u043E\u0440\u0438\u0441\u0442\u043E\u0432\u0443\u0432\u0430\u0442\u0438 Retrieval Augmented Generation \u0437 \u0432\u0430\u0448\u0438\u043C\u0438 \u043D\u043E\u0442\u0430\u0442\u043A\u0430\u043C\u0438").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.ragEnabled).onChange(async (value) => {
        this.plugin.settings.ragEnabled = value;
        await this.plugin.saveSettings();
        if (value && this.plugin.ragService) {
          new import_obsidian2.Notice("RAG \u0443\u0432\u0456\u043C\u043A\u043D\u0435\u043D\u043E. \u0417\u0430\u043F\u0443\u0441\u043A\u0430\u0454\u0442\u044C\u0441\u044F \u0456\u043D\u0434\u0435\u043A\u0441\u0430\u0446\u0456\u044F \u0434\u043E\u043A\u0443\u043C\u0435\u043D\u0442\u0456\u0432...");
          this.plugin.ragService.indexDocuments();
        }
      })
    );
    new import_obsidian2.Setting(containerEl).setName("\u0428\u043B\u044F\u0445 \u0434\u043E \u043F\u0430\u043F\u043A\u0438 RAG").setDesc(
      "\u0428\u043B\u044F\u0445 \u0434\u043E \u043F\u0430\u043F\u043A\u0438, \u0449\u043E \u043C\u0456\u0441\u0442\u0438\u0442\u044C \u0434\u043E\u043A\u0443\u043C\u0435\u043D\u0442\u0438 \u0434\u043B\u044F RAG (\u0432\u0456\u0434\u043D\u043E\u0441\u043D\u043E \u043A\u043E\u0440\u0435\u043D\u044F \u0441\u0445\u043E\u0432\u0438\u0449\u0430)"
    ).addText(
      (text) => text.setPlaceholder("data/rag_docs").setValue(this.plugin.settings.ragFolderPath).onChange(async (value) => {
        this.plugin.settings.ragFolderPath = value.trim();
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("\u041A\u0456\u043B\u044C\u043A\u0456\u0441\u0442\u044C \u0434\u043E\u043A\u0443\u043C\u0435\u043D\u0442\u0456\u0432 RAG \u0443 \u043A\u043E\u043D\u0442\u0435\u043A\u0441\u0442\u0456").setDesc("\u0421\u043A\u0456\u043B\u044C\u043A\u0438 \u043D\u0430\u0439\u0431\u0456\u043B\u044C\u0448 \u0440\u0435\u043B\u0435\u0432\u0430\u043D\u0442\u043D\u0438\u0445 \u0444\u0440\u0430\u0433\u043C\u0435\u043D\u0442\u0456\u0432 \u0434\u043E\u043A\u0443\u043C\u0435\u043D\u0442\u0456\u0432 \u0434\u043E\u0434\u0430\u0432\u0430\u0442\u0438 \u0434\u043E \u043A\u043E\u043D\u0442\u0435\u043A\u0441\u0442\u0443").addSlider(
      (slider) => slider.setLimits(1, 10, 1).setValue(this.plugin.settings.contextWindowSize).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.contextWindowSize = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "\u0420\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u0432\u0430\u043D\u043D\u044F \u041C\u043E\u0432\u043B\u0435\u043D\u043D\u044F" });
    new import_obsidian2.Setting(containerEl).setName("Google API Key").setDesc("API \u043A\u043B\u044E\u0447 \u0434\u043B\u044F \u0441\u0435\u0440\u0432\u0456\u0441\u0443 Google Speech-to-Text").addText(
      (text) => text.setPlaceholder("\u0412\u0432\u0435\u0434\u0456\u0442\u044C \u0432\u0430\u0448 Google API \u043A\u043B\u044E\u0447").setValue(this.plugin.settings.googleApiKey).onChange(async (value) => {
        this.plugin.settings.googleApiKey = value.trim();
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("\u041C\u043E\u0432\u0430 \u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u0432\u0430\u043D\u043D\u044F").setDesc(
      "\u041A\u043E\u0434 \u043C\u043E\u0432\u0438 \u0434\u043B\u044F Google Speech-to-Text (\u043D\u0430\u043F\u0440., uk-UA, en-US, pl-PL)"
    ).addText(
      (text) => text.setPlaceholder("uk-UA").setValue(this.plugin.settings.speechLanguage).onChange(async (value) => {
        this.plugin.settings.speechLanguage = value.trim();
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u0438\u0439 \u0447\u0430\u0441 \u0437\u0430\u043F\u0438\u0441\u0443").setDesc(
      "\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u0438\u0439 \u0447\u0430\u0441 (\u0432 \u0441\u0435\u043A\u0443\u043D\u0434\u0430\u0445) \u0434\u043B\u044F \u0437\u0430\u043F\u0438\u0441\u0443 \u043F\u0435\u0440\u0435\u0434 \u0430\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u043D\u043E\u044E \u0437\u0443\u043F\u0438\u043D\u043A\u043E\u044E"
    ).addSlider(
      (slider) => slider.setLimits(5, 60, 5).setValue(this.plugin.settings.maxRecordingTime).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.maxRecordingTime = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("\u0412\u0438\u044F\u0432\u043B\u0435\u043D\u043D\u044F \u0442\u0438\u0448\u0456").setDesc("\u0410\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u043D\u043E \u0437\u0443\u043F\u0438\u043D\u044F\u0442\u0438 \u0437\u0430\u043F\u0438\u0441 \u043F\u0456\u0441\u043B\u044F \u043F\u0435\u0440\u0456\u043E\u0434\u0443 \u0442\u0438\u0448\u0456 (\u044F\u043A\u0449\u043E \u043F\u0456\u0434\u0442\u0440\u0438\u043C\u0443\u0454\u0442\u044C\u0441\u044F)").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.silenceDetection).onChange(async (value) => {
        this.plugin.settings.silenceDetection = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

// ragService.ts
var RagService = class {
  constructor(plugin) {
    this.documents = [];
    this.isIndexing = false;
    this.plugin = plugin;
  }
  /**
   * Index all markdown files in the specified folder path
   */
  async indexDocuments() {
    var _a, _b;
    if (this.isIndexing)
      return;
    this.isIndexing = true;
    try {
      const folderPath = this.plugin.settings.ragFolderPath;
      const vault = this.plugin.app.vault;
      console.log(`AI Assistant path: "${folderPath}" (RAG documents will be loaded from 'data' subfolder)`);
      const allFiles = vault.getFiles();
      console.log(`Total files in vault: ${allFiles.length}`);
      const files = await this.getMarkdownFiles(vault, folderPath);
      console.log(`Found ${files.length} markdown files from "${folderPath}"`);
      console.log(`Indexing ${files.length} markdown files from ${folderPath}`);
      this.documents = [];
      for (const file of files) {
        try {
          const content = await vault.read(file);
          this.documents.push({
            path: file.path,
            content,
            metadata: {
              filename: file.name,
              created: (_a = file.stat) == null ? void 0 : _a.ctime,
              modified: (_b = file.stat) == null ? void 0 : _b.mtime
            }
          });
        } catch (error) {
          console.error(`Error reading file ${file.path}:`, error);
        }
      }
      console.log(`Indexed ${this.documents.length} documents for RAG`);
    } catch (error) {
      console.error("Error indexing documents:", error);
    } finally {
      this.isIndexing = false;
    }
  }
  /**
   * Get all markdown files in the specified folder path
   */
  async getMarkdownFiles(vault, folderPath) {
    const files = [];
    if (!folderPath) {
      return files;
    }
    let normalizedFolderPath = folderPath;
    if (!normalizedFolderPath.endsWith("/")) {
      normalizedFolderPath += "/";
    }
    const dataFolderPath = normalizedFolderPath + "data/";
    console.log(`Looking for markdown files in: "${dataFolderPath}"`);
    const allFiles = vault.getFiles();
    for (const file of allFiles) {
      if (file.extension === "md" && file.path.startsWith(dataFolderPath)) {
        console.log(`Adding file: ${file.path}`);
        files.push(file);
      }
    }
    return files;
  }
  /**
   * Simple search implementation to find relevant documents for a query
   * Later this could be replaced with a more sophisticated vector search
   */
  findRelevantDocuments(query, limit = 5) {
    if (!this.documents.length) {
      return [];
    }
    const scoredDocs = this.documents.map((doc) => {
      const lowerContent = doc.content.toLowerCase();
      const lowerQuery = query.toLowerCase();
      const terms = lowerQuery.split(/\s+/);
      let score = 0;
      for (const term of terms) {
        if (term.length > 2) {
          const regex = new RegExp(term, "gi");
          const matches = lowerContent.match(regex);
          if (matches) {
            score += matches.length;
          }
        }
      }
      return { doc, score };
    });
    return scoredDocs.sort((a, b) => b.score - a.score).slice(0, limit).map((item) => item.doc);
  }
  /**
   * Prepare context from relevant documents
   */
  prepareContext(query) {
    if (!this.plugin.settings.ragEnabled || this.documents.length === 0) {
      return "";
    }
    const limit = this.plugin.settings.contextWindowSize;
    const relevantDocs = this.findRelevantDocuments(query, limit);
    if (relevantDocs.length === 0) {
      return "";
    }
    let context = "### Context:\n\n";
    relevantDocs.forEach((doc, index) => {
      var _a;
      context += `Document ${index + 1} (${(_a = doc.metadata) == null ? void 0 : _a.filename}):
`;
      const maxChars = 1500;
      const content = doc.content.length > maxChars ? doc.content.substring(0, maxChars) + "..." : doc.content;
      context += content + "\n\n";
    });
    context += "### End of context\n\n";
    return context;
  }
};

// apiServices.ts
var ApiService = class {
  // Додаємо посилання на плагін
  constructor(plugin) {
    // private stateManager: StateManager; // Ймовірно, не потрібен
    // promptService не потрібен напряму, якщо MessageService керує ним
    // private promptService: PromptService;
    this.ollamaView = null;
    // Використовуємо конкретний тип
    this.eventHandlers = {};
    this.plugin = plugin;
    this.baseUrl = plugin.settings.ollamaServerUrl;
  }
  on(event, callback) {
    if (!this.eventHandlers[event]) {
      this.eventHandlers[event] = [];
    }
    this.eventHandlers[event].push(callback);
    return () => {
      this.eventHandlers[event] = this.eventHandlers[event].filter(
        (handler) => handler !== callback
      );
    };
  }
  emit(event, data) {
    const handlers = this.eventHandlers[event];
    if (handlers) {
      handlers.slice().forEach((handler) => {
        try {
          handler(data);
        } catch (e) {
          console.error(`Error in API Service event handler for ${event}:`, e);
        }
      });
    }
  }
  // getPromptService(): PromptService { // Ймовірно, не потрібно
  //   return this.promptService;
  // }
  setOllamaView(view) {
    this.ollamaView = view;
  }
  // setSystemPrompt(prompt: string | null): void { // Керується через PromptService
  //   this.promptService.setSystemPrompt(prompt);
  // }
  setBaseUrl(url) {
    this.baseUrl = url;
  }
  // setPlugin(plugin: any): void { // Встановлюється в конструкторі
  //   this.promptService.setPlugin(plugin);
  // }
  /**
   * Генерує відповідь від Ollama.
   * requestBody тепер містить model, prompt, system, options, stream, temperature.
   */
  async generateResponse(requestBody) {
    const apiUrl = `${this.baseUrl}/api/generate`;
    console.log("Sending request to Ollama:", apiUrl, JSON.stringify({ ...requestBody, prompt: requestBody.prompt.substring(0, 100) + "..." }));
    try {
      const response = await fetch(apiUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(requestBody)
      });
      if (!response.ok) {
        let errorText = `HTTP error! Status: ${response.status}`;
        try {
          const bodyText = await response.text();
          try {
            const errorJson = JSON.parse(bodyText);
            errorText += `: ${errorJson.error || bodyText}`;
          } catch (jsonError) {
            errorText += `: ${bodyText}`;
          }
          if (bodyText.includes("model not found")) {
            errorText = `Model '${requestBody.model}' not found on the Ollama server.`;
            this.emit("error", new Error(errorText));
          }
        } catch (bodyError) {
          console.error("Could not read error response body:", bodyError);
        }
        console.error("Ollama API Error:", errorText);
        throw new Error(errorText);
      }
      const data = await response.json();
      console.log("Received response from Ollama:", { ...data, response: data.response.substring(0, 100) + "..." });
      return data;
    } catch (error) {
      console.error(`Workspace error calling Ollama API (${apiUrl}):`, error);
      let connectionErrorMsg = `Failed to connect to Ollama server at ${this.baseUrl}. Is it running?`;
      if (error.message.includes("fetch")) {
        connectionErrorMsg += ` (Fetch error: ${error.message})`;
      }
      this.emit("connection-error", new Error(connectionErrorMsg));
      throw new Error(connectionErrorMsg);
    }
  }
  /**
   * Отримує список доступних моделей з Ollama.
   */
  async getModels() {
    const apiUrl = `${this.baseUrl}/api/tags`;
    try {
      const response = await fetch(apiUrl, {
        method: "GET",
        headers: { "Content-Type": "application/json" }
      });
      if (!response.ok) {
        const errorText = await response.text();
        console.error(`HTTP error fetching models! Status: ${response.status}`, errorText);
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
      const data = await response.json();
      if (Array.isArray(data.models)) {
        return data.models.map((model) => typeof model === "object" ? model.name : model).sort();
      }
      return [];
    } catch (error) {
      console.error(`Error fetching models from ${apiUrl}:`, error);
      if (error.message.includes("fetch") || error.message.includes("Failed to fetch")) {
        this.emit("connection-error", new Error(`Failed to fetch models from ${this.baseUrl}. Is it running?`));
      }
      return [];
    }
  }
  // resetState(): void { // Логіка стану, ймовірно, тут не потрібна
  //   // ...
  // }
};

// promptService.ts
var import_obsidian3 = require("obsidian");
var path = __toESM(require("path"));
function countWords(text) {
  if (!text)
    return 0;
  return text.trim().split(/\s+/).length;
}
var PromptService = class {
  // Змінено тип на конкретний
  // Прибираємо StateManager, якщо він не потрібен саме для формування промпту
  // private stateManager: StateManager;
  constructor(plugin) {
    this.systemPrompt = null;
    this.plugin = plugin;
  }
  setSystemPrompt(prompt) {
    this.systemPrompt = prompt;
  }
  getSystemPrompt() {
    return this.systemPrompt;
  }
  // Цей метод тепер стає менш важливим, основна логіка в prepareFullPrompt
  formatPrompt(userInput) {
    return userInput.trim();
  }
  // Об'єднаємо логіку RAG сюди
  // enhanceWithRagContext(prompt: string, ragContext: string | null): string { ... }
  // --- Новий метод для підготовки контексту ---
  buildContext(history, ragContext, userInput) {
    let promptParts = [];
    let systemWordCount = 0;
    let contextWordCount = 0;
    const currentSystemPrompt = this.getSystemPrompt();
    if (currentSystemPrompt) {
      systemWordCount = countWords(currentSystemPrompt);
    }
    if (ragContext) {
      const ragHeader = "\u041A\u043E\u043D\u0442\u0435\u043A\u0441\u0442\u043D\u0430 \u0456\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0456\u044F \u0437 \u043D\u043E\u0442\u0430\u0442\u043E\u043A:\n```\n";
      const ragFooter = "\n```\n\n";
      const fullRagBlock = ragHeader + ragContext + ragFooter;
      promptParts.push(fullRagBlock);
      contextWordCount += countWords(fullRagBlock);
    }
    const historyStrings = [];
    for (let i = history.length - 1; i >= 0; i--) {
      const msg = history[i];
      const formattedMsg = `${msg.role === "user" ? "User" : "Assistant"}: ${msg.content}`;
      historyStrings.push(formattedMsg);
      contextWordCount += countWords(formattedMsg);
    }
    promptParts = promptParts.concat(historyStrings.reverse());
    const userMsgFormatted = `User: ${userInput}`;
    promptParts.push(userMsgFormatted);
    const fullPrompt = promptParts.join("\n\n");
    return {
      fullPrompt,
      // Промпт без системного, але з RAG та історією
      contextWordCount,
      // Слова RAG + Історії
      systemPromptWordCount: systemWordCount
      // Слова системного промпту
    };
  }
  // --- Основний метод підготовки ---
  async prepareFullPrompt(content, history) {
    if (!this.plugin) {
      console.warn("Plugin reference not set in PromptService.");
      return this.formatPrompt(content);
    }
    try {
      const roleDefinition = await this.getRoleDefinition();
      this.setSystemPrompt(roleDefinition);
    } catch (error) {
      console.error("Error getting role definition:", error);
      this.setSystemPrompt(null);
    }
    let ragContext = null;
    if (this.plugin.settings.ragEnabled && this.plugin.ragService) {
      try {
        ragContext = this.plugin.ragService.prepareContext(content);
      } catch (error) {
        console.error("Error processing RAG:", error);
      }
    }
    let { fullPrompt, contextWordCount, systemPromptWordCount } = this.buildContext(history, ragContext, content);
    const userInputWordCount = countWords(content);
    const tokenApproximationFactor = 0.75;
    const modelContextLimit = this.plugin.settings.contextWindow;
    const wordLimit = Math.max(100, modelContextLimit / tokenApproximationFactor - systemPromptWordCount - userInputWordCount - 200);
    if (contextWordCount > wordLimit) {
      console.warn(`Context too long (${contextWordCount} words > limit ${wordLimit}). Trimming oldest messages/RAG.`);
      let promptLines = fullPrompt.split("\n\n");
      let currentWordCount = contextWordCount;
      while (currentWordCount > wordLimit && promptLines.length > 1) {
        const lineToRemove = promptLines.shift();
        if (lineToRemove) {
          currentWordCount -= countWords(lineToRemove);
        }
      }
      fullPrompt = promptLines.join("\n\n");
      console.log(`Trimmed context word count: ${currentWordCount}`);
    }
    if (!fullPrompt.includes(`User: ${content.trim()}`)) {
      console.warn("User input was trimmed, re-adding it.");
      fullPrompt += `

User: ${content.trim()}`;
    }
    return fullPrompt;
  }
  // --- Методи для роботи з ролями (без змін) ---
  async getDefaultRoleDefinition() {
    if (!this.plugin)
      return null;
    try {
      const pluginFolder = this.plugin.manifest.dir;
      if (!pluginFolder) {
        console.error("Cannot determine plugin folder path.");
        return null;
      }
      const rolePath = "default-role.md";
      const fullPath = normalizePath(path.join(pluginFolder, rolePath));
      let content = null;
      const adapter = this.plugin.app.vault.adapter;
      if (await adapter.exists(fullPath)) {
        try {
          content = await adapter.read(fullPath);
        } catch (readError) {
          console.error(`Error reading default role file at ${fullPath}:`, readError);
          return null;
        }
      } else {
        console.log(`Default role file not found at ${fullPath}, creating it.`);
        try {
          const defaultContent = "# Default AI Role\n\nYou are a helpful assistant.";
          await adapter.write(fullPath, defaultContent);
          content = defaultContent;
        } catch (createError) {
          console.error(`Error creating default role file at ${fullPath}:`, createError);
          return null;
        }
      }
      if (content !== null) {
        const currentTime = new Date().toLocaleTimeString("uk-UA");
        content += `

\u041F\u043E\u0442\u043E\u0447\u043D\u0438\u0439 \u0447\u0430\u0441: ${currentTime}`;
        return content;
      }
      return null;
    } catch (error) {
      console.error("Error handling default role definition:", error);
      return null;
    }
  }
  async getCustomRoleDefinition() {
    if (!this.plugin || !this.plugin.settings.customRoleFilePath)
      return null;
    try {
      const customPath = normalizePath(this.plugin.settings.customRoleFilePath);
      const file = this.plugin.app.vault.getAbstractFileByPath(customPath);
      if (file instanceof import_obsidian3.TFile) {
        let content = await this.plugin.app.vault.read(file);
        const currentTime = new Date().toLocaleTimeString("uk-UA");
        content += `

\u041F\u043E\u0442\u043E\u0447\u043D\u0438\u0439 \u0447\u0430\u0441: ${currentTime}`;
        return content;
      } else {
        console.warn(`Custom role file not found or is not a file: ${customPath}`);
        return null;
      }
    } catch (error) {
      console.error("Error reading custom role definition:", error);
      return null;
    }
  }
  async getRoleDefinition() {
    if (!this.plugin || !this.plugin.settings.followRole)
      return null;
    try {
      if (this.plugin.settings.useDefaultRoleDefinition) {
        return await this.getDefaultRoleDefinition();
      } else if (this.plugin.settings.customRoleFilePath) {
        return await this.getCustomRoleDefinition();
      }
      return null;
    } catch (error) {
      console.error("Error reading role definition:", error);
      return null;
    }
  }
  // Цей метод більше не потрібен тут, його логіка в ApiService
  // processModelResponse(response: string): string { ... }
  // Цей метод теж не потрібен тут, він в ApiService або MessageService
  // prepareRequestBody(modelName: string, prompt: string, temperature: number = 0.2): any { ... }
};

// messageService.ts
var MessageService = class {
  constructor(plugin) {
    this.view = null;
    // Додаємо посилання
    this.isProcessing = false;
    this.plugin = plugin;
    this.apiService = plugin.apiService;
    this.promptService = plugin.promptService;
  }
  setView(view) {
    this.view = view;
  }
  async loadMessageHistory() {
    if (!this.view)
      return;
    let historyLoaded = false;
    try {
      const history = await this.plugin.loadMessageHistory();
      if (Array.isArray(history) && history.length > 0) {
        for (const msg of history) {
          const role = msg.role;
          if (role && msg.content && msg.timestamp) {
            this.view.internalAddMessage(role, msg.content, {
              saveHistory: false,
              timestamp: msg.timestamp
            });
          } else {
            console.warn("\u041F\u0440\u043E\u043F\u0443\u0441\u043A \u043F\u043E\u0432\u0456\u0434\u043E\u043C\u043B\u0435\u043D\u043D\u044F \u0437 \u043D\u0435\u043F\u043E\u0432\u043D\u0438\u043C\u0438 \u0434\u0430\u043D\u0438\u043C\u0438 \u043F\u0456\u0434 \u0447\u0430\u0441 \u0437\u0430\u0432\u0430\u043D\u0442\u0430\u0436\u0435\u043D\u043D\u044F \u0456\u0441\u0442\u043E\u0440\u0456\u0457:", msg);
          }
        }
        historyLoaded = true;
        setTimeout(() => {
          var _a;
          return (_a = this.view) == null ? void 0 : _a.guaranteedScrollToBottom(100, true);
        }, 100);
      }
      if (historyLoaded) {
        await this.view.saveMessageHistory();
      }
    } catch (error) {
      console.error("MessageService: \u041F\u043E\u043C\u0438\u043B\u043A\u0430 \u0437\u0430\u0432\u0430\u043D\u0442\u0430\u0436\u0435\u043D\u043D\u044F \u0456\u0441\u0442\u043E\u0440\u0456\u0457:", error);
    } finally {
      if (this.view && this.view.getMessagesCount() === 0) {
        this.view.showEmptyState();
      } else if (this.view) {
        this.view.hideEmptyState();
      }
    }
  }
  async sendMessage(content) {
    if (this.isProcessing || !content.trim() || !this.view)
      return;
    await this.processWithOllama(content);
  }
  async processWithOllama(content) {
    if (!this.view)
      return;
    this.isProcessing = true;
    this.view.setLoadingState(true);
    const loadingMessageEl = this.view.addLoadingIndicator();
    setTimeout(async () => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i;
      let responseData = null;
      try {
        const history = (_b = (_a = this.view) == null ? void 0 : _a.getMessages()) != null ? _b : [];
        const formattedPrompt = await this.promptService.prepareFullPrompt(content, history);
        const requestBody = {
          model: this.plugin.settings.modelName,
          prompt: formattedPrompt,
          stream: false,
          // Поки що без стрімінгу
          temperature: this.plugin.settings.temperature,
          options: {
            num_ctx: this.plugin.settings.contextWindow
            // Використовуємо contextWindow
          },
          system: (_c = this.promptService.getSystemPrompt()) != null ? _c : void 0
          // Додаємо системний промпт, якщо є
        };
        if (!requestBody.system) {
          delete requestBody.system;
        }
        responseData = await this.apiService.generateResponse(requestBody);
        (_d = this.view) == null ? void 0 : _d.removeLoadingIndicator(loadingMessageEl);
        if (responseData && responseData.response) {
          const textArea = document.createElement("textarea");
          textArea.innerHTML = responseData.response;
          const decodedResponse = textArea.value;
          (_e = this.view) == null ? void 0 : _e.internalAddMessage("assistant", decodedResponse);
        } else {
          (_f = this.view) == null ? void 0 : _f.internalAddMessage("error", "\u041E\u0442\u0440\u0438\u043C\u0430\u043D\u043E \u043F\u043E\u0440\u043E\u0436\u043D\u044E \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u044C \u0432\u0456\u0434 \u043C\u043E\u0434\u0435\u043B\u0456.");
        }
      } catch (error) {
        console.error("\u041F\u043E\u043C\u0438\u043B\u043A\u0430 \u043E\u0431\u0440\u043E\u0431\u043A\u0438 \u0437\u0430\u043F\u0438\u0442\u0443 \u0434\u043E Ollama:", error);
        (_g = this.view) == null ? void 0 : _g.removeLoadingIndicator(loadingMessageEl);
        let errorMessage = "\u041D\u0435\u0432\u0456\u0434\u043E\u043C\u0430 \u043F\u043E\u043C\u0438\u043B\u043A\u0430 \u043F\u0456\u0434 \u0447\u0430\u0441 \u0432\u0437\u0430\u0454\u043C\u043E\u0434\u0456\u0457 \u0437 Ollama.";
        if (error instanceof Error) {
          errorMessage = error.message;
          if (errorMessage.includes("Model") && errorMessage.includes("not found")) {
            errorMessage += ` \u041F\u0435\u0440\u0435\u0432\u0456\u0440\u0442\u0435 \u043D\u0430\u0437\u0432\u0443 \u043C\u043E\u0434\u0435\u043B\u0456 "${this.plugin.settings.modelName}" \u0443 \u043D\u0430\u043B\u0430\u0448\u0442\u0443\u0432\u0430\u043D\u043D\u044F\u0445.`;
          } else if (errorMessage.includes("connect") || errorMessage.includes("fetch")) {
            errorMessage += ` \u041F\u0435\u0440\u0435\u0432\u0456\u0440\u0442\u0435 URL \u0441\u0435\u0440\u0432\u0435\u0440\u0430 Ollama (${this.plugin.settings.ollamaServerUrl}) \u0442\u0430 \u043F\u0435\u0440\u0435\u043A\u043E\u043D\u0430\u0439\u0442\u0435\u0441\u044F, \u0449\u043E \u0441\u0435\u0440\u0432\u0435\u0440 \u0437\u0430\u043F\u0443\u0449\u0435\u043D\u043E.`;
          } else if (error.message.includes("context window")) {
            errorMessage = `\u041F\u043E\u043C\u0438\u043B\u043A\u0430 \u043A\u043E\u043D\u0442\u0435\u043A\u0441\u0442\u043D\u043E\u0433\u043E \u0432\u0456\u043A\u043D\u0430: ${error.message}. \u0421\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0437\u043C\u0435\u043D\u0448\u0438\u0442\u0438 \u0440\u043E\u0437\u043C\u0456\u0440 \u0432\u0456\u043A\u043D\u0430 \u0432 \u043D\u0430\u043B\u0430\u0448\u0442\u0443\u0432\u0430\u043D\u043D\u044F\u0445 \u0430\u0431\u043E \u0441\u043A\u043E\u0440\u043E\u0442\u0438\u0442\u0438 \u0456\u0441\u0442\u043E\u0440\u0456\u044E.`;
          }
        }
        (_h = this.view) == null ? void 0 : _h.internalAddMessage("error", errorMessage);
      } finally {
        this.isProcessing = false;
        (_i = this.view) == null ? void 0 : _i.setLoadingState(false);
      }
    }, 0);
  }
  addSystemMessage(content) {
    if (this.view) {
      this.view.internalAddMessage("system", content);
    }
  }
};

// main.ts
var OllamaPlugin = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    this.view = null;
    this.eventHandlers = {};
    this.documents = [];
    this.embeddings = [];
    this.indexUpdateTimeout = null;
  }
  on(event, callback) {
    if (!this.eventHandlers[event]) {
      this.eventHandlers[event] = [];
    }
    this.eventHandlers[event].push(callback);
    return () => {
      this.eventHandlers[event] = this.eventHandlers[event].filter(
        (handler) => handler !== callback
      );
    };
  }
  emit(event, data) {
    const handlers = this.eventHandlers[event];
    if (handlers) {
      handlers.slice().forEach((handler) => {
        try {
          handler(data);
        } catch (e) {
          console.error(`Error in event handler for ${event}:`, e);
        }
      });
    }
  }
  async onload() {
    console.log("Ollama Plugin Loaded!");
    await this.loadSettings();
    this.apiService = new ApiService(this);
    this.ragService = new RagService(this);
    this.promptService = new PromptService(this);
    this.messageService = new MessageService(this);
    this.registerView(VIEW_TYPE_OLLAMA, (leaf) => {
      console.log("OllamaPlugin: Registering new view instance.");
      this.view = new OllamaView(leaf, this);
      this.messageService.setView(this.view);
      if (this.apiService) {
        this.apiService.setOllamaView(this.view);
      }
      return this.view;
    });
    this.apiService.on("connection-error", (error) => {
      console.error("Ollama connection error event received:", error);
      if (this.view) {
        this.view.internalAddMessage(
          "error",
          `Failed to connect to Ollama: ${error.message}. Please check settings.`
        );
      } else {
        new import_obsidian4.Notice(`Failed to connect to Ollama: ${error.message}`);
        console.log("Ollama connection error: View not available to display message.");
      }
    });
    this.addRibbonIcon("message-square", "Open Ollama Chat", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-ollama-view",
      name: "Open Ollama Chat",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "change-model",
      name: "Change Ollama Model (Example)",
      callback: async () => {
        const newModel = "llama3:latest";
        console.log(`Changing model to ${newModel}`);
        this.settings.modelName = newModel;
        await this.saveSettings();
        this.emit("model-changed", newModel);
      }
    });
    this.addCommand({
      id: "index-rag-documents",
      name: "Index documents for RAG",
      callback: async () => {
        await this.ragService.indexDocuments();
      }
    });
    this.addCommand({
      id: "clear-ollama-history",
      name: "Clear Ollama Chat History",
      callback: async () => {
        await this.clearMessageHistory();
      }
    });
    this.settingTab = new OllamaSettingTab(this.app, this);
    this.addSettingTab(this.settingTab);
    this.app.workspace.onLayoutReady(async () => {
      if (this.settings.ragEnabled) {
        setTimeout(() => {
          console.log("OllamaPlugin: RAG enabled, starting initial index.");
          this.ragService.indexDocuments();
        }, 5e3);
      }
    });
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        if (this.settings.ragEnabled) {
          this.debounceIndexUpdate();
        }
      })
    );
  }
  onunload() {
    console.log("Ollama Plugin Unloaded!");
    this.app.workspace.getLeavesOfType(VIEW_TYPE_OLLAMA).forEach((leaf) => {
      leaf.detach();
    });
    if (this.indexUpdateTimeout) {
      clearTimeout(this.indexUpdateTimeout);
    }
  }
  updateApiService() {
    if (this.apiService) {
      this.apiService.setBaseUrl(this.settings.ollamaServerUrl);
    }
  }
  debounceIndexUpdate() {
    if (this.indexUpdateTimeout) {
      clearTimeout(this.indexUpdateTimeout);
    }
    this.indexUpdateTimeout = setTimeout(() => {
      console.log("OllamaPlugin: Debounced RAG index update triggered.");
      this.ragService.indexDocuments();
      this.indexUpdateTimeout = null;
    }, 3e4);
  }
  async activateView() {
    var _a;
    const { workspace } = this.app;
    let leaf = null;
    const existingLeaves = workspace.getLeavesOfType(VIEW_TYPE_OLLAMA);
    if (existingLeaves.length > 0) {
      leaf = existingLeaves[0];
      console.log("OllamaPlugin: Found existing view leaf.");
    } else {
      console.log("OllamaPlugin: No existing view leaf found, creating new one.");
      leaf = (_a = workspace.getRightLeaf(false)) != null ? _a : workspace.getLeaf(true);
      await leaf.setViewState({ type: VIEW_TYPE_OLLAMA, active: true });
      console.log("OllamaPlugin: New view leaf created.");
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
      const viewInstance = leaf.view;
      if (viewInstance instanceof OllamaView) {
        this.view = viewInstance;
        this.messageService.setView(this.view);
        if (this.apiService) {
          this.apiService.setOllamaView(this.view);
        }
        console.log("OllamaPlugin: View activated and services linked.");
      } else {
        console.error("OllamaPlugin: Leaf revealed, but view instance is not of type OllamaView?");
      }
    } else {
      console.error("OllamaPlugin: Failed to get or create a leaf for the view.");
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.updateApiService();
    console.log("OllamaPlugin: Settings saved.");
  }
  async saveMessageHistory(messagesJsonString) {
    if (!this.settings.saveMessageHistory) {
      return;
    }
    const adapter = this.app.vault.adapter;
    const pluginConfigDir = this.manifest.dir;
    if (!pluginConfigDir) {
      console.error("OllamaPlugin: Could not determine plugin directory path.");
      new import_obsidian4.Notice("Error: Could not determine plugin directory path for saving history.");
      return;
    }
    const relativeLogPath = `${pluginConfigDir}/chat_history.json`;
    const logPath = (0, import_obsidian4.normalizePath)(relativeLogPath);
    console.log(`OllamaPlugin: Preparing to save history to vault path: ${logPath}`);
    try {
      let dataToWrite = messagesJsonString;
      let finalSizeKB = dataToWrite.length / 1024;
      if (dataToWrite.trim() === "[]") {
        console.log("OllamaPlugin: Clear operation detected. Writing empty array.");
      } else if (finalSizeKB > this.settings.logFileSizeLimit) {
        console.log(`OllamaPlugin: New history size (${finalSizeKB.toFixed(2)}KB) exceeds limit (${this.settings.logFileSizeLimit}KB). Trimming oldest messages.`);
        try {
          let parsedMessages = JSON.parse(dataToWrite);
          if (!Array.isArray(parsedMessages)) {
            throw new Error("History data is not an array.");
          }
          while (JSON.stringify(parsedMessages).length / 1024 > this.settings.logFileSizeLimit && parsedMessages.length > 1) {
            parsedMessages.shift();
          }
          dataToWrite = parsedMessages.length > 0 ? JSON.stringify(parsedMessages) : "[]";
          finalSizeKB = dataToWrite.length / 1024;
          console.log(`OllamaPlugin: History trimmed. New size: ${finalSizeKB.toFixed(2)}KB`);
        } catch (e) {
          console.error("OllamaPlugin: Error parsing history for trimming. Resetting history:", e);
          dataToWrite = "[]";
          finalSizeKB = dataToWrite.length / 1024;
        }
      }
      const fileExists = await adapter.exists(logPath);
      if (fileExists) {
        try {
          const relativeBackupPath = relativeLogPath + ".backup";
          const backupPath = (0, import_obsidian4.normalizePath)(relativeBackupPath);
          if (await adapter.exists(backupPath)) {
            await adapter.remove(backupPath);
          }
          await adapter.copy(logPath, backupPath);
        } catch (backupError) {
          console.error("OllamaPlugin: Failed to create history backup:", backupError);
        }
      }
      await adapter.write(logPath, dataToWrite);
      console.log(`OllamaPlugin: Write operation completed for ${logPath}.`);
    } catch (error) {
      console.error(`OllamaPlugin: Failed to save message history to ${logPath}:`, error);
      new import_obsidian4.Notice("Error saving chat history.");
    }
  }
  async loadMessageHistory() {
    if (!this.settings.saveMessageHistory) {
      return [];
    }
    const adapter = this.app.vault.adapter;
    const pluginConfigDir = this.manifest.dir;
    if (!pluginConfigDir) {
      console.error("OllamaPlugin: Could not determine plugin directory path for loading.");
      return [];
    }
    const relativeLogPath = `${pluginConfigDir}/chat_history.json`;
    const logPath = (0, import_obsidian4.normalizePath)(relativeLogPath);
    try {
      if (!await adapter.exists(logPath)) {
        return [];
      }
      const data = await adapter.read(logPath);
      if (!data || data.trim() === "" || data.trim() === "[]") {
        return [];
      }
      const parsedData = JSON.parse(data);
      if (Array.isArray(parsedData)) {
        console.log(`OllamaPlugin: Successfully parsed ${parsedData.length} messages from history file: ${logPath}.`);
        return parsedData;
      } else {
        console.warn(`OllamaPlugin: Parsed history data from ${logPath} is not an array. Returning empty history.`);
        return [];
      }
    } catch (error) {
      console.error(`OllamaPlugin: Failed to load/parse message history from ${logPath}:`, error);
      return [];
    }
  }
  async clearMessageHistory() {
    console.log("OllamaPlugin: Clearing message history initiated.");
    try {
      await this.saveMessageHistory("[]");
      if (this.view) {
        this.view.clearDisplayAndState();
        console.log("OllamaPlugin: Cleared active view display and state.");
      } else {
        console.log("OllamaPlugin: View not active, history file cleared/reset.");
      }
      new import_obsidian4.Notice("Ollama chat history cleared.");
    } catch (error) {
      console.error("OllamaPlugin: Failed to clear message history:", error);
      new import_obsidian4.Notice("Error clearing chat history.");
    }
  }
};
