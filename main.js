/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  ACTIVE_CHAT_ID_KEY: () => ACTIVE_CHAT_ID_KEY2,
  CHAT_INDEX_KEY: () => CHAT_INDEX_KEY,
  SESSIONS_INDEX_KEY: () => SESSIONS_INDEX_KEY,
  default: () => OllamaPlugin2
});
module.exports = __toCommonJS(main_exports);
var import_obsidian12 = require("obsidian");

// src/OllamaView.ts
var import_obsidian3 = require("obsidian");

// src/ConfirmModal.ts
var import_obsidian = require("obsidian");
var ConfirmModal = class extends import_obsidian.Modal {
  constructor(app, title, message, onConfirm) {
    super(app);
    this.title = title;
    this.message = message;
    this.onConfirm = onConfirm;
    this.title = title;
    this.message = message;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl, titleEl } = this;
    titleEl.setText(this.title);
    contentEl.createEl("p", { text: this.message });
    new import_obsidian.Setting(contentEl).addButton((button) => button.setButtonText("Confirm").setCta().onClick(() => {
      this.onConfirm();
      this.close();
    })).addButton((button) => button.setButtonText("Cancel").onClick(() => {
      this.close();
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/PromptModal.ts
var import_obsidian2 = require("obsidian");
var PromptModal = class extends import_obsidian2.Modal {
  constructor(app, title, promptText, initialValue = "", onSubmit) {
    super(app);
    this.title = title;
    this.promptText = promptText;
    this.initialValue = initialValue;
    this.onSubmit = onSubmit;
    // Приватний метод для обробки відправки (щоб уникнути дублювання коду для кнопки та Enter)
    this.submitInput = () => {
      this.onSubmit(this.inputValue);
      this.close();
    };
    this.title = title;
    this.promptText = promptText;
    this.inputValue = initialValue;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl, titleEl } = this;
    let textInput;
    titleEl.setText(this.title);
    if (this.promptText) {
      contentEl.createEl("p", { text: this.promptText });
    }
    new import_obsidian2.Setting(contentEl).setName("New value:").addText((text) => {
      textInput = text;
      text.setValue(this.inputValue).onChange((value) => {
        this.inputValue = value;
      });
      text.inputEl.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          this.submitInput();
        }
      });
    });
    new import_obsidian2.Setting(contentEl).addButton((button) => button.setButtonText("Submit").setCta().onClick(this.submitInput)).addButton((button) => button.setButtonText("Cancel").onClick(() => {
      this.close();
    }));
    setTimeout(() => {
      var _a, _b;
      (_a = textInput == null ? void 0 : textInput.inputEl) == null ? void 0 : _a.focus();
      (_b = textInput == null ? void 0 : textInput.inputEl) == null ? void 0 : _b.select();
    }, 50);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/OllamaView.ts
var VIEW_TYPE_OLLAMA_PERSONAS = "ollama-personas-chat-view";
var CSS_CLASS_CONTAINER = "ollama-container";
var CSS_CLASS_CHAT_CONTAINER = "ollama-chat-container";
var CSS_CLASS_INPUT_CONTAINER = "chat-input-container";
var CSS_CLASS_BUTTONS_CONTAINER = "buttons-container";
var CSS_CLASS_SEND_BUTTON = "send-button";
var CSS_CLASS_VOICE_BUTTON = "voice-button";
var CSS_CLASS_TRANSLATE_INPUT_BUTTON = "translate-input-button";
var CSS_CLASS_TRANSLATING_INPUT = "translating-input";
var CSS_CLASS_MENU_BUTTON = "menu-button";
var CSS_CLASS_MENU_DROPDOWN = "menu-dropdown";
var CSS_CLASS_MENU_OPTION = "menu-option";
var CSS_CLASS_MENU_HEADER_ITEM = "menu-header-item";
var CSS_CLASS_SUBMENU_ICON = "submenu-icon";
var CSS_CLASS_SUBMENU_CONTENT = "submenu-content";
var CSS_CLASS_SUBMENU_CONTENT_HIDDEN = "submenu-content-hidden";
var CSS_CLASS_SETTINGS_OPTION = "settings-option";
var CSS_CLASS_EMPTY_STATE = "ollama-empty-state";
var CSS_CLASS_MESSAGE_GROUP = "message-group";
var CSS_CLASS_USER_GROUP = "user-message-group";
var CSS_CLASS_OLLAMA_GROUP = "ollama-message-group";
var CSS_CLASS_SYSTEM_GROUP = "system-message-group";
var CSS_CLASS_ERROR_GROUP = "error-message-group";
var CSS_CLASS_MESSAGE = "message";
var CSS_CLASS_USER_MESSAGE = "user-message";
var CSS_CLASS_OLLAMA_MESSAGE = "ollama-message";
var CSS_CLASS_SYSTEM_MESSAGE = "system-message";
var CSS_CLASS_ERROR_MESSAGE = "error-message";
var CSS_CLASS_SYSTEM_ICON = "system-icon";
var CSS_CLASS_ERROR_ICON = "error-icon";
var CSS_CLASS_SYSTEM_TEXT = "system-message-text";
var CSS_CLASS_ERROR_TEXT = "error-message-text";
var CSS_CLASS_CONTENT_CONTAINER = "message-content-container";
var CSS_CLASS_CONTENT = "message-content";
var CSS_CLASS_THINKING_DOTS = "thinking-dots";
var CSS_CLASS_THINKING_DOT = "thinking-dot";
var CSS_CLASS_THINKING_BLOCK = "thinking-block";
var CSS_CLASS_THINKING_HEADER = "thinking-header";
var CSS_CLASS_THINKING_TOGGLE = "thinking-toggle";
var CSS_CLASS_THINKING_TITLE = "thinking-title";
var CSS_CLASS_THINKING_CONTENT = "thinking-content";
var CSS_CLASS_TIMESTAMP = "message-timestamp";
var CSS_CLASS_COPY_BUTTON = "copy-button";
var CSS_CLASS_TRANSLATE_BUTTON = "translate-button";
var CSS_CLASS_TRANSLATION_CONTAINER = "translation-container";
var CSS_CLASS_TRANSLATION_CONTENT = "translation-content";
var CSS_CLASS_TRANSLATION_PENDING = "translation-pending";
var CSS_CLASS_RECORDING = "recording";
var CSS_CLASS_DISABLED = "disabled";
var CSS_CLASS_MESSAGE_ARRIVING = "message-arriving";
var CSS_CLASS_DATE_SEPARATOR = "chat-date-separator";
var CSS_CLASS_AVATAR = "message-group-avatar";
var CSS_CLASS_AVATAR_USER = "user-avatar";
var CSS_CLASS_AVATAR_AI = "ai-avatar";
var CSS_CLASS_CODE_BLOCK_COPY_BUTTON = "code-block-copy-button";
var CSS_CLASS_CODE_BLOCK_LANGUAGE = "code-block-language";
var CSS_CLASS_NEW_MESSAGE_INDICATOR = "new-message-indicator";
var CSS_CLASS_VISIBLE = "visible";
var CSS_CLASS_MENU_SEPARATOR = "menu-separator";
var CSS_CLASS_CLEAR_CHAT_OPTION = "clear-chat-option";
var CSS_CLASS_EXPORT_CHAT_OPTION = "export-chat-option";
var CSS_CLASS_CONTENT_COLLAPSIBLE = "message-content-collapsible";
var CSS_CLASS_CONTENT_COLLAPSED = "message-content-collapsed";
var CSS_CLASS_SHOW_MORE_BUTTON = "show-more-button";
var CSS_CLASS_MODEL_OPTION = "model-option";
var CSS_CLASS_MODEL_LIST_CONTAINER = "model-list-container";
var CSS_CLASS_ROLE_OPTION = "role-option";
var CSS_CLASS_ROLE_LIST_CONTAINER = "role-list-container";
var CSS_CLASS_CHAT_OPTION = "chat-option";
var CSS_CLASS_CHAT_LIST_CONTAINER = "chat-list-container";
var CSS_CLASS_MENU_HEADER = "menu-header";
var CSS_CLASS_NEW_CHAT_OPTION = "new-chat-option";
var CSS_CLASS_RENAME_CHAT_OPTION = "rename-chat-option";
var CSS_CLASS_DELETE_CHAT_OPTION = "delete-chat-option";
var CSS_CLASS_CLONE_CHAT_OPTION = "clone-chat-option";
var CSS_CLASS_DANGER_OPTION = "danger-option";
var CSS_CLASS_MODEL_DISPLAY = "model-display";
var CSS_CLASS_ROLE_DISPLAY = "role-display";
var CSS_CLASS_INPUT_CONTROLS_CONTAINER = "input-controls-container";
var CSS_CLASS_INPUT_CONTROLS_LEFT = "input-controls-left";
var CSS_CLASS_INPUT_CONTROLS_RIGHT = "input-controls-right";
var CSS_CLASS_CHAT_LIST_SCROLLABLE = "chat-list-scrollable";
var CSS_CLASS_TEMPERATURE_INDICATOR = "temperature-indicator";
var CSS_CLASS_TOGGLE_LOCATION_BUTTON = "toggle-location-button";
var CSS_CLASS_TOGGLE_VIEW_LOCATION = "toggle-view-location-option";
var CHAT_LIST_MAX_HEIGHT = "250px";
var CSS_CLASS_REGENERATE_BUTTON = "regenerate-button";
var CSS_ROLE_PANEL = "ollama-role-panel";
var CSS_ROLE_PANEL_HEADER = "ollama-role-panel-header";
var CSS_ROLE_PANEL_LIST = "ollama-role-panel-list";
var CSS_ROLE_PANEL_ITEM = "ollama-role-panel-item";
var CSS_ROLE_PANEL_ITEM_ICON = "ollama-role-panel-item-icon";
var CSS_ROLE_PANEL_ITEM_TEXT = "ollama-role-panel-item-text";
var CSS_ROLE_PANEL_ITEM_ACTIVE = "is-active";
var CSS_ROLE_PANEL_ITEM_CUSTOM = "is-custom";
var CSS_ROLE_PANEL_ITEM_NONE = "ollama-role-panel-item-none";
var CSS_MAIN_CHAT_AREA = "ollama-main-chat-area";
var LANGUAGES = {
  af: "Afrikaans",
  sq: "Albanian",
  am: "Amharic",
  ar: "Arabic",
  hy: "Armenian",
  az: "Azerbaijani",
  eu: "Basque",
  be: "Belarusian",
  bn: "Bengali",
  bs: "Bosnian",
  bg: "Bulgarian",
  ca: "Catalan",
  ceb: "Cebuano",
  ny: "Chichewa",
  "zh-CN": "Chinese (Simplified)",
  "zh-TW": "Chinese (Traditional)",
  co: "Corsican",
  hr: "Croatian",
  cs: "Czech",
  da: "Danish",
  nl: "Dutch",
  en: "English",
  eo: "Esperanto",
  et: "Estonian",
  tl: "Filipino",
  fi: "Finnish",
  fr: "French",
  fy: "Frisian",
  gl: "Galician",
  ka: "Georgian",
  de: "German",
  el: "Greek",
  gu: "Gujarati",
  ht: "Haitian Creole",
  ha: "Hausa",
  haw: "Hawaiian",
  iw: "Hebrew",
  he: "Hebrew",
  hi: "Hindi",
  hmn: "Hmong",
  hu: "Hungarian",
  is: "Icelandic",
  ig: "Igbo",
  id: "Indonesian",
  ga: "Irish",
  it: "Italian",
  ja: "Japanese",
  jw: "Javanese",
  kn: "Kannada",
  kk: "Kazakh",
  km: "Khmer",
  rw: "Kinyarwanda",
  ko: "Korean",
  ku: "Kurdish (Kurmanji)",
  ky: "Kyrgyz",
  lo: "Lao",
  la: "Latin",
  lv: "Latvian",
  lt: "Lithuanian",
  lb: "Luxembourgish",
  mk: "Macedonian",
  mg: "Malagasy",
  ms: "Malay",
  ml: "Malayalam",
  mt: "Maltese",
  mi: "Maori",
  mr: "Marathi",
  mn: "Mongolian",
  my: "Myanmar (Burmese)",
  ne: "Nepali",
  no: "Norwegian",
  or: "Odia (Oriya)",
  ps: "Pashto",
  fa: "Persian",
  pl: "Polish",
  pt: "Portuguese",
  pa: "Punjabi",
  ro: "Romanian",
  ru: "Russian",
  sm: "Samoan",
  gd: "Scots Gaelic",
  sr: "Serbian",
  st: "Sesotho",
  sn: "Shona",
  sd: "Sindhi",
  si: "Sinhala",
  sk: "Slovak",
  sl: "Slovenian",
  so: "Somali",
  es: "Spanish",
  su: "Sundanese",
  sw: "Swahili",
  sv: "Swedish",
  tg: "Tajik",
  ta: "Tamil",
  tt: "Tatar",
  te: "Telugu",
  th: "Thai",
  tr: "Turkish",
  tk: "Turkmen",
  uk: "Ukrainian",
  ur: "Urdu",
  ug: "Uyghur",
  uz: "Uzbek",
  vi: "Vietnamese",
  cy: "Welsh",
  xh: "Xhosa",
  yi: "Yiddish",
  yo: "Yoruba",
  zu: "Zulu"
};
var OllamaView = class extends import_obsidian3.ItemView {
  // <--- НОВА ВЛАСТИВІСТЬ для списку чатів у панелі
  constructor(leaf, plugin) {
    super(leaf);
    // Кнопка в панелі (для десктопу)
    // --- State ---
    this.isProcessing = false;
    this.scrollTimeout = null;
    this.speechWorker = null;
    this.mediaRecorder = null;
    this.audioStream = null;
    this.emptyStateEl = null;
    this.resizeTimeout = null;
    this.currentMessages = [];
    this.lastRenderedMessageDate = null;
    this.newMessagesIndicatorEl = null;
    this.userScrolledUp = false;
    // Нова обгортка для чату та вводу
    this.lastProcessedChatId = null;
    // Допоміжна функція для створення підменю (з попереднього коду)
    this.createSubmenuSection = (title, icon, listContainerClass, sectionClass) => {
      const section = this.menuDropdown.createDiv();
      if (sectionClass)
        section.addClass(sectionClass);
      const header = section.createDiv({
        cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_MENU_HEADER_ITEM}`
      });
      (0, import_obsidian3.setIcon)(header.createSpan({ cls: "menu-option-icon" }), icon);
      header.createSpan({ cls: "menu-option-text", text: title });
      (0, import_obsidian3.setIcon)(
        header.createSpan({ cls: CSS_CLASS_SUBMENU_ICON }),
        "chevron-right"
      );
      const isChatList = listContainerClass === CSS_CLASS_CHAT_LIST_CONTAINER;
      const content = section.createDiv({
        cls: `${CSS_CLASS_SUBMENU_CONTENT} ${CSS_CLASS_SUBMENU_CONTENT_HIDDEN} ${listContainerClass} ${isChatList ? CSS_CLASS_CHAT_LIST_SCROLLABLE : ""}`
      });
      content.style.maxHeight = "0";
      content.style.overflow = "hidden";
      content.style.transition = "max-height 0.3s ease-out, padding 0.3s ease-out";
      content.style.paddingTop = "0";
      content.style.paddingBottom = "0";
      return { header, content, section };
    };
    //   public handleSettingsUpdated = async (): Promise<void> => {
    //     this.plugin.logger.debug("[OllamaView] handleSettingsUpdated called");
    //     const activeChat = await this.plugin.chatManager?.getActiveChat();
    //     const currentModelName = activeChat?.metadata?.modelName || this.plugin.settings.modelName;
    //     // Отримуємо ім'я поточної ролі (з чату або глобальних налаштувань)
    //     const currentRolePath = activeChat?.metadata?.selectedRolePath ?? this.plugin.settings.selectedRolePath;
    //     const currentRoleName = await this.plugin.findRoleNameByPath(currentRolePath); // Використовуємо хелпер
    //     const currentTemperature = activeChat?.metadata?.temperature ?? this.plugin.settings.temperature;
    //     this.updateModelDisplay(currentModelName);
    //     this.updateRoleDisplay(currentRoleName); // Оновлення маленького індикатора ролі
    //     this.updateInputPlaceholder(currentRoleName);
    //     this.updateTemperatureIndicator(currentTemperature);
    //     this.updateToggleViewLocationOption();
    //     this.updateToggleLocationButton();
    //     // --- Оновлюємо список у бічній панелі ---
    //     await this.updateRolePanelList();
    //     // --- Оновлюємо список у випадаючому меню (якщо воно використовується) ---
    //     if (this.isMenuOpen() && this.roleSubmenuContent && !this.roleSubmenuContent.classList.contains(CSS_CLASS_SUBMENU_CONTENT_HIDDEN)) {
    //          this.plugin.logger.debug("[handleSettingsUpdated] Role submenu open, refreshing role list menu.");
    //          await this.renderRoleList();
    //     }
    // }
    // Приклад для handleSettingsUpdated
    this.handleSettingsUpdated = async () => {
      var _a, _b, _c, _d, _e, _f;
      this.plugin.logger.debug(
        "[handleSettingsUpdated] Updating relevant UI elements directly..."
      );
      const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
      const currentModelName = ((_b = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _b.modelName) || this.plugin.settings.modelName;
      const currentRolePath = (_d = (_c = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _c.selectedRolePath) != null ? _d : this.plugin.settings.selectedRolePath;
      const currentRoleName = await this.plugin.findRoleNameByPath(
        currentRolePath
      );
      const currentTemperature = (_f = (_e = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _e.temperature) != null ? _f : this.plugin.settings.temperature;
      this.updateModelDisplay(currentModelName);
      this.updateRoleDisplay(currentRoleName);
      this.updateInputPlaceholder(currentRoleName);
      this.updateTemperatureIndicator(currentTemperature);
      await this.updateRolePanelList();
      this.updateToggleViewLocationOption();
      this.updateToggleLocationButton();
    };
    // --- Новий метод для рендерингу списку в ПАНЕЛІ ---
    this.updateRolePanelList = async () => {
      var _a, _b;
      if (!this.rolePanelListEl || !this.plugin.chatManager) {
        this.plugin.logger.debug(
          "[updateRolePanelList] Skipping update: Panel list element or chat manager not ready."
        );
        return;
      }
      this.plugin.logger.debug(
        "[updateRolePanelList] Updating role list in the side panel..."
      );
      this.rolePanelListEl.empty();
      try {
        const roles = await this.plugin.listRoleFiles(true);
        const activeChat = await this.plugin.chatManager.getActiveChat();
        const currentRolePath = (_b = (_a = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _a.selectedRolePath) != null ? _b : this.plugin.settings.selectedRolePath;
        this.plugin.logger.debug(
          `[updateRolePanelList] Current active role path for panel: ${currentRolePath || "None"}`
        );
        const noneOptionEl = this.rolePanelListEl.createDiv({
          cls: [CSS_ROLE_PANEL_ITEM, CSS_ROLE_PANEL_ITEM_NONE, "menu-option"]
        });
        const noneIconSpan = noneOptionEl.createSpan({
          cls: [CSS_ROLE_PANEL_ITEM_ICON, "menu-option-icon"]
        });
        noneOptionEl.createSpan({
          cls: [CSS_ROLE_PANEL_ITEM_TEXT, "menu-option-text"],
          text: "None (Default)"
        });
        if (!currentRolePath) {
          noneOptionEl.addClass(CSS_ROLE_PANEL_ITEM_ACTIVE);
          (0, import_obsidian3.setIcon)(noneIconSpan, "check");
        } else {
          (0, import_obsidian3.setIcon)(noneIconSpan, "slash");
        }
        this.registerDomEvent(
          noneOptionEl,
          "click",
          () => this.handleRolePanelItemClick(null, currentRolePath)
        );
        if (roles.length > 0) {
          this.rolePanelListEl.createEl("hr", { cls: "menu-separator" });
        }
        roles.forEach((roleInfo) => {
          const roleOptionEl = this.rolePanelListEl.createDiv({
            cls: [CSS_ROLE_PANEL_ITEM, "menu-option"]
          });
          const iconSpan = roleOptionEl.createSpan({
            cls: [CSS_ROLE_PANEL_ITEM_ICON, "menu-option-icon"]
          });
          roleOptionEl.createSpan({
            cls: [CSS_ROLE_PANEL_ITEM_TEXT, "menu-option-text"],
            text: roleInfo.name
          });
          if (roleInfo.isCustom) {
            roleOptionEl.addClass(CSS_ROLE_PANEL_ITEM_CUSTOM);
          }
          if (roleInfo.path === currentRolePath) {
            roleOptionEl.addClass(CSS_ROLE_PANEL_ITEM_ACTIVE);
            (0, import_obsidian3.setIcon)(iconSpan, "check");
          } else {
            (0, import_obsidian3.setIcon)(iconSpan, roleInfo.isCustom ? "user" : "file-text");
          }
          this.registerDomEvent(
            roleOptionEl,
            "click",
            () => this.handleRolePanelItemClick(roleInfo, currentRolePath)
          );
        });
        this.plugin.logger.debug(
          `[updateRolePanelList] Rendered ${roles.length + 1} role options in panel.`
        );
      } catch (error) {
        this.plugin.logger.error(
          "[updateRolePanelList] Error rendering role panel list:",
          error
        );
        this.rolePanelListEl.createDiv({
          text: "Error loading roles.",
          cls: "menu-error-text"
        });
      }
    };
    // --- Новий обробник кліку для ПАНЕЛІ ролей ---
    this.handleRolePanelItemClick = async (roleInfo, currentRolePath) => {
      var _a, _b, _c, _d, _e;
      const newRolePath = (_a = roleInfo == null ? void 0 : roleInfo.path) != null ? _a : "";
      const roleNameForEvent = (_b = roleInfo == null ? void 0 : roleInfo.name) != null ? _b : "None";
      this.plugin.logger.debug(
        `[handleRolePanelItemClick] Clicked role: ${roleNameForEvent} (Path: ${newRolePath || "None"})`
      );
      if (newRolePath !== currentRolePath) {
        const activeChat = await ((_c = this.plugin.chatManager) == null ? void 0 : _c.getActiveChat());
        try {
          if (activeChat) {
            this.plugin.logger.debug(
              `[handleRolePanelItemClick] Setting active role for chat ${activeChat.metadata.id} to: ${newRolePath || "None"}`
            );
            await this.plugin.chatManager.updateActiveChatMetadata({
              selectedRolePath: newRolePath
            });
          } else {
            this.plugin.logger.debug(
              `[handleRolePanelItemClick] No active chat. Setting global default role to: ${newRolePath || "None"}`
            );
            this.plugin.settings.selectedRolePath = newRolePath;
            await this.plugin.saveSettings();
            this.plugin.emit("role-changed", roleNameForEvent);
            (_e = (_d = this.plugin.promptService) == null ? void 0 : _d.clearRoleCache) == null ? void 0 : _e.call(_d);
          }
        } catch (error) {
          this.plugin.logger.error(
            `[handleRolePanelItemClick] Error setting role to ${newRolePath}:`,
            error
          );
          new import_obsidian3.Notice("Failed to set the role.");
        }
      } else {
        this.plugin.logger.debug(
          `[handleRolePanelItemClick] Clicked role is already active.`
        );
      }
    };
    this.handleModelDisplayClick = async (event) => {
      var _a, _b;
      const menu = new import_obsidian3.Menu();
      let itemsAdded = false;
      const loadingNotice = new import_obsidian3.Notice("Loading models...", 0);
      try {
        const models = await this.plugin.ollamaService.getModels();
        const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
        const currentModelName = ((_b = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _b.modelName) || this.plugin.settings.modelName;
        loadingNotice.hide();
        if (models.length === 0) {
          menu.addItem(
            (item) => item.setTitle("No models found").setDisabled(true)
          );
          itemsAdded = true;
        } else {
          models.forEach((modelName) => {
            menu.addItem(
              (item) => item.setTitle(modelName).setIcon(
                modelName === currentModelName ? "check" : "radio-button"
              ).onClick(async () => {
                var _a2, _b2;
                const chatToUpdate = await ((_a2 = this.plugin.chatManager) == null ? void 0 : _a2.getActiveChat());
                const latestModelName = ((_b2 = chatToUpdate == null ? void 0 : chatToUpdate.metadata) == null ? void 0 : _b2.modelName) || this.plugin.settings.modelName;
                if (modelName !== latestModelName) {
                  if (chatToUpdate) {
                    await this.plugin.chatManager.updateActiveChatMetadata({
                      modelName
                    });
                  } else {
                    new import_obsidian3.Notice("Cannot set model: No active chat.");
                  }
                }
              })
            );
            itemsAdded = true;
          });
        }
      } catch (error) {
        loadingNotice.hide();
        console.error("Error loading models for model selection menu:", error);
        menu.addItem(
          (item) => item.setTitle("Error loading models").setDisabled(true)
        );
        itemsAdded = true;
        new import_obsidian3.Notice("Failed to load models. Check Ollama connection.");
      } finally {
        if (itemsAdded) {
          menu.showAtMouseEvent(event);
        } else {
          console.warn("Model menu was not shown because no items were added.");
        }
      }
    };
    // --- Event Handlers ---
    // Input & Sending
    this.handleKeyDown = (e) => {
      var _a;
      if (e.key === "Enter" && !e.shiftKey && !this.isProcessing && !((_a = this.sendButton) == null ? void 0 : _a.disabled)) {
        e.preventDefault();
        this.sendMessage();
      }
    };
    this.handleSendClick = () => {
      var _a;
      if (!this.isProcessing && !((_a = this.sendButton) == null ? void 0 : _a.disabled)) {
        this.sendMessage();
      } else {
      }
    };
    this.handleInputForResize = () => {
      if (this.resizeTimeout)
        clearTimeout(this.resizeTimeout);
      this.resizeTimeout = setTimeout(() => {
        this.adjustTextareaHeight();
        this.updateSendButtonState();
      }, 75);
    };
    // Input Area Buttons
    this.handleVoiceClick = () => {
      this.toggleVoiceRecognition();
    };
    this.handleTranslateInputClick = async () => {
      const currentText = this.inputEl.value;
      const targetLang = "en";
      if (!currentText.trim()) {
        new import_obsidian3.Notice("Input empty...");
        return;
      }
      if (!this.plugin.settings.enableTranslation) {
        new import_obsidian3.Notice("Translation disabled...");
        return;
      }
      const apiKey = this.plugin.settings.googleTranslationApiKey;
      if (!apiKey) {
        new import_obsidian3.Notice("Translation API Key not set...");
        return;
      }
      (0, import_obsidian3.setIcon)(this.translateInputButton, "loader");
      this.translateInputButton.disabled = true;
      this.translateInputButton.classList.add(CSS_CLASS_TRANSLATING_INPUT);
      this.translateInputButton.title = "Translating...";
      try {
        const translatedText = await this.plugin.translationService.translate(
          currentText,
          targetLang
        );
        if (translatedText !== null) {
          this.inputEl.value = translatedText;
          this.inputEl.dispatchEvent(new Event("input"));
          this.inputEl.focus();
          const end = translatedText.length;
          this.inputEl.setSelectionRange(end, end);
        } else {
          console.warn("Input translation failed.");
        }
      } catch (error) {
        console.error("Input translation error:", error);
        new import_obsidian3.Notice("Input translation error.");
      } finally {
        (0, import_obsidian3.setIcon)(this.translateInputButton, "languages");
        this.translateInputButton.disabled = this.isProcessing;
        this.translateInputButton.classList.remove(CSS_CLASS_TRANSLATING_INPUT);
        this.translateInputButton.title = "Translate input to English";
      }
    };
    // Menu Button Click (Toggles Custom Div)
    this.handleMenuClick = (e) => {
      e.stopPropagation();
      if (!this.menuDropdown) {
        console.error("menuDropdown missing!");
        return;
      }
      const isHidden = this.menuDropdown.style.display === "none";
      if (isHidden) {
        this.menuDropdown.style.display = "block";
        this.collapseAllSubmenus(null);
      } else {
        this.closeMenu();
      }
    };
    // --- Action Handlers (Must call closeMenu) ---
    this.handleNewChatClick = async () => {
      this.closeMenu();
      try {
        const newChat = await this.plugin.chatManager.createNewChat();
        if (newChat) {
          new import_obsidian3.Notice(`Created new chat: ${newChat.metadata.name}`);
          this.focusInput();
        } else {
          new import_obsidian3.Notice("Failed to create new chat.");
        }
      } catch (error) {
        new import_obsidian3.Notice("Error creating new chat.");
      }
    };
    // У файлі src/OllamaView.ts
    this.handleRenameChatClick = async () => {
      var _a;
      this.closeMenu();
      const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
      if (!activeChat) {
        new import_obsidian3.Notice("No active chat to rename.");
        return;
      }
      const currentName = activeChat.metadata.name;
      const chatId = activeChat.metadata.id;
      new PromptModal(
        this.app,
        "Rename Chat",
        `Enter new name for "${currentName}":`,
        currentName,
        async (newName) => {
          let noticeMessage = "Rename cancelled or name unchanged.";
          const trimmedName = newName == null ? void 0 : newName.trim();
          if (trimmedName && trimmedName !== "" && trimmedName !== currentName) {
            this.plugin.logger.debug(
              `[OllamaView] Attempting rename for chat ${chatId} to "${trimmedName}" via updateActiveChatMetadata`
            );
            const success = await this.plugin.chatManager.updateActiveChatMetadata({
              name: trimmedName
            });
            this.plugin.logger.debug(
              `[handleRenameChatClick] updateActiveChatMetadata returned: ${success}`
            );
            if (success) {
              noticeMessage = `Chat renamed to "${trimmedName}"`;
              this.plugin.logger.info(
                `Chat ${chatId} rename initiated to "${trimmedName}".`
              );
              if (this.chatSubmenuContent && !this.chatSubmenuContent.classList.contains(
                CSS_CLASS_SUBMENU_CONTENT_HIDDEN
              )) {
                this.plugin.logger.info(
                  "[handleRenameChatClick] Forcing chat list menu refresh after rename completed."
                );
                await this.renderChatListMenu();
              } else {
                this.plugin.logger.debug(
                  "[handleRenameChatClick] Chat list submenu is closed after rename, not forcing refresh."
                );
              }
            } else {
              noticeMessage = "Failed to rename chat.";
              this.plugin.logger.error(
                `[OllamaView] Failed to rename chat ${chatId} using updateActiveChatMetadata.`
              );
            }
          } else if (trimmedName && trimmedName === currentName) {
            noticeMessage = "Name unchanged.";
          } else if (newName === null || trimmedName === "") {
            noticeMessage = "Rename cancelled or invalid name entered.";
          }
          new import_obsidian3.Notice(noticeMessage);
          this.focusInput();
        }
      ).open();
    };
    this.handleCloneChatClick = async () => {
      var _a;
      this.closeMenu();
      const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
      if (!activeChat) {
        new import_obsidian3.Notice("No active chat to clone.");
        return;
      }
      const originalName = activeChat.metadata.name;
      const cloningNotice = new import_obsidian3.Notice("Cloning chat...", 0);
      try {
        const clonedChat = await this.plugin.chatManager.cloneChat(
          activeChat.metadata.id
        );
        if (clonedChat) {
          new import_obsidian3.Notice(
            `Chat cloned as "${clonedChat.metadata.name}" and activated.`
          );
        } else {
          new import_obsidian3.Notice("Failed to clone chat.");
        }
      } catch (error) {
        new import_obsidian3.Notice("An error occurred while cloning the chat.");
      } finally {
        cloningNotice.hide();
      }
    };
    this.handleClearChatClick = async () => {
      var _a;
      this.closeMenu();
      const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
      if (activeChat) {
        const chatName = activeChat.metadata.name;
        new ConfirmModal(
          this.app,
          "Clear Chat Messages",
          `Are you sure you want to clear all messages in chat "${chatName}"?
This action cannot be undone.`,
          () => {
            this.plugin.chatManager.clearActiveChatMessages();
          }
        ).open();
      } else {
        new import_obsidian3.Notice("No active chat to clear.");
      }
    };
    this.handleDeleteChatClick = async () => {
      var _a;
      this.closeMenu();
      const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
      if (activeChat) {
        const chatName = activeChat.metadata.name;
        new ConfirmModal(
          this.app,
          "Delete Chat",
          `Are you sure you want to delete chat "${chatName}"?
This action cannot be undone.`,
          async () => {
            const success = await this.plugin.chatManager.deleteChat(
              activeChat.metadata.id
            );
            if (success) {
              new import_obsidian3.Notice(`Chat "${chatName}" deleted.`);
            } else {
              new import_obsidian3.Notice(`Failed to delete chat "${chatName}".`);
            }
          }
        ).open();
      } else {
        new import_obsidian3.Notice("No active chat to delete.");
      }
    };
    // Цей обробник події викликається при натисканні на "Export to Note"
    this.handleExportChatClick = async () => {
      var _a, _b;
      this.closeMenu();
      const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
      if (!activeChat || activeChat.messages.length === 0) {
        new import_obsidian3.Notice("Chat empty, nothing to export.");
        return;
      }
      try {
        const markdownContent = this.formatChatToMarkdown(activeChat.messages);
        const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
        const safeName = activeChat.metadata.name.replace(/[\\/?:*"<>|]/g, "-");
        const filename = `ollama-chat-${safeName}-${timestamp}.md`;
        let targetFolderPath = (_b = this.plugin.settings.chatExportFolderPath) == null ? void 0 : _b.trim();
        let targetFolder = null;
        if (targetFolderPath) {
          targetFolderPath = (0, import_obsidian3.normalizePath)(targetFolderPath);
          const abstractFile = this.app.vault.getAbstractFileByPath(targetFolderPath);
          if (!abstractFile) {
            try {
              await this.app.vault.createFolder(targetFolderPath);
              targetFolder = this.app.vault.getAbstractFileByPath(
                targetFolderPath
              );
              if (targetFolder) {
                new import_obsidian3.Notice(`Created export folder: ${targetFolderPath}`);
              } else {
                this.plugin.logger.error(
                  "Failed to get folder even after creation attempt:",
                  targetFolderPath
                );
                new import_obsidian3.Notice(`Error creating export folder. Saving to vault root.`);
                targetFolder = this.app.vault.getRoot();
              }
            } catch (err) {
              this.plugin.logger.error("Error creating export folder:", err);
              new import_obsidian3.Notice(`Error creating export folder. Saving to vault root.`);
              targetFolder = this.app.vault.getRoot();
            }
          } else if (abstractFile instanceof import_obsidian3.TFolder) {
            targetFolder = abstractFile;
          } else {
            new import_obsidian3.Notice(
              `Error: Export path is not a folder. Saving to vault root.`
            );
            targetFolder = this.app.vault.getRoot();
          }
        } else {
          targetFolder = this.app.vault.getRoot();
        }
        if (!targetFolder) {
          this.plugin.logger.error(
            "Failed to determine a valid target folder for export."
          );
          new import_obsidian3.Notice("Error determining export folder. Cannot save file.");
          return;
        }
        const filePath = (0, import_obsidian3.normalizePath)(`${targetFolder.path}/${filename}`);
        const existingFile = this.app.vault.getAbstractFileByPath(filePath);
        if (existingFile) {
        }
        const file = await this.app.vault.create(filePath, markdownContent);
        new import_obsidian3.Notice(`Chat exported to ${file.path}`);
      } catch (error) {
        this.plugin.logger.error("Error exporting chat:", error);
        if (error instanceof Error && error.message.includes("File already exists")) {
          new import_obsidian3.Notice("Error exporting chat: File already exists.");
        } else {
          new import_obsidian3.Notice("An unexpected error occurred during chat export.");
        }
      }
    };
    this.handleSettingsClick = async () => {
      var _a, _b, _c, _d;
      this.closeMenu();
      (_b = (_a = this.app.setting) == null ? void 0 : _a.open) == null ? void 0 : _b.call(_a);
      (_d = (_c = this.app.setting) == null ? void 0 : _c.openTabById) == null ? void 0 : _d.call(_c, this.plugin.manifest.id);
    };
    this.handleDocumentClickForMenu = (e) => {
      var _a, _b;
      if (this.isMenuOpen() && !((_a = this.menuButton) == null ? void 0 : _a.contains(e.target)) && !((_b = this.menuDropdown) == null ? void 0 : _b.contains(e.target))) {
        this.closeMenu();
      }
    };
    // Plugin Event Handlers
    this.handleModelChange = (modelName) => {
      var _a;
      this.updateModelDisplay(modelName);
      (_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat().then((chat) => {
        var _a2, _b;
        const temp = (_b = (_a2 = chat == null ? void 0 : chat.metadata) == null ? void 0 : _a2.temperature) != null ? _b : this.plugin.settings.temperature;
        this.updateTemperatureIndicator(temp);
      });
      if (this.currentMessages.length > 0) {
        this.addMessageToDisplay(
          "system",
          `Model changed to: ${modelName}`,
          new Date()
        );
      }
    };
    this.handleRoleChange = (roleName) => {
      const displayRole = roleName || "None";
      this.updateInputPlaceholder(displayRole);
      this.updateRoleDisplay(displayRole);
      if (this.currentMessages.length > 0) {
        this.addMessageToDisplay(
          "system",
          `Role changed to: ${displayRole}`,
          new Date()
        );
      } else {
        new import_obsidian3.Notice(`Role set to: ${displayRole}`);
      }
    };
    this.handleRolesUpdated = () => {
      var _a;
      (_a = this.plugin.promptService) == null ? void 0 : _a.clearRoleCache();
      if (this.isMenuOpen()) {
        this.renderRoleList();
      }
    };
    // OllamaView.ts
    this.handleChatListUpdated = () => {
      this.plugin.logger.info(
        "[handleChatListUpdated] Received 'chat-list-updated' event."
      );
      const menuOpen = this.isMenuOpen();
      this.plugin.logger.debug(`[handleChatListUpdated] Is dropdown menu open? ${menuOpen}`);
      if (menuOpen) {
        const isChatSubmenuVisible = this.chatSubmenuContent && !this.chatSubmenuContent.classList.contains(
          CSS_CLASS_SUBMENU_CONTENT_HIDDEN
        );
        this.plugin.logger.debug(`[handleChatListUpdated] Is chat submenu visible? ${isChatSubmenuVisible}`);
        if (isChatSubmenuVisible) {
          this.plugin.logger.info(
            "[handleChatListUpdated] Dropdown menu and chat submenu are open, calling renderChatListMenu()."
          );
          this.renderChatListMenu().catch((error) => {
            this.plugin.logger.error("[handleChatListUpdated] Error rendering chat list menu:", error);
          });
        } else {
          this.plugin.logger.debug(
            "[handleChatListUpdated] Dropdown menu is open, but chat submenu is collapsed. Not re-rendering dropdown list."
          );
        }
      } else {
        this.plugin.logger.debug(
          "[handleChatListUpdated] Dropdown menu is closed. Not re-rendering dropdown list."
        );
      }
      this.plugin.logger.info("[handleChatListUpdated] Updating chat panel list.");
      this.updateChatPanelList().catch((error) => {
        this.plugin.logger.error("[handleChatListUpdated] Error updating chat panel list:", error);
      });
    };
    //   private handleActiveChatChanged = (data: { chatId: string | null, chat: Chat | null }): void => {
    //     this.plugin.logger.debug(`[OllamaView] Active chat changed event received. New ID: ${data.chatId}`);
    //     this.loadAndDisplayActiveChat(); // Цей метод тепер має оновити все, включаючи панель ролей
    //     // Додатково оновити список ролей у випадаючому меню, якщо воно відкрите
    //     if (this.isMenuOpen() && this.roleSubmenuContent && !this.roleSubmenuContent.classList.contains(CSS_CLASS_SUBMENU_CONTENT_HIDDEN)) {
    //         this.plugin.logger.debug("[OllamaView] Active chat changed, role submenu open, refreshing role list menu.");
    //         this.renderRoleList(); // Оновлення списку в меню
    //     }
    // }
    // В src/OllamaView.ts
    // OllamaView.ts
    this.handleActiveChatChanged = async (data) => {
      var _a, _b, _c, _d, _e;
      this.plugin.logger.debug(`[handleActiveChatChanged] Event received. New ID: ${data.chatId}, Previous processed ID: ${this.lastProcessedChatId}`);
      const chatSwitched = data.chatId !== this.lastProcessedChatId;
      const previousChatId = this.lastProcessedChatId;
      this.lastProcessedChatId = data.chatId;
      if (chatSwitched) {
        this.plugin.logger.info(`[handleActiveChatChanged] Chat switched from ${previousChatId} to ${data.chatId}. Reloading view via loadAndDisplayActiveChat.`);
        await this.loadAndDisplayActiveChat();
      } else if (data.chatId !== null && data.chat !== null) {
        this.plugin.logger.info(`[handleActiveChatChanged] Active chat metadata changed (ID: ${data.chatId}). Updating UI elements directly.`);
        const activeChat = data.chat;
        const currentModelName = ((_a = activeChat.metadata) == null ? void 0 : _a.modelName) || this.plugin.settings.modelName;
        const currentRolePath = (_c = (_b = activeChat.metadata) == null ? void 0 : _b.selectedRolePath) != null ? _c : this.plugin.settings.selectedRolePath;
        const currentRoleName = await this.findRoleNameByPath(currentRolePath);
        const currentTemperature = (_e = (_d = activeChat.metadata) == null ? void 0 : _d.temperature) != null ? _e : this.plugin.settings.temperature;
        this.plugin.logger.debug(`[handleActiveChatChanged] Updating display: Model=${currentModelName}, Role=${currentRoleName}, Temp=${currentTemperature}`);
        this.updateModelDisplay(currentModelName);
        this.updateRoleDisplay(currentRoleName);
        this.updateInputPlaceholder(currentRoleName);
        this.updateTemperatureIndicator(currentTemperature);
        const panelUpdatePromises = [
          this.updateChatPanelList().catch((e) => this.plugin.logger.error("Error updating chat panel list:", e)),
          this.updateRolePanelList().catch((e) => this.plugin.logger.error("Error updating role panel list:", e))
        ];
        await Promise.all(panelUpdatePromises);
        this.plugin.logger.debug("[handleActiveChatChanged] Side panel lists updated for metadata change.");
      } else {
        if (data.chatId === null && previousChatId !== null) {
          this.plugin.logger.info(`[handleActiveChatChanged] Active chat explicitly set to null. Reloading view.`);
          await this.loadAndDisplayActiveChat();
        } else if (data.chatId !== null && data.chat === null) {
          this.plugin.logger.warn(`[handleActiveChatChanged] Received metadata change event for chat ${data.chatId}, but chat data was null. Reloading view as a fallback.`);
          await this.loadAndDisplayActiveChat();
        } else {
          this.plugin.logger.debug(`[handleActiveChatChanged] Unhandled case or no actual change (e.g., null -> null). chatId: ${data.chatId}. Updating panels as a precaution.`);
          const panelUpdatePromises = [
            this.updateChatPanelList().catch((e) => this.plugin.logger.error("Error updating chat panel list:", e)),
            this.updateRolePanelList().catch((e) => this.plugin.logger.error("Error updating role panel list:", e))
          ];
          await Promise.all(panelUpdatePromises);
        }
      }
      if (this.isMenuOpen() && this.roleSubmenuContent && !this.roleSubmenuContent.classList.contains(CSS_CLASS_SUBMENU_CONTENT_HIDDEN)) {
        this.plugin.logger.debug("[handleActiveChatChanged] Role submenu open, refreshing role list menu.");
        this.renderRoleList().catch((error) => {
          this.plugin.logger.error("[handleActiveChatChanged] Error rendering role list menu:", error);
        });
      }
      this.plugin.logger.debug(`[handleActiveChatChanged] Finished processing event for chat ID: ${data.chatId}`);
    };
    this.handleMessageAdded = (data) => {
      var _a;
      if (data.chatId === ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChatId())) {
        this.addMessageToDisplay(
          data.message.role,
          data.message.content,
          data.message.timestamp
        );
        if (this.isMenuOpen()) {
          this.renderChatListMenu();
        }
      }
    };
    // Refresh list date if open
    this.handleMessagesCleared = (chatId) => {
      var _a;
      if (chatId === ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChatId())) {
        console.log("[OllamaView] Messages cleared event received.");
        this.clearChatContainerInternal();
        this.currentMessages = [];
        this.showEmptyState();
      }
    };
    // --- Window/Workspace State Handlers ---
    this.handleVisibilityChange = () => {
      if (document.visibilityState === "visible" && this.leaf.view === this) {
        requestAnimationFrame(() => {
          var _a;
          this.guaranteedScrollToBottom(50, true);
          this.adjustTextareaHeight();
          (_a = this.inputEl) == null ? void 0 : _a.focus();
        });
      }
    };
    this.handleActiveLeafChange = (leaf) => {
      var _a;
      if ((leaf == null ? void 0 : leaf.view) === this) {
        (_a = this.inputEl) == null ? void 0 : _a.focus();
        setTimeout(() => this.guaranteedScrollToBottom(150, true), 100);
      }
    };
    this.handleWindowResize = () => {
      if (this.resizeTimeout)
        clearTimeout(this.resizeTimeout);
      this.resizeTimeout = setTimeout(() => this.adjustTextareaHeight(), 100);
    };
    // --- Scroll Handling ---
    this.handleScroll = () => {
      if (!this.chatContainer || !this.newMessagesIndicatorEl)
        return;
      const threshold = 150;
      const atBottom = this.chatContainer.scrollHeight - this.chatContainer.scrollTop - this.chatContainer.clientHeight < threshold;
      const previousScrolledUp = this.userScrolledUp;
      this.userScrolledUp = !atBottom;
      if (previousScrolledUp && atBottom) {
        this.newMessagesIndicatorEl.classList.remove(CSS_CLASS_VISIBLE);
      }
    };
    this.handleNewMessageIndicatorClick = () => {
      var _a;
      if (this.chatContainer) {
        this.chatContainer.scrollTo({
          top: this.chatContainer.scrollHeight,
          behavior: "smooth"
        });
      }
      (_a = this.newMessagesIndicatorEl) == null ? void 0 : _a.classList.remove(CSS_CLASS_VISIBLE);
      this.userScrolledUp = false;
    };
    // private adjustTextareaHeight = (): void => {
    //   requestAnimationFrame(() => { // Кадр 1: Скидання
    //     if (!this.inputEl) return;
    //     const textarea = this.inputEl;
    //     const originalMinHeightStyle = textarea.style.minHeight;
    //     // Скидаємо height та inline min-height для коректного вимірювання
    //     textarea.style.height = 'auto';
    //     textarea.style.minHeight = '0'; // Повністю скидаємо inline min-height
    //     requestAnimationFrame(() => { // Кадр 2: Вимірювання та встановлення
    //       if (!this.inputEl) return;
    //       const computedStyle = window.getComputedStyle(textarea);
    //       // Читаємо базовий min-height (з CSS) та max-height
    //       const baseMinHeight = parseFloat(computedStyle.minHeight) || 40;
    //       const maxHeight = parseFloat(computedStyle.maxHeight);
    //       // Вимірюємо scrollHeight ПІСЛЯ скидання
    //       const scrollHeight = textarea.scrollHeight;
    //       // Обчислюємо цільову min-height, використовуючи базовий min-height з CSS
    //       let targetMinHeight = Math.max(baseMinHeight, scrollHeight);
    //       // Застосовуємо обмеження max-height
    //       if (!isNaN(maxHeight) && targetMinHeight > maxHeight) {
    //         targetMinHeight = maxHeight;
    //         // Переконуємося, що overflow увімкнено при досягненні межі
    //         if (textarea.style.overflowY !== 'auto' && textarea.style.overflowY !== 'scroll') {
    //           textarea.style.overflowY = 'auto';
    //         }
    //       } else {
    //         // Вимикаємо overflow, якщо не досягли межі
    //         if (textarea.style.overflowY === 'auto' || textarea.style.overflowY === 'scroll') {
    //           textarea.style.overflowY = 'hidden'; // Або '' для повернення до CSS за замовчуванням
    //         }
    //       }
    //       // Встановлюємо обчислену min-height та height: auto
    //       textarea.style.minHeight = `${targetMinHeight}px`;
    //       textarea.style.height = 'auto'; // Дозволяємо висоті слідувати за min-height
    //     });
    //   });
    // }
    this.adjustTextareaHeight = () => {
      requestAnimationFrame(() => {
        if (!this.inputEl)
          return;
        const textarea = this.inputEl;
        const computedStyle = window.getComputedStyle(textarea);
        const baseMinHeight = parseFloat(computedStyle.minHeight) || 40;
        const maxHeight = parseFloat(computedStyle.maxHeight);
        const currentScrollTop = textarea.scrollTop;
        textarea.style.height = "auto";
        const scrollHeight = textarea.scrollHeight;
        let targetHeight = Math.max(baseMinHeight, scrollHeight);
        let applyOverflow = false;
        if (!isNaN(maxHeight) && targetHeight > maxHeight) {
          targetHeight = maxHeight;
          applyOverflow = true;
        }
        textarea.style.height = `${targetHeight}px`;
        textarea.style.overflowY = applyOverflow ? "auto" : "hidden";
        textarea.scrollTop = currentScrollTop;
        this.plugin.logger.debug(
          `[AdjustHeight] scrollH: ${scrollHeight}, baseMin: ${baseMinHeight}, targetH: ${targetHeight}, overflow: ${applyOverflow}`
        );
      });
    };
    this.handleRoleDisplayClick = async (event) => {
      var _a, _b, _c;
      const menu = new import_obsidian3.Menu();
      let itemsAdded = false;
      try {
        const roles = await this.plugin.listRoleFiles(true);
        const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
        const currentRolePath = (_c = (_b = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _b.selectedRolePath) != null ? _c : this.plugin.settings.selectedRolePath;
        menu.addItem((item) => {
          item.setTitle("None").setIcon(!currentRolePath ? "check" : "slash").onClick(async () => {
            var _a2, _b2;
            const newRolePath = "";
            if (currentRolePath !== newRolePath) {
              if (activeChat) {
                await this.plugin.chatManager.updateActiveChatMetadata({
                  selectedRolePath: newRolePath
                });
              } else {
                this.plugin.settings.selectedRolePath = newRolePath;
                await this.plugin.saveSettings();
                this.plugin.emit("role-changed", "None");
                (_b2 = (_a2 = this.plugin.promptService) == null ? void 0 : _a2.clearRoleCache) == null ? void 0 : _b2.call(_a2);
              }
            }
          });
          itemsAdded = true;
        });
        if (roles.length > 0) {
          menu.addSeparator();
          itemsAdded = true;
        }
        roles.forEach((roleInfo) => {
          menu.addItem((item) => {
            item.setTitle(roleInfo.name).setIcon(
              roleInfo.path === currentRolePath ? "check" : roleInfo.isCustom ? "user" : "file-text"
            ).onClick(async () => {
              var _a2, _b2;
              const newRolePath = roleInfo.path;
              if (currentRolePath !== newRolePath) {
                if (activeChat) {
                  await this.plugin.chatManager.updateActiveChatMetadata({
                    selectedRolePath: newRolePath
                  });
                } else {
                  this.plugin.settings.selectedRolePath = newRolePath;
                  await this.plugin.saveSettings();
                  this.plugin.emit("role-changed", roleInfo.name);
                  (_b2 = (_a2 = this.plugin.promptService) == null ? void 0 : _a2.clearRoleCache) == null ? void 0 : _b2.call(_a2);
                }
              }
            });
            itemsAdded = true;
          });
        });
      } catch (error) {
        console.error("Error loading roles for role selection menu:", error);
        if (!itemsAdded) {
          menu.addItem(
            (item) => item.setTitle("Error loading roles").setDisabled(true)
          );
          itemsAdded = true;
        }
        new import_obsidian3.Notice("Failed to load roles.");
      } finally {
        if (itemsAdded) {
          menu.showAtMouseEvent(event);
        } else {
        }
      }
    };
    this.handleTemperatureClick = async () => {
      var _a, _b;
      const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
      if (!activeChat) {
        new import_obsidian3.Notice("Select or create a chat to change temperature.");
        return;
      }
      const currentTemp = (_b = activeChat.metadata.temperature) != null ? _b : this.plugin.settings.temperature;
      const currentTempString = currentTemp !== null && currentTemp !== void 0 ? String(currentTemp) : "";
      new PromptModal(
        this.app,
        "Set Temperature",
        `Enter new temperature (e.g., 0.7). Higher values = more creative, lower = more focused.`,
        currentTempString,
        // Попередньо заповнюємо поточним значенням
        async (newValue) => {
          if (newValue === null || newValue.trim() === "") {
            new import_obsidian3.Notice("Temperature change cancelled.");
            return;
          }
          const newTemp = parseFloat(newValue.trim());
          if (isNaN(newTemp) || newTemp < 0 || newTemp > 2) {
            new import_obsidian3.Notice(
              "Invalid temperature. Please enter a number between 0.0 and 2.0.",
              4e3
            );
            return;
          }
          try {
            await this.plugin.chatManager.updateActiveChatMetadata({
              temperature: newTemp
            });
            this.updateTemperatureIndicator(newTemp);
            new import_obsidian3.Notice(
              `Temperature set to ${newTemp} for chat "${activeChat.metadata.name}".`
            );
          } catch (error) {
            this.plugin.logger.error("Failed to update chat temperature:", error);
            new import_obsidian3.Notice("Error setting temperature.");
          }
        }
      ).open();
    };
    // --- Новий обробник кліку для перемикання ---
    this.handleToggleViewLocationClick = async () => {
      this.closeMenu();
      const currentSetting = this.plugin.settings.openChatInTab;
      const newSetting = !currentSetting;
      this.plugin.settings.openChatInTab = newSetting;
      await this.plugin.saveSettings();
      this.app.workspace.detachLeavesOfType(VIEW_TYPE_OLLAMA_PERSONAS);
      setTimeout(() => {
        this.plugin.logger.debug("Re-activating view with new setting...");
        this.plugin.activateView();
      }, 50);
    };
    this.updateChatPanelList = async () => {
      if (!this.chatPanelListEl || !this.plugin.chatManager) {
        this.plugin.logger.debug("[updateChatPanelList] Skipping update: Chat panel list element or chat manager not ready.");
        return;
      }
      this.plugin.logger.debug("[updateChatPanelList] Updating chat list in the side panel...");
      this.chatPanelListEl.empty();
      try {
        const chats = this.plugin.chatManager.listAvailableChats() || [];
        const currentActiveId = this.plugin.chatManager.getActiveChatId();
        this.plugin.logger.debug(`[updateChatPanelList] Fetched ${chats.length} chats. Active ID: ${currentActiveId}`);
        if (chats.length === 0) {
          this.chatPanelListEl.createDiv({
            cls: "menu-info-text",
            // Можна перевикористати стиль
            text: "No saved chats yet."
          });
          this.plugin.logger.debug("[updateChatPanelList] Rendered 'No saved chats yet.' message.");
          return;
        }
        chats.sort((a, b) => Number(b.lastModified) - Number(a.lastModified));
        chats.forEach((chatMeta) => {
          const chatOptionEl = this.chatPanelListEl.createDiv({ cls: [CSS_ROLE_PANEL_ITEM, "menu-option", "ollama-chat-panel-item"] });
          const iconSpan = chatOptionEl.createSpan({ cls: [CSS_ROLE_PANEL_ITEM_ICON, "menu-option-icon"] });
          const textSpan = chatOptionEl.createSpan({ cls: [CSS_ROLE_PANEL_ITEM_TEXT, "menu-option-text"] });
          textSpan.createDiv({ cls: "chat-panel-item-name", text: chatMeta.name });
          textSpan.createDiv({ cls: "chat-panel-item-date", text: this.formatRelativeDate(new Date(Number(chatMeta.lastModified))) });
          if (chatMeta.id === currentActiveId) {
            chatOptionEl.addClass(CSS_ROLE_PANEL_ITEM_ACTIVE);
            (0, import_obsidian3.setIcon)(iconSpan, "check");
          } else {
            (0, import_obsidian3.setIcon)(iconSpan, "message-square");
          }
          this.registerDomEvent(chatOptionEl, "click", async () => {
            var _a;
            if (chatMeta.id !== ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChatId())) {
              this.plugin.logger.debug(`[updateChatPanelList] Activating chat ID: ${chatMeta.id} from panel click.`);
              await this.plugin.chatManager.setActiveChat(chatMeta.id);
            } else {
              this.plugin.logger.debug(`[updateChatPanelList] Clicked already active chat ID: ${chatMeta.id}. No action.`);
            }
          });
        });
        this.plugin.logger.debug(`[updateChatPanelList] Rendered ${chats.length} chat options in panel.`);
      } catch (error) {
        this.plugin.logger.error("[updateChatPanelList] Error rendering chat panel list:", error);
        this.chatPanelListEl.createDiv({ text: "Error loading chats.", cls: "menu-error-text" });
      }
    };
    this.plugin = plugin;
    this.initSpeechWorker();
    this.scrollListenerDebounced = (0, import_obsidian3.debounce)(this.handleScroll, 150, true);
  }
  // --- Getters ---
  /** Checks if the custom menu dropdown is currently visible */
  isMenuOpen() {
    return !!this.menuDropdown && this.menuDropdown.style.display === "block";
  }
  // --- Obsidian View Methods ---
  getViewType() {
    return VIEW_TYPE_OLLAMA_PERSONAS;
  }
  getDisplayText() {
    return "AI Forge";
  }
  getIcon() {
    return "brain-circuit";
  }
  async onOpen() {
    this.plugin.logger.debug("[OllamaView] onOpen started.");
    this.createUIElements();
    try {
      const initialRolePath = this.plugin.settings.selectedRolePath;
      const initialRoleName = await this.findRoleNameByPath(initialRolePath);
      this.updateInputPlaceholder(initialRoleName);
      this.updateRoleDisplay(initialRoleName);
      this.updateModelDisplay(this.plugin.settings.modelName);
      this.updateTemperatureIndicator(this.plugin.settings.temperature);
      this.plugin.logger.debug(
        "[OllamaView] Initial UI elements updated based on settings."
      );
    } catch (error) {
      this.plugin.logger.error(
        "[OllamaView] Error during initial UI update in onOpen:",
        error
      );
    }
    this.attachEventListeners();
    this.autoResizeTextarea();
    this.updateSendButtonState();
    try {
      this.plugin.logger.debug(
        "[OllamaView] Calling loadAndDisplayActiveChat from onOpen..."
      );
      await this.loadAndDisplayActiveChat();
      this.plugin.logger.debug(
        "[OllamaView] loadAndDisplayActiveChat completed successfully in onOpen."
      );
    } catch (error) {
      this.plugin.logger.error(
        "[OllamaView] Error during initial chat load in onOpen:",
        error
      );
      this.showEmptyState();
      try {
        this.plugin.logger.debug(
          "[OllamaView] Updating role panel list in onOpen catch block..."
        );
        await this.updateRolePanelList();
        this.plugin.logger.debug(
          "[OllamaView] Role panel list updated in onOpen catch block."
        );
      } catch (panelError) {
        this.plugin.logger.error(
          "[OllamaView] Error updating role panel list in onOpen catch block:",
          panelError
        );
      }
    }
    setTimeout(() => {
      var _a;
      (_a = this.inputEl) == null ? void 0 : _a.focus();
      this.plugin.logger.debug("[OllamaView] Input focused in onOpen.");
    }, 150);
    if (this.inputEl) {
      this.inputEl.dispatchEvent(new Event("input"));
    }
    this.plugin.logger.debug("[OllamaView] onOpen finished.");
  }
  async onClose() {
    if (this.speechWorker) {
      this.speechWorker.terminate();
      this.speechWorker = null;
    }
    this.stopVoiceRecording(false);
    if (this.audioStream) {
      this.audioStream.getTracks().forEach((t) => t.stop());
      this.audioStream = null;
    }
    if (this.scrollTimeout)
      clearTimeout(this.scrollTimeout);
    if (this.resizeTimeout)
      clearTimeout(this.resizeTimeout);
  }
  // --- UI Creation (with Custom Div Menu & Accordion) ---
  createUIElements() {
    this.contentEl.empty();
    const flexContainer = this.contentEl.createDiv({
      cls: CSS_CLASS_CONTAINER
    });
    this.rolePanelEl = flexContainer.createDiv({ cls: CSS_ROLE_PANEL });
    this.rolePanelEl.createEl("h4", {
      text: "Chats",
      cls: CSS_ROLE_PANEL_HEADER
    });
    this.chatPanelListEl = this.rolePanelEl.createDiv({
      cls: [CSS_ROLE_PANEL_LIST, "ollama-chat-panel-list"]
    });
    this.rolePanelEl.createEl("hr", { cls: "menu-separator" });
    this.rolePanelEl.createEl("h4", {
      text: "Roles",
      cls: CSS_ROLE_PANEL_HEADER
    });
    this.rolePanelListEl = this.rolePanelEl.createDiv({
      cls: CSS_ROLE_PANEL_LIST
    });
    this.mainChatAreaEl = flexContainer.createDiv({ cls: CSS_MAIN_CHAT_AREA });
    this.chatContainerEl = this.mainChatAreaEl.createDiv({
      cls: "ollama-chat-area-content"
    });
    this.chatContainer = this.chatContainerEl.createDiv({
      cls: CSS_CLASS_CHAT_CONTAINER
    });
    this.newMessagesIndicatorEl = this.chatContainerEl.createDiv({
      cls: CSS_CLASS_NEW_MESSAGE_INDICATOR
    });
    (0, import_obsidian3.setIcon)(
      this.newMessagesIndicatorEl.createSpan({ cls: "indicator-icon" }),
      "arrow-down"
    );
    this.newMessagesIndicatorEl.createSpan({ text: " New Messages" });
    const inputContainer = this.mainChatAreaEl.createDiv({
      cls: CSS_CLASS_INPUT_CONTAINER
    });
    this.inputEl = inputContainer.createEl("textarea", {
      attr: { placeholder: `Text...`, rows: 1 }
    });
    const controlsContainer = inputContainer.createDiv({
      cls: CSS_CLASS_INPUT_CONTROLS_CONTAINER
    });
    const leftControls = controlsContainer.createDiv({
      cls: CSS_CLASS_INPUT_CONTROLS_LEFT
    });
    this.translateInputButton = leftControls.createEl("button", {
      cls: CSS_CLASS_TRANSLATE_INPUT_BUTTON,
      attr: { "aria-label": "Translate input to English" }
    });
    (0, import_obsidian3.setIcon)(this.translateInputButton, "languages");
    this.translateInputButton.title = "Translate input to English";
    this.modelDisplayEl = leftControls.createDiv({
      cls: CSS_CLASS_MODEL_DISPLAY
    });
    this.modelDisplayEl.setText("...");
    this.modelDisplayEl.title = "Click to select model";
    this.roleDisplayEl = leftControls.createDiv({
      cls: CSS_CLASS_ROLE_DISPLAY
    });
    this.roleDisplayEl.setText("...");
    this.roleDisplayEl.title = "Click to select role";
    this.temperatureIndicatorEl = leftControls.createDiv({
      cls: CSS_CLASS_TEMPERATURE_INDICATOR
    });
    this.temperatureIndicatorEl.setText("?");
    this.temperatureIndicatorEl.title = "Click to set temperature";
    this.buttonsContainer = controlsContainer.createDiv({
      cls: `${CSS_CLASS_BUTTONS_CONTAINER} ${CSS_CLASS_INPUT_CONTROLS_RIGHT}`
    });
    this.sendButton = this.buttonsContainer.createEl("button", {
      cls: CSS_CLASS_SEND_BUTTON,
      attr: { "aria-label": "Send" }
    });
    (0, import_obsidian3.setIcon)(this.sendButton, "send");
    this.voiceButton = this.buttonsContainer.createEl("button", {
      cls: CSS_CLASS_VOICE_BUTTON,
      attr: { "aria-label": "Voice Input" }
    });
    (0, import_obsidian3.setIcon)(this.voiceButton, "mic");
    this.toggleLocationButton = this.buttonsContainer.createEl("button", {
      cls: CSS_CLASS_TOGGLE_LOCATION_BUTTON,
      attr: { "aria-label": "Toggle View Location" }
    });
    this.menuButton = this.buttonsContainer.createEl("button", {
      cls: CSS_CLASS_MENU_BUTTON,
      attr: { "aria-label": "Menu" }
    });
    (0, import_obsidian3.setIcon)(this.menuButton, "more-vertical");
    this.updateToggleLocationButton();
    this.menuDropdown = inputContainer.createEl("div", {
      cls: [CSS_CLASS_MENU_DROPDOWN, "ollama-chat-menu"]
    });
    const roleSection = this.createSubmenuSection(
      "Select Role",
      "users",
      CSS_CLASS_ROLE_LIST_CONTAINER,
      "role-submenu-section"
    );
    this.roleSubmenuHeader = roleSection.header;
    this.roleSubmenuContent = roleSection.content;
    this.menuDropdown.style.display = "none";
    const modelSection = this.createSubmenuSection(
      "Select Model",
      "list-collapse",
      CSS_CLASS_MODEL_LIST_CONTAINER,
      "model-submenu-section"
    );
    this.modelSubmenuHeader = modelSection.header;
    this.modelSubmenuContent = modelSection.content;
    const chatSection = this.createSubmenuSection(
      "Load Chat",
      "messages-square",
      CSS_CLASS_CHAT_LIST_CONTAINER
    );
    this.chatSubmenuHeader = chatSection.header;
    this.chatSubmenuContent = chatSection.content;
    this.menuDropdown.createEl("hr", { cls: CSS_CLASS_MENU_SEPARATOR });
    this.menuDropdown.createEl("div", {
      text: "Actions",
      cls: CSS_CLASS_MENU_HEADER
    });
    this.newChatOption = this.menuDropdown.createEl("div", {
      cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_NEW_CHAT_OPTION}`
    });
    (0, import_obsidian3.setIcon)(
      this.newChatOption.createSpan({ cls: "menu-option-icon" }),
      "plus-circle"
    );
    this.newChatOption.createSpan({
      cls: "menu-option-text",
      text: "New Chat"
    });
    this.renameChatOption = this.menuDropdown.createEl("div", {
      cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_RENAME_CHAT_OPTION}`
    });
    (0, import_obsidian3.setIcon)(
      this.renameChatOption.createSpan({ cls: "menu-option-icon" }),
      "pencil"
    );
    this.renameChatOption.createSpan({
      cls: "menu-option-text",
      text: "Rename Chat"
    });
    this.cloneChatOption = this.menuDropdown.createEl("div", {
      cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_CLONE_CHAT_OPTION}`
    });
    (0, import_obsidian3.setIcon)(
      this.cloneChatOption.createSpan({ cls: "menu-option-icon" }),
      "copy-plus"
    );
    this.cloneChatOption.createSpan({
      cls: "menu-option-text",
      text: "Clone Chat"
    });
    this.exportChatOption = this.menuDropdown.createEl("div", {
      cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_EXPORT_CHAT_OPTION}`
    });
    (0, import_obsidian3.setIcon)(
      this.exportChatOption.createSpan({ cls: "menu-option-icon" }),
      "download"
    );
    this.exportChatOption.createSpan({
      cls: "menu-option-text",
      text: "Export Chat to Note"
    });
    this.menuDropdown.createEl("hr", { cls: CSS_CLASS_MENU_SEPARATOR });
    this.clearChatOption = this.menuDropdown.createEl("div", {
      cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_CLEAR_CHAT_OPTION} ${CSS_CLASS_DANGER_OPTION}`
    });
    (0, import_obsidian3.setIcon)(
      this.clearChatOption.createSpan({ cls: "menu-option-icon" }),
      "trash"
    );
    this.clearChatOption.createSpan({
      cls: "menu-option-text",
      text: "Clear Messages"
    });
    this.deleteChatOption = this.menuDropdown.createEl("div", {
      cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_DELETE_CHAT_OPTION} ${CSS_CLASS_DANGER_OPTION}`
    });
    (0, import_obsidian3.setIcon)(
      this.deleteChatOption.createSpan({ cls: "menu-option-icon" }),
      "trash-2"
    );
    this.deleteChatOption.createSpan({
      cls: "menu-option-text",
      text: "Delete Chat"
    });
    this.menuDropdown.createEl("hr", { cls: CSS_CLASS_MENU_SEPARATOR });
    this.toggleViewLocationOption = this.menuDropdown.createEl("div", {
      cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_TOGGLE_VIEW_LOCATION}`
    });
    this.menuDropdown.createEl("hr", { cls: CSS_CLASS_MENU_SEPARATOR });
    this.updateToggleViewLocationOption();
    this.settingsOption = this.menuDropdown.createEl("div", {
      cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_SETTINGS_OPTION}`
    });
    (0, import_obsidian3.setIcon)(
      this.settingsOption.createSpan({ cls: "menu-option-icon" }),
      "settings"
    );
    this.settingsOption.createSpan({
      cls: "menu-option-text",
      text: "Settings"
    });
  }
  // --- Event Listeners (with Custom Div Menu) ---
  attachEventListeners() {
    if (!this.inputEl)
      console.error("inputEl missing!");
    if (!this.sendButton)
      console.error("sendButton missing!");
    if (!this.menuButton)
      console.error("menuButton missing!");
    if (!this.modelDisplayEl)
      console.error("modelDisplayEl missing!");
    if (!this.translateInputButton)
      console.error("translateInputButton missing!");
    if (this.inputEl) {
      this.inputEl.addEventListener("keydown", this.handleKeyDown);
      this.inputEl.addEventListener("input", this.handleInputForResize);
    }
    if (this.sendButton)
      this.sendButton.addEventListener("click", this.handleSendClick);
    if (this.voiceButton)
      this.voiceButton.addEventListener("click", this.handleVoiceClick);
    if (this.translateInputButton)
      this.translateInputButton.addEventListener(
        "click",
        this.handleTranslateInputClick
      );
    if (this.menuButton)
      this.menuButton.addEventListener("click", this.handleMenuClick);
    if (this.modelDisplayEl)
      this.registerDomEvent(
        this.modelDisplayEl,
        "click",
        this.handleModelDisplayClick
      );
    if (this.roleDisplayEl) {
      this.registerDomEvent(
        this.roleDisplayEl,
        "click",
        this.handleRoleDisplayClick
      );
    } else {
      this.plugin.logger.error("roleDisplayEl missing!");
    }
    if (this.temperatureIndicatorEl) {
      this.registerDomEvent(
        this.temperatureIndicatorEl,
        "click",
        this.handleTemperatureClick
      );
    } else {
      this.plugin.logger.error("temperatureIndicatorEl missing!");
    }
    if (this.toggleLocationButton) {
      this.registerDomEvent(
        this.toggleLocationButton,
        "click",
        this.handleToggleViewLocationClick
      );
    } else {
      this.plugin.logger.error("toggleLocationButton missing!");
    }
    if (this.modelSubmenuHeader)
      this.registerDomEvent(
        this.modelSubmenuHeader,
        "click",
        () => this.toggleSubmenu(
          this.modelSubmenuHeader,
          this.modelSubmenuContent,
          "models"
        )
      );
    else
      console.error("modelSubmenuHeader missing!");
    if (this.roleSubmenuHeader)
      this.registerDomEvent(
        this.roleSubmenuHeader,
        "click",
        () => this.toggleSubmenu(
          this.roleSubmenuHeader,
          this.roleSubmenuContent,
          "roles"
        )
      );
    else
      console.error("roleSubmenuHeader missing!");
    if (this.chatSubmenuHeader)
      this.registerDomEvent(
        this.chatSubmenuHeader,
        "click",
        () => this.toggleSubmenu(
          this.chatSubmenuHeader,
          this.chatSubmenuContent,
          "chats"
        )
      );
    else
      console.error("chatSubmenuHeader missing!");
    if (this.settingsOption)
      this.settingsOption.addEventListener("click", this.handleSettingsClick);
    else
      console.error("settingsOption missing!");
    if (this.clearChatOption)
      this.clearChatOption.addEventListener("click", this.handleClearChatClick);
    else
      console.error("clearChatOption missing!");
    if (this.exportChatOption)
      this.exportChatOption.addEventListener(
        "click",
        this.handleExportChatClick
      );
    else
      console.error("exportChatOption missing!");
    if (this.newChatOption)
      this.newChatOption.addEventListener("click", this.handleNewChatClick);
    else
      console.error("newChatOption missing!");
    if (this.renameChatOption)
      this.renameChatOption.addEventListener(
        "click",
        this.handleRenameChatClick
      );
    else
      console.error("renameChatOption missing!");
    if (this.cloneChatOption)
      this.cloneChatOption.addEventListener("click", this.handleCloneChatClick);
    else
      console.error("cloneChatOption missing!");
    if (this.deleteChatOption)
      this.deleteChatOption.addEventListener(
        "click",
        this.handleDeleteChatClick
      );
    else
      console.error("deleteChatOption missing!");
    if (this.settingsOption)
      this.settingsOption.addEventListener("click", this.handleSettingsClick);
    else
      console.error("settingsOption missing!");
    if (this.clearChatOption)
      this.clearChatOption.addEventListener("click", this.handleClearChatClick);
    else
      console.error("clearChatOption missing!");
    if (this.exportChatOption)
      this.exportChatOption.addEventListener(
        "click",
        this.handleExportChatClick
      );
    else
      console.error("exportChatOption missing!");
    if (this.newChatOption)
      this.newChatOption.addEventListener("click", this.handleNewChatClick);
    else
      console.error("newChatOption missing!");
    if (this.renameChatOption)
      this.renameChatOption.addEventListener(
        "click",
        this.handleRenameChatClick
      );
    else
      console.error("renameChatOption missing!");
    if (this.cloneChatOption)
      this.cloneChatOption.addEventListener("click", this.handleCloneChatClick);
    else
      console.error("cloneChatOption missing!");
    if (this.deleteChatOption)
      this.deleteChatOption.addEventListener(
        "click",
        this.handleDeleteChatClick
      );
    else
      console.error("deleteChatOption missing!");
    if (this.toggleViewLocationOption) {
      this.registerDomEvent(
        this.toggleViewLocationOption,
        "click",
        this.handleToggleViewLocationClick
      );
    } else {
      this.plugin.logger.error("toggleViewLocationOption missing!");
    }
    this.registerDomEvent(window, "resize", this.handleWindowResize);
    this.registerEvent(
      this.app.workspace.on("resize", this.handleWindowResize)
    );
    this.registerDomEvent(document, "click", this.handleDocumentClickForMenu);
    this.registerDomEvent(
      document,
      "visibilitychange",
      this.handleVisibilityChange
    );
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", this.handleActiveLeafChange)
    );
    if (this.chatContainer) {
      this.registerDomEvent(
        this.chatContainer,
        "scroll",
        this.scrollListenerDebounced
      );
    } else {
      this.plugin.logger.error("chatContainer missing!");
    }
    if (this.newMessagesIndicatorEl) {
      this.registerDomEvent(
        this.newMessagesIndicatorEl,
        "click",
        this.handleNewMessageIndicatorClick
      );
    }
    this.register(this.plugin.on("model-changed", this.handleModelChange));
    this.register(this.plugin.on("role-changed", this.handleRoleChange));
    this.register(this.plugin.on("roles-updated", this.handleRolesUpdated));
    this.register(this.plugin.on("roles-updated", this.updateRolePanelList));
    this.plugin.on("active-chat-changed", this.handleActiveChatChanged);
    this.register(this.plugin.on("message-added", this.handleMessageAdded));
    this.register(
      this.plugin.on("messages-cleared", this.handleMessagesCleared)
    );
    this.register(
      this.plugin.on("chat-list-updated", this.handleChatListUpdated)
    );
    this.register(
      this.plugin.on("settings-updated", this.handleSettingsUpdated)
    );
  }
  // --- Додано: Метод для оновлення кнопки перемикання ---
  updateToggleLocationButton() {
    if (!this.toggleLocationButton)
      return;
    let iconName;
    let titleText;
    if (this.plugin.settings.openChatInTab) {
      iconName = "sidebar-right";
      titleText = "Move to Sidebar";
    } else {
      iconName = "layout-list";
      titleText = "Move to Tab";
    }
    (0, import_obsidian3.setIcon)(this.toggleLocationButton, iconName);
    this.toggleLocationButton.setAttribute("aria-label", titleText);
    this.toggleLocationButton.title = titleText;
  }
  updateModelDisplay(modelName) {
    if (this.modelDisplayEl) {
      if (modelName) {
        const displayName = modelName;
        const shortName = displayName.replace(/:latest$/, "");
        this.modelDisplayEl.setText(shortName);
        this.modelDisplayEl.title = `Current model: ${displayName}. Click to change.`;
        this.modelDisplayEl.removeClass("model-not-available");
      } else {
        this.modelDisplayEl.setText("Not available");
        this.modelDisplayEl.title = "No Ollama models detected. Check Ollama connection and ensure models are installed.";
        this.modelDisplayEl.addClass("model-not-available");
      }
    } else {
      console.error("[OllamaView] modelDisplayEl is missing!");
    }
  }
  // Handles clicks on submenu headers (Model, Role, Chat)
  // Змінено: Логіка розгортання підменю
  async toggleSubmenu(headerEl, contentEl, type) {
    if (!headerEl || !contentEl)
      return;
    const iconEl = headerEl.querySelector(`.${CSS_CLASS_SUBMENU_ICON}`);
    const isHidden = contentEl.style.maxHeight === "0px" || contentEl.classList.contains(CSS_CLASS_SUBMENU_CONTENT_HIDDEN);
    if (isHidden) {
      this.collapseAllSubmenus(contentEl);
    }
    if (isHidden) {
      if (iconEl instanceof HTMLElement)
        (0, import_obsidian3.setIcon)(iconEl, "chevron-down");
      contentEl.empty();
      contentEl.createDiv({
        cls: "menu-loading",
        text: `Loading ${type}...`
      });
      contentEl.classList.remove(CSS_CLASS_SUBMENU_CONTENT_HIDDEN);
      contentEl.style.maxHeight = "40px";
      contentEl.style.paddingTop = "5px";
      contentEl.style.paddingBottom = "5px";
      contentEl.style.overflowY = "hidden";
      try {
        switch (type) {
          case "models":
            await this.renderModelList();
            break;
          case "roles":
            await this.renderRoleList();
            break;
          case "chats":
            await this.renderChatListMenu();
            break;
        }
        requestAnimationFrame(() => {
          if (!contentEl.classList.contains(CSS_CLASS_SUBMENU_CONTENT_HIDDEN)) {
            if (type === "chats") {
              contentEl.style.maxHeight = CHAT_LIST_MAX_HEIGHT;
              contentEl.style.overflowY = "auto";
            } else {
              contentEl.style.maxHeight = contentEl.scrollHeight + "px";
              contentEl.style.overflowY = "hidden";
            }
          }
        });
      } catch (error) {
        this.plugin.logger.error(`Error rendering ${type} list:`, error);
        contentEl.empty();
        contentEl.createDiv({
          cls: "menu-error-text",
          text: `Error loading ${type}.`
        });
        contentEl.style.maxHeight = "50px";
        contentEl.style.overflowY = "hidden";
      }
    } else {
      contentEl.classList.add(CSS_CLASS_SUBMENU_CONTENT_HIDDEN);
      contentEl.style.maxHeight = "0";
      contentEl.style.paddingTop = "0";
      contentEl.style.paddingBottom = "0";
      contentEl.style.overflowY = "hidden";
      if (iconEl instanceof HTMLElement)
        (0, import_obsidian3.setIcon)(iconEl, "chevron-right");
    }
  }
  // Helper to collapse all submenus except the one potentially being opened
  collapseAllSubmenus(exceptContent) {
    const submenus = [
      {
        header: this.modelSubmenuHeader,
        content: this.modelSubmenuContent
      },
      {
        header: this.roleSubmenuHeader,
        content: this.roleSubmenuContent
      },
      {
        header: this.chatSubmenuHeader,
        content: this.chatSubmenuContent
      }
    ];
    submenus.forEach((submenu) => {
      if (submenu.content && submenu.header && submenu.content !== exceptContent) {
        if (!submenu.content.classList.contains(CSS_CLASS_SUBMENU_CONTENT_HIDDEN)) {
          submenu.content.classList.add(CSS_CLASS_SUBMENU_CONTENT_HIDDEN);
          submenu.content.style.maxHeight = "0";
          submenu.content.style.paddingTop = "0";
          submenu.content.style.paddingBottom = "0";
          const iconEl = submenu.header.querySelector(
            `.${CSS_CLASS_SUBMENU_ICON}`
          );
          if (iconEl instanceof HTMLElement) {
            (0, import_obsidian3.setIcon)(iconEl, "chevron-right");
          }
        }
      }
    });
  }
  // --- UI Update Methods ---
  updateInputPlaceholder(roleName) {
    if (this.inputEl) {
      const displayRole = roleName || "Assistant";
      this.inputEl.placeholder = `Message ${displayRole}...`;
    }
  }
  closeMenu() {
    if (this.menuDropdown) {
      this.menuDropdown.style.display = "none";
      this.collapseAllSubmenus(null);
    }
  }
  autoResizeTextarea() {
    this.adjustTextareaHeight();
  }
  updateRoleDisplay(roleName) {
    if (this.roleDisplayEl) {
      const displayName = roleName || "None";
      this.roleDisplayEl.setText(displayName);
      this.roleDisplayEl.title = `Current role: ${displayName}. Click to change.`;
    }
  }
  updateSendButtonState() {
    if (!this.inputEl || !this.sendButton)
      return;
    const isDisabled = this.inputEl.value.trim() === "" || this.isProcessing;
    this.sendButton.disabled = isDisabled;
    this.sendButton.classList.toggle(CSS_CLASS_DISABLED, isDisabled);
  }
  showEmptyState() {
    var _a, _b;
    if (this.currentMessages.length === 0 && !this.emptyStateEl && this.chatContainer) {
      this.chatContainer.empty();
      this.emptyStateEl = this.chatContainer.createDiv({
        cls: CSS_CLASS_EMPTY_STATE
      });
      this.emptyStateEl.createDiv({
        cls: "empty-state-message",
        text: "No messages yet"
      });
      const modelName = ((_b = (_a = this.plugin) == null ? void 0 : _a.settings) == null ? void 0 : _b.modelName) || "the AI";
      this.emptyStateEl.createDiv({
        cls: "empty-state-tip",
        text: `Type a message or use the menu options to start interacting with ${modelName}.`
      });
    }
  }
  hideEmptyState() {
    if (this.emptyStateEl) {
      this.emptyStateEl.remove();
      this.emptyStateEl = null;
    }
  }
  setLoadingState(isLoading) {
    this.isProcessing = isLoading;
    if (this.inputEl)
      this.inputEl.disabled = isLoading;
    this.updateSendButtonState();
    if (this.voiceButton) {
      this.voiceButton.disabled = isLoading;
      this.voiceButton.classList.toggle(CSS_CLASS_DISABLED, isLoading);
    }
    if (this.translateInputButton) {
      this.translateInputButton.disabled = isLoading;
      this.translateInputButton.classList.toggle(CSS_CLASS_DISABLED, isLoading);
    }
    if (this.menuButton) {
      this.menuButton.disabled = isLoading;
      this.menuButton.classList.toggle(CSS_CLASS_DISABLED, isLoading);
    }
  }
  // Load and Display Chat (Тепер оновлює і температуру)
  // В src/OllamaView.ts
  // --- ВАЖЛИВО: Переконайтесь, що цей метод також оновлений! ---
  // (Перевірив ваш код, він вже містить виклик updateRolePanelList, це добре)
  // OllamaView.ts
  async loadAndDisplayActiveChat() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    this.plugin.logger.debug("[loadAndDisplayActiveChat] Start loading/displaying active chat...");
    this.clearChatContainerInternal();
    this.currentMessages = [];
    this.lastRenderedMessageDate = null;
    let activeChat = null;
    let availableModels = [];
    let finalModelName = null;
    let finalRolePath = void 0;
    let finalRoleName = "None";
    let finalTemperature = void 0;
    let errorOccurred = false;
    try {
      activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat()) || null;
      this.plugin.logger.debug(`[loadAndDisplayActiveChat] Active chat fetched: ${(_c = (_b = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _b.id) != null ? _c : "null"}`);
      availableModels = await this.plugin.ollamaService.getModels();
      this.plugin.logger.debug(`[loadAndDisplayActiveChat] Available models fetched: ${availableModels.join(", ")}`);
      finalRolePath = (_e = (_d = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _d.selectedRolePath) != null ? _e : this.plugin.settings.selectedRolePath;
      finalRoleName = await this.findRoleNameByPath(finalRolePath);
      this.plugin.logger.debug(`[loadAndDisplayActiveChat] Determined role: Path='${finalRolePath || "None"}', Name='${finalRoleName}'`);
    } catch (error) {
      this.plugin.logger.error("[loadAndDisplayActiveChat] Error fetching active chat, models, or role:", error);
      new import_obsidian3.Notice("Error connecting to Ollama or loading chat data.", 5e3);
      errorOccurred = true;
      finalModelName = null;
      finalTemperature = this.plugin.settings.temperature;
      finalRolePath = this.plugin.settings.selectedRolePath;
      finalRoleName = await this.findRoleNameByPath(finalRolePath);
      activeChat = null;
    }
    if (!errorOccurred && activeChat) {
      let preferredModel = ((_f = activeChat.metadata) == null ? void 0 : _f.modelName) || this.plugin.settings.modelName;
      if (availableModels.length > 0) {
        if (preferredModel && availableModels.includes(preferredModel)) {
          finalModelName = preferredModel;
        } else {
          finalModelName = availableModels[0];
          this.plugin.logger.warn(`[loadAndDisplayActiveChat] Preferred model '${preferredModel}' not available. Using first available: '${finalModelName}'.`);
        }
      } else {
        finalModelName = null;
        this.plugin.logger.warn(`[loadAndDisplayActiveChat] No Ollama models detected.`);
      }
      this.plugin.logger.debug(`[loadAndDisplayActiveChat] Determined final model for chat: ${finalModelName != null ? finalModelName : "None"}`);
      if (activeChat.metadata.modelName !== finalModelName && finalModelName !== null) {
        try {
          this.plugin.logger.debug(`[loadAndDisplayActiveChat] Updating chat model metadata from '${activeChat.metadata.modelName}' to '${finalModelName}'`);
          this.plugin.chatManager.updateActiveChatMetadata({ modelName: finalModelName }).catch((updateError) => {
            this.plugin.logger.error("[loadAndDisplayActiveChat] Background error updating chat model metadata:", updateError);
          });
        } catch (updateError) {
          this.plugin.logger.error("[loadAndDisplayActiveChat] Sync error during model metadata update call:", updateError);
        }
      }
      finalTemperature = (_h = (_g = activeChat.metadata) == null ? void 0 : _g.temperature) != null ? _h : this.plugin.settings.temperature;
      this.plugin.logger.debug(`[loadAndDisplayActiveChat] Determined final temperature for chat: ${finalTemperature}`);
    } else if (!errorOccurred && !activeChat) {
      this.plugin.logger.debug("[loadAndDisplayActiveChat] No active chat found. Using global settings.");
      finalModelName = availableModels.includes(this.plugin.settings.modelName) ? this.plugin.settings.modelName : availableModels.length > 0 ? availableModels[0] : null;
      finalTemperature = this.plugin.settings.temperature;
      this.plugin.logger.debug(`[loadAndDisplayActiveChat] Using global model: ${finalModelName != null ? finalModelName : "None"}, Temp: ${finalTemperature}, Role: ${finalRoleName}`);
    }
    if (activeChat !== null && !errorOccurred) {
      if (activeChat.messages && activeChat.messages.length > 0) {
        this.plugin.logger.debug(`[loadAndDisplayActiveChat] Rendering ${activeChat.messages.length} messages.`);
        this.hideEmptyState();
        this.renderMessages(activeChat.messages);
        this.checkAllMessagesForCollapsing();
        this.plugin.logger.debug("[loadAndDisplayActiveChat] Scrolling to bottom after rendering messages.");
        setTimeout(() => {
          this.guaranteedScrollToBottom(100, false);
        }, 150);
      } else {
        this.plugin.logger.debug("[loadAndDisplayActiveChat] Active chat exists but has no messages. Showing empty state.");
        this.showEmptyState();
      }
    } else {
      this.plugin.logger.debug("[loadAndDisplayActiveChat] No active chat or error occurred earlier. Showing empty state.");
      this.showEmptyState();
    }
    this.plugin.logger.debug("[loadAndDisplayActiveChat] Updating final UI elements including side panels...");
    this.updateInputPlaceholder(finalRoleName);
    this.updateRoleDisplay(finalRoleName);
    this.updateModelDisplay(finalModelName);
    this.updateTemperatureIndicator(finalTemperature);
    const panelUpdatePromises = [
      this.updateChatPanelList().catch((e) => this.plugin.logger.error("Error updating chat panel list:", e)),
      this.updateRolePanelList().catch((e) => this.plugin.logger.error("Error updating role panel list:", e))
    ];
    await Promise.all(panelUpdatePromises);
    this.plugin.logger.debug("[loadAndDisplayActiveChat] Side panel lists updated.");
    if (finalModelName === null) {
      this.plugin.logger.warn("[loadAndDisplayActiveChat] No model available. Disabling input.");
      if (this.inputEl) {
        this.inputEl.disabled = true;
        this.inputEl.placeholder = "No models available...";
      }
      if (this.sendButton) {
        this.sendButton.disabled = true;
        this.sendButton.classList.add(CSS_CLASS_DISABLED);
      }
      this.setLoadingState(false);
    } else {
      if (this.inputEl) {
        this.inputEl.disabled = this.isProcessing;
      }
      this.updateSendButtonState();
    }
    this.plugin.logger.debug("[loadAndDisplayActiveChat] Finished.");
  }
  /** Renders a list of messages to the chat container */
  renderMessages(messagesToRender) {
    this.clearChatContainerInternal();
    this.currentMessages = [...messagesToRender];
    this.lastRenderedMessageDate = null;
    messagesToRender.forEach((message) => {
      this.renderMessageInternal(message, messagesToRender);
    });
  }
  /** Appends a single message to the display */
  addMessageToDisplay(role, content, timestamp) {
    if (!this.chatContainer)
      return;
    const newMessage = { role, content, timestamp };
    const currentContext = [...this.currentMessages];
    const messageEl = this.renderMessageInternal(newMessage, [
      ...currentContext,
      newMessage
    ]);
    this.currentMessages.push(newMessage);
    if (messageEl) {
      this.checkMessageForCollapsing(messageEl);
    }
    const isUserOrError = role === "user" || role === "error";
    if (!isUserOrError && this.userScrolledUp && this.newMessagesIndicatorEl) {
      this.newMessagesIndicatorEl.classList.add(CSS_CLASS_VISIBLE);
    } else if (!this.userScrolledUp) {
      const forceScroll = !isUserOrError;
      this.guaranteedScrollToBottom(forceScroll ? 100 : 50, forceScroll);
    }
    this.hideEmptyState();
  }
  /** Sends the user's input as a message and gets a response */
  async sendMessage() {
    var _a;
    const content = this.inputEl.value.trim();
    if (!content || this.isProcessing || this.sendButton.disabled)
      return;
    const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
    if (!activeChat) {
      new import_obsidian3.Notice("Error: No active chat session found.");
      return;
    }
    const userMessageContent = this.inputEl.value;
    this.clearInputField();
    this.setLoadingState(true);
    this.hideEmptyState();
    let loadingEl = null;
    try {
      const userMessage = await this.plugin.chatManager.addMessageToActiveChat(
        "user",
        userMessageContent
      );
      if (!userMessage)
        throw new Error("Failed to add user message to history.");
      loadingEl = this.addLoadingIndicator();
      this.guaranteedScrollToBottom(50, true);
      const assistantMessage = await this.plugin.ollamaService.generateChatResponse(activeChat);
      if (loadingEl) {
        this.removeLoadingIndicator(loadingEl);
        loadingEl = null;
      }
      if (assistantMessage) {
        await this.plugin.chatManager.addMessageToActiveChat(
          assistantMessage.role,
          assistantMessage.content
        );
      } else {
        this.addMessageToDisplay(
          "error",
          "Assistant did not provide a response.",
          new Date()
        );
      }
    } catch (error) {
      if (loadingEl) {
        this.removeLoadingIndicator(loadingEl);
        loadingEl = null;
      }
      this.addMessageToDisplay(
        "error",
        `Error: ${error.message || "Unknown error."}`,
        new Date()
      );
    } finally {
      if (loadingEl) {
        this.removeLoadingIndicator(loadingEl);
      }
      this.setLoadingState(false);
      this.focusInput();
    }
  }
  // --- Core Rendering Logic ---
  /** Renders a single message bubble based on the message object and context */
  renderMessageInternal(message, messageContext) {
    const messageIndex = messageContext.findIndex((m) => m === message);
    if (messageIndex === -1)
      return null;
    const prevMessage = messageIndex > 0 ? messageContext[messageIndex - 1] : null;
    const isNewDay = !this.lastRenderedMessageDate || !this.isSameDay(this.lastRenderedMessageDate, message.timestamp);
    if (isNewDay) {
      this.renderDateSeparator(message.timestamp);
      this.lastRenderedMessageDate = message.timestamp;
    } else if (messageIndex === 0 && !this.lastRenderedMessageDate) {
      this.lastRenderedMessageDate = message.timestamp;
    }
    let messageGroup = null;
    let groupClass = CSS_CLASS_MESSAGE_GROUP;
    let messageClass = `${CSS_CLASS_MESSAGE} ${CSS_CLASS_MESSAGE_ARRIVING}`;
    let showAvatar = true;
    let isUser = false;
    const isFirstInGroup = !prevMessage || prevMessage.role !== message.role || isNewDay;
    switch (message.role) {
      case "user":
        groupClass += ` ${CSS_CLASS_USER_GROUP}`;
        messageClass += ` ${CSS_CLASS_USER_MESSAGE}`;
        isUser = true;
        break;
      case "assistant":
        groupClass += ` ${CSS_CLASS_OLLAMA_GROUP}`;
        messageClass += ` ${CSS_CLASS_OLLAMA_MESSAGE}`;
        break;
      case "system":
        groupClass += ` ${CSS_CLASS_SYSTEM_GROUP}`;
        messageClass += ` ${CSS_CLASS_SYSTEM_MESSAGE}`;
        showAvatar = false;
        break;
      case "error":
        groupClass += ` ${CSS_CLASS_ERROR_GROUP}`;
        messageClass += ` ${CSS_CLASS_ERROR_MESSAGE}`;
        showAvatar = false;
        break;
    }
    const lastElement = this.chatContainer.lastElementChild;
    if (isFirstInGroup || !lastElement || !lastElement.matches(`.${groupClass.split(" ")[1]}`)) {
      messageGroup = this.chatContainer.createDiv({ cls: groupClass });
      if (showAvatar)
        this.renderAvatar(messageGroup, isUser);
    } else {
      messageGroup = lastElement;
    }
    let messageWrapper = messageGroup.querySelector(
      ".message-wrapper"
    );
    if (!messageWrapper) {
      messageWrapper = messageGroup.createDiv({ cls: "message-wrapper" });
      if (messageGroup.classList.contains(CSS_CLASS_USER_GROUP)) {
        messageWrapper.style.order = "1";
      } else {
        messageWrapper.style.order = "2";
      }
    }
    const messageEl = messageWrapper.createDiv({ cls: messageClass });
    const contentContainer = messageEl.createDiv({
      cls: CSS_CLASS_CONTENT_CONTAINER
    });
    const contentEl = contentContainer.createDiv({
      cls: CSS_CLASS_CONTENT
    });
    switch (message.role) {
      case "assistant":
      case "user":
        contentEl.addClass(CSS_CLASS_CONTENT_COLLAPSIBLE);
        if (message.role === "assistant") {
          this.renderAssistantContent(contentEl, message.content);
        } else {
          message.content.split("\n").forEach((line, i, arr) => {
            contentEl.appendText(line);
            if (i < arr.length - 1)
              contentEl.createEl("br");
          });
        }
        break;
      case "system":
        (0, import_obsidian3.setIcon)(contentEl.createSpan({ cls: CSS_CLASS_SYSTEM_ICON }), "info");
        contentEl.createSpan({
          cls: CSS_CLASS_SYSTEM_TEXT,
          text: message.content
        });
        break;
      case "error":
        (0, import_obsidian3.setIcon)(
          contentEl.createSpan({ cls: CSS_CLASS_ERROR_ICON }),
          "alert-triangle"
        );
        contentEl.createSpan({
          cls: CSS_CLASS_ERROR_TEXT,
          text: message.content
        });
        break;
    }
    this.checkMessageForCollapsing(messageEl);
    const buttonsWrapper = messageWrapper.createDiv({
      cls: "message-actions-wrapper"
    });
    if (message.role === "user") {
      const regenerateBtn = buttonsWrapper.createEl("button", {
        cls: CSS_CLASS_REGENERATE_BUTTON,
        attr: {
          /*...*/
        }
      });
      (0, import_obsidian3.setIcon)(regenerateBtn, "refresh-cw");
      this.registerDomEvent(regenerateBtn, "click", (e) => {
        e.stopPropagation();
        this.handleRegenerateClick(message);
      });
    }
    if (message.role === "user" || message.role === "assistant") {
      const copyBtn = buttonsWrapper.createEl("button", {
        cls: CSS_CLASS_COPY_BUTTON,
        attr: {
          /*...*/
        }
      });
      (0, import_obsidian3.setIcon)(copyBtn, "copy");
      this.registerDomEvent(copyBtn, "click", (e) => {
        e.stopPropagation();
        this.handleCopyClick(message.content, copyBtn);
      });
      if (this.plugin.settings.enableTranslation) {
        const translateBtn = buttonsWrapper.createEl("button", {
          cls: CSS_CLASS_TRANSLATE_BUTTON,
          attr: {
            /*...*/
          }
        });
        (0, import_obsidian3.setIcon)(translateBtn, "languages");
        this.registerDomEvent(translateBtn, "click", (e) => {
          e.stopPropagation();
          this.handleTranslateClick(message.content, contentEl, translateBtn);
        });
      }
    }
    messageEl.createDiv({
      cls: CSS_CLASS_TIMESTAMP,
      text: this.formatTime(message.timestamp)
    });
    messageEl.addClass(CSS_CLASS_MESSAGE_ARRIVING);
    setTimeout(
      () => messageEl.classList.remove(CSS_CLASS_MESSAGE_ARRIVING),
      500
    );
    return messageEl;
  }
  // --- Новий обробник для кнопки Регенерації ---
  async handleRegenerateClick(userMessage) {
    var _a;
    this.plugin.logger.info(
      `Regenerate requested for user message timestamp: ${userMessage.timestamp.toISOString()}`
    );
    const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
    if (!activeChat) {
      new import_obsidian3.Notice("Cannot regenerate: No active chat found.");
      return;
    }
    const chatId = activeChat.metadata.id;
    const messageIndex = activeChat.messages.findIndex(
      (msg) => msg.role === "user" && msg.timestamp.getTime() === userMessage.timestamp.getTime() && msg.content === userMessage.content
    );
    if (messageIndex === -1) {
      this.plugin.logger.error(
        "Could not find the user message in the active chat history for regeneration.",
        userMessage
      );
      new import_obsidian3.Notice("Error: Could not find the message to regenerate from.");
      return;
    }
    if (messageIndex === activeChat.messages.length - 1) {
      new import_obsidian3.Notice("This is the last message, nothing to regenerate after it.");
      return;
    }
    new ConfirmModal(
      this.app,
      "Confirm Regeneration",
      "This will delete all messages after this prompt and generate a new response. Continue?",
      async () => {
        this.plugin.logger.debug(
          `User confirmed regeneration for chat ${chatId} after index ${messageIndex}`
        );
        let loadingIndicator = null;
        try {
          this.setLoadingState(true);
          const deleteSuccess = await this.plugin.chatManager.deleteMessagesAfter(
            chatId,
            messageIndex
          );
          if (!deleteSuccess) {
            throw new Error("Failed to delete subsequent messages.");
          }
          await this.loadAndDisplayActiveChat();
          this.scrollToBottom();
          loadingIndicator = this.addLoadingIndicator();
          this.guaranteedScrollToBottom(50, true);
          const updatedChat = await this.plugin.chatManager.getActiveChat();
          if (!updatedChat)
            throw new Error("Failed to get updated chat after deletion.");
          this.plugin.logger.info(
            `Generating new response for chat ${chatId} based on history up to index ${messageIndex}`
          );
          const assistantMessage = await this.plugin.ollamaService.generateChatResponse(updatedChat);
          if (loadingIndicator)
            this.removeLoadingIndicator(loadingIndicator);
          loadingIndicator = null;
          if (assistantMessage) {
            await this.plugin.chatManager.addMessageToActiveChat(
              assistantMessage.role,
              assistantMessage.content
            );
          } else {
            this.plugin.logger.warn(
              "Regeneration: Assistant did not provide a response."
            );
            this.addMessageToDisplay(
              "error",
              "Assistant did not provide a response for regeneration.",
              new Date()
            );
          }
        } catch (error) {
          this.plugin.logger.error("Error during regeneration process:", error);
          new import_obsidian3.Notice(`Regeneration failed: ${error.message}`);
          if (loadingIndicator)
            this.removeLoadingIndicator(loadingIndicator);
        } finally {
          this.setLoadingState(false);
          this.focusInput();
        }
      }
      // Кінець колбеку ConfirmModal
    ).open();
  }
  // --- Action Button Handlers ---
  handleCopyClick(content, buttonEl) {
    let textToCopy = content;
    if (this.detectThinkingTags(this.decodeHtmlEntities(content)).hasThinkingTags) {
      textToCopy = this.decodeHtmlEntities(content).replace(/<think>[\s\S]*?<\/think>/g, "").trim();
    }
    navigator.clipboard.writeText(textToCopy).then(() => {
      (0, import_obsidian3.setIcon)(buttonEl, "check");
      buttonEl.setAttribute("title", "Copied!");
      setTimeout(() => {
        (0, import_obsidian3.setIcon)(buttonEl, "copy");
        buttonEl.setAttribute("title", "Copy");
      }, 2e3);
    }).catch((err) => {
    });
  }
  async handleTranslateClick(originalContent, contentEl, buttonEl) {
    var _a, _b, _c;
    const targetLang = this.plugin.settings.translationTargetLanguage;
    const apiKey = this.plugin.settings.googleTranslationApiKey;
    if (!targetLang || !apiKey) {
      new import_obsidian3.Notice(
        "Translation not configured. Please check language and API key in settings."
      );
      return;
    }
    let textToTranslate = originalContent;
    if (this.detectThinkingTags(this.decodeHtmlEntities(originalContent)).hasThinkingTags) {
      textToTranslate = this.decodeHtmlEntities(originalContent).replace(/<think>[\s\S]*?<\/think>/g, "").trim();
    }
    if (!textToTranslate)
      return;
    (_a = contentEl.querySelector(`.${CSS_CLASS_TRANSLATION_CONTAINER}`)) == null ? void 0 : _a.remove();
    (0, import_obsidian3.setIcon)(buttonEl, "loader");
    buttonEl.disabled = true;
    buttonEl.classList.add(CSS_CLASS_TRANSLATION_PENDING);
    buttonEl.setAttribute("title", "Translating...");
    try {
      const translatedText = await this.plugin.translationService.translate(
        textToTranslate,
        targetLang
      );
      if (translatedText !== null) {
        const translationContainer = contentEl.createDiv({
          cls: CSS_CLASS_TRANSLATION_CONTAINER
        });
        const translationContentEl = translationContainer.createDiv({
          cls: CSS_CLASS_TRANSLATION_CONTENT
        });
        await import_obsidian3.MarkdownRenderer.renderMarkdown(
          translatedText,
          translationContentEl,
          (_c = (_b = this.plugin.app.vault.getRoot()) == null ? void 0 : _b.path) != null ? _c : "",
          // Шлях контексту (корінь сховища)
          this
          // Компонент (View)
        );
        const targetLangName = LANGUAGES[targetLang] || targetLang;
        translationContainer.createEl("div", {
          cls: "translation-indicator",
          text: `[Translated to ${targetLangName}]`
        });
        this.guaranteedScrollToBottom(50, false);
      }
    } catch (error) {
      new import_obsidian3.Notice("An unexpected error occurred during translation.");
    } finally {
      (0, import_obsidian3.setIcon)(buttonEl, "languages");
      buttonEl.disabled = false;
      buttonEl.classList.remove(CSS_CLASS_TRANSLATION_PENDING);
      const targetLangName = LANGUAGES[targetLang] || targetLang;
      buttonEl.setAttribute("title", `Translate to ${targetLangName}`);
    }
  }
  // --- Rendering Helpers ---
  renderAvatar(groupEl, isUser) {
    const settings = this.plugin.settings;
    const avatarType = isUser ? settings.userAvatarType : settings.aiAvatarType;
    const avatarContent = isUser ? settings.userAvatarContent : settings.aiAvatarContent;
    const avatarClass = isUser ? CSS_CLASS_AVATAR_USER : CSS_CLASS_AVATAR_AI;
    const avatarEl = groupEl.createDiv({
      cls: `${CSS_CLASS_AVATAR} ${avatarClass}`
    });
    if (avatarType === "initials") {
      avatarEl.textContent = avatarContent || (isUser ? "U" : "A");
    } else if (avatarType === "icon") {
      try {
        (0, import_obsidian3.setIcon)(avatarEl, avatarContent || (isUser ? "user" : "bot"));
      } catch (e) {
        avatarEl.textContent = isUser ? "U" : "A";
      }
    } else {
      avatarEl.textContent = isUser ? "U" : "A";
    }
  }
  renderDateSeparator(date) {
    if (!this.chatContainer)
      return;
    this.chatContainer.createDiv({
      cls: CSS_CLASS_DATE_SEPARATOR,
      text: this.formatDateSeparator(date)
    });
  }
  renderAssistantContent(containerEl, content) {
    var _a, _b;
    const decodedContent = this.decodeHtmlEntities(content);
    const thinkingInfo = this.detectThinkingTags(decodedContent);
    containerEl.empty();
    if (thinkingInfo.hasThinkingTags) {
      const processedHtml = this.processThinkingTags(decodedContent);
      containerEl.innerHTML = processedHtml;
      this.addThinkingToggleListeners(containerEl);
      this.addCodeBlockEnhancements(containerEl);
    } else {
      import_obsidian3.MarkdownRenderer.renderMarkdown(
        decodedContent,
        // Use decoded content for rendering
        containerEl,
        (_b = (_a = this.app.vault.getRoot()) == null ? void 0 : _a.path) != null ? _b : "",
        // Source path context
        this
        // Component context for links etc.
      );
      this.addCodeBlockEnhancements(containerEl);
    }
  }
  addCodeBlockEnhancements(contentEl) {
    contentEl.querySelectorAll("pre").forEach((pre) => {
      if (pre.querySelector(`.${CSS_CLASS_CODE_BLOCK_COPY_BUTTON}`))
        return;
      const code = pre.querySelector("code");
      if (!code)
        return;
      const codeText = code.textContent || "";
      const langClass = Array.from(code.classList).find(
        (cls) => cls.startsWith("language-")
      );
      if (langClass) {
        const lang = langClass.replace("language-", "");
        if (lang) {
          if (!pre.querySelector(`.${CSS_CLASS_CODE_BLOCK_LANGUAGE}`)) {
            pre.createEl("span", {
              cls: CSS_CLASS_CODE_BLOCK_LANGUAGE,
              text: lang
            });
          }
        }
      }
      const copyBtn = pre.createEl("button", {
        cls: CSS_CLASS_CODE_BLOCK_COPY_BUTTON
      });
      (0, import_obsidian3.setIcon)(copyBtn, "copy");
      copyBtn.setAttribute("title", "Copy Code");
      copyBtn.setAttribute("aria-label", "Copy code block");
      this.registerDomEvent(copyBtn, "click", (e) => {
        e.stopPropagation();
        navigator.clipboard.writeText(codeText).then(() => {
          (0, import_obsidian3.setIcon)(copyBtn, "check");
          copyBtn.setAttribute("title", "Copied!");
          setTimeout(() => {
            (0, import_obsidian3.setIcon)(copyBtn, "copy");
            copyBtn.setAttribute("title", "Copy Code");
          }, 1500);
        }).catch((err) => {
          new import_obsidian3.Notice("Failed to copy code.");
        });
      });
    });
  }
  // --- Menu List Rendering (Accordion Style) ---
  async renderModelList() {
    var _a, _b;
    const container = this.modelSubmenuContent;
    if (!container)
      return;
    container.empty();
    const modelIconMap = {
      llama: "box-minimal",
      mistral: "wind"
    };
    const defaultIcon = "box";
    try {
      const models = await this.plugin.ollamaService.getModels();
      const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
      const currentModelName = ((_b = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _b.modelName) || this.plugin.settings.modelName;
      if (models.length === 0) {
        container.createEl("div", {
          cls: "menu-info-text",
          text: "No models."
        });
        return;
      }
      models.forEach((modelName) => {
        const optionEl = container.createDiv({
          cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_MODEL_OPTION}`
        });
        const iconSpan = optionEl.createEl("span", {
          cls: "menu-option-icon"
        });
        let iconToUse = defaultIcon;
        if (modelName === currentModelName) {
          iconToUse = "check";
          optionEl.addClass("is-selected");
        } else {
          const l = modelName.toLowerCase();
          let f = false;
          for (const k in modelIconMap) {
            if (l.includes(k)) {
              iconToUse = modelIconMap[k];
              f = true;
              break;
            }
          }
          if (!f)
            iconToUse = defaultIcon;
        }
        try {
          (0, import_obsidian3.setIcon)(iconSpan, iconToUse);
        } catch (e) {
          iconSpan.style.minWidth = "18px";
        }
        optionEl.createEl("span", {
          cls: "menu-option-text",
          text: modelName
        });
        this.registerDomEvent(optionEl, "click", async () => {
          var _a2;
          if (modelName !== currentModelName) {
            const chat = await ((_a2 = this.plugin.chatManager) == null ? void 0 : _a2.getActiveChat());
            if (chat)
              await this.plugin.chatManager.updateActiveChatMetadata({
                modelName
              });
            else
              new import_obsidian3.Notice("No active chat.");
          }
          this.closeMenu();
        });
      });
      this.updateSubmenuHeight(container);
    } catch (error) {
      container.empty();
      container.createEl("div", {
        cls: "menu-error-text",
        text: "Error models."
      });
      this.updateSubmenuHeight(container);
    }
  }
  async renderRoleList() {
    var _a, _b, _c;
    const container = this.roleSubmenuContent;
    if (!container)
      return;
    container.empty();
    try {
      const roles = await this.plugin.listRoleFiles(true);
      const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
      const currentChatRolePath = (_c = (_b = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _b.selectedRolePath) != null ? _c : this.plugin.settings.selectedRolePath;
      const noRoleOptionEl = container.createDiv({
        cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_ROLE_OPTION}`
      });
      const noRoleIconSpan = noRoleOptionEl.createEl("span", {
        cls: "menu-option-icon"
      });
      if (!currentChatRolePath) {
        (0, import_obsidian3.setIcon)(noRoleIconSpan, "check");
        noRoleOptionEl.addClass("is-selected");
      } else {
        (0, import_obsidian3.setIcon)(noRoleIconSpan, "slash");
        noRoleIconSpan.style.minWidth = "18px";
      }
      noRoleOptionEl.createEl("span", {
        cls: "menu-option-text",
        text: "None"
      });
      this.registerDomEvent(noRoleOptionEl, "click", async () => {
        var _a2, _b2, _c2;
        const nrp = "";
        if (this.plugin.settings.selectedRolePath !== nrp || currentChatRolePath !== nrp) {
          this.plugin.settings.selectedRolePath = nrp;
          await this.plugin.saveSettings();
          const chat = await ((_a2 = this.plugin.chatManager) == null ? void 0 : _a2.getActiveChat());
          if (chat && chat.metadata.selectedRolePath !== nrp) {
            await this.plugin.chatManager.updateActiveChatMetadata({
              selectedRolePath: nrp
            });
            (_c2 = (_b2 = this.plugin.promptService) == null ? void 0 : _b2.clearRoleCache) == null ? void 0 : _c2.call(_b2);
          }
          this.plugin.emit("role-changed", "None");
        }
        this.closeMenu();
      });
      if (roles.length > 0)
        container.createEl("hr", { cls: CSS_CLASS_MENU_SEPARATOR });
      roles.forEach((roleInfo) => {
        const roleOptionEl = container.createDiv({
          cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_ROLE_OPTION}`
        });
        if (roleInfo.isCustom)
          roleOptionEl.addClass("is-custom");
        const iconSpan = roleOptionEl.createEl("span", {
          cls: "menu-option-icon"
        });
        if (roleInfo.path === currentChatRolePath) {
          (0, import_obsidian3.setIcon)(iconSpan, "check");
          roleOptionEl.addClass("is-selected");
        } else {
          (0, import_obsidian3.setIcon)(iconSpan, roleInfo.isCustom ? "user" : "box");
          iconSpan.style.minWidth = "18px";
        }
        roleOptionEl.createEl("span", {
          cls: "menu-option-text",
          text: roleInfo.name
        });
        this.registerDomEvent(roleOptionEl, "click", async () => {
          var _a2, _b2, _c2;
          const nrp = roleInfo.path;
          if (this.plugin.settings.selectedRolePath !== nrp || currentChatRolePath !== nrp) {
            this.plugin.settings.selectedRolePath = nrp;
            await this.plugin.saveSettings();
            const chat = await ((_a2 = this.plugin.chatManager) == null ? void 0 : _a2.getActiveChat());
            if (chat && chat.metadata.selectedRolePath !== nrp) {
              await this.plugin.chatManager.updateActiveChatMetadata({
                selectedRolePath: nrp
              });
              (_c2 = (_b2 = this.plugin.promptService) == null ? void 0 : _b2.clearRoleCache) == null ? void 0 : _c2.call(_b2);
            }
            this.plugin.emit("role-changed", roleInfo.name);
          }
          this.closeMenu();
        });
      });
      this.updateSubmenuHeight(container);
    } catch (error) {
      container.empty();
      container.createEl("div", {
        cls: "menu-error-text",
        text: "Error roles."
      });
      this.updateSubmenuHeight(container);
    }
  }
  async renderChatListMenu() {
    var _a, _b;
    const container = this.chatSubmenuContent;
    if (!container) {
      this.plugin.logger.warn(
        "[renderChatListMenu] Chat submenu container not found!"
      );
      return;
    }
    container.empty();
    try {
      const chats = ((_a = this.plugin.chatManager) == null ? void 0 : _a.listAvailableChats()) || [];
      const currentActiveId = (_b = this.plugin.chatManager) == null ? void 0 : _b.getActiveChatId();
      this.plugin.logger.debug(
        `[renderChatListMenu] Fetched ${chats.length} chats from ChatManager. Active ID: ${currentActiveId}`
      );
      if (chats.length === 0) {
        container.createEl("div", {
          cls: "menu-info-text",
          text: "No saved chats."
        });
        this.plugin.logger.debug(
          "[renderChatListMenu] Rendered 'No saved chats.' message."
        );
        return;
      }
      chats.forEach((chatMeta) => {
        const chatOptionEl = container.createDiv({
          cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_CHAT_OPTION}`
        });
        const iconSpan = chatOptionEl.createEl("span", {
          cls: "menu-option-icon"
        });
        if (chatMeta.id === currentActiveId) {
          (0, import_obsidian3.setIcon)(iconSpan, "check");
          chatOptionEl.addClass("is-selected");
        } else {
          (0, import_obsidian3.setIcon)(iconSpan, "message-square");
        }
        const textSpan = chatOptionEl.createEl("span", {
          cls: "menu-option-text"
        });
        textSpan.createEl("div", {
          cls: "chat-option-name",
          text: chatMeta.name
        });
        const dateText = this.formatRelativeDate(
          new Date(chatMeta.lastModified)
        );
        textSpan.createEl("div", {
          cls: "chat-option-date",
          text: dateText
        });
        this.registerDomEvent(chatOptionEl, "click", async () => {
          var _a2;
          this.plugin.logger.debug(
            `[renderChatListMenu] Clicked chat option: ${chatMeta.name} (ID: ${chatMeta.id})`
          );
          if (chatMeta.id !== ((_a2 = this.plugin.chatManager) == null ? void 0 : _a2.getActiveChatId())) {
            await this.plugin.chatManager.setActiveChat(chatMeta.id);
          }
          this.closeMenu();
        });
      });
      this.updateSubmenuHeight(container);
      this.plugin.logger.debug(
        "[renderChatListMenu] Finished rendering chat list successfully."
      );
    } catch (error) {
      this.plugin.logger.error(
        "[renderChatListMenu] Error rendering chat list:",
        error
      );
      container.empty();
      container.createEl("div", {
        cls: "menu-error-text",
        text: "Error chats."
      });
      this.updateSubmenuHeight(container);
    }
  }
  updateSubmenuHeight(contentEl) {
    if (contentEl && !contentEl.classList.contains(CSS_CLASS_SUBMENU_CONTENT_HIDDEN)) {
      requestAnimationFrame(() => {
        contentEl.style.maxHeight = contentEl.scrollHeight + "px";
      });
    }
  }
  // --- Speech Recognition Methods ---
  // --- Speech Recognition Placeholders ---
  initSpeechWorker() {
    try {
      const bufferToBase64 = (buffer) => {
        let binary = "";
        const bytes = new Uint8Array(buffer);
        const len = bytes.byteLength;
        for (let i = 0; i < len; i++) {
          binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
      };
      const workerCode = `
             // Worker Scope
             self.onmessage = async (event) => {
                 const { apiKey, audioBlob, languageCode = 'uk-UA' } = event.data;

                 if (!apiKey || apiKey.trim() === '') {
                     self.postMessage({ error: true, message: 'Google API Key is not configured. Please add it in plugin settings.' });
                     return;
                 }

                 const url = "https://speech.googleapis.com/v1/speech:recognize?key=" + apiKey;

                 try {
                     const arrayBuffer = await audioBlob.arrayBuffer();

                     // Optimized Base64 Conversion (using helper if needed, or direct if worker supports TextDecoder efficiently)
                     // Simpler approach: pass buffer directly if API allows, or use efficient base64:
                     let base64Audio;
                     if (typeof TextDecoder !== 'undefined') { // Browser environment check
                             // Modern approach (often faster if native)
                             const base64String = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
                             base64Audio = base64String;

                     } else {
                             // Fallback (similar to original, ensure correctness)
                             base64Audio = btoa(
                                 new Uint8Array(arrayBuffer).reduce((data, byte) => data + String.fromCharCode(byte), '')
                             );
                     }


                     const response = await fetch(url, {
                         method: 'POST',
                         body: JSON.stringify({
                             config: {
                                 encoding: 'WEBM_OPUS', // Ensure this matches MediaRecorder output
                                 sampleRateHertz: 48000, // Match sample rate if possible
                                 languageCode: languageCode,
                                 model: 'latest_long', // Consider other models if needed
                                 enableAutomaticPunctuation: true,
                             },
                             audio: { content: base64Audio },
                         }),
                         headers: { 'Content-Type': 'application/json' },
                     });

                     const responseData = await response.json();

                     if (!response.ok) {
                         //console.error("Google Speech API Error:", responseData);
                         self.postMessage({
                             error: true,
                             message: "Error from Google Speech API: " + (responseData.error?.message || response.statusText || 'Unknown error')
                         });
                         return;
                     }

                     if (responseData.results && responseData.results.length > 0) {
                         const transcript = responseData.results
                             .map(result => result.alternatives[0].transcript)
                             .join(' ')
                             .trim();
                         self.postMessage(transcript); // Send back only the transcript string
                     } else {
                         // Handle cases where API returns ok but no results (e.g., silence)
                         self.postMessage({ error: true, message: 'No speech detected or recognized.' });
                     }
                 } catch (error) {
                     //console.error("Error in speech worker processing:", error);
                     self.postMessage({
                         error: true,
                         message: 'Error processing speech recognition: ' + (error instanceof Error ? error.message : String(error))
                     });
                 }
             };
           `;
      const workerBlob = new Blob([workerCode], {
        type: "application/javascript"
      });
      const workerUrl = URL.createObjectURL(workerBlob);
      this.speechWorker = new Worker(workerUrl);
      URL.revokeObjectURL(workerUrl);
      this.setupSpeechWorkerHandlers();
    } catch (error) {
      new import_obsidian3.Notice("Speech recognition feature failed to initialize.");
      this.speechWorker = null;
    }
  }
  setupSpeechWorkerHandlers() {
    if (!this.speechWorker)
      return;
    this.speechWorker.onmessage = (event) => {
      const data = event.data;
      if (data && typeof data === "object" && data.error) {
        new import_obsidian3.Notice(`Speech Recognition Error: ${data.message}`);
        this.updateInputPlaceholder(this.plugin.settings.modelName);
        this.updateSendButtonState();
        return;
      }
      if (typeof data === "string" && data.trim()) {
        const transcript = data.trim();
        this.insertTranscript(transcript);
      } else if (typeof data !== "string") {
      }
      this.updateSendButtonState();
    };
    this.speechWorker.onerror = (error) => {
      new import_obsidian3.Notice(
        "An unexpected error occurred in the speech recognition worker."
      );
      this.updateInputPlaceholder(this.plugin.settings.modelName);
      this.stopVoiceRecording(false);
    };
  }
  insertTranscript(transcript) {
    var _a, _b;
    if (!this.inputEl)
      return;
    const currentVal = this.inputEl.value;
    const start = (_a = this.inputEl.selectionStart) != null ? _a : currentVal.length;
    const end = (_b = this.inputEl.selectionEnd) != null ? _b : currentVal.length;
    let textToInsert = transcript;
    const precedingChar = start > 0 ? currentVal[start - 1] : null;
    const followingChar = end < currentVal.length ? currentVal[end] : null;
    if (precedingChar && precedingChar !== " " && precedingChar !== "\n") {
      textToInsert = " " + textToInsert;
    }
    if (followingChar && followingChar !== " " && followingChar !== "\n" && !textToInsert.endsWith(" ")) {
      textToInsert += " ";
    }
    const newValue = currentVal.substring(0, start) + textToInsert + currentVal.substring(end);
    this.inputEl.value = newValue;
    const newCursorPos = start + textToInsert.length;
    this.inputEl.setSelectionRange(newCursorPos, newCursorPos);
    this.inputEl.focus();
    this.inputEl.dispatchEvent(new Event("input"));
  }
  async toggleVoiceRecognition() {
    if (this.mediaRecorder && this.mediaRecorder.state === "recording") {
      this.stopVoiceRecording(true);
    } else {
      await this.startVoiceRecognition();
    }
  }
  async startVoiceRecognition() {
    var _a;
    if (!this.speechWorker) {
      new import_obsidian3.Notice(
        "\u0424\u0443\u043D\u043A\u0446\u0456\u044F \u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u0432\u0430\u043D\u043D\u044F \u043C\u043E\u0432\u043B\u0435\u043D\u043D\u044F \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u0430 (worker \u043D\u0435 \u0456\u043D\u0456\u0446\u0456\u0430\u043B\u0456\u0437\u043E\u0432\u0430\u043D\u043E)."
      );
      return;
    }
    const speechApiKey = this.plugin.settings.googleApiKey;
    if (!speechApiKey) {
      new import_obsidian3.Notice(
        "\u041A\u043B\u044E\u0447 Google API \u0434\u043B\u044F \u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u0432\u0430\u043D\u043D\u044F \u043C\u043E\u0432\u043B\u0435\u043D\u043D\u044F \u043D\u0435 \u043D\u0430\u043B\u0430\u0448\u0442\u043E\u0432\u0430\u043D\u043E. \u0411\u0443\u0434\u044C \u043B\u0430\u0441\u043A\u0430, \u0434\u043E\u0434\u0430\u0439\u0442\u0435 \u0439\u043E\u0433\u043E \u0432 \u043D\u0430\u043B\u0430\u0448\u0442\u0443\u0432\u0430\u043D\u043D\u044F\u0445 \u043F\u043B\u0430\u0433\u0456\u043D\u0430."
      );
      return;
    }
    try {
      this.audioStream = await navigator.mediaDevices.getUserMedia({
        audio: true
      });
      let recorderOptions;
      const preferredMimeType = "audio/webm;codecs=opus";
      if (MediaRecorder.isTypeSupported(preferredMimeType)) {
        recorderOptions = { mimeType: preferredMimeType };
      } else {
        recorderOptions = void 0;
      }
      this.mediaRecorder = new MediaRecorder(this.audioStream, recorderOptions);
      const audioChunks = [];
      (_a = this.voiceButton) == null ? void 0 : _a.classList.add(CSS_CLASS_RECORDING);
      (0, import_obsidian3.setIcon)(this.voiceButton, "stop-circle");
      this.inputEl.placeholder = "Recording... Speak now.";
      this.mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          audioChunks.push(event.data);
        }
      };
      this.mediaRecorder.onstop = () => {
        var _a2;
        if (this.speechWorker && audioChunks.length > 0) {
          const audioBlob = new Blob(audioChunks, {
            type: ((_a2 = this.mediaRecorder) == null ? void 0 : _a2.mimeType) || "audio/webm"
          });
          this.inputEl.placeholder = "Processing speech...";
          this.speechWorker.postMessage({
            apiKey: speechApiKey,
            // Використовуємо правильний ключ
            audioBlob,
            languageCode: this.plugin.settings.speechLanguage || "uk-UA"
          });
        } else if (audioChunks.length === 0) {
          this.getCurrentRoleDisplayName().then(
            (roleName) => this.updateInputPlaceholder(roleName)
          );
          this.updateSendButtonState();
        }
      };
      this.mediaRecorder.onerror = (event) => {
        new import_obsidian3.Notice("An error occurred during recording.");
        this.stopVoiceRecording(false);
      };
      this.mediaRecorder.start();
    } catch (error) {
      if (error instanceof DOMException && error.name === "NotAllowedError") {
        new import_obsidian3.Notice("Microphone access denied. Please grant permission.");
      } else if (error instanceof DOMException && error.name === "NotFoundError") {
        new import_obsidian3.Notice(
          "Microphone not found. Please ensure it's connected and enabled."
        );
      } else {
        new import_obsidian3.Notice("Could not start voice recording.");
      }
      this.stopVoiceRecording(false);
    }
  }
  stopVoiceRecording(processAudio) {
    var _a, _b;
    if (this.mediaRecorder && this.mediaRecorder.state === "recording") {
      this.mediaRecorder.stop();
    } else if (!processAudio && ((_a = this.mediaRecorder) == null ? void 0 : _a.state) === "inactive") {
    }
    (_b = this.voiceButton) == null ? void 0 : _b.classList.remove(CSS_CLASS_RECORDING);
    (0, import_obsidian3.setIcon)(this.voiceButton, "mic");
    this.getCurrentRoleDisplayName().then(
      (roleName) => this.updateInputPlaceholder(roleName)
    );
    this.updateSendButtonState();
    if (this.audioStream) {
      this.audioStream.getTracks().forEach((track) => track.stop());
      this.audioStream = null;
    }
    this.mediaRecorder = null;
  }
  // --- Thinking Tag Handling ---
  processThinkingTags(content) {
    const r = /<think>([\s\S]*?)<\/think>/g;
    let i = 0;
    const p = [];
    let m;
    while ((m = r.exec(content)) !== null) {
      if (m.index > i)
        p.push(this.markdownToHtml(content.substring(i, m.index)));
      const c = m[1];
      const h = `<div class="${CSS_CLASS_THINKING_BLOCK}"><div class="${CSS_CLASS_THINKING_HEADER}" data-fold-state="folded"><div class="${CSS_CLASS_THINKING_TOGGLE}">\u25BA</div><div class="${CSS_CLASS_THINKING_TITLE}">Thinking</div></div><div class="${CSS_CLASS_THINKING_CONTENT}" style="display: none;">${this.markdownToHtml(
        c
      )}</div></div>`;
      p.push(h);
      i = r.lastIndex;
    }
    if (i < content.length)
      p.push(this.markdownToHtml(content.substring(i)));
    return p.join("");
  }
  markdownToHtml(markdown) {
    var _a, _b;
    if (!(markdown == null ? void 0 : markdown.trim()))
      return "";
    const d = document.createElement("div");
    import_obsidian3.MarkdownRenderer.renderMarkdown(
      markdown,
      d,
      (_b = (_a = this.app.workspace.getActiveFile()) == null ? void 0 : _a.path) != null ? _b : "",
      this
    );
    return d.innerHTML;
  }
  addThinkingToggleListeners(contentEl) {
    const h = contentEl.querySelectorAll(
      `.${CSS_CLASS_THINKING_HEADER}`
    );
    h.forEach((hdr) => {
      this.registerDomEvent(hdr, "click", () => {
        const c = hdr.nextElementSibling;
        const t = hdr.querySelector(
          `.${CSS_CLASS_THINKING_TOGGLE}`
        );
        if (!c || !t)
          return;
        const f = hdr.getAttribute("data-fold-state") === "folded";
        if (f) {
          c.style.display = "block";
          t.textContent = "\u25BC";
          hdr.setAttribute("data-fold-state", "expanded");
        } else {
          c.style.display = "none";
          t.textContent = "\u25BA";
          hdr.setAttribute("data-fold-state", "folded");
        }
      });
    });
  }
  decodeHtmlEntities(text) {
    if (typeof document === "undefined") {
      return text.replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&#39;/g, "'");
    }
    const ta = document.createElement("textarea");
    ta.innerHTML = text;
    return ta.value;
  }
  detectThinkingTags(content) {
    return /<think>[\s\S]*?<\/think>/gi.test(content) ? { hasThinkingTags: true, format: "standard" } : { hasThinkingTags: false, format: "none" };
  }
  // --- Message Collapsing ---
  checkMessageForCollapsing(messageEl) {
    const c = messageEl.querySelector(
      `.${CSS_CLASS_CONTENT_COLLAPSIBLE}`
    );
    const h = this.plugin.settings.maxMessageHeight;
    if (!c || h <= 0) {
      if (c && h <= 0) {
        const b = messageEl.querySelector(`.${CSS_CLASS_SHOW_MORE_BUTTON}`);
        b == null ? void 0 : b.remove();
        c.style.maxHeight = "";
        c.classList.remove(CSS_CLASS_CONTENT_COLLAPSED);
      }
      return;
    }
    requestAnimationFrame(() => {
      if (!c)
        return;
      const b = messageEl.querySelector(`.${CSS_CLASS_SHOW_MORE_BUTTON}`);
      b == null ? void 0 : b.remove();
      c.style.maxHeight = "";
      c.classList.remove(CSS_CLASS_CONTENT_COLLAPSED);
      const sh = c.scrollHeight;
      if (sh > h) {
        c.style.maxHeight = `${h}px`;
        c.classList.add(CSS_CLASS_CONTENT_COLLAPSED);
        const smb = messageEl.createEl("button", {
          cls: CSS_CLASS_SHOW_MORE_BUTTON,
          text: "Show More \u25BC"
        });
        this.registerDomEvent(
          smb,
          "click",
          () => this.toggleMessageCollapse(c, smb)
        );
      } else {
        c.style.maxHeight = "";
        c.classList.remove(CSS_CLASS_CONTENT_COLLAPSED);
      }
    });
  }
  checkAllMessagesForCollapsing() {
    var _a;
    (_a = this.chatContainer) == null ? void 0 : _a.querySelectorAll(`.${CSS_CLASS_MESSAGE}`).forEach((msgEl) => {
      this.checkMessageForCollapsing(msgEl);
    });
  }
  toggleMessageCollapse(contentEl, buttonEl) {
    const i = contentEl.classList.contains(CSS_CLASS_CONTENT_COLLAPSED);
    const h = this.plugin.settings.maxMessageHeight;
    if (i) {
      contentEl.style.maxHeight = "";
      contentEl.classList.remove(CSS_CLASS_CONTENT_COLLAPSED);
      buttonEl.setText("Show Less \u25B2");
    } else {
      contentEl.style.maxHeight = `${h}px`;
      contentEl.classList.add(CSS_CLASS_CONTENT_COLLAPSED);
      buttonEl.setText("Show More \u25BC");
    }
  }
  // --- Helpers & Utilities ---
  getChatContainer() {
    return this.chatContainer;
  }
  clearChatContainerInternal() {
    this.currentMessages = [];
    this.lastRenderedMessageDate = null;
    if (this.chatContainer)
      this.chatContainer.empty();
    this.hideEmptyState();
  }
  clearDisplayAndState() {
    this.clearChatContainerInternal();
    this.showEmptyState();
    this.updateSendButtonState();
    setTimeout(() => this.focusInput(), 50);
  }
  addLoadingIndicator() {
    this.hideEmptyState();
    const group = this.chatContainer.createDiv({
      cls: `${CSS_CLASS_MESSAGE_GROUP} ${CSS_CLASS_OLLAMA_GROUP}`
    });
    this.renderAvatar(group, false);
    const message = group.createDiv({
      cls: `${CSS_CLASS_MESSAGE} ${CSS_CLASS_OLLAMA_MESSAGE}`
    });
    const dots = message.createDiv({ cls: CSS_CLASS_THINKING_DOTS });
    for (let i = 0; i < 3; i++)
      dots.createDiv({ cls: CSS_CLASS_THINKING_DOT });
    this.guaranteedScrollToBottom(50, true);
    return group;
  }
  removeLoadingIndicator(loadingEl) {
    if (loadingEl == null ? void 0 : loadingEl.parentNode) {
      loadingEl.remove();
    }
  }
  scrollToBottom() {
    this.guaranteedScrollToBottom(50, true);
  }
  clearInputField() {
    if (this.inputEl) {
      this.inputEl.value = "";
      this.inputEl.dispatchEvent(new Event("input"));
    }
  }
  // Trigger resize/button update
  focusInput() {
    setTimeout(() => {
      var _a;
      (_a = this.inputEl) == null ? void 0 : _a.focus();
    }, 0);
  }
  // Use setTimeout to ensure focus happens after potential UI updates
  /** Guarantees scroll to bottom after a delay, respecting user scroll position unless forced */
  guaranteedScrollToBottom(delay = 50, forceScroll = false) {
    if (this.scrollTimeout) {
      clearTimeout(this.scrollTimeout);
      this.scrollTimeout = null;
    }
    this.scrollTimeout = setTimeout(() => {
      requestAnimationFrame(() => {
        var _a, _b;
        if (this.chatContainer) {
          const threshold = 100;
          const isScrolledUp = this.chatContainer.scrollHeight - this.chatContainer.scrollTop - this.chatContainer.clientHeight > threshold;
          if (isScrolledUp !== this.userScrolledUp) {
            this.userScrolledUp = isScrolledUp;
            if (!isScrolledUp)
              (_a = this.newMessagesIndicatorEl) == null ? void 0 : _a.classList.remove(CSS_CLASS_VISIBLE);
          }
          if (forceScroll || !this.userScrolledUp || this.isProcessing) {
            const behavior = this.isProcessing ? "auto" : "smooth";
            this.chatContainer.scrollTo({
              top: this.chatContainer.scrollHeight,
              behavior
            });
            if (forceScroll) {
              this.userScrolledUp = false;
              (_b = this.newMessagesIndicatorEl) == null ? void 0 : _b.classList.remove(CSS_CLASS_VISIBLE);
            }
          }
        } else {
        }
      });
      this.scrollTimeout = null;
    }, delay);
  }
  // Formatting Helpers
  formatTime(date) {
    return date.toLocaleTimeString(void 0, {
      hour: "numeric",
      minute: "2-digit"
    });
  }
  // Use locale default time format
  formatDateSeparator(date) {
    const now = new Date();
    const yesterday = new Date(now);
    yesterday.setDate(now.getDate() - 1);
    if (this.isSameDay(date, now))
      return "Today";
    else if (this.isSameDay(date, yesterday))
      return "Yesterday";
    else
      return date.toLocaleDateString(void 0, {
        weekday: "long",
        year: "numeric",
        month: "long",
        day: "numeric"
      });
  }
  formatRelativeDate(date) {
    const now = new Date();
    const diffSeconds = Math.round((now.getTime() - date.getTime()) / 1e3);
    const diffDays = Math.floor(diffSeconds / (60 * 60 * 24));
    if (diffDays === 0) {
      const diffHours = Math.floor(diffSeconds / (60 * 60));
      if (diffHours < 1)
        return "Just now";
      if (diffHours === 1)
        return "1 hour ago";
      if (diffHours < now.getHours())
        return `${diffHours} hours ago`;
      else
        return "Today";
    } else if (diffDays === 1) {
      return "Yesterday";
    } else if (diffDays < 7) {
      return `${diffDays} days ago`;
    } else {
      return date.toLocaleDateString(void 0, {
        month: "short",
        day: "numeric"
      });
    }
  }
  isSameDay(date1, date2) {
    return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate();
  }
  // Formatting function used by export
  formatChatToMarkdown(messagesToFormat) {
    let localLastDate = null;
    const exportTimestamp = new Date();
    let markdown = `# AI Forge Chat Export
> Exported on: ${exportTimestamp.toLocaleString(void 0)}

`;
    messagesToFormat.forEach((message) => {
      var _a;
      if (!((_a = message.content) == null ? void 0 : _a.trim()))
        return;
      if (localLastDate === null || !this.isSameDay(localLastDate, message.timestamp)) {
        if (localLastDate !== null)
          markdown += `***
`;
        markdown += `**${this.formatDateSeparator(
          message.timestamp
        )}**
***

`;
      }
      localLastDate = message.timestamp;
      const time = this.formatTime(message.timestamp);
      let prefix = "";
      let contentPrefix = "";
      let content = message.content.trim();
      if (message.role === "assistant") {
        content = this.decodeHtmlEntities(content).replace(/<think>[\s\S]*?<\/think>/g, "").trim();
        if (!content)
          return;
      }
      switch (message.role) {
        case "user":
          prefix = `**User (${time}):**
`;
          break;
        case "assistant":
          prefix = `**Assistant (${time}):**
`;
          break;
        case "system":
          prefix = `> _[System (${time})]_ 
> `;
          contentPrefix = "> ";
          break;
        case "error":
          prefix = `> [!ERROR] Error (${time}):
> `;
          contentPrefix = "> ";
          break;
      }
      markdown += prefix;
      if (contentPrefix) {
        markdown += content.split("\n").map(
          (line) => line.trim() ? `${contentPrefix}${line}` : contentPrefix.trim()
        ).join(`
`) + "\n\n";
      } else if (content.includes("```")) {
        content = content.replace(/(\n*\s*)```/g, "\n\n```").replace(/```(\s*\n*)/g, "```\n\n");
        markdown += content.trim() + "\n\n";
      } else {
        markdown += content.split("\n").map((line) => line.trim() ? line : "").join("\n") + "\n\n";
      }
    });
    return markdown.trim();
  }
  async getCurrentRoleDisplayName() {
    var _a, _b, _c, _d;
    try {
      const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
      const rolePath = (_c = (_b = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _b.selectedRolePath) != null ? _c : this.plugin.settings.selectedRolePath;
      if (rolePath) {
        const allRoles = await this.plugin.listRoleFiles(true);
        const foundRole = allRoles.find((role) => role.path === rolePath);
        if (foundRole) {
          return foundRole.name;
        } else {
          console.warn(
            `Role with path "${rolePath}" not found in listRoleFiles results.`
          );
          return ((_d = rolePath.split("/").pop()) == null ? void 0 : _d.replace(".md", "")) || "Selected Role";
        }
      }
    } catch (error) {
      console.error("Error getting current role display name:", error);
    }
    return "None";
  }
  updateTemperatureIndicator(temperature) {
    if (!this.temperatureIndicatorEl)
      return;
    const tempValue = temperature != null ? temperature : this.plugin.settings.temperature;
    const emoji = this.getTemperatureEmoji(tempValue);
    this.temperatureIndicatorEl.setText(emoji);
    this.temperatureIndicatorEl.title = `Temperature: ${tempValue.toFixed(
      1
    )}. Click to change.`;
  }
  // --- Нова допоміжна функція для отримання емодзі температури ---
  getTemperatureEmoji(temperature) {
    if (temperature <= 0.4) {
      return "\u{1F9CA}";
    } else if (temperature > 0.4 && temperature <= 0.6) {
      return "\u{1F642}";
    } else {
      return "\u{1F92A}";
    }
  }
  updateToggleViewLocationOption() {
    if (!this.toggleViewLocationOption)
      return;
    this.toggleViewLocationOption.empty();
    const iconSpan = this.toggleViewLocationOption.createSpan({
      cls: "menu-option-icon"
    });
    const textSpan = this.toggleViewLocationOption.createSpan({
      cls: "menu-option-text"
    });
    if (this.plugin.settings.openChatInTab) {
      (0, import_obsidian3.setIcon)(iconSpan, "sidebar-right");
      textSpan.setText("Show in Sidebar");
      this.toggleViewLocationOption.title = "Close tab and reopen in sidebar";
    } else {
      (0, import_obsidian3.setIcon)(iconSpan, "layout-list");
      textSpan.setText("Show in Tab");
      this.toggleViewLocationOption.title = "Close sidebar panel and reopen in tab";
    }
  }
  async findRoleNameByPath(rolePath) {
    var _a;
    if (!rolePath) {
      return "None";
    }
    try {
      const allRoles = await this.plugin.listRoleFiles(true);
      const foundRole = allRoles.find((role) => role.path === rolePath);
      if (foundRole) {
        return foundRole.name;
      } else {
        const fileName = (_a = rolePath.split("/").pop()) == null ? void 0 : _a.replace(".md", "");
        this.plugin.logger.warn(
          `[findRoleNameByPath] Role not found in list for path "${rolePath}". Using derived name: "${fileName || "Unknown"}"`
        );
        return fileName || "Unknown Role";
      }
    } catch (error) {
      this.plugin.logger.error(
        `[findRoleNameByPath] Error fetching roles list while finding name for path "${rolePath}":`,
        error
      );
      return "Error";
    }
  }
};

// src/settings.ts
var import_obsidian5 = require("obsidian");

// src/Logger.ts
var import_obsidian4 = require("obsidian");
var LogLevel = /* @__PURE__ */ ((LogLevel3) => {
  LogLevel3[LogLevel3["DEBUG"] = 1] = "DEBUG";
  LogLevel3[LogLevel3["INFO"] = 2] = "INFO";
  LogLevel3[LogLevel3["WARN"] = 3] = "WARN";
  LogLevel3[LogLevel3["ERROR"] = 4] = "ERROR";
  LogLevel3[LogLevel3["NONE"] = 5] = "NONE";
  return LogLevel3;
})(LogLevel || {});
var Logger = class {
  constructor(plugin, initialSettings) {
    this.consoleLogLevel = 2 /* INFO */;
    this.fileLogLevel = 3 /* WARN */;
    this.fileLoggingEnabled = false;
    this.logCallerInfo = false;
    // <--- Прапорець для опції
    this.logFileMaxSizeMB = 5;
    this.logQueue = [];
    // Буфер для запису у файл
    this.isWritingToFile = false;
    this.writeDebounceTimeout = null;
    this.plugin = plugin;
    this.adapter = plugin.app.vault.adapter;
    this.logFilePath = (0, import_obsidian4.normalizePath)(initialSettings.logFilePath || `${this.plugin.manifest.dir}/ai-forge.log`);
    this.logFileMaxSizeMB = initialSettings.logFileMaxSizeMB || 5;
    this.updateSettings(initialSettings);
    console.log(`[Logger] Initialized. Console Level: ${this.getLogLevelName(this.consoleLogLevel)}, File Logging: ${this.fileLoggingEnabled}, File Level: ${this.getLogLevelName(this.fileLogLevel)}, Log Caller: ${this.logCallerInfo}, Path: ${this.logFilePath}`);
    if (this.fileLoggingEnabled) {
      this.rotateLogFileIfNeeded().then(() => {
        this.info("Logger initialized & file rotation checked.");
      });
    } else {
      this.info("Logger initialized.");
    }
  }
  getLogLevelName(level) {
    return LogLevel[level] || "UNKNOWN";
  }
  getLogLevelFromString(levelString, defaultLevel = 2 /* INFO */) {
    switch (levelString == null ? void 0 : levelString.toUpperCase()) {
      case "DEBUG":
        return 1 /* DEBUG */;
      case "INFO":
        return 2 /* INFO */;
      case "WARN":
        return 3 /* WARN */;
      case "ERROR":
        return 4 /* ERROR */;
      case "NONE":
        return 5 /* NONE */;
      default:
        return defaultLevel;
    }
  }
  // --- Оновлення Налаштувань ---
  updateSettings(settings) {
    if (settings.consoleLogLevel !== void 0) {
      this.consoleLogLevel = this.getLogLevelFromString(settings.consoleLogLevel, 2 /* INFO */);
      console.log(`[Logger] Console log level set to: ${this.getLogLevelName(this.consoleLogLevel)}`);
    }
    if (settings.fileLogLevel !== void 0) {
      this.fileLogLevel = this.getLogLevelFromString(settings.fileLogLevel, 3 /* WARN */);
      console.log(`[Logger] File log level set to: ${this.getLogLevelName(this.fileLogLevel)}`);
    }
    if (settings.fileLoggingEnabled !== void 0) {
      const wasEnabled = this.fileLoggingEnabled;
      this.fileLoggingEnabled = settings.fileLoggingEnabled;
      console.log(`[Logger] File logging enabled: ${this.fileLoggingEnabled}`);
      if (!wasEnabled && this.fileLoggingEnabled) {
        this.rotateLogFileIfNeeded();
      }
    }
    if (settings.logCallerInfo !== void 0) {
      this.logCallerInfo = settings.logCallerInfo;
      console.log(`[Logger] Log Caller Info enabled: ${this.logCallerInfo}`);
    }
  }
  // --- Отримання Інформації про Викликаючого ---
  /**
   * Намагається визначити ім'я/контекст функції, що викликала метод логера.
   * УВАГА: Має вплив на продуктивність! Використовуйте обережно.
   */
  getCallerInfo() {
    var _a, _b;
    if (!this.logCallerInfo) {
      return "unknown";
    }
    try {
      const err = new Error();
      const stackLines = (_a = err.stack) == null ? void 0 : _a.split("\n");
      if (stackLines && stackLines.length > 3) {
        const callerLine = stackLines[3];
        const match = callerLine.match(/at (?:new )?([\w$.<>\[\] ]+)?(?: \[as \w+\])? ?\(?/);
        let callerName = (_b = match == null ? void 0 : match[1]) == null ? void 0 : _b.trim();
        if (callerName) {
          callerName = callerName.replace(/^Object\./, "");
          callerName = callerName.replace(/<anonymous>/, "anonymous");
          if (callerName.includes("/") || callerName.includes("\\")) {
            return "(file context)";
          }
          return callerName;
        }
      }
    } catch (e) {
    }
    return "unknown";
  }
  // --- Методи Логування ---
  debug(...args) {
    this.log(1 /* DEBUG */, console.debug, ...args);
  }
  info(...args) {
    this.log(2 /* INFO */, console.info, ...args);
  }
  warn(...args) {
    this.log(3 /* WARN */, console.warn, ...args);
  }
  error(...args) {
    this.log(4 /* ERROR */, console.error, ...args);
  }
  // --- Ядро Логування ---
  log(level, consoleMethod, ...args) {
    const caller = this.getCallerInfo();
    if (level >= this.consoleLogLevel) {
      const prefix = this.logCallerInfo && caller !== "unknown" ? `[${this.getLogLevelName(level)}] [${caller}]` : `[${this.getLogLevelName(level)}]`;
      consoleMethod(prefix, ...args);
    }
    if (this.fileLoggingEnabled && level >= this.fileLogLevel) {
      this.queueOrWriteToFile(level, caller, args);
    }
  }
  // --- Робота з Файлом (з чергою/буфером) ---
  queueOrWriteToFile(level, caller, args) {
    try {
      const timestamp = new Date().toISOString();
      const levelName = this.getLogLevelName(level);
      const message = args.map((arg) => {
        if (typeof arg === "string")
          return arg;
        if (arg instanceof Error)
          return arg.stack || arg.message;
        try {
          return JSON.stringify(arg);
        } catch (e) {
          return String(arg);
        }
      }).join(" ");
      const callerInfo = this.logCallerInfo && caller !== "unknown" ? ` [${caller}]` : "";
      const logLine = `${timestamp} [${levelName}]${callerInfo} ${message}
`;
      this.logQueue.push(logLine);
      if (!this.isWritingToFile) {
        this.triggerWriteToFile();
      }
    } catch (error) {
      console.error("[Logger] Error formatting log line:", error);
    }
  }
  triggerWriteToFile() {
    if (this.writeDebounceTimeout) {
      clearTimeout(this.writeDebounceTimeout);
    }
    this.writeDebounceTimeout = setTimeout(async () => {
      if (this.isWritingToFile || this.logQueue.length === 0) {
        return;
      }
      this.isWritingToFile = true;
      const linesToWrite = [...this.logQueue];
      this.logQueue = [];
      try {
        const contentToWrite = linesToWrite.join("");
        await this.adapter.append(this.logFilePath, contentToWrite);
      } catch (error) {
        console.error("[Logger] Failed to write batch to log file:", error);
        this.logQueue.unshift(...linesToWrite);
      } finally {
        this.isWritingToFile = false;
        if (this.logQueue.length > 0) {
          this.triggerWriteToFile();
        }
      }
    }, 500);
  }
  async rotateLogFileIfNeeded() {
    if (!this.fileLoggingEnabled)
      return;
    try {
      if (await this.adapter.exists(this.logFilePath)) {
        const stats = await this.adapter.stat(this.logFilePath);
        const maxSizeInBytes = (this.logFileMaxSizeMB || 5) * 1024 * 1024;
        if (stats && stats.type === "file" && stats.size > maxSizeInBytes) {
          const backupPath = this.logFilePath + ".bak";
          console.log(`[Logger] Rotating log file (size ${stats.size} > ${maxSizeInBytes}). Backup: ${backupPath}`);
          if (await this.adapter.exists(backupPath)) {
            await this.adapter.remove(backupPath);
          }
          await this.adapter.rename(this.logFilePath, backupPath);
        }
      }
    } catch (error) {
      console.error("[Logger] Error rotating log file:", error);
    }
  }
};

// src/settings.ts
var LANGUAGES2 = {
  /* ... ваш довгий список мов ... */
  "af": "Afrikaans",
  "sq": "Albanian",
  "am": "Amharic",
  "ar": "Arabic",
  "hy": "Armenian",
  "az": "Azerbaijani",
  "eu": "Basque",
  "be": "Belarusian",
  "bn": "Bengali",
  "bs": "Bosnian",
  "bg": "Bulgarian",
  "ca": "Catalan",
  "ceb": "Cebuano",
  "ny": "Chichewa",
  "zh-CN": "Chinese (Simplified)",
  "zh-TW": "Chinese (Traditional)",
  "co": "Corsican",
  "hr": "Croatian",
  "cs": "Czech",
  "da": "Danish",
  "nl": "Dutch",
  "en": "English",
  "eo": "Esperanto",
  "et": "Estonian",
  "tl": "Filipino",
  "fi": "Finnish",
  "fr": "French",
  "fy": "Frisian",
  "gl": "Galician",
  "ka": "Georgian",
  "de": "German",
  "el": "Greek",
  "gu": "Gujarati",
  "ht": "Haitian Creole",
  "ha": "Hausa",
  "haw": "Hawaiian",
  "iw": "Hebrew",
  "he": "Hebrew",
  "hi": "Hindi",
  "hmn": "Hmong",
  "hu": "Hungarian",
  "is": "Icelandic",
  "ig": "Igbo",
  "id": "Indonesian",
  "ga": "Irish",
  "it": "Italian",
  "ja": "Japanese",
  "jw": "Javanese",
  "kn": "Kannada",
  "kk": "Kazakh",
  "km": "Khmer",
  "rw": "Kinyarwanda",
  "ko": "Korean",
  "ku": "Kurdish (Kurmanji)",
  "ky": "Kyrgyz",
  "lo": "Lao",
  "la": "Latin",
  "lv": "Latvian",
  "lt": "Lithuanian",
  "lb": "Luxembourgish",
  "mk": "Macedonian",
  "mg": "Malagasy",
  "ms": "Malay",
  "ml": "Malayalam",
  "mt": "Maltese",
  "mi": "Maori",
  "mr": "Marathi",
  "mn": "Mongolian",
  "my": "Myanmar (Burmese)",
  "ne": "Nepali",
  "no": "Norwegian",
  "or": "Odia (Oriya)",
  "ps": "Pashto",
  "fa": "Persian",
  "pl": "Polish",
  "pt": "Portuguese",
  "pa": "Punjabi",
  "ro": "Romanian",
  "ru": "Russian",
  "sm": "Samoan",
  "gd": "Scots Gaelic",
  "sr": "Serbian",
  "st": "Sesotho",
  "sn": "Shona",
  "sd": "Sindhi",
  "si": "Sinhala",
  "sk": "Slovak",
  "sl": "Slovenian",
  "so": "Somali",
  "es": "Spanish",
  "su": "Sundanese",
  "sw": "Swahili",
  "sv": "Swedish",
  "tg": "Tajik",
  "ta": "Tamil",
  "tt": "Tatar",
  "te": "Telugu",
  "th": "Thai",
  "tr": "Turkish",
  "tk": "Turkmen",
  "uk": "Ukrainian",
  "ur": "Urdu",
  "ug": "Uyghur",
  "uz": "Uzbek",
  "vi": "Vietnamese",
  "cy": "Welsh",
  "xh": "Xhosa",
  "yi": "Yiddish",
  "yo": "Yoruba",
  "zu": "Zulu"
};
var DEFAULT_SETTINGS = {
  // Connection & Model
  ollamaServerUrl: "http://localhost:11434",
  modelName: "",
  temperature: 0.7,
  contextWindow: 4096,
  // Roles
  userRolesFolderPath: "/etc/ai-forge/roles",
  selectedRolePath: "",
  followRole: true,
  // Storage & History
  saveMessageHistory: true,
  chatHistoryFolderPath: "/etc/ai-forge/chats",
  chatExportFolderPath: "/etc/ai-forge/xports",
  // View Behavior
  openChatInTab: false,
  // За замовчуванням - бічна панель
  maxMessageHeight: 300,
  // Appearance
  userAvatarType: "initials",
  userAvatarContent: "U",
  aiAvatarType: "icon",
  aiAvatarContent: "bot",
  // RAG
  ragEnabled: false,
  ragFolderPath: "etc/ai-forge/rag",
  ragEnableSemanticSearch: true,
  ragEmbeddingModel: "nomic-embed-text",
  ragChunkSize: 512,
  ragSimilarityThreshold: 0.5,
  ragTopK: 3,
  maxCharsPerDoc: 1500,
  // Productivity
  enableProductivityFeatures: false,
  dailyTaskFileName: "Tasks_Today.md",
  useAdvancedContextStrategy: false,
  enableSummarization: false,
  summarizationPrompt: "Summarize the key points discussed so far in this conversation:\n\n{text_to_summarize}",
  keepLastNMessagesBeforeSummary: 10,
  summarizationChunkSize: 1500,
  // Speech & Translation
  googleApiKey: "",
  speechLanguage: "uk-UA",
  enableTranslation: false,
  translationTargetLanguage: "uk",
  googleTranslationApiKey: "",
  // Logger Settings
  consoleLogLevel: "INFO",
  fileLoggingEnabled: false,
  fileLogLevel: "WARN",
  logCallerInfo: false,
  logFilePath: "",
  logFileMaxSizeMB: 5
};
var OllamaSettingTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.debouncedUpdateChatPath = (0, import_obsidian5.debounce)(async () => {
      this.plugin.logger.debug("Debounced: Updating chat path and ensuring folder exists...");
      if (this.plugin.chatManager) {
        this.plugin.chatManager.updateChatsFolderPath();
        await this.plugin.chatManager.ensureFoldersExist();
      }
    }, 1e3, true);
    this.debouncedUpdateRolePath = (0, import_obsidian5.debounce)(async () => {
      this.plugin.logger.debug("Debounced: Refreshing role list due to path change...");
      await this.plugin.listRoleFiles(true);
      this.plugin.emit("roles-updated");
    }, 1e3, true);
    this.debouncedUpdateRagPath = (0, import_obsidian5.debounce)(async () => {
      this.plugin.logger.debug("Debounced: Re-indexing RAG due to path change...");
      if (this.plugin.settings.ragEnabled && this.plugin.ragService) {
        await this.plugin.ragService.indexDocuments();
      }
    }, 1e3, true);
  }
  // Допоміжна функція для створення заголовків секцій
  createSectionHeader(text) {
    this.containerEl.createEl("h3", { text }).addClass("ai-forge-settings-header");
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "AI Forge Settings" });
    this.createSectionHeader("Connection & Model Defaults");
    new import_obsidian5.Setting(containerEl).setName("Ollama Server URL").setDesc("The URL of your running Ollama server (e.g., http://localhost:11434 or http://192.168.X.X:11434).").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.ollamaServerUrl).setValue(this.plugin.settings.ollamaServerUrl).onChange(async (value) => {
      let url = value.trim();
      if (url && !url.startsWith("http://") && !url.startsWith("https://")) {
        url = "http://" + url;
      }
      if (url.endsWith("/")) {
        url = url.slice(0, -1);
      }
      this.plugin.settings.ollamaServerUrl = url || DEFAULT_SETTINGS.ollamaServerUrl;
      await this.plugin.saveSettings();
    }));
    let modelDropdown = null;
    const updateOptions = async (dropdown, button) => {
      if (!dropdown)
        return;
      const currentVal = this.plugin.settings.modelName;
      dropdown.selectEl.innerHTML = "";
      dropdown.addOption("", "Loading models...");
      dropdown.setDisabled(true);
      button == null ? void 0 : button.setDisabled(true).setIcon("loader");
      try {
        const models = await this.plugin.ollamaService.getModels();
        dropdown.selectEl.innerHTML = "";
        dropdown.addOption("", "-- Select default model --");
        if (models && models.length > 0) {
          models.forEach((modelName) => {
            dropdown.addOption(modelName, modelName);
          });
          dropdown.setValue(models.includes(currentVal) ? currentVal : "");
        } else {
          dropdown.addOption("", "No models found");
          dropdown.setValue("");
        }
      } catch (error) {
        this.plugin.logger.error("Error fetching models for settings:", error);
        dropdown.selectEl.innerHTML = "";
        dropdown.addOption("", "Error loading models!");
        dropdown.setValue("");
      } finally {
        dropdown.setDisabled(false);
        button == null ? void 0 : button.setDisabled(false).setIcon("refresh-cw");
      }
    };
    new import_obsidian5.Setting(containerEl).setName("Default Model Name").setDesc("The default Ollama model for new chats.").addDropdown(async (dropdown) => {
      modelDropdown = dropdown;
      dropdown.onChange(async (value) => {
        this.plugin.settings.modelName = value;
        await this.plugin.saveSettings();
      });
      await updateOptions(dropdown);
    }).addExtraButton((button) => {
      button.setIcon("refresh-cw").setTooltip("Refresh model list").onClick(async () => {
        await updateOptions(modelDropdown, button);
        new import_obsidian5.Notice("Model list refreshed!");
      });
    });
    new import_obsidian5.Setting(containerEl).setName("Default Temperature").setDesc("Controls randomness (0.0 = deterministic, >1.0 = creative).").addSlider((slider) => slider.setLimits(0, 2, 0.1).setValue(this.plugin.settings.temperature).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.temperature = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("Context Window Size (Tokens)").setDesc("Max tokens model considers. Requires restart/reload if changed while model is loaded.").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.contextWindow.toString()).setValue(this.plugin.settings.contextWindow.toString()).onChange(async (value) => {
      const num = parseInt(value.trim(), 10);
      this.plugin.settings.contextWindow = !isNaN(num) && num > 0 ? num : DEFAULT_SETTINGS.contextWindow;
      await this.plugin.saveSettings();
    }));
    this.createSectionHeader("View Behavior");
    new import_obsidian5.Setting(containerEl).setName("Open Chat in Main Tab").setDesc("ON: Open in a main tab. OFF: Open in the right sidebar.").addToggle((toggle) => toggle.setValue(this.plugin.settings.openChatInTab).onChange(async (value) => {
      this.plugin.settings.openChatInTab = value;
      await this.plugin.saveSettings();
      new import_obsidian5.Notice("Chat view location setting saved. Re-open the view to apply.", 5e3);
    }));
    new import_obsidian5.Setting(containerEl).setName("Max Message Height (pixels)").setDesc("Collapse longer messages with 'Show More'. 0 disables.").addText((text) => text.setPlaceholder("Example: 300").setValue(this.plugin.settings.maxMessageHeight.toString()).onChange(async (value) => {
      var _a, _b;
      const num = parseInt(value.trim(), 10);
      this.plugin.settings.maxMessageHeight = !isNaN(num) && num >= 0 ? num : DEFAULT_SETTINGS.maxMessageHeight;
      await this.plugin.saveSettings();
      (_b = (_a = this.plugin.view) == null ? void 0 : _a.checkAllMessagesForCollapsing) == null ? void 0 : _b.call(_a);
    }));
    this.createSectionHeader("Appearance");
    new import_obsidian5.Setting(containerEl).setName("User Avatar Style").addDropdown((dropdown) => dropdown.addOption("initials", "Initials").addOption("icon", "Icon").setValue(this.plugin.settings.userAvatarType).onChange(async (value) => {
      this.plugin.settings.userAvatarType = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.userAvatarType === "initials") {
      new import_obsidian5.Setting(containerEl).setName("User Initials").setDesc("Max 2 chars.").addText((text) => text.setValue(this.plugin.settings.userAvatarContent).onChange(async (value) => {
        this.plugin.settings.userAvatarContent = value.trim().substring(0, 2) || "U";
        await this.plugin.saveSettings();
      }));
    } else {
      new import_obsidian5.Setting(containerEl).setName("User Icon ID").setDesc('Obsidian icon ID (e.g., "user").').addText((text) => text.setPlaceholder("user").setValue(this.plugin.settings.userAvatarContent).onChange(async (value) => {
        this.plugin.settings.userAvatarContent = value.trim() || "user";
        await this.plugin.saveSettings();
      }));
    }
    new import_obsidian5.Setting(containerEl).setName("AI Avatar Style").addDropdown((dropdown) => dropdown.addOption("initials", "Initials").addOption("icon", "Icon").setValue(this.plugin.settings.aiAvatarType).onChange(async (value) => {
      this.plugin.settings.aiAvatarType = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.aiAvatarType === "initials") {
      new import_obsidian5.Setting(containerEl).setName("AI Initials").setDesc("Max 2 chars.").addText((text) => text.setValue(this.plugin.settings.aiAvatarContent).onChange(async (value) => {
        this.plugin.settings.aiAvatarContent = value.trim().substring(0, 2) || "AI";
        await this.plugin.saveSettings();
      }));
    } else {
      new import_obsidian5.Setting(containerEl).setName("AI Icon ID").setDesc('Obsidian icon ID (e.g., "bot").').addText((text) => text.setPlaceholder("bot").setValue(this.plugin.settings.aiAvatarContent).onChange(async (value) => {
        this.plugin.settings.aiAvatarContent = value.trim() || "bot";
        await this.plugin.saveSettings();
      }));
    }
    this.createSectionHeader("Roles & Personas");
    new import_obsidian5.Setting(containerEl).setName("Custom Roles Folder Path").setDesc("Folder with custom role (.md) files.").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.userRolesFolderPath).setValue(this.plugin.settings.userRolesFolderPath).onChange(async (value) => {
      this.plugin.settings.userRolesFolderPath = value.trim();
      await this.plugin.saveSettings();
      this.debouncedUpdateRolePath();
    }));
    new import_obsidian5.Setting(containerEl).setName("Always Apply Selected Role").setDesc("Always use the selected role as system prompt.").addToggle((toggle) => toggle.setValue(this.plugin.settings.followRole).onChange(async (value) => {
      this.plugin.settings.followRole = value;
      await this.plugin.saveSettings();
    }));
    this.createSectionHeader("Storage & History");
    new import_obsidian5.Setting(containerEl).setName("Save Message History").setDesc("Save chat conversations to files.").addToggle((toggle) => toggle.setValue(this.plugin.settings.saveMessageHistory).onChange(async (value) => {
      this.plugin.settings.saveMessageHistory = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.saveMessageHistory) {
      new import_obsidian5.Setting(containerEl).setName("Chat History Folder Path").setDesc("Folder to store chat history (.json files).").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.chatHistoryFolderPath).setValue(this.plugin.settings.chatHistoryFolderPath).onChange(async (value) => {
        this.plugin.settings.chatHistoryFolderPath = value.trim() || DEFAULT_SETTINGS.chatHistoryFolderPath;
        await this.plugin.saveSettings();
        this.debouncedUpdateChatPath();
      }));
    }
    new import_obsidian5.Setting(containerEl).setName("Chat Export Folder Path").setDesc("Default folder for exported Markdown chats.").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.chatExportFolderPath || "Vault Root").setValue(this.plugin.settings.chatExportFolderPath).onChange(async (value) => {
      this.plugin.settings.chatExportFolderPath = value.trim();
      await this.plugin.saveSettings();
    }));
    this.createSectionHeader("Retrieval-Augmented Generation (RAG)");
    new import_obsidian5.Setting(containerEl).setName("Enable RAG").setDesc("Allow retrieving info from notes for context.").addToggle((toggle) => toggle.setValue(this.plugin.settings.ragEnabled).onChange(async (value) => {
      this.plugin.settings.ragEnabled = value;
      await this.plugin.saveSettings();
      this.display();
      if (value)
        this.debouncedUpdateRagPath();
    }));
    if (this.plugin.settings.ragEnabled) {
      new import_obsidian5.Setting(containerEl).setName("RAG Documents Folder Path").setDesc("Folder with notes for RAG.").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.ragFolderPath).setValue(this.plugin.settings.ragFolderPath).onChange(async (value) => {
        var _a, _b, _c, _d;
        this.plugin.settings.ragFolderPath = value.trim() || DEFAULT_SETTINGS.ragFolderPath;
        await this.plugin.saveSettings();
        this.debouncedUpdateRagPath();
        (_b = (_a = this.plugin).updateDailyTaskFilePath) == null ? void 0 : _b.call(_a);
        (_d = (_c = this.plugin).loadAndProcessInitialTasks) == null ? void 0 : _d.call(_c);
      }));
      new import_obsidian5.Setting(containerEl).setName("Enable Semantic Search").setDesc("Use embeddings (more accurate).").addToggle((toggle) => toggle.setValue(this.plugin.settings.ragEnableSemanticSearch).onChange(async (value) => {
        this.plugin.settings.ragEnableSemanticSearch = value;
        await this.plugin.saveSettings();
        this.display();
        this.debouncedUpdateRagPath();
      }));
      if (this.plugin.settings.ragEnableSemanticSearch) {
        let embeddingDropdown = null;
        const updateEmbeddingOptions = async (dropdown, button) => {
          if (!dropdown)
            return;
          const previousValue = this.plugin.settings.ragEmbeddingModel;
          dropdown.selectEl.innerHTML = "";
          dropdown.addOption("", "Loading models...");
          dropdown.setDisabled(true);
          button == null ? void 0 : button.setDisabled(true).setIcon("loader");
          try {
            const models = await this.plugin.ollamaService.getModels();
            dropdown.selectEl.innerHTML = "";
            dropdown.addOption("", "-- Select Embedding Model --");
            const commonEmbedModels = ["nomic-embed-text", "all-minilm", "mxbai-embed-large", "bge-base-en", "gte-base"];
            commonEmbedModels.forEach((modelName) => dropdown.addOption(modelName, modelName));
            dropdown.addOption("---", "--- Other Installed Models ---").setDisabled(true);
            if (models && models.length > 0) {
              models.forEach((modelName) => {
                if (!commonEmbedModels.includes(modelName)) {
                  dropdown.addOption(modelName, modelName);
                }
              });
            }
            dropdown.setValue(models.includes(previousValue) ? previousValue : commonEmbedModels[0] || "");
          } catch (error) {
            console.error("Error fetching models for embedding dropdown:", error);
            dropdown.selectEl.innerHTML = "";
            dropdown.addOption("", "Error loading models!");
            dropdown.setValue(previousValue);
          } finally {
            dropdown.setDisabled(false);
            button == null ? void 0 : button.setDisabled(false).setIcon("refresh-cw");
          }
        };
        new import_obsidian5.Setting(containerEl).setName("Embedding Model Name").setDesc("Ollama model for embeddings.").setClass("ollama-model-setting-container").addDropdown(async (dropdown) => {
          embeddingDropdown = dropdown;
          dropdown.onChange(async (value) => {
            this.plugin.settings.ragEmbeddingModel = value;
            await this.plugin.saveSettings();
            this.debouncedUpdateRagPath();
          });
          await updateEmbeddingOptions(dropdown);
        }).addExtraButton((button) => {
          button.setIcon("refresh-cw").setTooltip("Refresh model list").onClick(async () => {
            await updateEmbeddingOptions(embeddingDropdown, button);
            new import_obsidian5.Notice("Model list refreshed!");
          });
        });
        new import_obsidian5.Setting(containerEl).setName("Chunk Size (Characters)").setDesc("Size of text chunks for indexing.").addText((text) => text.setPlaceholder(String(DEFAULT_SETTINGS.ragChunkSize)).setValue(String(this.plugin.settings.ragChunkSize)).onChange(async (value) => {
          const num = parseInt(value.trim(), 10);
          this.plugin.settings.ragChunkSize = !isNaN(num) && num > 50 ? num : DEFAULT_SETTINGS.ragChunkSize;
          await this.plugin.saveSettings();
          this.debouncedUpdateRagPath();
        }));
        new import_obsidian5.Setting(containerEl).setName("Similarity Threshold").setDesc("Min relevance score (0.0-1.0).").addSlider((slider) => slider.setLimits(0, 1, 0.05).setValue(this.plugin.settings.ragSimilarityThreshold).setDynamicTooltip().onChange(async (value) => {
          this.plugin.settings.ragSimilarityThreshold = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian5.Setting(containerEl).setName("Top K Results").setDesc("Max number of relevant chunks.").addText((text) => text.setPlaceholder(String(DEFAULT_SETTINGS.ragTopK)).setValue(String(this.plugin.settings.ragTopK)).onChange(async (value) => {
          const num = parseInt(value.trim(), 10);
          this.plugin.settings.ragTopK = !isNaN(num) && num > 0 ? num : DEFAULT_SETTINGS.ragTopK;
          await this.plugin.saveSettings();
        }));
      }
      new import_obsidian5.Setting(containerEl).setName("Max Chars Per Doc (Legacy?)").setDesc("Max chars per chunk (0=no limit).").addText((text) => text.setPlaceholder(String(DEFAULT_SETTINGS.maxCharsPerDoc)).setValue(String(this.plugin.settings.maxCharsPerDoc)).onChange(async (value) => {
        const num = parseInt(value.trim(), 10);
        this.plugin.settings.maxCharsPerDoc = !isNaN(num) && num >= 0 ? num : DEFAULT_SETTINGS.maxCharsPerDoc;
        await this.plugin.saveSettings();
      }));
    }
    this.createSectionHeader("Productivity Assistant Features");
    new import_obsidian5.Setting(containerEl).setName("Enable Productivity Features").setDesc("Activate daily task integration etc.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableProductivityFeatures).onChange(async (value) => {
      var _a, _b, _c, _d;
      this.plugin.settings.enableProductivityFeatures = value;
      await this.plugin.saveSettings();
      this.display();
      (_b = (_a = this.plugin).updateDailyTaskFilePath) == null ? void 0 : _b.call(_a);
      (_d = (_c = this.plugin).loadAndProcessInitialTasks) == null ? void 0 : _d.call(_c);
    }));
    if (this.plugin.settings.enableProductivityFeatures) {
      new import_obsidian5.Setting(containerEl).setName("Daily Task File Name").setDesc("Filename in RAG folder.").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.dailyTaskFileName).setValue(this.plugin.settings.dailyTaskFileName).onChange(async (value) => {
        var _a, _b, _c, _d;
        this.plugin.settings.dailyTaskFileName = value.trim() || DEFAULT_SETTINGS.dailyTaskFileName;
        await this.plugin.saveSettings();
        (_b = (_a = this.plugin).updateDailyTaskFilePath) == null ? void 0 : _b.call(_a);
        (_d = (_c = this.plugin).loadAndProcessInitialTasks) == null ? void 0 : _d.call(_c);
      }));
      new import_obsidian5.Setting(containerEl).setName("Use Advanced Context Strategy").setDesc("Enable summarization/chunking.").addToggle((toggle) => toggle.setValue(this.plugin.settings.useAdvancedContextStrategy).onChange(async (value) => {
        this.plugin.settings.useAdvancedContextStrategy = value;
        await this.plugin.saveSettings();
        this.display();
      }));
      if (this.plugin.settings.useAdvancedContextStrategy) {
        new import_obsidian5.Setting(containerEl).setName("Enable Context Summarization").setDesc("Summarize older chat history.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableSummarization).onChange(async (value) => {
          this.plugin.settings.enableSummarization = value;
          await this.plugin.saveSettings();
          this.display();
        }));
        if (this.plugin.settings.enableSummarization) {
          new import_obsidian5.Setting(containerEl).setName("Summarization Prompt").setDesc("Use {text_to_summarize}.").addTextArea((text) => text.setPlaceholder(DEFAULT_SETTINGS.summarizationPrompt).setValue(this.plugin.settings.summarizationPrompt).onChange(async (value) => {
            this.plugin.settings.summarizationPrompt = value || DEFAULT_SETTINGS.summarizationPrompt;
            await this.plugin.saveSettings();
          }).inputEl.setAttrs({ rows: 4 }));
        }
        new import_obsidian5.Setting(containerEl).setName("Keep Last N Messages Before Summary").setDesc("Recent messages kept verbatim.").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.keepLastNMessagesBeforeSummary.toString()).setValue(this.plugin.settings.keepLastNMessagesBeforeSummary.toString()).onChange(async (value) => {
          const num = parseInt(value.trim(), 10);
          this.plugin.settings.keepLastNMessagesBeforeSummary = !isNaN(num) && num >= 0 ? num : DEFAULT_SETTINGS.keepLastNMessagesBeforeSummary;
          await this.plugin.saveSettings();
        }));
        new import_obsidian5.Setting(containerEl).setName("Summarization Chunk Size (Tokens)").setDesc("Approximate token size for summarization.").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.summarizationChunkSize.toString()).setValue(this.plugin.settings.summarizationChunkSize.toString()).onChange(async (value) => {
          const num = parseInt(value.trim(), 10);
          this.plugin.settings.summarizationChunkSize = !isNaN(num) && num > 100 ? num : DEFAULT_SETTINGS.summarizationChunkSize;
          await this.plugin.saveSettings();
        }));
      }
    }
    this.createSectionHeader("Speech & Translation");
    new import_obsidian5.Setting(containerEl).setName("Google API Key (Speech-to-Text)").setDesc("Required for voice input. Keep confidential.").addText((text) => text.setPlaceholder("Enter API Key").setValue(this.plugin.settings.googleApiKey).onChange(async (value) => {
      this.plugin.settings.googleApiKey = value.trim();
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("Speech Recognition Language").setDesc("Language for voice input.").addDropdown((dropdown) => {
      const speechLangs = {
        "uk-UA": "Ukrainian",
        "en-US": "English (US)"
        /* ... інші мови ... */
      };
      for (const code in speechLangs) {
        dropdown.addOption(code, speechLangs[code]);
      }
      dropdown.setValue(this.plugin.settings.speechLanguage).onChange(async (value) => {
        this.plugin.settings.speechLanguage = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian5.Setting(containerEl).setName("Enable Translation Feature").setDesc("Show translate buttons (uses Google Translate API).").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableTranslation).onChange(async (value) => {
      this.plugin.settings.enableTranslation = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.enableTranslation) {
      new import_obsidian5.Setting(containerEl).setName("Target Translation Language").setDesc("Translate messages/input into this language.").addDropdown((dropdown) => {
        for (const code in LANGUAGES2) {
          dropdown.addOption(code, LANGUAGES2[code]);
        }
        dropdown.setValue(this.plugin.settings.translationTargetLanguage).onChange(async (value) => {
          this.plugin.settings.translationTargetLanguage = value;
          await this.plugin.saveSettings();
        });
      });
      new import_obsidian5.Setting(containerEl).setName("Google Cloud Translation API Key").setDesc("Required for translation. Keep confidential.").addText((text) => text.setPlaceholder("Enter API Key").setValue(this.plugin.settings.googleTranslationApiKey).onChange(async (value) => {
        this.plugin.settings.googleTranslationApiKey = value.trim();
        await this.plugin.saveSettings();
      }));
    }
    this.createSectionHeader("Logging");
    const logLevelOptions = {};
    Object.keys(LogLevel).forEach((key) => {
      if (isNaN(Number(key))) {
        logLevelOptions[key] = key;
      }
    });
    new import_obsidian5.Setting(containerEl).setName("Console Log Level").setDesc("Minimum level for developer console.").addDropdown((dropdown) => dropdown.addOptions(logLevelOptions).setValue(this.plugin.settings.consoleLogLevel || "INFO").onChange(async (value) => {
      this.plugin.settings.consoleLogLevel = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("Enable File Logging").setDesc(`Log to ${this.plugin.manifest.dir}/ai-forge.log (for debugging).`).addToggle((toggle) => toggle.setValue(this.plugin.settings.fileLoggingEnabled).onChange(async (value) => {
      this.plugin.settings.fileLoggingEnabled = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.fileLoggingEnabled) {
      new import_obsidian5.Setting(containerEl).setName("File Log Level").setDesc("Minimum level for log file.").addDropdown((dropdown) => dropdown.addOptions(logLevelOptions).setValue(this.plugin.settings.fileLogLevel || "WARN").onChange(async (value) => {
        this.plugin.settings.fileLogLevel = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian5.Setting(containerEl).setName("Log Caller Method Name").setDesc("Include [MethodName] in logs. May slightly impact performance.").addToggle((toggle) => toggle.setValue(this.plugin.settings.logCallerInfo).onChange(async (value) => {
        this.plugin.settings.logCallerInfo = value;
        await this.plugin.saveSettings();
      }));
    }
  }
};

// src/ragService.ts
var import_obsidian6 = require("obsidian");
var RagService = class {
  // Модель за замовчуванням
  constructor(plugin) {
    // --- ЗМІНЕНО: Зберігаємо ембединги чанків ---
    this.chunkEmbeddings = [];
    // ------------------------------------------
    this.isIndexing = false;
    this.embeddingModelName = "nomic-embed-text";
    this.plugin = plugin;
    this.adapter = plugin.app.vault.adapter;
    this.embeddingModelName = this.plugin.settings.ragEmbeddingModel || DEFAULT_SETTINGS.ragEmbeddingModel;
  }
  /**
   * Розбиває текст на чанки (проста версія - за абзацами).
   * @param text Вхідний текст документа (бажано без YAML).Я
   * @param chunkSize Максимальна довжина чанка в символах (з налаштувань).
   * @returns Масив текстових чанків.
   */
  splitIntoChunks(text, chunkSize) {
    if (!text)
      return [];
    const paragraphs = text.split(/\n\s*\n/);
    const chunks = [];
    for (const p of paragraphs) {
      const trimmedP = p.trim();
      if (trimmedP.length === 0)
        continue;
      if (trimmedP.length > chunkSize) {
        for (let i = 0; i < trimmedP.length; i += chunkSize) {
          chunks.push(trimmedP.substring(i, i + chunkSize));
        }
      } else {
        chunks.push(trimmedP);
      }
    }
    return chunks.filter((chunk) => chunk.length > 20);
  }
  /**
   * Індексує markdown файли: розбиває на чанки, генерує embeddings, зберігає в пам'яті.
   */
  async indexDocuments() {
    var _a, _b;
    if (!this.plugin.settings.ragEnabled) {
      this.plugin.logger.debug("[RagService] RAG indexing skipped (disabled in settings).");
      this.chunkEmbeddings = [];
      return;
    }
    if (!this.plugin.settings.ragEnableSemanticSearch) {
      this.plugin.logger.debug("[RagService] Semantic Search indexing skipped (disabled in settings).");
      this.chunkEmbeddings = [];
      return;
    }
    if (this.isIndexing) {
      this.plugin.logger.warn("[RagService] Indexing already in progress.");
      return;
    }
    this.isIndexing = true;
    this.plugin.logger.debug("[RagService] Starting semantic indexing...");
    const startTime = Date.now();
    this.embeddingModelName = this.plugin.settings.ragEmbeddingModel || DEFAULT_SETTINGS.ragEmbeddingModel;
    const chunkSize = this.plugin.settings.ragChunkSize || DEFAULT_SETTINGS.ragChunkSize;
    this.plugin.logger.debug(`[RagService] Using embedding model: ${this.embeddingModelName}, Chunk size: ${chunkSize}`);
    const newEmbeddings = [];
    try {
      const folderPath = this.plugin.settings.ragFolderPath;
      const vault = this.plugin.app.vault;
      const metadataCache = this.plugin.app.metadataCache;
      this.plugin.logger.debug(`[RagService] RAG folder path: "${folderPath}"`);
      const files = await this.getMarkdownFiles(vault, folderPath);
      this.plugin.logger.debug(`[RagService] Found ${files.length} markdown files in "${folderPath}".`);
      let processedFiles = 0;
      for (const file of files) {
        this.plugin.logger.debug(`[RagService] Processing file: ${file.path}`);
        try {
          const content = await vault.read(file);
          const fileCache = metadataCache.getFileCache(file);
          const frontmatter = (fileCache == null ? void 0 : fileCache.frontmatter) || {};
          let bodyContent = content;
          if (fileCache == null ? void 0 : fileCache.frontmatterPosition) {
            bodyContent = content.substring(fileCache.frontmatterPosition.end.offset).trim();
          }
          const chunks = this.splitIntoChunks(bodyContent, chunkSize);
          if (!chunks || chunks.length === 0) {
            this.plugin.logger.debug(`[RagService] No valid chunks found in ${file.path}, skipping.`);
            continue;
          }
          this.plugin.logger.debug(`[RagService] Generating ${chunks.length} embeddings for ${file.path} using ${this.embeddingModelName}...`);
          const vectors = await this.plugin.ollamaService.generateEmbeddings(chunks, this.embeddingModelName);
          if (vectors && vectors.length === chunks.length) {
            const metadata = {
              ...frontmatter,
              path: file.path,
              filename: file.name,
              created: (_a = file.stat) == null ? void 0 : _a.ctime,
              modified: (_b = file.stat) == null ? void 0 : _b.mtime,
              "personal-logs": frontmatter["personal-logs"] === true
            };
            for (let i = 0; i < chunks.length; i++) {
              newEmbeddings.push({
                text: chunks[i],
                vector: vectors[i],
                metadata
                // Додаємо однакові метадані до всіх чанків файлу
              });
            }
            this.plugin.logger.debug(`[RagService] Successfully embedded ${vectors.length} chunks from ${file.path}`);
            processedFiles++;
          } else {
            this.plugin.logger.warn(`[RagService] Mismatch or error generating embeddings for ${file.path}. Expected ${chunks.length}, got ${vectors == null ? void 0 : vectors.length}`);
          }
        } catch (error) {
          this.plugin.logger.error(`[RagService] Error processing file ${file.path}:`, error);
        }
      }
      this.chunkEmbeddings = newEmbeddings;
      const duration = (Date.now() - startTime) / 1e3;
      this.plugin.logger.debug(`[RagService] Semantic indexing complete in ${duration.toFixed(2)}s. Indexed ${this.chunkEmbeddings.length} chunks from ${processedFiles} files.`);
    } catch (error) {
      this.plugin.logger.error("[RagService] Error during indexing process:", error);
    } finally {
      this.isIndexing = false;
    }
  }
  /**
   * Get all markdown files in the specified folder path
   */
  async getMarkdownFiles(vault, folderPath) {
    const files = [];
    if (!folderPath) {
      this.plugin.logger.warn("[RagService] RAG folder path is not set.");
      return files;
    }
    const folder = vault.getAbstractFileByPath((0, import_obsidian6.normalizePath)(folderPath));
    if (!(folder instanceof import_obsidian6.TFolder)) {
      this.plugin.logger.warn(`[RagService] RAG folder path "${folderPath}" not found or is not a folder.`);
      return files;
    }
    const allFiles = vault.getMarkdownFiles();
    for (const file of allFiles) {
      if (file.path.startsWith(folder.path + "/")) {
        files.push(file);
      }
    }
    return files;
  }
  // --- Обчислення Косинусної Подібності ---
  calculateCosineSimilarity(vecA, vecB) {
    if (!vecA || !vecB || vecA.length !== vecB.length || vecA.length === 0) {
      return 0;
    }
    let dotProduct = 0;
    let normA = 0;
    let normB = 0;
    for (let i = 0; i < vecA.length; i++) {
      dotProduct += vecA[i] * vecB[i];
      normA += vecA[i] * vecA[i];
      normB += vecB[i] * vecB[i];
    }
    if (normA === 0 || normB === 0)
      return 0;
    const magnitude = Math.sqrt(normA) * Math.sqrt(normB);
    if (magnitude === 0)
      return 0;
    return dotProduct / magnitude;
  }
  // ----------------------------------------------------------------------------
  /**
   * Знаходить релевантні ЧАНКИ документів за допомогою семантичної подібності.
   * @param query Запит користувача.
   * @param limit Максимальна кількість чанків для повернення (з налаштувань topK).
   * @returns Масив об'єктів ChunkVector, відсортований за подібністю.
   */
  async findRelevantDocuments(query, limit) {
    var _a;
    if (!this.plugin.settings.ragEnableSemanticSearch) {
      this.plugin.logger.debug("[RagService] Semantic search disabled, skipping retrieval.");
      return [];
    }
    if (!this.chunkEmbeddings || this.chunkEmbeddings.length === 0 || !query) {
      if (((_a = this.chunkEmbeddings) == null ? void 0 : _a.length) === 0)
        this.plugin.logger.warn("[RagService] No chunk embeddings available for search. Index might be empty or disabled.");
      return [];
    }
    this.plugin.logger.debug(`[RagService] Performing semantic search for query: "${query}"`);
    const startTime = Date.now();
    try {
      const queryEmbeddings = await this.plugin.ollamaService.generateEmbeddings([query], this.embeddingModelName);
      if (!queryEmbeddings || queryEmbeddings.length === 0 || !queryEmbeddings[0]) {
        this.plugin.logger.error("[RagService] Failed to generate embedding for the query.");
        return [];
      }
      const queryVector = queryEmbeddings[0];
      const scoredChunks = this.chunkEmbeddings.map((chunk) => {
        const similarity = this.calculateCosineSimilarity(queryVector, chunk.vector);
        return { ...chunk, score: similarity };
      });
      const similarityThreshold = this.plugin.settings.ragSimilarityThreshold || DEFAULT_SETTINGS.ragSimilarityThreshold;
      const relevantChunks = scoredChunks.filter((chunk) => chunk.score >= similarityThreshold);
      relevantChunks.sort((a, b) => b.score - a.score);
      const duration = Date.now() - startTime;
      this.plugin.logger.debug(`[RagService] Semantic search completed in ${duration}ms. Found ${relevantChunks.length} chunks above threshold ${similarityThreshold}.`);
      return relevantChunks.slice(0, limit);
    } catch (error) {
      this.plugin.logger.error("[RagService] Error during semantic search:", error);
      return [];
    }
  }
  /**
   * Готує контекст для LLM з найбільш релевантних чанків документів.
   * @param query Запит користувача для пошуку релевантних чанків.
   * @returns Рядок з форматованим контекстом або порожній рядок.
   */
  async prepareContext(query) {
    if (!this.plugin.settings.ragEnabled) {
      return "";
    }
    if (this.plugin.settings.ragEnableSemanticSearch) {
      const topK = this.plugin.settings.ragTopK || DEFAULT_SETTINGS.ragTopK;
      const relevantChunks = await this.findRelevantDocuments(query, topK);
      if (relevantChunks.length === 0) {
        this.plugin.logger.debug("[RagService] No relevant documents found via semantic search for context.");
        return "";
      }
      this.plugin.logger.debug(`[RagService] Preparing context from ${relevantChunks.length} top chunks.`);
      let context = "### Context from User Notes (Semantic Search):\n\n";
      relevantChunks.forEach((chunk, index) => {
        var _a, _b, _c, _d;
        let header = `--- Chunk ${index + 1} from: ${((_a = chunk.metadata) == null ? void 0 : _a.filename) || chunk.metadata.path}`;
        if (((_b = chunk.metadata) == null ? void 0 : _b["personal-logs"]) === true)
          header += ` [Type: Personal Log]`;
        header += ` (Score: ${(_d = (_c = chunk.score) == null ? void 0 : _c.toFixed(3)) != null ? _d : "N/A"}) ---
`;
        context += header;
        context += chunk.text.trim() + "\n\n";
      });
      context += "### End of Context\n\n";
      return context.trim();
    } else {
      this.plugin.logger.debug("[RagService] Semantic search disabled. Using legacy keyword search (if implemented) or skipping RAG.");
      return "";
    }
  }
  // Додатково: Функції для старого пошуку, якщо ви їх залишаєте
  /*
      private findRelevantDocuments_Keyword(query: string, limit: number): DocumentVector[] {
          // ... ваша стара логіка пошуку за ключовими словами ...
          const scoredDocs = this.documents
            .map(doc => ({ doc, score: this.calculateRelevanceScore(doc, query) }))
            .filter(item => item.score > 0);
          scoredDocs.sort((a, b) => b.score - a.score);
          return scoredDocs.slice(0, limit).map(item => ({...item.doc, score: item.score}));
      }
  
      private formatKeywordContext(docs: DocumentVector[]): string {
           let context = "### Context from User Notes (Keyword Search):\n\n";
           docs.forEach((doc, index) => {
               let header = `--- Document ${index + 1}: ${doc.metadata?.filename || doc.path} (Score: ${doc.score?.toFixed(0)}) ---\n`;
               // ... решта форматування ...
               const contentToUse = doc.body || doc.content;
               const maxCharsPerDoc = this.plugin.settings.maxCharsPerDoc || 1500;
               const truncatedContent = contentToUse.length > maxCharsPerDoc
                 ? contentToUse.substring(0, maxCharsPerDoc) + "...\n[Content Truncated]"
                 : contentToUse;
               context += header + truncatedContent + "\n\n";
           });
           context += "### End of Context\n\n";
           return context.trim();
      }
      */
};

// src/OllamaService.ts
var import_obsidian7 = require("obsidian");
var OllamaService = class {
  // Keep event emitter for connection errors
  constructor(plugin) {
    this.eventHandlers = {};
    this.plugin = plugin;
    if (!plugin.promptService) {
      const errorMsg = "[OllamaService] CRITICAL: PromptService not available on plugin instance during OllamaService construction!";
      plugin.logger.error(errorMsg);
      throw new Error(errorMsg);
    }
    this.promptService = plugin.promptService;
  }
  on(event, callback) {
    if (!this.eventHandlers[event])
      this.eventHandlers[event] = [];
    this.eventHandlers[event].push(callback);
    return () => {
      var _a, _b;
      this.eventHandlers[event] = (_a = this.eventHandlers[event]) == null ? void 0 : _a.filter((h) => h !== callback);
      if (((_b = this.eventHandlers[event]) == null ? void 0 : _b.length) === 0)
        delete this.eventHandlers[event];
    };
  }
  emit(event, data) {
    const h = this.eventHandlers[event];
    if (h)
      h.slice().forEach((handler) => {
        try {
          handler(data);
        } catch (e) {
          console.error(`Error in OllamaService event handler for ${event}:`, e);
        }
      });
  }
  setBaseUrl(url) {
  }
  /**
   * Sends a raw request body to the Ollama /api/generate endpoint.
   */
  async generateRaw(requestBody) {
    var _a;
    this.plugin.logger.debug("[OllamaService] Sending RAW request to /api/generate:", { model: requestBody.model, temp: requestBody.temperature, system: !!requestBody.system, prompt_len: (_a = requestBody.prompt) == null ? void 0 : _a.length });
    if (!requestBody.model || !requestBody.prompt) {
      throw new Error("generateRaw requires 'model' and 'prompt' in requestBody");
    }
    if (!requestBody.system) {
      delete requestBody.system;
    }
    return await this._ollamaFetch(
      "/api/generate",
      "POST",
      // Explicitly pass method
      JSON.stringify(requestBody)
      // Pass the stringified body
    );
  }
  /**
   * Generates embeddings for a list of text prompts.
   */
  async generateEmbeddings(prompts, model) {
    if (!prompts || prompts.length === 0)
      return [];
    const endpoint = "/api/embeddings";
    this.plugin.logger.debug(`[OllamaService] Generating ${prompts.length} embeddings using model ${model}...`);
    const embeddingsList = [];
    try {
      for (const prompt of prompts) {
        const trimmedPrompt = prompt.trim();
        if (!trimmedPrompt) {
          this.plugin.logger.warn("[OllamaService] Skipping empty prompt for embedding.");
          continue;
        }
        const requestBody = JSON.stringify({ model, prompt: trimmedPrompt });
        try {
          const embeddingResponse = await this._ollamaFetch(
            endpoint,
            "POST",
            // Explicitly pass method
            requestBody
            // Pass the stringified body
          );
          if (embeddingResponse && embeddingResponse.embedding) {
            embeddingsList.push(embeddingResponse.embedding);
          } else {
            this.plugin.logger.warn(`[OllamaService] Invalid structure in embedding response for model ${model}. Prompt (start): "${trimmedPrompt.substring(0, 50)}..."`);
          }
        } catch (singleError) {
          this.plugin.logger.error(`[OllamaService] Failed to generate embedding for one prompt using model ${model}. Prompt (start): "${trimmedPrompt.substring(0, 50)}..."`, singleError);
        }
      }
      this.plugin.logger.debug(`[OllamaService] Successfully generated ${embeddingsList.length} embeddings (out of ${prompts.length} prompts).`);
      return embeddingsList.length > 0 ? embeddingsList : null;
    } catch (error) {
      this.plugin.logger.error(`[OllamaService] General error during embedding generation for model ${model}:`, error);
      return null;
    }
  }
  async getModels(forceRefresh = false) {
    const endpoint = "/api/tags";
    const fullUrlForLogging = `${this.plugin.settings.ollamaServerUrl}${endpoint}`;
    this.plugin.logger.debug(`[OllamaService] Fetching models from ${fullUrlForLogging}`);
    let modelListResult = [];
    try {
      const data = await this._ollamaFetch(
        endpoint,
        // Передаємо '/api/tags'
        "GET"
        // Передаємо метод
      );
      if (data && Array.isArray(data.models)) {
        const modelNames = data.models.map((m) => m == null ? void 0 : m.name).filter((name) => typeof name === "string" && name.length > 0).sort();
        this.plugin.logger.debug(`[OllamaService] Found ${modelNames.length} models.`);
        modelListResult = modelNames;
      } else {
        this.plugin.logger.warn("[OllamaService] Invalid response structure received from /api/tags (expected { models: [...] }):", data);
      }
    } catch (e) {
      this.plugin.logger.error(`[OllamaService] Failed to fetch models:`, e);
    }
    return modelListResult;
  }
  // End getModels
  async getModelDetails(modelName) {
    this.plugin.logger.debug(`[OllamaService] Fetching details for model: ${modelName}`);
    const endpoint = "/api/show";
    try {
      const data = await this._ollamaFetch(
        endpoint,
        "POST",
        // Explicitly pass method
        JSON.stringify({ name: modelName })
        // Pass the stringified body
      );
      return data;
    } catch (e) {
      this.plugin.logger.warn(`[OllamaService] Failed to get details for model ${modelName}:`, e);
      return null;
    }
  }
  /**
       * Private helper for fetch requests to Ollama API.
       * Now accepts method and optional string body.
       */
  // --- FIX: Changed method signature and implementation ---
  async _ollamaFetch(endpoint, method, body) {
    var _a, _b;
    const url = `${this.plugin.settings.ollamaServerUrl}${endpoint}`;
    const headers = { "Content-Type": "application/json" };
    try {
      const requestParams = { url, method, headers, body, throw: false };
      this.plugin.logger.debug(`[OllamaService] Calling requestUrl with params:`, JSON.stringify(requestParams));
      const response = await (0, import_obsidian7.requestUrl)(requestParams);
      if (response.status >= 400) {
        let errorText = `Ollama API error! Status: ${response.status} at ${endpoint}`;
        try {
          errorText += `: ${response.text || ((_a = response.json) == null ? void 0 : _a.error) || "No details"}`;
        } catch (e) {
        }
        this.plugin.logger.error(`[OllamaService] ${errorText}`);
        this.emit("connection-error", new Error(errorText));
        throw new Error(errorText);
      }
      if (response.status === 204 || !response.text) {
        const errorMsg = `Ollama API success status (${response.status}) but empty response body at ${endpoint}`;
        this.plugin.logger.warn(`[OllamaService] ${errorMsg}`);
        throw new Error(errorMsg);
      }
      try {
        const jsonData = response.json;
        if (jsonData === null || jsonData === void 0) {
          throw new Error(`Ollama API returned null/undefined JSON at ${endpoint}`);
        }
        return jsonData;
      } catch (jsonError) {
        this.plugin.logger.error(`[OllamaService] Failed to parse JSON response from ${url}. Status: ${response.status}`, jsonError, "Response Text:", response.text);
        throw new Error(`Failed to parse Ollama JSON response from ${endpoint}`);
      }
    } catch (error) {
      this.plugin.logger.error(`[OllamaService] Error in _ollamaFetch (${url}):`, error);
      const connectionErrorMsg = `Failed to connect/communicate with Ollama server at ${this.plugin.settings.ollamaServerUrl}. Is it running? (Endpoint: ${endpoint})`;
      if (!((_b = error.message) == null ? void 0 : _b.includes("Ollama API error"))) {
        this.emit("connection-error", new Error(connectionErrorMsg));
      }
      throw new Error(error.message || connectionErrorMsg);
    }
  }
  /**
       * Генерує відповідь чату, готуючи промпт та викликаючи generateRaw.
       */
  async generateChatResponse(chat) {
    var _a, _b;
    if (!chat) {
      this.plugin.logger.error("[OllamaService] generateChatResponse called with null chat.");
      return null;
    }
    if (!this.promptService) {
      this.plugin.logger.error("[OllamaService] PromptService is not initialized!");
      new import_obsidian7.Notice("Error: Prompt service is unavailable.");
      return null;
    }
    const currentSettings = this.plugin.settings;
    const modelName = chat.metadata.modelName || currentSettings.modelName;
    const temperature = (_a = chat.metadata.temperature) != null ? _a : currentSettings.temperature;
    if (!modelName) {
      this.plugin.logger.error("[OllamaService] No model specified in chat metadata or settings.");
      new import_obsidian7.Notice("Error: No Ollama model selected.");
      return null;
    }
    try {
      const history = chat.getMessages();
      this.plugin.logger.debug("[OllamaService] Getting system prompt from PromptService...");
      const systemPrompt = await this.promptService.getSystemPromptForAPI(chat.metadata);
      this.plugin.logger.debug("[OllamaService] Preparing prompt body from PromptService...");
      const promptBody = await this.promptService.preparePromptBody(history, chat.metadata);
      if (promptBody === null || promptBody === void 0) {
        this.plugin.logger.error("[OllamaService] Prompt body generation failed (returned null/undefined).");
        new import_obsidian7.Notice("Error: Could not generate prompt body.");
        return null;
      }
      const requestBody = {
        model: modelName,
        prompt: promptBody,
        // Тут вже є історія + RAG + завдання
        stream: false,
        temperature,
        options: { num_ctx: currentSettings.contextWindow },
        // Додаємо system, тільки якщо він існує і не порожній
        ...systemPrompt && { system: systemPrompt }
      };
      this.plugin.logger.debug(`[OllamaService] Calling generateRaw for chat response: Model:"${modelName}", Temp:${temperature}, System Prompt Provided: ${!!systemPrompt}`);
      this.plugin.logger.debug("[OllamaService] Request body (prompt truncated):", { ...requestBody, prompt: promptBody.substring(0, 200) + "..." });
      const responseData = await this.generateRaw(requestBody);
      if (responseData && typeof responseData.response === "string") {
        this.plugin.logger.debug(`[OllamaService] Received response. Length: ${responseData.response.length} chars`);
        const assistantMessage = {
          role: "assistant",
          content: responseData.response.trim(),
          timestamp: new Date(responseData.created_at || Date.now())
          // Використовуємо час відповіді або поточний
        };
        return assistantMessage;
      } else {
        this.plugin.logger.warn("[OllamaService] generateRaw returned unexpected structure or no response.", responseData);
        throw new Error("Received unexpected or empty response from the model.");
      }
    } catch (error) {
      this.plugin.logger.error("[OllamaService] Error during chat response generation cycle:", error);
      let errorMessage = error instanceof Error ? error.message : "Unknown error generating response.";
      if (errorMessage.includes("model not found")) {
        errorMessage = `Model '${modelName}' not found. Check Ollama server or model name.`;
      } else if (errorMessage.includes("context window")) {
        errorMessage = `Context window error (${currentSettings.contextWindow} tokens): ${error.message}. Adjust context settings.`;
      } else if (errorMessage.includes("connect") || errorMessage.includes("fetch") || errorMessage.includes("NetworkError") || ((_b = error.message) == null ? void 0 : _b.includes("Failed to connect"))) {
        errorMessage = `Connection Error: Failed to reach Ollama at ${currentSettings.ollamaServerUrl}. Is it running?`;
      }
      new import_obsidian7.Notice(errorMessage);
      return null;
    }
  }
};

// src/PromptService.ts
var import_obsidian8 = require("obsidian");
var PromptService = class {
  constructor(plugin) {
    this.currentSystemPrompt = null;
    // Кеш для системного промпту ролі
    this.currentRolePath = null;
    // Кеш для шляху поточної ролі
    this.roleCache = {};
    // Кеш для завантажених ролей
    this.modelDetailsCache = {};
    this.plugin = plugin;
    this.app = plugin.app;
  }
  _countTokens(text) {
    if (!text)
      return 0;
    return Math.ceil(text.length / 4);
  }
  clearRoleCache() {
    this.plugin.logger.debug("[PromptService] Clearing role definition cache.");
    this.roleCache = {};
    this.currentRolePath = null;
    this.currentSystemPrompt = null;
  }
  clearModelDetailsCache() {
    this.plugin.logger.debug("[PromptService] Clearing model details cache.");
    this.modelDetailsCache = {};
  }
  /**
   * Завантажує визначення ролі (системний промпт + тип) з файлу або кешу.
   */
  async getRoleDefinition(rolePath) {
    var _a, _b, _c;
    const normalizedPath = rolePath ? (0, import_obsidian8.normalizePath)(rolePath) : null;
    if (normalizedPath === this.currentRolePath && normalizedPath && this.roleCache[normalizedPath]) {
      return this.roleCache[normalizedPath];
    }
    if (normalizedPath !== this.currentRolePath) {
      this.plugin.logger.info(`[PromptService] Role path changing from '${this.currentRolePath}' to '${normalizedPath}'. Clearing cache.`);
      if (this.currentRolePath && this.roleCache[this.currentRolePath]) {
        delete this.roleCache[this.currentRolePath];
      }
      this.currentRolePath = normalizedPath;
      this.currentSystemPrompt = null;
    }
    if (!normalizedPath || !this.plugin.settings.followRole) {
      this.plugin.logger.debug("[PromptService] No role path or followRole disabled. Role definition is null.");
      return { systemPrompt: null, isProductivityPersona: false };
    }
    if (this.roleCache[normalizedPath]) {
      this.plugin.logger.debug(`[PromptService] Returning newly cached role definition for: ${normalizedPath}`);
      this.currentSystemPrompt = this.roleCache[normalizedPath].systemPrompt;
      return this.roleCache[normalizedPath];
    }
    this.plugin.logger.debug(`[PromptService] Loading role definition from file: ${normalizedPath}`);
    const file = this.app.vault.getAbstractFileByPath(normalizedPath);
    if (file instanceof import_obsidian8.TFile) {
      try {
        const fileCache = this.app.metadataCache.getFileCache(file);
        const frontmatter = fileCache == null ? void 0 : fileCache.frontmatter;
        const content = await this.app.vault.cachedRead(file);
        const systemPromptBody = ((_a = fileCache == null ? void 0 : fileCache.frontmatterPosition) == null ? void 0 : _a.end) ? content.substring(fileCache.frontmatterPosition.end.offset).trim() : content.trim();
        const isProductivity = ((_b = frontmatter == null ? void 0 : frontmatter.assistant_type) == null ? void 0 : _b.toLowerCase()) === "productivity" || (frontmatter == null ? void 0 : frontmatter.is_planner) === true;
        const definition = {
          systemPrompt: systemPromptBody || null,
          isProductivityPersona: isProductivity
        };
        this.plugin.logger.info(`[PromptService] Role loaded: ${normalizedPath}. Is Productivity: ${isProductivity}. Prompt length: ${((_c = definition.systemPrompt) == null ? void 0 : _c.length) || 0}`);
        this.roleCache[normalizedPath] = definition;
        this.currentSystemPrompt = definition.systemPrompt;
        return definition;
      } catch (error) {
        this.plugin.logger.error(`[PromptService] Error processing role file ${normalizedPath}:`, error);
        new import_obsidian8.Notice(`Error loading role: ${file.basename}. Check console.`);
        this.currentSystemPrompt = null;
        return null;
      }
    } else {
      this.plugin.logger.warn(`[PromptService] Role file not found or not a file: ${normalizedPath}`);
      this.currentSystemPrompt = null;
      return null;
    }
  }
  /**
   * Перевіряє, чи активна зараз роль "продуктивності".
   */
  async _isProductivityPersonaActive(rolePath) {
    var _a;
    if (!this.plugin.settings.enableProductivityFeatures) {
      return false;
    }
    const roleDefinition = await this.getRoleDefinition(rolePath);
    return (_a = roleDefinition == null ? void 0 : roleDefinition.isProductivityPersona) != null ? _a : false;
  }
  /**
  * Повертає фінальний системний промпт для API, можливо включаючи RAG інструкції.
  * Не включає RAG контент чи історію.
  */
  async getSystemPromptForAPI(chatMetadata) {
    var _a;
    const settings = this.plugin.settings;
    this.plugin.logger.debug(`[PromptService] getSystemPromptForAPI checking chat path: '${chatMetadata.selectedRolePath}', settings path: '${settings.selectedRolePath}'`);
    const selectedRolePath = chatMetadata.selectedRolePath !== void 0 && chatMetadata.selectedRolePath !== null ? chatMetadata.selectedRolePath : settings.selectedRolePath;
    this.plugin.logger.debug(`[PromptService] getSystemPromptForAPI using determined path: '${selectedRolePath}'`);
    let roleDefinition = null;
    if (selectedRolePath && settings.followRole) {
      this.plugin.logger.debug(`[PromptService] getSystemPromptForAPI loading definition for: '${selectedRolePath}'`);
      roleDefinition = await this.getRoleDefinition(selectedRolePath);
    } else {
      this.plugin.logger.debug(`[PromptService] getSystemPromptForAPI skipping role load (Path: '${selectedRolePath}', Follow: ${settings.followRole})`);
    }
    let roleSystemPrompt = (roleDefinition == null ? void 0 : roleDefinition.systemPrompt) || null;
    const isProductivityActive = (_a = roleDefinition == null ? void 0 : roleDefinition.isProductivityPersona) != null ? _a : false;
    const ragInstructions = `
--- RAG Data Interpretation Rules ---
1.  You have access to context chunks from the user's notes provided under '### Context from User Notes (...)'. Each chunk originates from a specific file indicated in its header.
2.  Context from files/chunks marked with "[Type: Personal Log]" contains personal reflections, activities, or logs. Use this for analysis of personal state, mood, energy, and progress.
3.  Assume ANY bullet point item (lines starting with '-', '*', '+') OR any line containing one or more hash tags (#tag) represents a potential user goal, task, objective, idea, or key point. **Pay special attention to categorizing these:**
    * **Critical Goals/Tasks:** Identify these if the line contains tags like #critical, #critical\u{1F198} or keywords like "\u043A\u0440\u0438\u0442\u0438\u0447\u043D\u043E", "critical", "\u0442\u0435\u0440\u043C\u0456\u043D\u043E\u0432\u043E", "urgent". **Prioritize discussing these items, potential blockers, and progress.**
    * **Weekly Goals/Tasks:** Identify these if the line contains tags like #week, #weekly or keywords like "weekly", "\u0442\u0438\u0436\u043D\u0435\u0432\u0430", "\u0442\u0438\u0436\u043D\u0435\u0432\u0438\u0439". Consider their relevance for the current or upcoming week's planning.
    * Use the surrounding text and the source document name for context for all identified items.
4.  You can refer to specific source files by their names mentioned in the context chunk headers (e.g., "Chunk 2 from 'My Notes.md' suggests...").
5.  If the user asks about "available data", "all my notes", "summarize my RAG data", or similar general terms, base your answer on the entire provided context ('### Context from User Notes (...)'). Analyze themes across different chunks and documents.
--- End RAG Data Interpretation Rules ---
        `.trim();
    let finalSystemPrompt = "";
    if (settings.ragEnabled && this.plugin.ragService && settings.ragEnableSemanticSearch) {
      finalSystemPrompt += ragInstructions + "\n\n";
      this.plugin.logger.debug("[PromptService] RAG instructions added to system prompt.");
    } else {
      this.plugin.logger.debug("[PromptService] RAG instructions NOT added (RAG disabled or semantic search disabled).");
    }
    if (roleSystemPrompt) {
      finalSystemPrompt += roleSystemPrompt.trim();
      this.plugin.logger.debug(`[PromptService] Role system prompt added (Length: ${roleSystemPrompt.trim().length})`);
    } else {
      this.plugin.logger.debug("[PromptService] No role system prompt to add.");
    }
    if (isProductivityActive && finalSystemPrompt && settings.enableProductivityFeatures) {
      const now = new Date();
      const formattedDate = now.toLocaleDateString(void 0, { weekday: "long", year: "numeric", month: "long", day: "numeric" });
      const formattedTime = now.toLocaleTimeString(void 0, { hour: "numeric", minute: "2-digit" });
      finalSystemPrompt = finalSystemPrompt.replace(/\[Current Time\]/gi, formattedTime);
      finalSystemPrompt = finalSystemPrompt.replace(/\[Current Date\]/gi, formattedDate);
      this.plugin.logger.debug("[PromptService] Dynamic date/time injected.");
    }
    const trimmedFinalPrompt = finalSystemPrompt.trim();
    this.plugin.logger.debug(`[PromptService] Final System Prompt Length: ${trimmedFinalPrompt.length} chars. Has content: ${trimmedFinalPrompt.length > 0}`);
    return trimmedFinalPrompt.length > 0 ? trimmedFinalPrompt : null;
  }
  /**
      * Готує ТІЛО основного промпту (без системного), включаючи історію, контекст завдань та RAG.
      */
  async preparePromptBody(history, chatMetadata) {
    var _a, _b;
    this.plugin.logger.debug("[PromptService] Preparing prompt body...");
    const settings = this.plugin.settings;
    const selectedRolePath = chatMetadata.selectedRolePath !== void 0 && chatMetadata.selectedRolePath !== null ? chatMetadata.selectedRolePath : settings.selectedRolePath;
    const isProductivityActive = await this._isProductivityPersonaActive(selectedRolePath);
    this.plugin.logger.debug(`[PromptService] Productivity features potentially active for body: ${isProductivityActive}`);
    let taskContext = "";
    if (isProductivityActive && settings.enableProductivityFeatures && this.plugin.chatManager) {
      await ((_b = (_a = this.plugin).checkAndProcessTaskUpdate) == null ? void 0 : _b.call(_a));
      const taskState = this.plugin.chatManager.getCurrentTaskState();
      if (taskState && taskState.hasContent) {
        taskContext = "\n--- Today's Tasks Context ---\n";
        taskContext += `Urgent: ${taskState.urgent.join(", ") || "None"}
`;
        taskContext += `Other: ${taskState.regular.join(", ") || "None"}
`;
        taskContext += "--- End Tasks Context ---";
        this.plugin.logger.debug(`[PromptService] Injecting task context (Urgent: ${taskState.urgent.length}, Regular: ${taskState.regular.length})`);
      } else {
        this.plugin.logger.debug("[PromptService] No relevant task state found or no tasks to inject.");
      }
    }
    const approxTaskTokens = this._countTokens(taskContext);
    const maxRagTokens = settings.ragEnabled ? settings.ragTopK * settings.ragChunkSize / 4 * 1.5 : 0;
    const maxHistoryTokens = settings.contextWindow - approxTaskTokens - maxRagTokens - 200;
    this.plugin.logger.debug(`[PromptService] Max tokens available for history processing: ${maxHistoryTokens}`);
    let processedHistoryString = "";
    if (isProductivityActive && settings.useAdvancedContextStrategy) {
      processedHistoryString = await this._buildAdvancedContext(history, chatMetadata, maxHistoryTokens);
    } else {
      processedHistoryString = this._buildSimpleContext(history, maxHistoryTokens);
    }
    let ragContext = "";
    if (settings.ragEnabled && this.plugin.ragService && settings.ragEnableSemanticSearch) {
      const lastUserMessage = history.findLast((m) => m.role === "user");
      if (lastUserMessage == null ? void 0 : lastUserMessage.content) {
        ragContext = await this.plugin.ragService.prepareContext(lastUserMessage.content);
        if (!ragContext)
          this.plugin.logger.info("[PromptService] RAG prepareContext returned empty.");
        else
          this.plugin.logger.debug(`[PromptService] RAG context length: ${ragContext.length} chars`);
      } else {
        this.plugin.logger.warn("[PromptService] RAG enabled, but no last user message found.");
      }
    } else {
      this.plugin.logger.debug("[PromptService] RAG context NOT prepared.");
    }
    let finalPromptBodyParts = [];
    if (ragContext) {
      finalPromptBodyParts.push(ragContext);
    }
    if (taskContext) {
      finalPromptBodyParts.push(taskContext);
    }
    if (processedHistoryString) {
      finalPromptBodyParts.push(`### Conversation History:
${processedHistoryString}`);
    }
    const finalPromptBody = finalPromptBodyParts.join("\n\n").trim();
    if (!finalPromptBody) {
      this.plugin.logger.warn("[PromptService] No RAG, no tasks, and no history processed. Returning null prompt body.");
      return null;
    }
    this.plugin.logger.debug(`[PromptService] Final prompt body length (approx tokens): ${this._countTokens(finalPromptBody)}`);
    return finalPromptBody;
  }
  // Методи _buildSimpleContext, _buildAdvancedContext, _summarizeMessages залишаються
  // але мають використовувати this.plugin.logger замість console.log/warn
  _buildSimpleContext(history, maxTokens) {
    let context = "";
    let currentTokens = 0;
    for (let i = history.length - 1; i >= 0; i--) {
      const message = history[i];
      const formattedMessage = `${message.role === "user" ? "User" : "Assistant"}: ${message.content.trim()}`;
      const messageTokens = this._countTokens(formattedMessage) + 5;
      if (currentTokens + messageTokens <= maxTokens) {
        context = formattedMessage + "\n\n" + context;
        currentTokens += messageTokens;
      } else {
        this.plugin.logger.debug(`[PromptService] Simple context limit reached (${currentTokens}/${maxTokens} tokens).`);
        break;
      }
    }
    return context.trim();
  }
  async _buildAdvancedContext(history, chatMetadata, maxTokens) {
    this.plugin.logger.debug("[PromptService] Building advanced context...");
    const settings = this.plugin.settings;
    const processedParts = [];
    let currentTokens = 0;
    const keepN = Math.min(history.length, settings.keepLastNMessagesBeforeSummary || 3);
    const messagesToKeep = history.slice(-keepN);
    const messagesToProcess = history.slice(0, -keepN);
    this.plugin.logger.debug(`[PromptService] Advanced Context: Keeping last ${messagesToKeep.length}, processing ${messagesToProcess.length} older messages.`);
    if (messagesToProcess.length > 0) {
      if (settings.enableSummarization) {
        this.plugin.logger.info("[PromptService] Summarization enabled...");
      } else {
        this.plugin.logger.info("[PromptService] Summarization disabled. Including older messages directly if space allows.");
      }
    }
    this.plugin.logger.debug(`[PromptService] Advanced context built. Total approx tokens: ${currentTokens}`);
    return processedParts.join("\n\n").trim();
  }
  async _summarizeMessages(messagesToSummarize, chatMetadata) {
    if (!this.plugin.settings.enableSummarization || messagesToSummarize.length === 0) {
      return null;
    }
    this.plugin.logger.info(`[PromptService] Summarizing chunk of ${messagesToSummarize.length} messages...`);
    const textToSummarize = messagesToSummarize.map((m) => `${m.role === "user" ? "User" : "Assistant"}: ${m.content.trim()}`).join("\n");
    if (!textToSummarize.trim()) {
      this.plugin.logger.warn("[PromptService] No actual text content in messages to summarize.");
      return null;
    }
    const summarizationPromptTemplate = this.plugin.settings.summarizationPrompt || "Summarize the following conversation concisely:\n\n{text_to_summarize}";
    const summarizationFullPrompt = summarizationPromptTemplate.replace("{text_to_summarize}", textToSummarize);
    const modelName = chatMetadata.modelName || this.plugin.settings.modelName;
    const summarizationContextWindow = Math.min(this.plugin.settings.contextWindow || 4096, 4096);
    const requestBody = {
      model: modelName,
      prompt: summarizationFullPrompt,
      stream: false,
      temperature: 0.3,
      options: {
        num_ctx: summarizationContextWindow
      },
      system: "You are a helpful assistant specializing in concisely summarizing conversation history. Focus on extracting key points and decisions."
    };
    try {
      if (!this.plugin.ollamaService) {
        this.plugin.logger.error("[PromptService] OllamaService is not available for summarization.");
        return null;
      }
      const responseData = await this.plugin.ollamaService.generateRaw(requestBody);
      if (responseData && typeof responseData.response === "string") {
        const summary = responseData.response.trim();
        this.plugin.logger.info(`[PromptService] Summarization successful (${this._countTokens(summary)} tokens).`);
        return summary;
      } else {
        this.plugin.logger.warn("[PromptService] Summarization request returned unexpected structure:", responseData);
        return null;
      }
    } catch (error) {
      this.plugin.logger.error("[PromptService] Error during summarization request:", error, "Request body (first 100 chars):", JSON.stringify(requestBody).substring(0, 100));
      return null;
    }
  }
};

// src/ChatManager.ts
var import_obsidian10 = require("obsidian");

// src/Chat.ts
var import_obsidian9 = require("obsidian");
var Chat = class {
  // Додати властивість
  /**
   * Creates an instance of Chat. Should be called by ChatManager.
   * @param adapter - Obsidian's DataAdapter.
   * @param settings - Plugin settings relevant for chat operation.
   * @param data - The initial chat data (metadata and messages).
   * @param filePath - The full, normalized path where this chat should be saved/loaded from within the vault. **Required**.
   */
  constructor(adapter, settings, data, filePath, logger) {
    this.adapter = adapter;
    this.pluginSettings = settings;
    this.filePath = (0, import_obsidian9.normalizePath)(filePath);
    this.metadata = data.metadata;
    this.messages = data.messages.map((m) => ({ ...m, timestamp: new Date(m.timestamp) }));
    this.logger = logger;
    this.logger.debug(`[Chat ${this.metadata.id}] Initialized. Path: ${this.filePath}`);
    this.debouncedSave = (0, import_obsidian9.debounce)(this._saveToFile.bind(this), 1500, true);
  }
  // --- Message Management ---
  /**
   * Adds a new message to the chat history.
   * Updates the lastModified timestamp and triggers a debounced save.
   * @param role - The role of the message sender ('user', 'assistant', etc.).
   * @param content - The text content of the message.
   * @param timestamp - The timestamp for the message (defaults to now).
   * @returns The newly added message object.
   */
  addMessage(role, content, timestamp = new Date()) {
    const newMessage = { role, content, timestamp };
    this.messages.push(newMessage);
    this.metadata.lastModified = timestamp.toISOString();
    this.save();
    return newMessage;
  }
  /** Returns a copy of the chat messages array. */
  getMessages() {
    return [...this.messages];
  }
  /** Clears all messages from the chat history. Updates lastModified and saves. */
  clearMessages() {
    console.log(`[Chat ${this.metadata.id}] Clearing messages.`);
    this.messages = [];
    this.metadata.lastModified = new Date().toISOString();
    this.save();
  }
  // У файлі Chat.ts
  /**
   * Updates specified metadata fields for the chat.
   * Automatically updates the lastModified timestamp and triggers a save if changes occurred.
   * @param updates - An object containing metadata fields to update (cannot update 'id' or 'createdAt').
   * @returns {boolean} - True if any metadata field was actually changed, false otherwise.
   */
  updateMetadata(updates) {
    let changed = false;
    const currentMeta = this.metadata;
    if (updates.name !== void 0 && updates.name !== currentMeta.name) {
      currentMeta.name = updates.name;
      changed = true;
    }
    if (updates.modelName !== void 0 && updates.modelName !== currentMeta.modelName) {
      currentMeta.modelName = updates.modelName;
      changed = true;
    }
    if (updates.selectedRolePath !== void 0 && updates.selectedRolePath !== currentMeta.selectedRolePath) {
      currentMeta.selectedRolePath = updates.selectedRolePath;
      changed = true;
    }
    if (updates.temperature !== void 0 && updates.temperature !== currentMeta.temperature) {
      currentMeta.temperature = updates.temperature;
      changed = true;
    }
    if (updates.contextWindow !== void 0 && updates.contextWindow !== currentMeta.contextWindow) {
      currentMeta.contextWindow = updates.contextWindow;
      changed = true;
    }
    if (changed) {
      this.metadata.lastModified = new Date().toISOString();
      if (this.pluginSettings.logger) {
        this.pluginSettings.logger.debug(`[Chat ${this.metadata.id}] Metadata updated, scheduling save:`, updates);
      } else {
        console.log(`[Chat ${this.metadata.id}] Metadata updated, scheduling save:`, updates);
      }
      this.save();
    } else {
      if (this.pluginSettings.logger) {
        this.pluginSettings.logger.debug(`[Chat ${this.metadata.id}] updateMetadata called, but no changes detected.`);
      } else {
        console.log(`[Chat ${this.metadata.id}] updateMetadata called, but no changes detected.`);
      }
    }
    return changed;
  }
  // Також переконайтесь, що конструктор Chat приймає і зберігає logger (або plugin)
  // і що він передається при викликах new Chat та Chat.loadFromFile в ChatManager.ts
  // Приклад оновленого конструктора Chat:
  /*
      private logger: Logger; // Додати властивість
  
      constructor(
          adapter: DataAdapter,
          settings: ChatConstructorSettings,
          data: ChatData,
          filePath: string,
          logger: Logger // Додати параметр
      ) {
          this.adapter = adapter;
          this.pluginSettings = settings;
          this.filePath = normalizePath(filePath);
          this.metadata = data.metadata;
          this.messages = data.messages.map(m => ({ ...m, timestamp: new Date(m.timestamp) }));
          this.logger = logger; // Зберегти логер
  
          this.logger.debug(`[Chat ${this.metadata.id}] Initialized. Path: ${this.filePath}`);
          this.debouncedSave = debounce(this._saveToFile.bind(this), 1500, true);
      }
  
      // І оновіть статичний метод loadFromFile, щоб він теж приймав та передавав logger
       static async loadFromFile(filePath: string, adapter: DataAdapter, settings: ChatConstructorSettings, logger: Logger): Promise<Chat | null> {
          // ...
          return new Chat(adapter, settings, data, normPath, logger); // Передати logger
          // ...
       }
       */
  // --- Persistence ---
  /** Triggers a debounced save if message history saving is enabled. */
  save() {
    if (this.pluginSettings.saveMessageHistory) {
      this.debouncedSave();
    } else {
    }
  }
  /**
   * Saves the current chat state to its file immediately.
   * Bypasses the debounce timer. Returns true on success, false on failure.
   */
  async saveImmediately() {
    if (!this.pluginSettings.saveMessageHistory) {
      return true;
    }
    return await this._saveToFile();
  }
  /**
   * Internal method to perform the actual file writing operation.
   * Creates necessary directories if they don't exist.
   */
  async _saveToFile() {
    const chatData = {
      metadata: this.metadata,
      messages: this.messages.map((m) => ({
        ...m,
        timestamp: m.timestamp.toISOString()
        // Cast to any to satisfy type, it's a string
      }))
    };
    const jsonString = JSON.stringify(chatData, null, 2);
    try {
      const dirPath = this.filePath.substring(0, this.filePath.lastIndexOf("/"));
      if (dirPath && !await this.adapter.exists(dirPath)) {
        console.log(`[Chat ${this.metadata.id}] Directory ${dirPath} does not exist. Creating...`);
        await this.adapter.mkdir(dirPath);
        console.log(`[Chat ${this.metadata.id}] Directory ${dirPath} created.`);
      }
      await this.adapter.write(this.filePath, jsonString);
      return true;
    } catch (error) {
      console.error(`[Chat ${this.metadata.id}] Error saving chat to ${this.filePath}:`, error);
      new import_obsidian9.Notice(`Error saving chat: ${this.metadata.name}. Check console.`);
      return false;
    }
  }
  /**
   * Static method to load chat data from a specified file path within the vault.
   * Called by ChatManager.
   * @param filePath - The full, normalized path to the chat file.
   * @param adapter - Obsidian's DataAdapter.
   * @param settings - Plugin settings.
   * @returns A new Chat instance or null if loading fails.
   */
  static async loadFromFile(filePath, adapter, settings, logger) {
    var _a;
    const normPath = (0, import_obsidian9.normalizePath)(filePath);
    logger.debug(`[Chat] Static loadFromFile attempting for vault path: ${normPath}`);
    try {
      if (!await adapter.exists(normPath)) {
        logger.warn(`[Chat] File not found for loading: ${normPath}`);
        return null;
      }
      const json = await adapter.read(normPath);
      const data = JSON.parse(json);
      if (((_a = data == null ? void 0 : data.metadata) == null ? void 0 : _a.id) && Array.isArray(data.messages)) {
        logger.debug(`[Chat] Successfully parsed data, creating Chat instance for ID: ${data.metadata.id}`);
        return new Chat(adapter, settings, data, normPath, logger);
      } else {
        logger.error(`[Chat] Invalid data structure in file for static load: ${normPath}`, data);
        new import_obsidian9.Notice(`Error loading chat: Invalid data structure in ${filePath}`);
        return null;
      }
    } catch (e) {
      logger.error(`[Chat] Error loading or parsing file for static load: ${normPath}`, e);
      new import_obsidian9.Notice(`Error loading chat file: ${filePath}. ${e.message}`);
      return null;
    }
  }
  /**
   * Deletes the chat's associated `.json` file from the vault.
   * @returns true if the file was deleted or didn't exist, false on error.
   */
  async deleteFile() {
    console.log(`[Chat ${this.metadata.id}] Attempting to delete file: ${this.filePath}`);
    try {
      if (await this.adapter.exists(this.filePath)) {
        await this.adapter.remove(this.filePath);
        console.log(`[Chat ${this.metadata.id}] Successfully deleted file: ${this.filePath}`);
        return true;
      }
      console.log(`[Chat ${this.metadata.id}] File already deleted or never existed: ${this.filePath}`);
      return true;
    } catch (e) {
      console.error(`[Chat ${this.metadata.id}] Error deleting file ${this.filePath}:`, e);
      new import_obsidian9.Notice(`Error deleting chat file: ${this.metadata.name}. Check console.`);
      return false;
    }
  }
  toJSON() {
    return {
      metadata: this.metadata,
      messages: this.messages
    };
  }
};

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = { randomUUID };

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  var _a, _b, _c;
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = (_c = (_b = options.random) != null ? _b : (_a = options.rng) == null ? void 0 : _a.call(options)) != null ? _c : rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
    }
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// src/ChatManager.ts
var ChatManager = class {
  constructor(plugin) {
    this.chatsFolderPath = "/";
    this.chatIndex = {};
    this.activeChatId = null;
    this.activeChat = null;
    // Кеш ТІЛЬКИ для активного об'єкта Chat
    this.loadedChats = {};
    // Загальний кеш завантажених чатів (для швидкодії)
    // savingDebounced тепер не потрібен, бо debounce є в Chat
    this.currentTaskState = null;
    this.plugin = plugin;
    this.app = plugin.app;
    this.adapter = plugin.app.vault.adapter;
  }
  async initialize() {
    this.plugin.logger.info("Initializing ChatManager...");
    this.updateChatsFolderPath();
    await this.ensureFoldersExist();
    await this.loadChatIndex(true);
    this.plugin.logger.info(`ChatManager initialized. Index has ${Object.keys(this.chatIndex).length} chats.`);
  }
  updateChatsFolderPath() {
    var _a;
    const settingsPath = (_a = this.plugin.settings.chatHistoryFolderPath) == null ? void 0 : _a.trim();
    this.chatsFolderPath = settingsPath && settingsPath !== "/" ? (0, import_obsidian10.normalizePath)(settingsPath) : "/";
    this.plugin.logger.debug(`Chat history folder path set to: ${this.chatsFolderPath}`);
  }
  updateTaskState(tasks) {
    this.plugin.logger.debug("Updating task state in ChatManager", tasks);
    this.currentTaskState = tasks;
  }
  getCurrentTaskState() {
    return this.currentTaskState;
  }
  async ensureFoldersExist() {
    const historyPath = this.plugin.settings.chatHistoryFolderPath;
    const exportPath = this.plugin.settings.chatExportFolderPath;
    this.plugin.logger.debug(`Ensuring folders exist: History='${historyPath}', Export='${exportPath}'`);
    const checkAndCreate = async (folderPath, folderDesc) => {
      if (!folderPath || folderPath === "/")
        return;
      try {
        if (!await this.adapter.exists(folderPath)) {
          this.plugin.logger.info(`${folderDesc} folder doesn't exist. Creating: ${folderPath}`);
          await this.adapter.mkdir(folderPath);
        } else {
          const stat = await this.adapter.stat(folderPath);
          if ((stat == null ? void 0 : stat.type) !== "folder") {
            this.plugin.logger.error(`Path for ${folderDesc} exists but is not a folder: ${folderPath}`);
            new import_obsidian10.Notice(`Error: Path for ${folderDesc} is not a folder.`);
          }
        }
      } catch (error) {
        this.plugin.logger.error(`Error creating/checking ${folderDesc} directory '${folderPath}':`, error);
        new import_obsidian10.Notice(`Error creating folder for ${folderDesc}. Check settings and permissions.`);
      }
    };
    await checkAndCreate(historyPath, "Chat History");
    await checkAndCreate(exportPath, "Chat Export");
  }
  async loadChatIndex(forceScan = false) {
    var _a;
    this.plugin.logger.debug(`Loading chat index... (forceScan: ${forceScan})`);
    const storedIndex = await this.plugin.loadDataKey(CHAT_INDEX_KEY);
    if (!forceScan && storedIndex && Object.keys(storedIndex).length > 0) {
      this.chatIndex = storedIndex;
      this.plugin.logger.debug(`Loaded ${Object.keys(this.chatIndex).length} chat(s) from stored index.`);
      return;
    }
    this.plugin.logger.info(`Rebuilding chat index by scanning files in: ${this.chatsFolderPath}`);
    const newIndex = {};
    let filesScanned = 0;
    let chatsLoaded = 0;
    try {
      if (this.chatsFolderPath !== "/" && !await this.adapter.exists(this.chatsFolderPath)) {
        this.plugin.logger.warn(`Chat history folder '${this.chatsFolderPath}' not found during scan. Index will be empty.`);
        this.chatIndex = {};
        await this.saveChatIndex();
        return;
      }
      const listResult = await this.adapter.list(this.chatsFolderPath);
      const chatFiles = listResult.files.filter((filePath) => {
        const fileName = filePath.substring(filePath.lastIndexOf("/") + 1);
        return fileName.endsWith(".json") && !fileName.startsWith(".");
      });
      filesScanned = chatFiles.length;
      this.plugin.logger.debug(`Found ${filesScanned} potential chat files to scan.`);
      for (const fullPath of chatFiles) {
        const fileName = fullPath.substring(fullPath.lastIndexOf("/") + 1);
        const chatId = fileName.endsWith(".json") ? fileName.slice(0, -5) : null;
        if (!chatId)
          continue;
        try {
          const jsonContent = await this.adapter.read(fullPath);
          const data = JSON.parse(jsonContent);
          if (((_a = data == null ? void 0 : data.metadata) == null ? void 0 : _a.id) && data.metadata.id === chatId && data.metadata.name && data.metadata.lastModified && data.metadata.createdAt) {
            const metadata = data.metadata;
            newIndex[chatId] = {
              name: metadata.name,
              lastModified: typeof metadata.lastModified === "string" ? metadata.lastModified : new Date(metadata.lastModified || Date.now()).toISOString(),
              createdAt: typeof metadata.createdAt === "string" ? metadata.createdAt : new Date(metadata.createdAt || Date.now()).toISOString(),
              // Додаємо createdAt
              // Додаємо опціональні поля, якщо вони є
              ...metadata.modelName && { modelName: metadata.modelName },
              ...metadata.selectedRolePath && { selectedRolePath: metadata.selectedRolePath },
              ...metadata.temperature !== void 0 && { temperature: metadata.temperature },
              ...metadata.contextWindow !== void 0 && { contextWindow: metadata.contextWindow }
            };
            chatsLoaded++;
          } else {
            this.plugin.logger.warn(`Metadata validation FAILED for file: ${fullPath}. ID mismatch or missing required fields.`);
          }
        } catch (e) {
          this.plugin.logger.error(`Error reading or parsing chat file ${fullPath} during index scan:`, e);
        }
      }
      this.chatIndex = newIndex;
      await this.saveChatIndex();
      this.plugin.logger.info(`Index rebuilt: ${chatsLoaded} chats loaded from ${filesScanned} scanned files.`);
    } catch (error) {
      this.plugin.logger.error(`Critical error during index rebuild scan:`, error);
      this.chatIndex = {};
      await this.saveChatIndex();
    }
  }
  async saveChatIndex() {
    this.plugin.logger.debug(`Saving chat index with ${Object.keys(this.chatIndex).length} entries.`);
    await this.plugin.saveDataKey(CHAT_INDEX_KEY, this.chatIndex);
  }
  getChatFilePath(id) {
    const fileName = `${id}.json`;
    return this.chatsFolderPath === "/" ? (0, import_obsidian10.normalizePath)(fileName) : (0, import_obsidian10.normalizePath)(`${this.chatsFolderPath}/${fileName}`);
  }
  /**
   * Зберігає дані вказаного чату у файл (делегує класу Chat) та оновлює індекс.
   * Цей метод тепер використовується лише для початкового збереження нового чату.
   * Подальше збереження ініціюється з класу Chat через debounce.
   */
  async saveChatAndUpdateIndex(chat) {
    const saved = await chat.saveImmediately();
    if (saved) {
      const { id, createdAt, ...metaToStore } = chat.metadata;
      this.chatIndex[id] = metaToStore;
      await this.saveChatIndex();
      this.plugin.emit("chat-list-updated");
      return true;
    }
    return false;
  }
  /** Створює новий чат. */
  async createNewChat(name) {
    this.plugin.logger.info(`Creating new chat...`);
    try {
      const now = new Date();
      const newId = v4_default();
      const filePath = this.getChatFilePath(newId);
      const initialMetadata = {
        id: newId,
        name: name || `Chat ${now.toLocaleDateString()} ${now.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })}`,
        modelName: this.plugin.settings.modelName,
        selectedRolePath: this.plugin.settings.selectedRolePath,
        temperature: this.plugin.settings.temperature,
        contextWindow: this.plugin.settings.contextWindow,
        // <-- Додано
        createdAt: now.toISOString(),
        lastModified: now.toISOString()
      };
      const constructorSettings = { ...this.plugin.settings };
      const chatData = { metadata: initialMetadata, messages: [] };
      const newChat = new Chat(this.adapter, constructorSettings, chatData, filePath, this.plugin.logger);
      const saved = await this.saveChatAndUpdateIndex(newChat);
      if (!saved)
        throw new Error("Failed to save initial chat file.");
      this.loadedChats[newChat.metadata.id] = newChat;
      await this.setActiveChat(newChat.metadata.id);
      this.plugin.logger.info(`Created and activated new chat: ${newChat.metadata.name} (ID: ${newChat.metadata.id})`);
      return newChat;
    } catch (error) {
      this.plugin.logger.error("Error creating new chat:", error);
      new import_obsidian10.Notice("Error creating new chat session.");
      return null;
    }
  }
  /** Повертає масив метаданих всіх доступних чатів. */
  listAvailableChats() {
    return Object.entries(this.chatIndex).map(([id, storedMeta]) => {
      if (!storedMeta || typeof storedMeta.name !== "string" || typeof storedMeta.lastModified !== "string" || typeof storedMeta.createdAt !== "string") {
        this.plugin.logger.warn(`Invalid or incomplete metadata found in index for chat ID: ${id}. Skipping in list.`, storedMeta);
        return null;
      }
      return {
        id,
        createdAt: storedMeta.createdAt,
        // Тепер ми впевнені, що воно існує
        lastModified: storedMeta.lastModified,
        name: storedMeta.name,
        modelName: storedMeta.modelName,
        selectedRolePath: storedMeta.selectedRolePath,
        temperature: storedMeta.temperature,
        contextWindow: storedMeta.contextWindow
      };
    }).filter((chatMeta) => chatMeta !== null).sort((a, b) => new Date(b.lastModified).getTime() - new Date(a.lastModified).getTime());
  }
  getActiveChatId() {
    return this.activeChatId;
  }
  /** Завантажує та повертає екземпляр Chat за його ID. */
  async getChat(id) {
    this.plugin.logger.debug(`getChat called for ID: ${id}`);
    if (this.loadedChats[id]) {
      this.plugin.logger.debug(`Returning chat ${id} from memory cache.`);
      return this.loadedChats[id];
    }
    this.plugin.logger.debug(`Chat ${id} not in memory cache, loading from file...`);
    if (!this.chatIndex[id]) {
      this.plugin.logger.warn(`Chat ID ${id} not found in index during getChat.`);
      return null;
    }
    const filePath = this.getChatFilePath(id);
    try {
      const chat = await Chat.loadFromFile(filePath, this.adapter, this.plugin.settings, this.plugin.logger);
      if (chat) {
        this.plugin.logger.debug(`Successfully loaded chat ${id}. Caching.`);
        this.loadedChats[id] = chat;
        return chat;
      } else {
        this.plugin.logger.error(`Chat.loadFromFile returned null for ${id}. Removing from index if still present.`);
        if (this.chatIndex[id]) {
          delete this.chatIndex[id];
          await this.saveChatIndex();
          this.plugin.emit("chat-list-updated");
        }
        if (this.activeChatId === id)
          await this.setActiveChat(null);
        return null;
      }
    } catch (error) {
      this.plugin.logger.error(`Unexpected error during getChat for ${id} from ${filePath}:`, error);
      return null;
    }
  }
  async getActiveChat() {
    this.plugin.logger.debug(`getActiveChat called. Current activeChatId: ${this.activeChatId}`);
    if (!this.activeChatId) {
      this.plugin.logger.debug("No active chat ID set.");
      return null;
    }
    if (this.activeChat && this.activeChat.metadata.id === this.activeChatId) {
      this.plugin.logger.debug(`Returning cached active chat object: ${this.activeChatId}`);
      return this.activeChat;
    }
    this.plugin.logger.debug(`Active chat ${this.activeChatId} not in active cache, calling getChat...`);
    const chat = await this.getChat(this.activeChatId);
    if (chat) {
      this.activeChat = chat;
      return chat;
    } else {
      this.plugin.logger.warn(`Failed to load active chat ${this.activeChatId} via getChat.`);
      return null;
    }
  }
  async setActiveChat(id) {
    this.plugin.logger.debug(`setActiveChat called with ID: ${id}`);
    const previousActiveId = this.activeChatId;
    if (id && !this.chatIndex[id]) {
      this.plugin.logger.error(`Attempted to set active chat to non-existent ID: ${id}. Aborting.`);
      new import_obsidian10.Notice(`Error: Chat with ID ${id} not found.`);
      return;
    }
    if (id === previousActiveId) {
      this.plugin.logger.debug(`Chat ${id} is already active.`);
      if (id && !this.activeChat) {
        this.activeChat = await this.getChat(id);
        this.plugin.emit("active-chat-changed", { chatId: id, chat: this.activeChat });
      }
      return;
    }
    this.activeChatId = id;
    this.activeChat = null;
    let loadedChat = null;
    if (id) {
      loadedChat = await this.getChat(id);
      if (!loadedChat) {
        this.plugin.logger.error(`Failed to load chat data AFTER validating ID ${id}. Resetting active chat to null.`);
        this.activeChatId = null;
        id = null;
      } else {
        this.activeChat = loadedChat;
      }
    }
    this.plugin.logger.info(`Active chat changed from ${previousActiveId} to ${id}`);
    this.plugin.emit("active-chat-changed", { chatId: id, chat: loadedChat });
  }
  async addMessageToActiveChat(role, content) {
    const activeChat = await this.getActiveChat();
    if (!activeChat) {
      this.plugin.logger.error("Cannot add message: No active chat.");
      new import_obsidian10.Notice("Error: No active chat session.");
      return null;
    }
    const newMessage = activeChat.addMessage(role, content);
    this.plugin.logger.debug(`Added ${role} message to active chat ${activeChat.metadata.id}.`);
    if (this.chatIndex[activeChat.metadata.id]) {
      this.chatIndex[activeChat.metadata.id].lastModified = activeChat.metadata.lastModified;
      await this.saveChatIndex();
    }
    this.plugin.emit("message-added", { chatId: activeChat.metadata.id, message: newMessage });
    this.plugin.emit("chat-list-updated");
    return newMessage;
  }
  async clearActiveChatMessages() {
    const activeChat = await this.getActiveChat();
    if (!activeChat) {
      this.plugin.logger.warn("Cannot clear messages: No active chat.");
      return;
    }
    this.plugin.logger.info(`Clearing messages for chat: ${activeChat.metadata.id}`);
    activeChat.clearMessages();
    if (this.chatIndex[activeChat.metadata.id]) {
      this.chatIndex[activeChat.metadata.id].lastModified = activeChat.metadata.lastModified;
      await this.saveChatIndex();
    }
    this.plugin.emit("messages-cleared", activeChat.metadata.id);
    this.plugin.emit("chat-list-updated");
  }
  async updateActiveChatMetadata(metadataUpdate) {
    var _a, _b, _c, _d;
    const activeChat = await this.getActiveChat();
    if (!activeChat) {
      this.plugin.logger.warn("Cannot update metadata, no active chat.");
      new import_obsidian10.Notice("No active chat to update metadata for.");
      return false;
    }
    this.plugin.logger.debug(`Updating metadata for active chat ${activeChat.metadata.id}:`, metadataUpdate);
    const oldRolePath = activeChat.metadata.selectedRolePath;
    const oldModelName = activeChat.metadata.modelName;
    const changed = activeChat.updateMetadata(metadataUpdate);
    if (changed) {
      this.plugin.logger.debug(`Metadata changed. Chat ${activeChat.metadata.id} save scheduled by Chat class.`);
      if (this.chatIndex[activeChat.metadata.id]) {
        const metaToStore = {
          name: activeChat.metadata.name,
          lastModified: activeChat.metadata.lastModified,
          createdAt: activeChat.metadata.createdAt,
          // Явно додаємо createdAt
          // Додаємо опціональні поля, якщо вони є
          ...activeChat.metadata.modelName && { modelName: activeChat.metadata.modelName },
          ...activeChat.metadata.selectedRolePath && { selectedRolePath: activeChat.metadata.selectedRolePath },
          ...activeChat.metadata.temperature !== void 0 && { temperature: activeChat.metadata.temperature },
          ...activeChat.metadata.contextWindow !== void 0 && { contextWindow: activeChat.metadata.contextWindow }
        };
        this.chatIndex[activeChat.metadata.id] = metaToStore;
        await this.saveChatIndex();
        this.plugin.logger.debug(`[ChatManager.updateActiveChatMetadata] Updated chat index entry for ${activeChat.metadata.id} including createdAt.`);
      }
      const newRolePath = activeChat.metadata.selectedRolePath;
      const newModelName = activeChat.metadata.modelName;
      let roleChanged = false;
      let modelChanged = false;
      if (metadataUpdate.selectedRolePath !== void 0 && oldRolePath !== newRolePath) {
        roleChanged = true;
      }
      if (metadataUpdate.modelName !== void 0 && oldModelName !== newModelName) {
        modelChanged = true;
      }
      if (roleChanged) {
        try {
          const newRoleName = this.plugin.findRoleNameByPath(newRolePath);
          this.plugin.logger.debug(`Emitting 'role-changed': ${newRoleName}`);
          this.plugin.emit("role-changed", newRoleName);
          (_b = (_a = this.plugin.promptService) == null ? void 0 : _a.clearRoleCache) == null ? void 0 : _b.call(_a);
        } catch (e) {
          this.plugin.logger.error("Error finding role name/emitting role-changed:", e);
        }
      }
      if (modelChanged) {
        this.plugin.logger.debug(`Emitting 'model-changed': ${newModelName}`);
        this.plugin.emit("model-changed", newModelName);
        (_d = (_c = this.plugin.promptService) == null ? void 0 : _c.clearModelDetailsCache) == null ? void 0 : _d.call(_c);
      }
      this.plugin.emit("active-chat-changed", { chatId: this.activeChatId, chat: activeChat });
      this.plugin.emit("chat-list-updated");
      return true;
    } else {
      this.plugin.logger.debug("Metadata update called, but no actual changes detected.");
      return false;
    }
  }
  async deleteChat(id) {
    this.plugin.logger.info(`Deleting chat ID: ${id}`);
    const chatExistedInIndex = !!this.chatIndex[id];
    const filePath = this.getChatFilePath(id);
    let success = true;
    try {
      if (this.loadedChats[id]) {
        delete this.loadedChats[id];
        this.plugin.logger.debug(`Removed chat ${id} from memory cache.`);
      }
      if (chatExistedInIndex) {
        delete this.chatIndex[id];
        await this.saveChatIndex();
        this.plugin.logger.debug(`Removed chat ${id} from index.`);
      }
      if (await this.adapter.exists(filePath)) {
        await this.adapter.remove(filePath);
        this.plugin.logger.debug(`Removed chat file: ${filePath}`);
      } else {
        if (chatExistedInIndex) {
          this.plugin.logger.warn(`Chat file not found during deletion (but was in index): ${filePath}`);
        }
      }
    } catch (error) {
      this.plugin.logger.error(`Error during deletion process for chat ${id} or its file ${filePath}:`, error);
      new import_obsidian10.Notice(`Error deleting chat ${id}.`);
      success = false;
      await this.loadChatIndex(true);
    } finally {
      if (id === this.activeChatId) {
        this.plugin.logger.info(`Deleted active chat ${id}. Selecting new active chat...`);
        const availableChats = this.listAvailableChats();
        const nextActiveId = availableChats.length > 0 ? availableChats[0].id : null;
        await this.setActiveChat(nextActiveId);
      }
      this.plugin.emit("chat-list-updated");
    }
    return success && chatExistedInIndex;
  }
  async cloneChat(chatIdToClone) {
    this.plugin.logger.info(`Cloning chat ID: ${chatIdToClone}`);
    const originalChat = await this.getChat(chatIdToClone);
    if (!originalChat) {
      this.plugin.logger.error(`Cannot clone: Original chat ${chatIdToClone} not found.`);
      new import_obsidian10.Notice("Original chat not found.");
      return null;
    }
    try {
      const clonedData = originalChat.toJSON();
      const now = new Date();
      const newId = v4_default();
      const newFilePath = this.getChatFilePath(newId);
      clonedData.metadata.id = newId;
      clonedData.metadata.name = `Copy of ${originalChat.metadata.name}`;
      clonedData.metadata.createdAt = now.toISOString();
      clonedData.metadata.lastModified = now.toISOString();
      const constructorSettings = { ...this.plugin.settings };
      const clonedChat = new Chat(this.adapter, constructorSettings, clonedData, newFilePath, this.plugin.logger);
      const saved = await this.saveChatAndUpdateIndex(clonedChat);
      if (!saved)
        throw new Error("Failed to save the cloned chat file.");
      this.loadedChats[clonedChat.metadata.id] = clonedChat;
      await this.setActiveChat(clonedChat.metadata.id);
      this.plugin.logger.info(`Cloned chat "${clonedChat.metadata.name}" created and activated.`);
      return clonedChat;
    } catch (error) {
      this.plugin.logger.error("Error cloning chat:", error);
      new import_obsidian10.Notice("An error occurred while cloning the chat.");
      return null;
    }
  }
  // --- Метод видалення повідомлень ---
  async deleteMessagesAfter(chatId, userMessageIndex) {
    this.plugin.logger.info(`Deleting messages after index ${userMessageIndex} for chat ${chatId}`);
    const chat = await this.getChat(chatId);
    if (!chat) {
      this.plugin.logger.error(`Cannot delete messages: Chat ${chatId} not found.`);
      return false;
    }
    if (userMessageIndex < 0 || userMessageIndex >= chat.messages.length - 1) {
      this.plugin.logger.warn(`Invalid index (${userMessageIndex}) or last message, nothing to delete after in chat ${chatId}.`);
      return true;
    }
    const originalLength = chat.messages.length;
    chat.messages = chat.messages.slice(0, userMessageIndex + 1);
    chat.updateMetadata({});
    this.plugin.logger.debug(`Messages for chat ${chatId} truncated from ${originalLength} to ${chat.messages.length}. Save scheduled.`);
    if (this.chatIndex[chatId]) {
      this.chatIndex[chatId].lastModified = chat.metadata.lastModified;
      await this.saveChatIndex();
    }
    if (this.activeChatId === chatId) {
      this.activeChat = chat;
      this.plugin.logger.debug(`Updated active chat cache for ${chatId} after message deletion.`);
    }
    return true;
  }
  // --- Кінець методу видалення ---
};

// src/main.ts
var import_child_process = require("child_process");

// src/TranslationService.ts
var import_obsidian11 = require("obsidian");
var GOOGLE_TRANSLATE_API_URL = "https://translation.googleapis.com/language/translate/v2";
var TranslationService = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  /**
   * Translates text using the Google Translate API.
   * @param text The text to translate.
   * @param targetLang The target language code (e.g., 'uk', 'en', 'de').
   * @returns The translated text or null if translation fails.
   */
  async translate(text, targetLang) {
    var _a, _b;
    const apiKey = this.plugin.settings.googleTranslationApiKey;
    if (!this.plugin.settings.enableTranslation) {
      console.warn("Translation feature is disabled in settings.");
      return null;
    }
    if (!apiKey) {
      console.error("Google Translation API Key is missing.");
      new import_obsidian11.Notice("Translation Error: Google Cloud Translation API Key is not configured in settings.");
      return null;
    }
    if (!text) {
      console.warn("Translate called with empty text.");
      return "";
    }
    if (!targetLang) {
      console.error("Target language is not set for translation.");
      new import_obsidian11.Notice("Translation Error: Target language not configured.");
      return null;
    }
    console.log(`[TranslationService] Translating to ${targetLang}...`);
    try {
      const response = await fetch(`${GOOGLE_TRANSLATE_API_URL}?key=${apiKey}`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          q: text,
          target: targetLang,
          format: "text"
          // Request plain text translation
        })
      });
      const data = await response.json();
      if (!response.ok) {
        const errorMsg = ((_a = data.error) == null ? void 0 : _a.message) || `HTTP error ${response.status}`;
        console.error(`Google Translate API error: ${errorMsg}`, data);
        new import_obsidian11.Notice(`Translation Error: ${errorMsg}`);
        return null;
      }
      if (((_b = data.data) == null ? void 0 : _b.translations) && data.data.translations.length > 0) {
        const translatedText = this.decodeHtmlEntities(data.data.translations[0].translatedText);
        console.log("[TranslationService] Translation successful.");
        return translatedText;
      } else {
        console.error("Google Translate API returned unexpected response structure:", data);
        new import_obsidian11.Notice("Translation Error: Unexpected response from API.");
        return null;
      }
    } catch (error) {
      console.error("Error calling Google Translate API:", error);
      new import_obsidian11.Notice(`Translation Error: Failed to fetch. ${error.message}`);
      return null;
    }
  }
  // Helper to decode HTML entities (like &amp;, &lt;, etc.)
  decodeHtmlEntities(text) {
    if (typeof document !== "undefined") {
      const textArea = document.createElement("textarea");
      textArea.innerHTML = text;
      return textArea.value;
    } else {
      return text.replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&#39;/g, "'");
    }
  }
};

// src/main.ts
var SESSIONS_INDEX_KEY_V1 = "chatSessionsIndex_v1";
var ACTIVE_SESSION_ID_KEY_V1 = "activeChatSessionId_v1";
var SESSIONS_INDEX_KEY = "chatIndex_v2";
var ACTIVE_CHAT_ID_KEY2 = "activeChatId_v2";
var CHAT_INDEX_KEY = "chatIndex_v2";
var OllamaPlugin2 = class extends import_obsidian12.Plugin {
  constructor() {
    super(...arguments);
    this.view = null;
    this.eventHandlers = {};
    this.roleListCache = null;
    this.roleCacheClearTimeout = null;
    this.indexUpdateTimeout = null;
    // Змінено тип
    this.dailyTaskFilePath = null;
    this.taskFileContentCache = null;
    this.taskFileNeedsUpdate = false;
    this.taskCheckInterval = null;
  }
  // --- Event Emitter Methods (зроблено public) ---
  on(event, callback) {
    if (!this.eventHandlers[event])
      this.eventHandlers[event] = [];
    this.eventHandlers[event].push(callback);
    return () => {
      var _a, _b;
      this.eventHandlers[event] = (_a = this.eventHandlers[event]) == null ? void 0 : _a.filter(
        (h) => h !== callback
      );
      if (((_b = this.eventHandlers[event]) == null ? void 0 : _b.length) === 0) {
        delete this.eventHandlers[event];
      }
    };
  }
  emit(event, data) {
    const handlers = this.eventHandlers[event];
    if (handlers) {
      handlers.slice().forEach((handler) => {
        try {
          handler(data);
        } catch (e) {
          this.logger.error(
            `[OllamaPlugin] Error in event handler for ${event}:`,
            e
          );
        }
      });
    }
  }
  // --------------------------
  isTaskFileUpdated() {
    return this.taskFileNeedsUpdate;
  }
  async onload() {
    const initialSettingsData = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
    const loggerSettings = {
      consoleLogLevel: true ? initialSettingsData.consoleLogLevel || "INFO" : "DEBUG",
      // Використовуємо initialSettingsData
      fileLoggingEnabled: initialSettingsData.fileLoggingEnabled,
      fileLogLevel: initialSettingsData.fileLogLevel,
      logCallerInfo: initialSettingsData.logCallerInfo,
      logFilePath: initialSettingsData.logFilePath,
      logFileMaxSizeMB: initialSettingsData.logFileMaxSizeMB
    };
    this.logger = new Logger(this, loggerSettings);
    this.logger.info("Logger initialized.");
    await this.loadSettingsAndMigrate();
    this.promptService = new PromptService(this);
    this.ollamaService = new OllamaService(this);
    this.translationService = new TranslationService(this);
    this.ragService = new RagService(this);
    this.chatManager = new ChatManager(this);
    this.logger.info("Services initialized.");
    await this.chatManager.initialize();
    this.logger.updateSettings({
      consoleLogLevel: this.settings.consoleLogLevel,
      fileLoggingEnabled: this.settings.fileLoggingEnabled,
      fileLogLevel: this.settings.fileLogLevel,
      logCallerInfo: this.settings.logCallerInfo,
      logFilePath: this.settings.logFilePath,
      logFileMaxSizeMB: this.settings.logFileMaxSizeMB
    });
    this.registerView(VIEW_TYPE_OLLAMA_PERSONAS, (leaf) => {
      this.logger.debug("Registering AI Forge view.");
      this.view = new OllamaView(leaf, this);
      return this.view;
    });
    this.ollamaService.on("connection-error", (error) => {
      this.logger.error(
        "[Plugin] Connection error event received:",
        error
      );
      this.emit(
        "ollama-connection-error",
        error.message || "Unknown connection error"
      );
    });
    this.register(
      this.on("ollama-connection-error", (message) => {
        var _a, _b;
        (_b = (_a = this.view) == null ? void 0 : _a.addMessageToDisplay) == null ? void 0 : _b.call(_a, "error", message, new Date());
      })
    );
    this.register(
      this.on(
        "active-chat-changed",
        this.handleActiveChatChangedLocally.bind(this)
      )
    );
    this.register(
      this.on("chat-list-updated", () => {
        var _a, _b;
        this.logger.debug(
          "[Plugin] Event 'chat-list-updated' received."
        );
        (_b = (_a = this.view) == null ? void 0 : _a.renderChatListMenu) == null ? void 0 : _b.call(_a);
      })
    );
    this.register(
      this.on("settings-updated", () => {
        var _a, _b, _c;
        this.logger.info("[Plugin] Event 'settings-updated' received.");
        this.logger.updateSettings({
          /* ... передаємо об'єкт LoggerSettings ... */
          consoleLogLevel: this.settings.consoleLogLevel,
          fileLoggingEnabled: this.settings.fileLoggingEnabled,
          fileLogLevel: this.settings.fileLogLevel,
          logCallerInfo: this.settings.logCallerInfo,
          logFilePath: this.settings.logFilePath,
          logFileMaxSizeMB: this.settings.logFileMaxSizeMB
        });
        this.updateDailyTaskFilePath();
        this.loadAndProcessInitialTasks();
        this.updateOllamaServiceConfig();
        this.roleListCache = null;
        (_a = this.promptService) == null ? void 0 : _a.clearRoleCache();
        (_c = (_b = this.view) == null ? void 0 : _b.handleSettingsUpdated) == null ? void 0 : _c.call(_b);
        this.emit("roles-updated");
      })
    );
    this.addRibbonIcon("brain-circuit", "Open AI Forge Chat", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-chat-view",
      name: "Open AI Forge Chat",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "index-rag-documents",
      name: "AI Forge: Index documents for RAG",
      callback: async () => {
        if (this.settings.ragEnabled)
          await this.ragService.indexDocuments();
        else
          new import_obsidian12.Notice("RAG is disabled in settings.");
      }
    });
    this.addCommand({
      id: "clear-active-chat-history",
      name: "AI Forge: Clear Active Chat History",
      callback: async () => {
        await this.clearMessageHistoryWithConfirmation();
      }
    });
    this.addCommand({
      id: "refresh-roles",
      name: "AI Forge: Refresh Roles List",
      callback: async () => {
        await this.listRoleFiles(true);
        this.emit("roles-updated");
        new import_obsidian12.Notice("Role list refreshed.");
      }
    });
    this.addCommand({
      id: "new-chat",
      name: "AI Forge: New Chat",
      callback: async () => {
        const newChat = await this.chatManager.createNewChat();
        if (newChat) {
          new import_obsidian12.Notice(`Created new chat: ${newChat.metadata.name}`);
        }
      }
    });
    this.addCommand({
      id: "switch-chat",
      name: "AI Forge: Switch Chat",
      callback: async () => {
        await this.showChatSwitcher();
      }
    });
    this.addCommand({
      id: "rename-active-chat",
      name: "AI Forge: Rename Active Chat",
      callback: async () => {
        await this.renameActiveChat();
      }
    });
    this.addCommand({
      id: "delete-active-chat",
      name: "AI Forge: Delete Active Chat",
      callback: async () => {
        await this.deleteActiveChatWithConfirmation();
      }
    });
    this.settingTab = new OllamaSettingTab(this.app, this);
    this.addSettingTab(this.settingTab);
    this.app.workspace.onLayoutReady(async () => {
      if (this.settings.ragEnabled) {
        this.logger.info("Layout ready, scheduling initial RAG index.");
        setTimeout(() => {
          var _a;
          (_a = this.ragService) == null ? void 0 : _a.indexDocuments();
        }, 5e3);
      }
      const savedActiveId = await this.loadDataKey(ACTIVE_CHAT_ID_KEY2);
      if (savedActiveId && this.settings.saveMessageHistory) {
        this.logger.info(
          `Layout ready, restoring active chat ID: ${savedActiveId}`
        );
        await this.chatManager.setActiveChat(savedActiveId);
      } else {
        this.logger.info(
          `Layout ready, no saved active chat ID or history saving disabled.`
        );
      }
    });
    const debouncedRoleClear = (0, import_obsidian12.debounce)(
      () => {
        var _a, _b, _c, _d;
        this.logger.debug(
          "Role/RAG change detected (debounced), clearing cache & emitting."
        );
        this.roleListCache = null;
        (_b = (_a = this.promptService) == null ? void 0 : _a.clearRoleCache) == null ? void 0 : _b.call(_a);
        this.emit("roles-updated");
        (_d = (_c = this.view) == null ? void 0 : _c.renderRoleList) == null ? void 0 : _d.call(_c);
      },
      1500,
      true
    );
    this.fileChangeHandlerDebounced = (0, import_obsidian12.debounce)(
      (file) => {
        if (!file)
          return;
        this.logger.debug(
          `Debounced file change check for roles/RAG: ${file.path}`
        );
        this.handleRoleOrRagFileChange(
          file.path,
          debouncedRoleClear,
          false
        );
      },
      1e3,
      true
    );
    const handleModifyEvent = (file) => {
      if (file instanceof import_obsidian12.TFile) {
        this.logger.debug(`Modify event: ${file.path}`);
        this.fileChangeHandlerDebounced(file);
        this.handleTaskFileModify(file);
      }
    };
    const handleDeleteEvent = (file) => {
      var _a;
      this.logger.debug(`Delete event: ${file.path}`);
      this.handleRoleOrRagFileChange(file.path, debouncedRoleClear, true);
      if (this.settings.enableProductivityFeatures && file.path === this.dailyTaskFilePath) {
        this.logger.info(
          `Task file ${this.dailyTaskFilePath} deleted.`
        );
        this.dailyTaskFilePath = null;
        this.taskFileContentCache = null;
        this.taskFileNeedsUpdate = false;
        (_a = this.chatManager) == null ? void 0 : _a.updateTaskState(null);
      }
    };
    const handleRenameEvent = (file, oldPath) => {
      this.logger.debug(`Rename event: ${oldPath} -> ${file.path}`);
      this.fileChangeHandlerDebounced(file);
      this.handleRoleOrRagFileChange(oldPath, debouncedRoleClear, true);
      if (this.settings.enableProductivityFeatures) {
        if (oldPath === this.dailyTaskFilePath) {
          this.logger.info(
            `Task file potentially renamed from ${oldPath}`
          );
          this.updateDailyTaskFilePath();
          this.loadAndProcessInitialTasks();
        } else if (file.path === this.dailyTaskFilePath) {
          this.logger.info(
            `A file was renamed to become the task file: ${file.path}`
          );
          this.taskFileNeedsUpdate = true;
          this.checkAndProcessTaskUpdate();
        }
      }
    };
    const handleCreateEvent = (file) => {
      this.logger.debug(`Create event: ${file.path}`);
      this.fileChangeHandlerDebounced(file);
      if (this.settings.enableProductivityFeatures && file.path === this.dailyTaskFilePath) {
        this.logger.info(
          `Task file ${this.dailyTaskFilePath} created.`
        );
        this.taskFileNeedsUpdate = true;
        this.checkAndProcessTaskUpdate();
      }
    };
    this.registerEvent(this.app.vault.on("modify", handleModifyEvent));
    this.registerEvent(this.app.vault.on("delete", handleDeleteEvent));
    this.registerEvent(this.app.vault.on("rename", handleRenameEvent));
    this.registerEvent(this.app.vault.on("create", handleCreateEvent));
    this.updateDailyTaskFilePath();
    await this.loadAndProcessInitialTasks();
    if (this.settings.enableProductivityFeatures) {
      this.taskCheckInterval = setInterval(
        () => this.checkAndProcessTaskUpdate(),
        5e3
      );
      this.registerInterval(this.taskCheckInterval);
    }
  }
  // --- Логіка файлу завдань ---
  updateDailyTaskFilePath() {
    var _a, _b;
    const folderPath = (_a = this.settings.ragFolderPath) == null ? void 0 : _a.trim();
    const fileName = (_b = this.settings.dailyTaskFileName) == null ? void 0 : _b.trim();
    const newPath = folderPath && fileName ? (0, import_obsidian12.normalizePath)(`${folderPath}/${fileName}`) : null;
    if (newPath !== this.dailyTaskFilePath) {
      this.logger.info(`Daily task file path set to: ${newPath}`);
      this.dailyTaskFilePath = newPath;
      this.taskFileContentCache = null;
      this.taskFileNeedsUpdate = true;
    } else if (!newPath) {
      this.dailyTaskFilePath = null;
      this.logger.info(`Daily task file path is not configured.`);
    }
  }
  handleTaskFileModify(file) {
    if (this.settings.enableProductivityFeatures && file.path === this.dailyTaskFilePath) {
      this.logger.debug(
        `Detected modification in task file: ${file.path}`
      );
      this.taskFileNeedsUpdate = true;
    }
  }
  async loadAndProcessInitialTasks() {
    var _a, _b, _c, _d;
    if (!this.settings.enableProductivityFeatures || !this.dailyTaskFilePath) {
      this.taskFileContentCache = null;
      (_a = this.chatManager) == null ? void 0 : _a.updateTaskState(null);
      this.taskFileNeedsUpdate = false;
      return;
    }
    try {
      const fileExists = await this.app.vault.adapter.exists(
        this.dailyTaskFilePath
      );
      if (fileExists) {
        const content = await this.app.vault.adapter.read(
          this.dailyTaskFilePath
        );
        if (content !== this.taskFileContentCache || this.taskFileContentCache === null) {
          this.logger.info(
            `Loading and processing tasks from ${this.dailyTaskFilePath}`
          );
          this.taskFileContentCache = content;
          const tasks = this.parseTasks(content);
          (_b = this.chatManager) == null ? void 0 : _b.updateTaskState(tasks);
          this.taskFileNeedsUpdate = false;
        } else {
          this.logger.debug(
            `Task file content unchanged, skipping processing.`
          );
          this.taskFileNeedsUpdate = false;
        }
      } else {
        this.logger.warn(
          `Task file ${this.dailyTaskFilePath} not found.`
        );
        this.taskFileContentCache = null;
        (_c = this.chatManager) == null ? void 0 : _c.updateTaskState(null);
        this.taskFileNeedsUpdate = false;
      }
    } catch (error) {
      this.logger.error(
        `Error loading/processing task file ${this.dailyTaskFilePath}:`,
        error
      );
      this.taskFileContentCache = null;
      (_d = this.chatManager) == null ? void 0 : _d.updateTaskState(null);
      this.taskFileNeedsUpdate = false;
    }
  }
  parseTasks(content) {
    const lines = content.split("\n");
    const urgent = [];
    const regular = [];
    let hasContent = false;
    for (const line of lines) {
      const trimmedLine = line.trim();
      if (!trimmedLine)
        continue;
      hasContent = true;
      if (trimmedLine.startsWith("- [x]") || trimmedLine.startsWith("- [X]"))
        continue;
      if (trimmedLine.startsWith("!") || trimmedLine.toLowerCase().includes("[urgent]")) {
        urgent.push(
          trimmedLine.replace(/^!/, "").replace(/\[urgent\]/i, "").trim()
        );
      } else if (trimmedLine.startsWith("- [ ]")) {
        regular.push(
          trimmedLine.substring(trimmedLine.indexOf("]") + 1).trim()
        );
      } else if (trimmedLine.startsWith("- ")) {
        regular.push(trimmedLine.substring(1).trim());
      } else {
        regular.push(trimmedLine);
      }
    }
    const filteredUrgent = urgent.filter((task) => task.length > 0);
    const filteredRegular = regular.filter((task) => task.length > 0);
    hasContent = filteredUrgent.length > 0 || filteredRegular.length > 0;
    this.logger.debug(
      `Parsed tasks - Urgent: ${filteredUrgent.length}, Regular: ${filteredRegular.length}, HasContent: ${hasContent}`
    );
    return { urgent: filteredUrgent, regular: filteredRegular, hasContent };
  }
  async checkAndProcessTaskUpdate() {
    if (this.taskFileNeedsUpdate) {
      this.logger.debug(
        "checkAndProcessTaskUpdate: taskFileNeedsUpdate is true, reloading..."
      );
      await this.loadAndProcessInitialTasks();
    }
  }
  // --- Кінець логіки файлу завдань ---
  // Обробник змін для ролей та RAG (без debounce)
  handleRoleOrRagFileChange(changedPath, debouncedRoleClear, isDeletion = false) {
    const normPath = (0, import_obsidian12.normalizePath)(changedPath);
    this.logger.debug(
      `Handling file change for path: ${normPath}, isDeletion: ${isDeletion}`
    );
    const userRolesPath = this.settings.userRolesFolderPath ? (0, import_obsidian12.normalizePath)(this.settings.userRolesFolderPath) : null;
    const builtInRolesPath = this.manifest.dir ? (0, import_obsidian12.normalizePath)(`${this.manifest.dir}/roles`) : null;
    let isRoleFile = false;
    if (normPath.toLowerCase().endsWith(".md")) {
      if (userRolesPath && normPath.startsWith(userRolesPath + "/")) {
        isRoleFile = true;
      } else if (builtInRolesPath && normPath.startsWith(builtInRolesPath + "/")) {
        isRoleFile = true;
      }
    }
    if (isRoleFile) {
      this.logger.debug(`Role file change detected: ${normPath}`);
      debouncedRoleClear();
    }
    const ragFolderPath = this.settings.ragFolderPath ? (0, import_obsidian12.normalizePath)(this.settings.ragFolderPath) : null;
    if (this.settings.ragEnabled && ragFolderPath && normPath.startsWith(ragFolderPath + "/")) {
      if (normPath !== this.dailyTaskFilePath) {
        this.logger.debug(
          `RAG file change detected: ${normPath}, isDeletion: ${isDeletion}. Triggering debounced index.`
        );
        this.debounceIndexUpdate();
      } else {
        this.logger.debug(
          `Change in task file ${normPath} detected, handled separately, skipping RAG index trigger.`
        );
      }
    }
  }
  async onunload() {
    var _a, _b, _c, _d;
    this.logger.info("Unloading AI Forge Plugin...");
    this.app.workspace.getLeavesOfType(VIEW_TYPE_OLLAMA_PERSONAS).forEach((l) => l.detach());
    this.view = null;
    if (this.indexUpdateTimeout)
      clearTimeout(this.indexUpdateTimeout);
    if (this.roleCacheClearTimeout)
      clearTimeout(this.roleCacheClearTimeout);
    if (this.taskCheckInterval)
      clearInterval(this.taskCheckInterval);
    try {
      if (this.chatManager && this.settings.saveMessageHistory) {
        const lastActiveId = this.chatManager.getActiveChatId();
        if (lastActiveId !== void 0 && lastActiveId !== null) {
          this.logger.info(
            `Saving activeChatId (${lastActiveId}) on unload.`
          );
          await this.saveDataKey(ACTIVE_CHAT_ID_KEY2, lastActiveId);
        } else {
          this.logger.info(
            `No active chat ID found to save on unload.`
          );
          await this.saveDataKey(ACTIVE_CHAT_ID_KEY2, null);
        }
      } else {
        this.logger.info(
          `History saving disabled or chatManager missing, not saving active chat ID.`
        );
        await this.saveDataKey(ACTIVE_CHAT_ID_KEY2, null);
      }
    } catch (error) {
      this.logger.error("Error saving active chat ID on unload:", error);
    }
    (_b = (_a = this.promptService) == null ? void 0 : _a.clearModelDetailsCache) == null ? void 0 : _b.call(_a);
    (_d = (_c = this.promptService) == null ? void 0 : _c.clearRoleCache) == null ? void 0 : _d.call(_c);
    this.roleListCache = null;
    this.logger.info("AI Forge Plugin unloaded.");
  }
  updateOllamaServiceConfig() {
    var _a;
    if (this.ollamaService) {
      this.logger.info(
        "Settings changed, potentially updating Ollama service config."
      );
      (_a = this.promptService) == null ? void 0 : _a.clearModelDetailsCache();
    }
  }
  debounceIndexUpdate() {
    if (this.indexUpdateTimeout)
      clearTimeout(this.indexUpdateTimeout);
    this.indexUpdateTimeout = setTimeout(async () => {
      this.logger.debug("Debounced RAG index update starting...");
      if (this.settings.ragEnabled && this.ragService) {
        await this.ragService.indexDocuments();
      }
      this.indexUpdateTimeout = null;
    }, 3e4);
  }
  // Оновлений метод активації View
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const viewType = VIEW_TYPE_OLLAMA_PERSONAS;
    const existingLeaves = workspace.getLeavesOfType(viewType);
    this.logger.debug(
      `activateView called. Found ${existingLeaves.length} existing leaves. Open in tab setting: ${this.settings.openChatInTab}`
    );
    if (existingLeaves.length > 0) {
      leaf = existingLeaves[0];
      this.logger.debug(`Found existing view leaf. Revealing it.`);
    } else {
      this.logger.debug(`No existing view leaf found. Creating new one.`);
      if (this.settings.openChatInTab) {
        this.logger.debug(`Setting requests view in tab.`);
        leaf = workspace.getLeaf("tab");
      } else {
        this.logger.debug(
          `Setting requests view in sidebar. Checking right sidebar...`
        );
        leaf = workspace.getRightLeaf(false);
        if (!leaf) {
          this.logger.warn(
            `Right sidebar leaf not found or not open. Per default settings, chat should open here.`
          );
          this.logger.warn(
            `Falling back to opening in a new tab as sidebar is not available.`
          );
          leaf = workspace.getLeaf("tab");
        } else {
          this.logger.debug(`Found existing right sidebar leaf.`);
        }
      }
      if (leaf) {
        this.logger.debug(`Setting view state for the leaf.`);
        try {
          await leaf.setViewState({ type: viewType, active: true });
        } catch (e) {
          this.logger.error("Error setting view state:", e);
          new import_obsidian12.Notice("Error opening AI Forge view.");
          return;
        }
      } else {
        this.logger.error(
          "Failed to get or create leaf for AI Forge view."
        );
        new import_obsidian12.Notice("Could not open AI Forge view.");
        return;
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
      if (leaf.view instanceof OllamaView) {
        this.view = leaf.view;
        this.logger.debug("AI Forge View instance assigned/confirmed.");
      } else {
        this.logger.error(
          "Leaf revealed, but view is not an instance of OllamaView:",
          leaf.view
        );
      }
    }
  }
  // Завантаження та Міграція Налаштувань
  async loadSettingsAndMigrate() {
    const loadedData = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS, loadedData);
    let migrated = false;
    if (loadedData && loadedData[SESSIONS_INDEX_KEY_V1] !== void 0 && this.settings[SESSIONS_INDEX_KEY] === void 0) {
      this.logger.info("Migrating chat index key v1 -> v2");
      this.settings[SESSIONS_INDEX_KEY] = loadedData[SESSIONS_INDEX_KEY_V1];
      delete this.settings[SESSIONS_INDEX_KEY_V1];
      migrated = true;
    }
    if (loadedData && loadedData[ACTIVE_SESSION_ID_KEY_V1] !== void 0 && this.settings[ACTIVE_CHAT_ID_KEY2] === void 0) {
      this.logger.info("Migrating active chat id key v1 -> v2");
      this.settings[ACTIVE_CHAT_ID_KEY2] = loadedData[ACTIVE_SESSION_ID_KEY_V1];
      delete this.settings[ACTIVE_SESSION_ID_KEY_V1];
      migrated = true;
    }
    if (migrated) {
      this.logger.info("Saving migrated settings...");
      await this.saveData(this.settings);
    }
  }
  async saveSettings() {
    this.logger.debug("Saving plugin settings...");
    await this.saveData(this.settings);
    this.logger.debug("Settings saved. Emitting 'settings-updated' event.");
    this.emit("settings-updated");
  }
  // Data Helpers
  async saveDataKey(key, value) {
    try {
      const data = await this.loadData() || {};
      data[key] = value;
      await this.saveData(data);
      this.logger.debug(`Saved data for key: ${key}`);
    } catch (error) {
      this.logger.error(`Error saving data key ${key}:`, error);
    }
  }
  async loadDataKey(key) {
    try {
      const data = await this.loadData() || {};
      this.logger.debug(`Loaded data for key: ${key}`);
      return data[key];
    } catch (error) {
      this.logger.error(`Error loading data key ${key}:`, error);
      return void 0;
    }
  }
  // History Persistence
  async clearMessageHistoryWithConfirmation() {
    this.logger.debug("Clear active chat history command triggered.");
    if (!this.chatManager) {
      this.logger.error("ChatManager not ready for clearMessageHistory.");
      new import_obsidian12.Notice("Error: Chat Manager not ready.");
      return;
    }
    const activeChat = await this.chatManager.getActiveChat();
    if (activeChat && activeChat.messages.length > 0) {
      new ConfirmModal(
        this.app,
        "Clear History",
        `Clear messages in "${activeChat.metadata.name}"?`,
        async () => {
          this.logger.info(
            `User confirmed clearing history for chat: ${activeChat.metadata.id}`
          );
          await this.chatManager.clearActiveChatMessages();
          new import_obsidian12.Notice(
            `History cleared for "${activeChat.metadata.name}".`
          );
        }
      ).open();
    } else if (activeChat) {
      new import_obsidian12.Notice("Chat history is already empty.");
    } else {
      new import_obsidian12.Notice("No active chat to clear.");
    }
  }
  // List Role Files Method (з виправленням path.basename)
  async listRoleFiles(forceRefresh = false) {
    var _a;
    if (this.roleListCache && !forceRefresh) {
      this.logger.debug("Returning cached roles.");
      return this.roleListCache;
    }
    this.logger.debug(
      "Fetching roles list (forceRefresh=" + forceRefresh + ")..."
    );
    const roles = [];
    const addedNamesLowerCase = /* @__PURE__ */ new Set();
    const adapter = this.app.vault.adapter;
    const pluginDir = this.manifest.dir;
    const builtInRoleName = "Productivity Assistant";
    const builtInRoleFileName = "Productivity_Assistant.md";
    let builtInRolePath = null;
    if (pluginDir) {
      builtInRolePath = (0, import_obsidian12.normalizePath)(
        `${pluginDir}/roles/${builtInRoleFileName}`
      );
      this.logger.debug(
        `Checking for built-in role at: ${builtInRolePath}`
      );
      try {
        if (await adapter.exists(builtInRolePath)) {
          const stat = await adapter.stat(builtInRolePath);
          if ((stat == null ? void 0 : stat.type) === "file") {
            this.logger.debug(
              `Found built-in role: ${builtInRoleName}`
            );
            roles.push({
              name: builtInRoleName,
              path: builtInRolePath,
              isCustom: false
            });
            addedNamesLowerCase.add(builtInRoleName.toLowerCase());
          } else {
            this.logger.warn(
              `Built-in role path exists but is not a file: ${builtInRolePath}`
            );
          }
        } else {
          this.logger.warn(
            `Built-in role file NOT FOUND at: ${builtInRolePath}.`
          );
        }
      } catch (error) {
        this.logger.error(
          `Error checking/adding built-in role at ${builtInRolePath}:`,
          error
        );
      }
    } else {
      this.logger.warn(
        "Plugin directory not found, cannot locate built-in roles."
      );
    }
    const userRolesFolderPath = this.settings.userRolesFolderPath ? (0, import_obsidian12.normalizePath)(this.settings.userRolesFolderPath) : null;
    if (userRolesFolderPath && userRolesFolderPath !== "/") {
      this.logger.debug(
        `Processing user roles from: ${userRolesFolderPath}`
      );
      try {
        if (await adapter.exists(userRolesFolderPath) && ((_a = await adapter.stat(userRolesFolderPath)) == null ? void 0 : _a.type) === "folder") {
          const listResult = await adapter.list(userRolesFolderPath);
          for (const filePath of listResult.files) {
            if (filePath.toLowerCase().endsWith(".md") && filePath.split("/").length === userRolesFolderPath.split("/").length + 1 && filePath !== builtInRolePath) {
              const fileName = filePath.substring(
                filePath.lastIndexOf("/") + 1
              );
              const roleName = fileName.endsWith(".md") ? fileName.slice(0, -3) : fileName;
              if (!addedNamesLowerCase.has(roleName.toLowerCase())) {
                roles.push({
                  name: roleName,
                  path: filePath,
                  isCustom: true
                });
                addedNamesLowerCase.add(roleName.toLowerCase());
              } else {
                this.logger.warn(
                  `Skipping user role "${roleName}" from "${filePath}" due to name conflict.`
                );
              }
            }
          }
        } else {
          this.logger.warn(
            `User roles path not found or not a folder: ${userRolesFolderPath}`
          );
        }
      } catch (e) {
        this.logger.error(
          `Error listing user roles in ${userRolesFolderPath}:`,
          e
        );
      }
    } else if (userRolesFolderPath === "/") {
      this.logger.warn(
        "User roles folder path is set to root '/', skipping scan."
      );
    }
    roles.sort((a, b) => a.name.localeCompare(b.name));
    this.roleListCache = roles;
    this.logger.debug(`Found total ${roles.length} roles.`);
    return roles;
  }
  // Execute System Command Method
  async executeSystemCommand(command) {
    var _a;
    this.logger.info(`Executing system command: ${command}`);
    if (!(command == null ? void 0 : command.trim())) {
      return {
        stdout: "",
        stderr: "Empty command.",
        error: new Error("Empty command.")
      };
    }
    if (typeof process === "undefined" || !((_a = process == null ? void 0 : process.versions) == null ? void 0 : _a.node)) {
      this.logger.error(
        "Node.js environment not available. Cannot execute system command."
      );
      new import_obsidian12.Notice("Cannot execute system command.");
      return {
        stdout: "",
        stderr: "Node.js required.",
        error: new Error("Node.js required.")
      };
    }
    return new Promise((resolve) => {
      (0, import_child_process.exec)(command, (error, stdout, stderr) => {
        if (error)
          this.logger.error(`Exec error for "${command}": ${error}`);
        if (stderr)
          this.logger.error(
            `Exec stderr for "${command}": ${stderr}`
          );
        if (stdout)
          this.logger.debug(
            `Exec stdout for "${command}": ${stdout}`
          );
        resolve({
          stdout: stdout.toString(),
          stderr: stderr.toString(),
          error
        });
      });
    });
  }
  // --- Session Management Command Helpers ---
  async showChatSwitcher() {
    new import_obsidian12.Notice("Switch Chat UI not implemented yet.");
  }
  // У файлі src/main.ts
  async renameActiveChat() {
    var _a;
    const activeChat = await ((_a = this.chatManager) == null ? void 0 : _a.getActiveChat());
    if (!activeChat) {
      new import_obsidian12.Notice("No active chat to rename.");
      return;
    }
    const currentName = activeChat.metadata.name;
    const chatId = activeChat.metadata.id;
    new PromptModal(
      this.app,
      "Rename Chat",
      `Enter new name for "${currentName}":`,
      currentName,
      async (newName) => {
        const trimmedName = newName == null ? void 0 : newName.trim();
        if (trimmedName && trimmedName !== "" && trimmedName !== currentName) {
          this.logger.debug(
            `Attempting to rename chat ${chatId} to "${trimmedName}" via updateActiveChatMetadata`
          );
          const success = await this.chatManager.updateActiveChatMetadata({
            name: trimmedName
          });
          if (success) {
            this.logger.info(
              `Chat ${chatId} rename initiated to "${trimmedName}".`
            );
          } else {
            this.logger.error(
              `Failed to rename chat ${chatId} using updateActiveChatMetadata.`
            );
          }
        } else if (newName !== null) {
          new import_obsidian12.Notice("Rename cancelled or name unchanged.");
        }
      }
    ).open();
  }
  async deleteActiveChatWithConfirmation() {
    var _a;
    const activeChat = await ((_a = this.chatManager) == null ? void 0 : _a.getActiveChat());
    if (!activeChat) {
      new import_obsidian12.Notice("No active chat.");
      return;
    }
    const chatName = activeChat.metadata.name;
    new ConfirmModal(
      this.app,
      "Delete Chat",
      `Delete chat "${chatName}"?`,
      async () => {
        const success = await this.chatManager.deleteChat(
          activeChat.metadata.id
        );
        if (success) {
          new import_obsidian12.Notice(`Chat "${chatName}" deleted.`);
        } else {
          new import_obsidian12.Notice(`Failed to delete chat "${chatName}".`);
        }
      }
    ).open();
  }
  // Обробник зміни активного чату
  async handleActiveChatChangedLocally(data) {
    this.logger.info(
      `Handling 'active-chat-changed' locally. New active ID: ${data.chatId}`
    );
    if (this.settings.saveMessageHistory) {
      await this.saveDataKey(ACTIVE_CHAT_ID_KEY2, data.chatId);
      this.logger.debug(`Saved active chat ID: ${data.chatId}`);
    }
  }
  // Пошук імені ролі (з виправленням path.basename)
  findRoleNameByPath(rolePath) {
    var _a;
    if (!rolePath)
      return "None";
    const cachedRole = (_a = this.roleListCache) == null ? void 0 : _a.find(
      (rl) => rl.path === rolePath
    );
    if (cachedRole)
      return cachedRole.name;
    try {
      const fileName = rolePath.substring(rolePath.lastIndexOf("/") + 1);
      const roleName = fileName.endsWith(".md") ? fileName.slice(0, -3) : fileName;
      return roleName;
    } catch (e) {
      this.logger.warn(
        `Could not determine role name for path: ${rolePath}`,
        e
      );
      return "Unknown Role";
    }
  }
};
