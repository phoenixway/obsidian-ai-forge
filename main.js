/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  ACTIVE_CHAT_ID_KEY: () => ACTIVE_CHAT_ID_KEY,
  CHAT_INDEX_KEY: () => CHAT_INDEX_KEY,
  SESSIONS_INDEX_KEY: () => SESSIONS_INDEX_KEY,
  default: () => OllamaPlugin2
});
module.exports = __toCommonJS(main_exports);
var import_obsidian23 = require("obsidian");

// src/OllamaView.ts
var import_obsidian15 = require("obsidian");

// src/ConfirmModal.ts
var import_obsidian = require("obsidian");
var ConfirmModal = class extends import_obsidian.Modal {
  constructor(app, title, message, onConfirm) {
    super(app);
    this.title = title;
    this.message = message;
    this.onConfirm = onConfirm;
    this.title = title;
    this.message = message;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl, titleEl } = this;
    titleEl.setText(this.title);
    contentEl.createEl("p", { text: this.message });
    new import_obsidian.Setting(contentEl).addButton((button) => button.setButtonText("Confirm").setCta().onClick(() => {
      this.onConfirm();
      this.close();
    })).addButton((button) => button.setButtonText("Cancel").onClick(() => {
      this.close();
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/PromptModal.ts
var import_obsidian2 = require("obsidian");
var PromptModal = class extends import_obsidian2.Modal {
  constructor(app, title, promptText, initialValue = "", onSubmit) {
    super(app);
    this.title = title;
    this.promptText = promptText;
    this.initialValue = initialValue;
    this.onSubmit = onSubmit;
    // Приватний метод для обробки відправки (щоб уникнути дублювання коду для кнопки та Enter)
    this.submitInput = () => {
      this.onSubmit(this.inputValue);
      this.close();
    };
    this.title = title;
    this.promptText = promptText;
    this.inputValue = initialValue;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl, titleEl } = this;
    let textInput;
    titleEl.setText(this.title);
    if (this.promptText) {
      contentEl.createEl("p", { text: this.promptText });
    }
    new import_obsidian2.Setting(contentEl).setName("New value:").addText((text) => {
      textInput = text;
      text.setValue(this.inputValue).onChange((value) => {
        this.inputValue = value;
      });
      text.inputEl.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          this.submitInput();
        }
      });
    });
    new import_obsidian2.Setting(contentEl).addButton((button) => button.setButtonText("Submit").setCta().onClick(this.submitInput)).addButton((button) => button.setButtonText("Cancel").onClick(() => {
      this.close();
    }));
    setTimeout(() => {
      var _a, _b;
      (_a = textInput == null ? void 0 : textInput.inputEl) == null ? void 0 : _a.focus();
      (_b = textInput == null ? void 0 : textInput.inputEl) == null ? void 0 : _b.select();
    }, 50);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/settings.ts
var import_obsidian4 = require("obsidian");

// src/Logger.ts
var import_obsidian3 = require("obsidian");
var LogLevel = /* @__PURE__ */ ((LogLevel3) => {
  LogLevel3[LogLevel3["DEBUG"] = 1] = "DEBUG";
  LogLevel3[LogLevel3["INFO"] = 2] = "INFO";
  LogLevel3[LogLevel3["WARN"] = 3] = "WARN";
  LogLevel3[LogLevel3["ERROR"] = 4] = "ERROR";
  LogLevel3[LogLevel3["TRACE"] = 6] = "TRACE";
  LogLevel3[LogLevel3["NONE"] = 5] = "NONE";
  return LogLevel3;
})(LogLevel || {});
var Logger = class {
  constructor(plugin, initialSettings) {
    this.consoleLogLevel = 2 /* INFO */;
    this.fileLogLevel = 3 /* WARN */;
    this.fileLoggingEnabled = false;
    this.logCallerInfo = false;
    this.logFileMaxSizeMB = 5;
    this.logQueue = [];
    this.isWritingToFile = false;
    this.writeDebounceTimeout = null;
    this.plugin = plugin;
    this.adapter = plugin.app.vault.adapter;
    this.logFilePath = (0, import_obsidian3.normalizePath)(initialSettings.logFilePath || `${this.plugin.manifest.dir}/ai-forge.log`);
    this.logFileMaxSizeMB = initialSettings.logFileMaxSizeMB || 5;
    this.updateSettings(initialSettings);
    if (this.fileLoggingEnabled) {
      this.rotateLogFileIfNeeded().then(() => {
      });
    } else {
    }
  }
  // --- ДОДАНО: Публічний метод для отримання шляху ---
  getLogFilePath() {
    return this.logFilePath;
  }
  // --- КІНЕЦЬ ДОДАНОГО МЕТОДУ ---
  getLogLevelName(level) {
    return LogLevel[level] || "UNKNOWN";
  }
  getLogLevelFromString(levelString, defaultLevel = 2 /* INFO */) {
    return LogLevel[levelString == null ? void 0 : levelString.toUpperCase()] || defaultLevel;
  }
  updateSettings(settings) {
    if (settings.consoleLogLevel !== void 0) {
      this.consoleLogLevel = this.getLogLevelFromString(settings.consoleLogLevel, 2 /* INFO */);
    }
    if (settings.fileLogLevel !== void 0) {
      this.fileLogLevel = this.getLogLevelFromString(settings.fileLogLevel, 3 /* WARN */);
    }
    if (settings.fileLoggingEnabled !== void 0) {
      const wasEnabled = this.fileLoggingEnabled;
      this.fileLoggingEnabled = settings.fileLoggingEnabled;
      if (!wasEnabled && this.fileLoggingEnabled) {
        this.rotateLogFileIfNeeded();
      }
    }
    if (settings.logCallerInfo !== void 0) {
      this.logCallerInfo = settings.logCallerInfo;
    }
    if (settings.logFilePath !== void 0) {
      this.logFilePath = (0, import_obsidian3.normalizePath)(settings.logFilePath || `${this.plugin.manifest.dir}/ai-forge.log`);
    }
    if (settings.logFileMaxSizeMB !== void 0) {
      this.logFileMaxSizeMB = settings.logFileMaxSizeMB || 5;
    }
  }
  getCallerInfo() {
    return "unknown";
  }
  debug(...args) {
    this.log(1 /* DEBUG */, console.debug, ...args);
  }
  info(...args) {
    this.log(2 /* INFO */, console.info, ...args);
  }
  warn(...args) {
    this.log(3 /* WARN */, console.warn, ...args);
  }
  error(...args) {
    this.log(4 /* ERROR */, console.error, ...args);
  }
  trace(...args) {
    this.log(6 /* TRACE */, console.error, ...args);
  }
  log(level, consoleMethod, ...args) {
    const caller = this.getCallerInfo();
    if (level >= this.consoleLogLevel) {
      const prefix = this.logCallerInfo && caller !== "unknown" ? `[${this.getLogLevelName(level)}] [${caller}]` : `[${this.getLogLevelName(level)}]`;
      consoleMethod(prefix, ...args);
    }
    if (this.fileLoggingEnabled && level >= this.fileLogLevel) {
      this.queueOrWriteToFile(level, caller, args);
    }
  }
  queueOrWriteToFile(level, caller, args) {
  }
  triggerWriteToFile() {
  }
  async rotateLogFileIfNeeded() {
  }
};

// src/settings.ts
var LANGUAGES = {
  af: "Afrikaans",
  sq: "Albanian",
  am: "Amharic",
  ar: "Arabic",
  hy: "Armenian",
  az: "Azerbaijani",
  eu: "Basque",
  be: "Belarusian",
  bn: "Bengali",
  bs: "Bosnian",
  bg: "Bulgarian",
  ca: "Catalan",
  ceb: "Cebuano",
  ny: "Chichewa",
  "zh-CN": "Chinese (Simplified)",
  "zh-TW": "Chinese (Traditional)",
  co: "Corsican",
  hr: "Croatian",
  cs: "Czech",
  da: "Danish",
  nl: "Dutch",
  en: "English",
  eo: "Esperanto",
  et: "Estonian",
  tl: "Filipino",
  fi: "Finnish",
  fr: "French",
  fy: "Frisian",
  gl: "Galician",
  ka: "Georgian",
  de: "German",
  el: "Greek",
  gu: "Gujarati",
  ht: "Haitian Creole",
  ha: "Hausa",
  haw: "Hawaiian",
  iw: "Hebrew",
  he: "Hebrew",
  hi: "Hindi",
  hmn: "Hmong",
  hu: "Hungarian",
  is: "Icelandic",
  ig: "Igbo",
  id: "Indonesian",
  ga: "Irish",
  it: "Italian",
  ja: "Japanese",
  jw: "Javanese",
  kn: "Kannada",
  kk: "Kazakh",
  km: "Khmer",
  rw: "Kinyarwanda",
  ko: "Korean",
  ku: "Kurdish (Kurmanji)",
  ky: "Kyrgyz",
  lo: "Lao",
  la: "Latin",
  lv: "Latvian",
  lt: "Lithuanian",
  lb: "Luxembourgish",
  mk: "Macedonian",
  mg: "Malagasy",
  ms: "Malay",
  ml: "Malayalam",
  mt: "Maltese",
  mi: "Maori",
  mr: "Marathi",
  mn: "Mongolian",
  my: "Myanmar (Burmese)",
  ne: "Nepali",
  no: "Norwegian",
  or: "Odia (Oriya)",
  ps: "Pashto",
  fa: "Persian",
  pl: "Polish",
  pt: "Portuguese",
  pa: "Punjabi",
  ro: "Romanian",
  ru: "Russian",
  sm: "Samoan",
  gd: "Scots Gaelic",
  sr: "Serbian",
  st: "Sesotho",
  sn: "Shona",
  sd: "Sindhi",
  si: "Sinhala",
  sk: "Slovak",
  sl: "Slovenian",
  so: "Somali",
  es: "Spanish",
  su: "Sundanese",
  sw: "Swahili",
  sv: "Swedish",
  tg: "Tajik",
  ta: "Tamil",
  tt: "Tatar",
  te: "Telugu",
  th: "Thai",
  tr: "Turkish",
  tk: "Turkmen",
  uk: "Ukrainian",
  ur: "Urdu",
  ug: "Uyghur",
  uz: "Uzbek",
  vi: "Vietnamese",
  cy: "Welsh",
  xh: "Xhosa",
  yi: "Yiddish",
  yo: "Yoruba",
  zu: "Zulu"
};
var DEFAULT_SETTINGS = {
  // Connection & Model
  ollamaServerUrl: "http://localhost:11434",
  modelName: "",
  temperature: 0.7,
  contextWindow: 4096,
  // Roles
  userRolesFolderPath: "ai-forge/roles",
  // Кращий шлях за замовчуванням у Vault
  selectedRolePath: "",
  followRole: true,
  // Storage & History
  saveMessageHistory: true,
  chatHistoryFolderPath: "ai-forge/chats",
  // Кращий шлях за замовчуванням у Vault
  chatExportFolderPath: "ai-forge/exports",
  // Кращий шлях за замовчуванням у Vault
  // View Behavior
  openChatInTab: false,
  maxMessageHeight: 300,
  sidebarWidth: void 0,
  // Або null. Означає, що ширина не встановлена користувачем
  // Appearance
  userAvatarType: "initials",
  userAvatarContent: "U",
  aiAvatarType: "icon",
  aiAvatarContent: "bot",
  fixBrokenEmojis: true,
  // RAG
  ragEnabled: false,
  ragFolderPath: "ai-forge/rag",
  // Кращий шлях за замовчуванням у Vault
  ragEnableSemanticSearch: true,
  ragEmbeddingModel: "nomic-embed-text",
  // Популярна модель для вбудовувань
  ragChunkSize: 512,
  ragSimilarityThreshold: 0.5,
  ragTopK: 3,
  maxCharsPerDoc: 1500,
  ragAutoIndexOnStartup: true,
  // Productivity
  enableProductivityFeatures: false,
  dailyTaskFileName: "Tasks_Today.md",
  // Advanced Context Management (Summarization)
  useAdvancedContextStrategy: false,
  enableSummarization: false,
  summarizationPrompt: "Summarize the key points discussed so far in this conversation:\n\n{text_to_summarize}",
  keepLastNMessagesBeforeSummary: 10,
  summarizationChunkSize: 1500,
  summarizationModelName: "",
  // Залишаємо порожнім, вимагає вибору
  fallbackSummarizationModelName: "gemma2:2b",
  // Приклад fallback моделі
  // Speech & Translation
  googleApiKey: "",
  // Speech-to-Text
  speechLanguage: "uk-UA",
  // Ukrainian
  enableTranslation: false,
  // Застаріле поле, буде контролюватись translationProvider
  translationTargetLanguage: "uk",
  // Ukrainian
  googleTranslationApiKey: "",
  // Google Translate
  translationProvider: "none",
  // За замовчуванням вимкнено
  ollamaTranslationModel: "",
  // Залишаємо порожнім
  // Tools/Agents
  enableToolUse: true,
  // Weather Agent Settings (ЗНАЧЕННЯ ЗА ЗАМОВЧУВАННЯМ ДЛЯ НОВИХ ПОЛІВ!)
  openWeatherMapApiKey: "YOUR_OPENWEATHERMAP_API_KEY",
  // Плейсхолдер!
  weatherDefaultLocation: "Kyiv",
  // Приклад локації за замовчуванням
  // Logger Settings
  consoleLogLevel: "INFO",
  fileLoggingEnabled: false,
  fileLogLevel: "WARN",
  logCallerInfo: false,
  logFilePath: "",
  // Logger сам підставить шлях до папки плагіна
  logFileMaxSizeMB: 5
};
var OllamaSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.debouncedUpdateChatPath = (0, import_obsidian4.debounce)(async () => {
      this.plugin.logger.debug("Debounced: Updating chat path and ensuring folder exists...");
      if (this.plugin.chatManager) {
        this.plugin.chatManager.updateChatsFolderPath();
        await this.plugin.chatManager.ensureFoldersExist();
      }
    }, 1e3, true);
    this.debouncedUpdateRolePath = (0, import_obsidian4.debounce)(async () => {
      this.plugin.logger.debug("Debounced: Refreshing role list due to path change...");
      await this.plugin.listRoleFiles(true);
      this.plugin.emit("roles-updated");
    }, 1e3, true);
    this.debouncedUpdateRagPath = (0, import_obsidian4.debounce)(async () => {
      this.plugin.logger.debug("Debounced: Re-indexing RAG due to path change...");
      if (this.plugin.settings.ragEnabled && this.plugin.ragService) {
        await this.plugin.ragService.indexDocuments();
      }
    }, 1e3, true);
  }
  // Допоміжна функція для створення заголовків секцій
  createSectionHeader(text) {
    this.containerEl.createEl("h3", { text }).addClass("ai-forge-settings-header");
  }
  // Нова допоміжна функція для створення підзаголовків груп
  createGroupHeader(text) {
    this.containerEl.createEl("h4", { text }).addClass("ai-forge-settings-group-header");
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "AI Forge Settings" });
    this.createSectionHeader("General");
    this.createGroupHeader("Connection & Model Defaults");
    new import_obsidian4.Setting(containerEl).setName("Ollama Server URL").setDesc("The URL of your running Ollama server (e.g., http://localhost:11434 or http://192.168.X.X:11434).").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.ollamaServerUrl).setValue(this.plugin.settings.ollamaServerUrl).onChange(async (value) => {
      let url = value.trim();
      if (url && !url.startsWith("http://") && !url.startsWith("https://")) {
        url = "http://" + url;
      }
      if (url.endsWith("/")) {
        url = url.slice(0, -1);
      }
      this.plugin.settings.ollamaServerUrl = url || DEFAULT_SETTINGS.ollamaServerUrl;
      await this.plugin.saveSettings();
    }));
    let modelDropdown = null;
    const updateOptions = async (dropdown, button) => {
      if (!dropdown)
        return;
      const currentVal = this.plugin.settings.modelName;
      dropdown.selectEl.innerHTML = "";
      dropdown.addOption("", "Loading models...");
      dropdown.setDisabled(true);
      button == null ? void 0 : button.setDisabled(true).setIcon("loader");
      try {
        const models = await this.plugin.ollamaService.getModels();
        dropdown.selectEl.innerHTML = "";
        dropdown.addOption("", "-- Select default model --");
        if (models && models.length > 0) {
          models.forEach((modelName) => {
            dropdown.addOption(modelName, modelName);
          });
          dropdown.setValue(models.includes(currentVal) ? currentVal : "");
        } else {
          dropdown.addOption("", "No models found");
          dropdown.setValue("");
        }
      } catch (error) {
        this.plugin.logger.error("Error fetching models for settings:", error);
        dropdown.selectEl.innerHTML = "";
        dropdown.addOption("", "Error loading models!");
        dropdown.setValue("");
      } finally {
        dropdown.setDisabled(false);
        button == null ? void 0 : button.setDisabled(false).setIcon("refresh-cw");
      }
    };
    new import_obsidian4.Setting(containerEl).setName("Default Model Name").setDesc("The default Ollama model for new chats.").addDropdown(async (dropdown) => {
      modelDropdown = dropdown;
      dropdown.onChange(async (value) => {
        this.plugin.settings.modelName = value;
        await this.plugin.saveSettings();
      });
      await updateOptions(dropdown);
    }).addExtraButton((button) => {
      button.setIcon("refresh-cw").setTooltip("Refresh model list").onClick(async () => {
        await updateOptions(modelDropdown, button);
        new import_obsidian4.Notice("Model list refreshed!");
      });
    });
    new import_obsidian4.Setting(containerEl).setName("Default Temperature").setDesc("Controls randomness (0.0 = deterministic, >1.0 = creative).").addSlider((slider) => slider.setLimits(0, 2, 0.1).setValue(this.plugin.settings.temperature).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.temperature = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Context Window Size (Tokens)").setDesc("Max tokens model considers. Requires restart/reload if changed while model is loaded.").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.contextWindow.toString()).setValue(this.plugin.settings.contextWindow.toString()).onChange(async (value) => {
      const num = parseInt(value.trim(), 10);
      this.plugin.settings.contextWindow = !isNaN(num) && num > 0 ? num : DEFAULT_SETTINGS.contextWindow;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Enable Tool Use (Experimental)").setDesc("Allow AI models to use registered tools/agents to perform actions. Requires compatible models (e.g., Llama 3.1, some Mistral models).").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableToolUse).onChange(async (value) => {
      this.plugin.settings.enableToolUse = value;
      await this.plugin.saveSettings();
    }));
    this.createGroupHeader("View Behavior");
    new import_obsidian4.Setting(containerEl).setName("Open Chat in Main Tab").setDesc("ON: Open in a main tab. OFF: Open in the right sidebar.").addToggle((toggle) => toggle.setValue(this.plugin.settings.openChatInTab).onChange(async (value) => {
      this.plugin.settings.openChatInTab = value;
      await this.plugin.saveSettings();
      new import_obsidian4.Notice("Chat view location setting saved. Re-open the view to apply.", 5e3);
    }));
    new import_obsidian4.Setting(containerEl).setName("Max Message Height (pixels)").setDesc("Collapse longer messages with 'Show More'. 0 disables.").addText((text) => text.setPlaceholder("Example: 300").setValue(this.plugin.settings.maxMessageHeight.toString()).onChange(async (value) => {
      var _a, _b;
      const num = parseInt(value.trim(), 10);
      this.plugin.settings.maxMessageHeight = !isNaN(num) && num >= 0 ? num : DEFAULT_SETTINGS.maxMessageHeight;
      await this.plugin.saveSettings();
      (_b = (_a = this.plugin.view) == null ? void 0 : _a.checkAllMessagesForCollapsing) == null ? void 0 : _b.call(_a);
    }));
    this.createGroupHeader("Appearance");
    new import_obsidian4.Setting(containerEl).setName("User Avatar Style").addDropdown((dropdown) => dropdown.addOption("initials", "Initials").addOption("icon", "Icon").addOption("image", "Image (Vault Path)").setValue(this.plugin.settings.userAvatarType).onChange(async (value) => {
      this.plugin.settings.userAvatarType = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    const userAvatarSetting = new import_obsidian4.Setting(containerEl).setDesc(" ");
    userAvatarSetting.controlEl.addClass("ai-forge-avatar-content-setting");
    if (this.plugin.settings.userAvatarType === "initials") {
      userAvatarSetting.setName("User Initials").setDesc("Max 2 chars.");
      userAvatarSetting.addText((text) => text.setValue(this.plugin.settings.userAvatarContent).onChange(async (value) => {
        this.plugin.settings.userAvatarContent = value.trim().substring(0, 2) || DEFAULT_SETTINGS.userAvatarContent;
        await this.plugin.saveSettings();
      }));
    } else if (this.plugin.settings.userAvatarType === "icon") {
      userAvatarSetting.setName("User Icon ID").setDesc('Obsidian icon ID (e.g., "user").');
      userAvatarSetting.addText((text) => text.setPlaceholder("user").setValue(this.plugin.settings.userAvatarContent).onChange(async (value) => {
        this.plugin.settings.userAvatarContent = value.trim() || "user";
        await this.plugin.saveSettings();
      }));
    } else if (this.plugin.settings.userAvatarType === "image") {
      userAvatarSetting.setName("User Avatar Image Path");
      userAvatarSetting.setDesc("Full path to the image file (png/jpeg/jpg) within your vault.");
      userAvatarSetting.addText((text) => text.setPlaceholder("e.g., Assets/Images/user.png").setValue(this.plugin.settings.userAvatarContent).onChange(async (value) => {
        const normalizedPath = (0, import_obsidian4.normalizePath)(value.trim());
        if (normalizedPath === "" || /\.(png|jpg|jpeg)$/i.test(normalizedPath)) {
          this.plugin.settings.userAvatarContent = normalizedPath;
        } else {
          new import_obsidian4.Notice("Invalid path. Please provide a path to a .png or .jpeg/jpg file, or leave empty.");
          text.setValue(this.plugin.settings.userAvatarContent);
          return;
        }
        await this.plugin.saveSettings();
      }));
    }
    new import_obsidian4.Setting(containerEl).setName("AI Avatar Style").addDropdown((dropdown) => dropdown.addOption("initials", "Initials").addOption("icon", "Icon").addOption("image", "Image (Vault Path)").setValue(this.plugin.settings.aiAvatarType).onChange(async (value) => {
      this.plugin.settings.aiAvatarType = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    const aiAvatarSetting = new import_obsidian4.Setting(containerEl).setDesc(" ");
    aiAvatarSetting.controlEl.addClass("ai-forge-avatar-content-setting");
    if (this.plugin.settings.aiAvatarType === "initials") {
      aiAvatarSetting.setName("AI Initials").setDesc("Max 2 chars.");
      aiAvatarSetting.addText((text) => text.setValue(this.plugin.settings.aiAvatarContent).onChange(async (value) => {
        this.plugin.settings.aiAvatarContent = value.trim().substring(0, 2) || DEFAULT_SETTINGS.aiAvatarContent;
        await this.plugin.saveSettings();
      }));
    } else if (this.plugin.settings.aiAvatarType === "icon") {
      aiAvatarSetting.setName("AI Icon ID").setDesc('Obsidian icon ID (e.g., "bot").');
      aiAvatarSetting.addText((text) => text.setPlaceholder("bot").setValue(this.plugin.settings.aiAvatarContent).onChange(async (value) => {
        this.plugin.settings.aiAvatarContent = value.trim() || "bot";
        await this.plugin.saveSettings();
      }));
    } else if (this.plugin.settings.aiAvatarType === "image") {
      aiAvatarSetting.setName("AI Avatar Image Path");
      aiAvatarSetting.setDesc("Full path to the image file (png/jpeg/jpg) within your vault.");
      aiAvatarSetting.addText((text) => text.setPlaceholder("e.g., Assets/Images/ai.png").setValue(this.plugin.settings.aiAvatarContent).onChange(async (value) => {
        const normalizedPath = (0, import_obsidian4.normalizePath)(value.trim());
        if (normalizedPath === "" || /\.(png|jpg|jpeg)$/i.test(normalizedPath)) {
          this.plugin.settings.aiAvatarContent = normalizedPath;
        } else {
          new import_obsidian4.Notice("Invalid path. Please provide a path to a .png or .jpeg/jpg file, or leave empty.");
          text.setValue(this.plugin.settings.aiAvatarContent);
          return;
        }
        await this.plugin.saveSettings();
      }));
    }
    new import_obsidian4.Setting(containerEl).setName("Fix Broken Emojis").setDesc("Replace certain emoji sequences that models might break (e.g., \u{1F916}).").addToggle((toggle) => toggle.setValue(this.plugin.settings.fixBrokenEmojis).onChange(async (value) => {
      this.plugin.settings.fixBrokenEmojis = value;
      await this.plugin.saveSettings();
    }));
    this.createSectionHeader("Content & Knowledge");
    this.createGroupHeader("Roles & Personas");
    new import_obsidian4.Setting(containerEl).setName("Custom Roles Folder Path").setDesc("Folder with custom role (.md) files.").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.userRolesFolderPath).setValue(this.plugin.settings.userRolesFolderPath).onChange(async (value) => {
      this.plugin.settings.userRolesFolderPath = (0, import_obsidian4.normalizePath)(value.trim()) || DEFAULT_SETTINGS.userRolesFolderPath;
      await this.plugin.saveSettings();
      this.debouncedUpdateRolePath();
    }));
    new import_obsidian4.Setting(containerEl).setName("Always Apply Selected Role").setDesc("Always use the selected role as system prompt.").addToggle((toggle) => toggle.setValue(this.plugin.settings.followRole).onChange(async (value) => {
      this.plugin.settings.followRole = value;
      await this.plugin.saveSettings();
    }));
    this.createGroupHeader("Retrieval-Augmented Generation (RAG)");
    new import_obsidian4.Setting(containerEl).setName("Enable RAG").setDesc("Allow retrieving info from notes for context.").addToggle((toggle) => toggle.setValue(this.plugin.settings.ragEnabled).onChange(async (value) => {
      this.plugin.settings.ragEnabled = value;
      await this.plugin.saveSettings();
      this.display();
      if (value)
        this.debouncedUpdateRagPath();
    }));
    if (this.plugin.settings.ragEnabled) {
      new import_obsidian4.Setting(containerEl).setName("RAG Documents Folder Path").setDesc("Folder with notes for RAG.").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.ragFolderPath).setValue(this.plugin.settings.ragFolderPath).onChange(async (value) => {
        var _a, _b, _c, _d;
        this.plugin.settings.ragFolderPath = (0, import_obsidian4.normalizePath)(value.trim()) || DEFAULT_SETTINGS.ragFolderPath;
        await this.plugin.saveSettings();
        this.debouncedUpdateRagPath();
        (_b = (_a = this.plugin).updateDailyTaskFilePath) == null ? void 0 : _b.call(_a);
        (_d = (_c = this.plugin).loadAndProcessInitialTasks) == null ? void 0 : _d.call(_c);
      }));
      new import_obsidian4.Setting(containerEl).setName("Enable Semantic Search").setDesc("Use embeddings (more accurate). If OFF, uses keyword search.").addToggle((toggle) => toggle.setValue(this.plugin.settings.ragEnableSemanticSearch).onChange(async (value) => {
        this.plugin.settings.ragEnableSemanticSearch = value;
        await this.plugin.saveSettings();
        this.display();
        this.debouncedUpdateRagPath();
      }));
      if (this.plugin.settings.ragEnableSemanticSearch) {
        let embeddingDropdown = null;
        const updateEmbeddingOptions = async (dropdown, button) => {
          if (!dropdown)
            return;
          const previousValue = this.plugin.settings.ragEmbeddingModel;
          dropdown.selectEl.innerHTML = "";
          dropdown.addOption("", "Loading models...");
          dropdown.setDisabled(true);
          button == null ? void 0 : button.setDisabled(true).setIcon("loader");
          try {
            const models = await this.plugin.ollamaService.getModels();
            dropdown.selectEl.innerHTML = "";
            dropdown.addOption("", "-- Select Embedding Model --");
            const commonEmbedModels = [
              "nomic-embed-text",
              "all-minilm",
              "mxbai-embed-large",
              "bge-base-en",
              "gte-base"
            ];
            commonEmbedModels.forEach((modelName) => dropdown.addOption(modelName, modelName));
            dropdown.addOption("---", "--- Other Installed Models ---").setDisabled(true);
            if (models && models.length > 0) {
              models.forEach((modelName) => {
                if (!commonEmbedModels.includes(modelName)) {
                  dropdown.addOption(modelName, modelName);
                }
              });
            }
            dropdown.setValue(
              models.includes(previousValue) ? previousValue : commonEmbedModels.length > 0 ? commonEmbedModels[0] : ""
            );
          } catch (error) {
            console.error("Error fetching models for embedding dropdown:", error);
            dropdown.selectEl.innerHTML = "";
            dropdown.addOption("", "Error loading models!");
            dropdown.setValue(previousValue);
          } finally {
            dropdown.setDisabled(false);
            button == null ? void 0 : button.setDisabled(false).setIcon("refresh-cw");
          }
        };
        new import_obsidian4.Setting(containerEl).setName("Embedding Model Name").setDesc("Ollama model for embeddings.").setClass("ollama-model-setting-container").addDropdown(async (dropdown) => {
          embeddingDropdown = dropdown;
          dropdown.onChange(async (value) => {
            this.plugin.settings.ragEmbeddingModel = value;
            await this.plugin.saveSettings();
            this.debouncedUpdateRagPath();
          });
          await updateEmbeddingOptions(dropdown);
        }).addExtraButton((button) => {
          button.setIcon("refresh-cw").setTooltip("Refresh model list").onClick(async () => {
            await updateEmbeddingOptions(embeddingDropdown, button);
            new import_obsidian4.Notice("Model list refreshed!");
          });
        });
        new import_obsidian4.Setting(containerEl).setName("Chunk Size (Characters)").setDesc("Size of text chunks for indexing.").addText((text) => text.setPlaceholder(String(DEFAULT_SETTINGS.ragChunkSize)).setValue(String(this.plugin.settings.ragChunkSize)).onChange(async (value) => {
          const num = parseInt(value.trim(), 10);
          this.plugin.settings.ragChunkSize = !isNaN(num) && num > 50 ? num : DEFAULT_SETTINGS.ragChunkSize;
          await this.plugin.saveSettings();
          this.debouncedUpdateRagPath();
        }));
        new import_obsidian4.Setting(containerEl).setName("Similarity Threshold").setDesc("Min relevance score (0.0-1.0). Higher = stricter matching.").addSlider((slider) => slider.setLimits(0, 1, 0.05).setValue(this.plugin.settings.ragSimilarityThreshold).setDynamicTooltip().onChange(async (value) => {
          this.plugin.settings.ragSimilarityThreshold = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian4.Setting(containerEl).setName("Top K Results").setDesc("Max number of relevant chunks to retrieve.").addText((text) => text.setPlaceholder(String(DEFAULT_SETTINGS.ragTopK)).setValue(String(this.plugin.settings.ragTopK)).onChange(async (value) => {
          const num = parseInt(value.trim(), 10);
          this.plugin.settings.ragTopK = !isNaN(num) && num > 0 ? num : DEFAULT_SETTINGS.ragTopK;
          await this.plugin.saveSettings();
        }));
      }
      new import_obsidian4.Setting(containerEl).setName("Max Chars Per Document (During Context Build)").setDesc("Limits characters included per retrieved document in the final prompt (0=no limit).").addText((text) => text.setPlaceholder(String(DEFAULT_SETTINGS.maxCharsPerDoc)).setValue(String(this.plugin.settings.maxCharsPerDoc)).onChange(async (value) => {
        const num = parseInt(value.trim(), 10);
        this.plugin.settings.maxCharsPerDoc = !isNaN(num) && num >= 0 ? num : DEFAULT_SETTINGS.maxCharsPerDoc;
        await this.plugin.saveSettings();
      }));
    }
    this.createSectionHeader("Features");
    this.createGroupHeader("Advanced Context Management (Summarization)");
    new import_obsidian4.Setting(containerEl).setName("Use Advanced Context Strategy").setDesc("Enable automatic chat summarization and message chunking for long conversations.").addToggle((toggle) => toggle.setValue(this.plugin.settings.useAdvancedContextStrategy).onChange(async (value) => {
      this.plugin.settings.useAdvancedContextStrategy = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.useAdvancedContextStrategy) {
      new import_obsidian4.Setting(containerEl).setName("Enable Context Summarization").setDesc("Automatically summarize older parts of the conversation.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableSummarization).onChange(async (value) => {
        this.plugin.settings.enableSummarization = value;
        await this.plugin.saveSettings();
        this.display();
      }));
      if (this.plugin.settings.enableSummarization) {
        new import_obsidian4.Setting(containerEl).setName("Summarization Prompt").setDesc("Prompt used for summarization. Use {text_to_summarize} placeholder.").addTextArea((text) => text.setPlaceholder(DEFAULT_SETTINGS.summarizationPrompt).setValue(this.plugin.settings.summarizationPrompt).onChange(async (value) => {
          this.plugin.settings.summarizationPrompt = value || DEFAULT_SETTINGS.summarizationPrompt;
          await this.plugin.saveSettings();
        }).inputEl.setAttrs({ rows: 4 }));
        let summarizationModelDropdown = null;
        const updateSummarizationOptions = async (dropdown, button) => {
          if (!dropdown)
            return;
          const currentVal = this.plugin.settings.summarizationModelName;
          dropdown.selectEl.innerHTML = "";
          dropdown.addOption("", "Loading models...");
          dropdown.setDisabled(true);
          button == null ? void 0 : button.setDisabled(true).setIcon("loader");
          try {
            const models = await this.plugin.ollamaService.getModels();
            dropdown.selectEl.innerHTML = "";
            dropdown.addOption("", "-- Select Summarization Model --");
            if (models && models.length > 0) {
              models.forEach((modelName) => {
                dropdown.addOption(modelName, modelName);
              });
              dropdown.setValue(models.includes(currentVal) ? currentVal : "");
            } else {
              dropdown.addOption("", "No models found");
              dropdown.setValue("");
            }
          } catch (error) {
            this.plugin.logger.error("Error fetching models for summarization settings:", error);
            dropdown.selectEl.innerHTML = "";
            dropdown.addOption("", "Error loading models!");
            dropdown.setValue("");
          } finally {
            dropdown.setDisabled(false);
            button == null ? void 0 : button.setDisabled(false).setIcon("refresh-cw");
          }
        };
        new import_obsidian4.Setting(containerEl).setName("Summarization Model").setDesc("Model used for summarizing chat history and individual messages.").addDropdown(async (dropdown) => {
          summarizationModelDropdown = dropdown;
          dropdown.onChange(async (value) => {
            this.plugin.settings.summarizationModelName = value;
            await this.plugin.saveSettings();
          });
          await updateSummarizationOptions(dropdown);
        }).addExtraButton((button) => {
          button.setIcon("refresh-cw").setTooltip("Refresh model list").onClick(async () => {
            await updateSummarizationOptions(summarizationModelDropdown, button);
            new import_obsidian4.Notice("Model list refreshed!");
          });
        });
        new import_obsidian4.Setting(containerEl).setName("Keep Last N Messages Before Summary").setDesc("Number of recent messages excluded from summarization.").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.keepLastNMessagesBeforeSummary.toString()).setValue(this.plugin.settings.keepLastNMessagesBeforeSummary.toString()).onChange(async (value) => {
          const num = parseInt(value.trim(), 10);
          this.plugin.settings.keepLastNMessagesBeforeSummary = !isNaN(num) && num >= 0 ? num : DEFAULT_SETTINGS.keepLastNMessagesBeforeSummary;
          await this.plugin.saveSettings();
        }));
        new import_obsidian4.Setting(containerEl).setName("Fallback Summarization Model").setDesc("Optional. Model to use if the primary summarization model is not set or not found. Uses the main Ollama server.").addText((text) => text.setPlaceholder("e.g., orca-mini or leave empty").setValue(this.plugin.settings.fallbackSummarizationModelName).onChange(async (value) => {
          this.plugin.settings.fallbackSummarizationModelName = value.trim();
          await this.plugin.saveSettings();
        }));
        new import_obsidian4.Setting(containerEl).setName("Summarization Chunk Size (Tokens)").setDesc("Approximate size of text chunks passed to the summarization model.").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.summarizationChunkSize.toString()).setValue(this.plugin.settings.summarizationChunkSize.toString()).onChange(async (value) => {
          const num = parseInt(value.trim(), 10);
          this.plugin.settings.summarizationChunkSize = !isNaN(num) && num > 100 ? num : DEFAULT_SETTINGS.summarizationChunkSize;
          await this.plugin.saveSettings();
        }));
      }
    }
    this.createGroupHeader("Productivity Assistant Features");
    new import_obsidian4.Setting(containerEl).setName("Enable Productivity Features").setDesc("Activate daily task integration.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableProductivityFeatures).onChange(async (value) => {
      var _a, _b, _c, _d;
      this.plugin.settings.enableProductivityFeatures = value;
      await this.plugin.saveSettings();
      this.display();
      (_b = (_a = this.plugin).updateDailyTaskFilePath) == null ? void 0 : _b.call(_a);
      (_d = (_c = this.plugin).loadAndProcessInitialTasks) == null ? void 0 : _d.call(_c);
    }));
    if (this.plugin.settings.enableProductivityFeatures) {
      new import_obsidian4.Setting(containerEl).setName("Daily Task File Name").setDesc("Filename within the RAG folder used for daily tasks.").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.dailyTaskFileName).setValue(this.plugin.settings.dailyTaskFileName).onChange(async (value) => {
        var _a, _b, _c, _d;
        this.plugin.settings.dailyTaskFileName = value.trim() || DEFAULT_SETTINGS.dailyTaskFileName;
        await this.plugin.saveSettings();
        (_b = (_a = this.plugin).updateDailyTaskFilePath) == null ? void 0 : _b.call(_a);
        (_d = (_c = this.plugin).loadAndProcessInitialTasks) == null ? void 0 : _d.call(_c);
      }));
    }
    this.createGroupHeader("Weather Agent Settings");
    new import_obsidian4.Setting(containerEl).setName("OpenWeatherMap API Key").setDesc("Your API key from OpenWeatherMap. Required for weather forecasts. Keep confidential.").addText((text) => text.setPlaceholder("YOUR_OPENWEATHERMAP_API_KEY").setValue(this.plugin.settings.openWeatherMapApiKey).onChange(async (value) => {
      this.plugin.settings.openWeatherMapApiKey = value.trim();
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Default Location").setDesc("Default city or location for weather forecasts if not specified in the query.").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.weatherDefaultLocation).setValue(this.plugin.settings.weatherDefaultLocation).onChange(async (value) => {
      this.plugin.settings.weatherDefaultLocation = value.trim();
      await this.plugin.saveSettings();
    }));
    this.createGroupHeader("Speech & Translation");
    new import_obsidian4.Setting(containerEl).setName("Translation Provider").setDesc("Select the service for message and input translation.").addDropdown((dropdown) => dropdown.addOption("none", "Disabled").addOption("google", "Google Translate API").addOption("ollama", "Ollama (Local Model)").setValue(this.plugin.settings.translationProvider).onChange(async (value) => {
      this.plugin.settings.translationProvider = value;
      this.plugin.settings.enableTranslation = value !== "none";
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.translationProvider === "google") {
      new import_obsidian4.Setting(containerEl).setName("Target Translation Language (Google)").setDesc("Translate messages/input into this language using Google.").addDropdown((dropdown) => {
        for (const code in LANGUAGES) {
          dropdown.addOption(code, LANGUAGES[code]);
        }
        dropdown.setValue(this.plugin.settings.translationTargetLanguage).onChange(async (value) => {
          this.plugin.settings.translationTargetLanguage = value;
          await this.plugin.saveSettings();
        });
      });
      new import_obsidian4.Setting(containerEl).setName("Google Cloud Translation API Key").setDesc("Required for Google translation feature. Keep confidential.").addText((text) => text.setPlaceholder("Enter API Key").setValue(this.plugin.settings.googleTranslationApiKey).onChange(async (value) => {
        this.plugin.settings.googleTranslationApiKey = value.trim();
        await this.plugin.saveSettings();
      }));
    }
    if (this.plugin.settings.translationProvider === "ollama") {
      let ollamaTranslationModelDropdown = null;
      const updateOllamaTranslationOptions = async (dropdown, button) => {
        if (!dropdown)
          return;
        const currentVal = this.plugin.settings.ollamaTranslationModel;
        dropdown.selectEl.innerHTML = "";
        dropdown.addOption("", "Loading models...");
        dropdown.setDisabled(true);
        button == null ? void 0 : button.setDisabled(true).setIcon("loader");
        try {
          const models = await this.plugin.ollamaService.getModels();
          dropdown.selectEl.innerHTML = "";
          dropdown.addOption("", "-- Select Ollama Translation Model --");
          if (models && models.length > 0) {
            models.forEach((m) => dropdown.addOption(m, m));
            dropdown.setValue(models.includes(currentVal) ? currentVal : "");
          } else {
            dropdown.addOption("", "No models found");
            dropdown.setValue("");
          }
        } catch (error) {
          this.plugin.logger.error("Error fetching models for Ollama translation settings:", error);
          dropdown.selectEl.innerHTML = "";
          dropdown.addOption("", "Error loading models!");
          dropdown.setValue("");
        } finally {
          dropdown.setDisabled(false);
          button == null ? void 0 : button.setDisabled(false).setIcon("refresh-cw");
        }
      };
      new import_obsidian4.Setting(containerEl).setName("Ollama Translation Model").setDesc("Ollama model to use for translation tasks.").addDropdown(async (dropdown) => {
        ollamaTranslationModelDropdown = dropdown;
        dropdown.onChange(async (value) => {
          this.plugin.settings.ollamaTranslationModel = value;
          await this.plugin.saveSettings();
        });
        await updateOllamaTranslationOptions(dropdown);
      }).addExtraButton((button) => {
        button.setIcon("refresh-cw").setTooltip("Refresh model list").onClick(async () => {
          await updateOllamaTranslationOptions(ollamaTranslationModelDropdown, button);
          new import_obsidian4.Notice("Model list refreshed!");
        });
      });
      new import_obsidian4.Setting(containerEl).setName("Target Translation Language (Ollama)").setDesc("Translate messages/input into this language using Ollama.").addDropdown((dropdown) => {
        for (const code in LANGUAGES) {
          dropdown.addOption(code, LANGUAGES[code]);
        }
        dropdown.setValue(this.plugin.settings.translationTargetLanguage).onChange(async (value) => {
          this.plugin.settings.translationTargetLanguage = value;
          await this.plugin.saveSettings();
        });
      });
    }
    new import_obsidian4.Setting(containerEl).setName("Google API Key (Speech-to-Text)").setDesc("Required for voice input. Keep confidential.").addText((text) => text.setPlaceholder("Enter API Key").setValue(this.plugin.settings.googleApiKey).onChange(async (value) => {
      this.plugin.settings.googleApiKey = value.trim();
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Speech Recognition Language").setDesc("Language for voice input (e.g., en-US, uk-UA).").addDropdown((dropdown) => {
      const speechLangs = {
        "uk-UA": "Ukrainian",
        "en-US": "English (US)",
        /* ... add more if needed ... */
        "en-GB": "English (UK)",
        "es-ES": "Spanish (Spain)"
        // Додайте інші мови за потреби
      };
      for (const code in speechLangs) {
        dropdown.addOption(code, speechLangs[code]);
      }
      dropdown.setValue(this.plugin.settings.speechLanguage).onChange(async (value) => {
        this.plugin.settings.speechLanguage = value;
        await this.plugin.saveSettings();
      });
    });
    this.createSectionHeader("Technical & Data");
    this.createGroupHeader("Storage & History");
    new import_obsidian4.Setting(containerEl).setName("Save Message History").setDesc("Save chat conversations to files.").addToggle((toggle) => toggle.setValue(this.plugin.settings.saveMessageHistory).onChange(async (value) => {
      this.plugin.settings.saveMessageHistory = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.saveMessageHistory) {
      new import_obsidian4.Setting(containerEl).setName("Chat History Folder Path").setDesc('Folder to store chat history (.json files). Use "/" for vault root.').addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.chatHistoryFolderPath).setValue(this.plugin.settings.chatHistoryFolderPath).onChange(async (value) => {
        this.plugin.settings.chatHistoryFolderPath = value.trim() === "/" ? "/" : (0, import_obsidian4.normalizePath)(value.trim()) || DEFAULT_SETTINGS.chatHistoryFolderPath;
        await this.plugin.saveSettings();
        this.debouncedUpdateChatPath();
      }));
    }
    new import_obsidian4.Setting(containerEl).setName("Chat Export Folder Path").setDesc("Default folder for exported Markdown chats.").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.chatExportFolderPath || "Vault Root").setValue(this.plugin.settings.chatExportFolderPath).onChange(async (value) => {
      this.plugin.settings.chatExportFolderPath = (0, import_obsidian4.normalizePath)(value.trim()) || DEFAULT_SETTINGS.chatExportFolderPath;
      await this.plugin.saveSettings();
      if (this.plugin.chatManager)
        await this.plugin.chatManager.ensureFoldersExist();
    }));
    this.createGroupHeader("Logging");
    const logLevelOptions = {};
    Object.keys(LogLevel).forEach((key) => {
      if (isNaN(Number(key))) {
        logLevelOptions[key] = key;
      }
    });
    new import_obsidian4.Setting(containerEl).setName("Console Log Level").setDesc("Minimum level for developer console.").addDropdown((dropdown) => dropdown.addOptions(logLevelOptions).setValue(this.plugin.settings.consoleLogLevel || "INFO").onChange(async (value) => {
      this.plugin.settings.consoleLogLevel = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Enable File Logging").setDesc(`Log to ${this.plugin.logger.getLogFilePath()} (for debugging).`).addToggle((toggle) => toggle.setValue(this.plugin.settings.fileLoggingEnabled).onChange(async (value) => {
      this.plugin.settings.fileLoggingEnabled = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.fileLoggingEnabled) {
      new import_obsidian4.Setting(containerEl).setName("File Log Level").setDesc("Minimum level for log file.").addDropdown((dropdown) => dropdown.addOptions(logLevelOptions).setValue(this.plugin.settings.fileLogLevel || "WARN").onChange(async (value) => {
        this.plugin.settings.fileLogLevel = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian4.Setting(containerEl).setName("Log Caller Method Name").setDesc("Include [MethodName] in logs. May slightly impact performance.").addToggle((toggle) => toggle.setValue(this.plugin.settings.logCallerInfo).onChange(async (value) => {
        this.plugin.settings.logCallerInfo = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian4.Setting(containerEl).setName("Log File Path").setDesc("Current location of the log file.").addText((text) => text.setValue(this.plugin.logger.getLogFilePath()).setDisabled(true));
      new import_obsidian4.Setting(containerEl).setName("Log File Max Size (MB)").setDesc("Maximum size of the log file before it is rotated.").addText((text) => text.setPlaceholder(String(DEFAULT_SETTINGS.logFileMaxSizeMB)).setValue(String(this.plugin.settings.logFileMaxSizeMB)).onChange(async (value) => {
        const num = parseInt(value.trim(), 10);
        this.plugin.settings.logFileMaxSizeMB = !isNaN(num) && num > 0 ? num : DEFAULT_SETTINGS.logFileMaxSizeMB;
        await this.plugin.saveSettings();
      }));
    }
  }
};

// src/SummaryModal.ts
var import_obsidian5 = require("obsidian");
var SummaryModal = class extends import_obsidian5.Modal {
  // Зберігаємо посилання для оновлення
  constructor(plugin, title, summary) {
    super(plugin.app);
    this.plugin = plugin;
    this.modalTitle = title;
    this.summaryText = summary;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h3", { text: this.modalTitle });
    this.summaryContainer = contentEl.createDiv({ cls: "summary-modal-content" });
    this.summaryContainer.setText(this.summaryText);
    this.summaryContainer.style.maxHeight = "60vh";
    this.summaryContainer.style.overflowY = "auto";
    this.summaryContainer.style.whiteSpace = "pre-wrap";
    this.summaryContainer.style.backgroundColor = "var(--background-secondary)";
    this.summaryContainer.style.padding = "10px";
    this.summaryContainer.style.borderRadius = "5px";
    this.summaryContainer.style.border = "1px solid var(--background-modifier-border)";
    this.summaryContainer.style.marginBottom = "15px";
    this.summaryContainer.style.userSelect = "text";
    const buttonContainer = new import_obsidian5.Setting(contentEl).addButton((btn) => btn.setButtonText("Copy").setTooltip("Copy summary to clipboard").setIcon("copy").onClick(() => {
      navigator.clipboard.writeText(this.summaryText).then(() => {
        new import_obsidian5.Notice("Summary copied!");
      }, (err) => {
        new import_obsidian5.Notice("Failed to copy summary.");
        this.plugin.logger.error("Copy summary error:", err);
      });
    }));
    if (this.plugin.settings.enableTranslation && this.plugin.settings.googleTranslationApiKey) {
      buttonContainer.addButton((translateBtn) => {
        translateBtn.setButtonText("Translate").setTooltip(`Translate to ${this.plugin.settings.translationTargetLanguage}`).setIcon("languages").onClick(async () => {
          const targetLang = this.plugin.settings.translationTargetLanguage;
          if (!targetLang) {
            new import_obsidian5.Notice("Target translation language not set in settings.");
            return;
          }
          translateBtn.setButtonText("Translating...");
          translateBtn.setDisabled(true);
          translateBtn.setIcon("loader");
          try {
            const translatedSummary = await this.plugin.translationService.translate(this.summaryText, targetLang);
            if (translatedSummary !== null) {
              this.summaryContainer.setText(translatedSummary);
              this.summaryText = translatedSummary;
              new import_obsidian5.Notice(`Summary translated to ${targetLang}`);
            } else {
            }
          } catch (error) {
            this.plugin.logger.error("Error translating summary in modal:", error);
            new import_obsidian5.Notice("Translation failed.");
          } finally {
            translateBtn.setButtonText("Translate");
            translateBtn.setDisabled(false);
            translateBtn.setIcon("languages");
          }
        });
      });
    }
    buttonContainer.addButton((btn) => btn.setButtonText("Close").onClick(() => {
      this.close();
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/constants.ts
var CSS_CLASSES = {
  MESSAGE_GROUP: "message-group",
  SYSTEM_GROUP: "system-message-group",
  MESSAGE: "message",
  SYSTEM_MESSAGE: "system-message",
  OLLAMA_MESSAGE: "ollama-message",
  // <-- Add/Uncomment
  CONTENT_CONTAINER: "message-content-container",
  CONTENT_COLLAPSIBLE: "message-content-collapsible",
  // <-- Add/Uncomment
  SYSTEM_ICON: "system-icon",
  SYSTEM_TEXT: "system-message-text",
  TIMESTAMP: "message-timestamp",
  DANGER_OPTION: "danger-option",
  CONTENT: "message-content",
  USER_GROUP: "user-message-group",
  // Likely needed if not already defined
  OLLAMA_GROUP: "ollama-message-group",
  // <-- Add/Uncomment
  THINKING_DOTS: "thinking-dots",
  // Needed by sendMessage placeholder
  THINKING_DOT: "thinking-dot",
  // Needed by sendMessage placeholder
  USER_MESSAGE: "user-message",
  // Likely needed if not already defined
  REGENERATE_BUTTON: "regenerate-button",
  // Likely needed
  COPY_BUTTON: "copy-button",
  // Likely needed
  DELETE_MESSAGE_BUTTON: "delete-message-button",
  // Likely needed
  MESSAGE_ARRIVING: "message-arriving",
  VISIBLE: "visible",
  DISABLED: "disabled",
  ERROR_TEXT: "error-message-text",
  // Додаємо відсутню константу
  SHOW_MORE_BUTTON: "show-more-button",
  SUBMENU_CONTENT_HIDDEN: "submenu-content-hidden",
  CODE_BLOCK_COPY_BUTTON: "code-block-copy-button",
  CODE_BLOCK_LANGUAGE: "code-block-language",
  AVATAR: "message-group-avatar",
  // Roles/Types
  USER_MESSAGE_GROUP: "user-message-group",
  ERROR_GROUP: "error-message-group",
  ERROR_MESSAGE: "error-message",
  // Content Specific
  CONTENT_COLLAPSED: "message-content-collapsed",
  ERROR_ICON: "error-icon",
  TRANSLATION_CONTAINER: "translation-container",
  TRANSLATION_CONTENT: "translation-content",
  AVATAR_USER: "user-avatar",
  AVATAR_AI: "ai-avatar",
  // Buttons & Actions
  TRANSLATE_BUTTON: "translate-button",
  SUMMARIZE_BUTTON: "summarize-button",
  STOP_BUTTON: "stop-generating-button",
  SCROLL_BOTTOM_BUTTON: "scroll-to-bottom-button",
  // States & Modifiers
  TRANSLATION_PENDING: "translation-pending",
  // For translate button maybe?
  RECORDING: "recording",
  // For voice button
  TOOL_MESSAGE: "tool-message",
  // Клас для повідомлення від інструменту
  TOOL_RESULT_HEADER: "tool-result-header",
  // Клас для заголовка результату інструменту
  TOOL_RESULT_ICON: "tool-result-icon",
  // Клас для іконки в заголовку результату
  TOOL_RESULT_CONTENT: "tool-result-content",
  // Клас для контенту результату інструменту
  TOOL_MESSAGE_GROUP: "tool-message-group",
  // Клас для обгортки групи повідомлення інструменту
  MESSAGE_WRAPPER: "message-wrapper",
  // Клас для внутрішньої обгортки повідомлення (між аватаром та вмістом)
  SYSTEM_MESSAGE_TEXT: "system-message-text",
  // <--- ДОДАЙТЕ ЦЕЙ КЛАС для тексту всередині
  MESSAGE_ACTIONS: "message-actions-wrapper",
  // <--- ДОДАЙТЕ/ПЕРЕВІРТЕ ЦЕЙ
  MESSAGE_ACTION_BUTTON: "message-action-button",
  // <--- ДОДАЙТЕ/ПЕРЕВІРТЕ ЦЕЙ
  // --- ДОДАЙТЕ АБО ПЕРЕВІРТЕ НАЯВНІСТЬ ЦИХ КЛАСІВ ДЛЯ АВАТАРІВ ---
  AVATAR_CONTAINER: "avatar-container",
  // Головний контейнер аватара
  AVATAR_USER_SPECIFIC: "user-avatar",
  // Специфічний клас для аватара користувача
  AVATAR_AI_SPECIFIC: "ai-avatar",
  // Специфічний клас для аватара AI
  AVATAR_IMAGE: "avatar-image",
  // Для <img> аватара
  AVATAR_ICON: "avatar-icon",
  // Для <span> з іконкою аватара
  AVATAR_INITIALS: "avatar-initials",
  // Для <div> з ініціалами
  THINKING_BLOCK: "thinking-block",
  THINKING_HEADER: "thinking-header",
  THINKING_TOGGLE: "thinking-toggle",
  THINKING_TITLE: "thinking-title",
  THINKING_CONTENT: "thinking-content",
  AVATAR_TOOL_SPECIFIC: "avatar-tool-specific",
  // Специфічний клас для аватара інструменту
  ASSISTANT_TOOL_USAGE_INDICATOR: "assistant-tool-usage-indicator"
  // --- ДОДАЙТЕ АБО ПЕРЕВІРТЕ НАЯВНІСТЬ ЦИХ КЛАСІВ ДЛЯ БЛОКІВ КОДУ ---
};

// src/MessageRendererUtils.ts
var import_obsidian6 = require("obsidian");
function decodeHtmlEntities(text) {
  if (typeof document === "undefined") {
    return text.replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&#39;/g, "'");
  }
  const ta = document.createElement("textarea");
  ta.innerHTML = text;
  return ta.value;
}
function detectThinkingTags(content) {
  const thinkTagRegex = /<think>[\s\S]*?<\/think>/gi;
  let contentWithoutTags = content;
  let hasThinkingTags = false;
  let previousContent;
  do {
    previousContent = contentWithoutTags;
    contentWithoutTags = contentWithoutTags.replace(thinkTagRegex, "");
    if (previousContent !== contentWithoutTags) {
      hasThinkingTags = true;
    }
  } while (previousContent !== contentWithoutTags && contentWithoutTags.includes("<think>"));
  contentWithoutTags = contentWithoutTags.trim();
  const format = /<[a-z][\s\S]*>/i.test(contentWithoutTags) ? "html" : "text";
  return {
    hasThinkingTags,
    contentWithoutTags,
    format
  };
}
async function markdownToHtml(app, view, markdown) {
  var _a, _b;
  if (!(markdown == null ? void 0 : markdown.trim()))
    return "";
  const div = document.createElement("div");
  try {
    await import_obsidian6.MarkdownRenderer.render(
      app,
      markdown,
      div,
      (_b = (_a = app.vault.getRoot()) == null ? void 0 : _a.path) != null ? _b : "",
      view
    );
  } catch (error) {
    console.error("Markdown rendering error, falling back to text:", error);
    div.textContent = markdown;
  }
  return div.innerHTML;
}
async function processThinkingTags(app, view, content) {
  const thinkTagRegex = /<think>([\s\S]*?)<\/think>/g;
  const parts = [];
  let lastIndex = 0;
  let match;
  while ((match = thinkTagRegex.exec(content)) !== null) {
    if (match.index > lastIndex) {
      const normalText = content.substring(lastIndex, match.index);
      parts.push(await markdownToHtml(app, view, normalText));
    }
    const thinkContent = match[1];
    const renderedThinkContent = await markdownToHtml(app, view, thinkContent);
    const headerHtml = `<div class="${CSS_CLASSES.THINKING_HEADER || "thinking-header"}" data-fold-state="folded"><div class="${CSS_CLASSES.THINKING_TOGGLE || "thinking-toggle"}">\u25BA</div><div class="${CSS_CLASSES.THINKING_TITLE || "thinking-title"}">Thinking</div></div>`;
    const contentHtml = `<div class="${CSS_CLASSES.THINKING_CONTENT || "thinking-content"}" style="display: none;">${renderedThinkContent}</div>`;
    parts.push(`<div class="${CSS_CLASSES.THINKING_BLOCK || "thinking-block"}">${headerHtml}${contentHtml}</div>`);
    lastIndex = thinkTagRegex.lastIndex;
  }
  if (lastIndex < content.length) {
    const remainingText = content.substring(lastIndex);
    parts.push(await markdownToHtml(app, view, remainingText));
  }
  return parts.join("");
}
function addThinkingToggleListeners(view, contentEl) {
  const headers = contentEl.querySelectorAll(`.${CSS_CLASSES.THINKING_HEADER || "thinking-header"}`);
  headers.forEach((header) => {
    if (header._listenerAttached)
      return;
    view.registerDomEvent(header, "click", () => {
      const content = header.nextElementSibling;
      const toggle = header.querySelector(`.${CSS_CLASSES.THINKING_TOGGLE || "thinking-toggle"}`);
      if (!content || !toggle)
        return;
      const isFolded = header.getAttribute("data-fold-state") === "folded";
      if (isFolded) {
        content.style.display = "block";
        toggle.textContent = "\u25BC";
        header.setAttribute("data-fold-state", "expanded");
      } else {
        content.style.display = "none";
        toggle.textContent = "\u25BA";
        header.setAttribute("data-fold-state", "folded");
      }
    });
    header._listenerAttached = true;
  });
}
function enhanceCodeBlocks(contentEl, view) {
  if (!view || !view.plugin) {
    view.plugin.logger.error("[enhanceCodeBlocks] Missing view or plugin context!");
    return;
  }
  try {
    const codeBlocks = contentEl.querySelectorAll("pre > code");
    codeBlocks.forEach((codeElement) => {
      var _a;
      const preElement = codeElement.parentElement;
      if (!preElement)
        return;
      if (preElement.querySelector(`.${CSS_CLASSES.CODE_BLOCK_COPY_BUTTON}`)) {
        return;
      }
      preElement.classList.add("enhanced");
      const copyButton = preElement.createEl("button", {
        cls: `${CSS_CLASSES.CODE_BLOCK_COPY_BUTTON} clickable-icon`,
        attr: { "aria-label": "Copy code", title: "Copy code" }
      });
      (0, import_obsidian6.setIcon)(copyButton, "copy");
      view.registerDomEvent(copyButton, "click", (event) => {
        event.stopPropagation();
        const codeToCopy = codeElement.textContent || "";
        navigator.clipboard.writeText(codeToCopy).then(() => {
          (0, import_obsidian6.setIcon)(copyButton, "check");
          setTimeout(() => (0, import_obsidian6.setIcon)(copyButton, "copy"), 2e3);
        }).catch((err) => {
          view.plugin.logger.error("Failed to copy code block:", err);
          new import_obsidian6.Notice("Failed to copy code to clipboard.");
        });
      });
      const language = (_a = Array.from(codeElement.classList).find((cls) => cls.startsWith("language-"))) == null ? void 0 : _a.replace("language-", "");
      if (language && !preElement.querySelector(`.${CSS_CLASSES.CODE_BLOCK_LANGUAGE}`)) {
        preElement.createDiv({
          cls: CSS_CLASSES.CODE_BLOCK_LANGUAGE,
          text: language
        });
      }
      preElement.style.position = "relative";
    });
  } catch (error) {
    view.plugin.logger.error("[MessageRendererUtils.enhanceCodeBlocks] Error processing code blocks:", error);
  }
}
function fixBrokenTwemojiImages(contentEl) {
  try {
    contentEl.querySelectorAll('img.emoji[alt][src*="twemoji.maxcdn.com"]').forEach((img) => {
      var _a;
      const alt = img.getAttribute("alt");
      if (alt && !img.getAttribute("data-fixed")) {
        const emojiHex = (_a = alt.codePointAt(0)) == null ? void 0 : _a.toString(16);
        if (emojiHex) {
          img.src = `https://cdn.jsdelivr.net/gh/jdecked/twemoji@latest/assets/svg/${emojiHex}.svg`;
          img.setAttribute("data-fixed", "true");
          img.onerror = () => {
            console.warn(`Failed to load emoji from jsdelivr: ${alt}`);
            if (img.parentNode) {
              img.replaceWith(document.createTextNode(alt));
            }
          };
        } else if (img.parentNode) {
          img.replaceWith(document.createTextNode(alt));
        }
      }
    });
  } catch (error) {
    console.error("[MessageRendererUtils.fixBrokenTwemojiImages] Error fixing Twemoji:", error);
  }
}
async function renderMarkdownContent(app, view, plugin, containerEl, markdownText) {
  var _a, _b;
  try {
    containerEl.empty();
    const decodedContent = decodeHtmlEntities(markdownText);
    const thinkingInfo = detectThinkingTags(decodedContent);
    if (thinkingInfo.hasThinkingTags) {
      const processedHtml = await processThinkingTags(app, view, decodedContent);
      containerEl.innerHTML = processedHtml;
      addThinkingToggleListeners(view, containerEl);
    } else {
      await import_obsidian6.MarkdownRenderer.render(app, decodedContent, containerEl, (_b = (_a = plugin.app.vault.getRoot()) == null ? void 0 : _a.path) != null ? _b : "", view);
    }
    enhanceCodeBlocks(containerEl, view);
    if (plugin.settings.fixBrokenEmojis) {
      fixBrokenTwemojiImages(containerEl);
    }
  } catch (error) {
    plugin.logger.error(
      "[MessageRendererUtils.renderMarkdownContent] Error rendering content:",
      error,
      "Content Preview:",
      markdownText.substring(0, 200)
    );
    containerEl.empty();
    containerEl.setText(`[Error rendering content. Please check console.]`);
  }
}
function renderAvatar(app, plugin, groupEl, isUser, avatarRoleType) {
  if (avatarRoleType === "tool" || avatarRoleType === "tool-usage") {
    const existingAvatar = groupEl.querySelector(`.${CSS_CLASSES.AVATAR_CONTAINER || "avatar-container"}`);
    if (existingAvatar) {
      existingAvatar.remove();
    }
    return;
  }
  const settings = plugin.settings;
  let avatarTypeToUse;
  let avatarContentToUse;
  if (isUser) {
    avatarTypeToUse = settings.userAvatarType;
    avatarContentToUse = settings.userAvatarContent;
  } else {
    switch (avatarRoleType) {
      case "system":
        avatarTypeToUse = "icon";
        avatarContentToUse = "info";
        break;
      case "error":
        avatarTypeToUse = "icon";
        avatarContentToUse = "alert-triangle";
        break;
      case "assistant":
      default:
        avatarTypeToUse = settings.aiAvatarType;
        avatarContentToUse = settings.aiAvatarContent;
        if (avatarTypeToUse === "icon" && !avatarContentToUse) {
          avatarContentToUse = "bot";
        }
        break;
    }
  }
  const mainAvatarContainerClass = CSS_CLASSES.AVATAR_CONTAINER || "avatar-container";
  let specificAvatarRoleClass = isUser ? CSS_CLASSES.AVATAR_USER_SPECIFIC || "user-avatar" : CSS_CLASSES.AVATAR_AI_SPECIFIC || "ai-avatar";
  if (!isUser && avatarRoleType === "tool") {
    specificAvatarRoleClass = `${specificAvatarRoleClass} ${CSS_CLASSES.AVATAR_TOOL_SPECIFIC || "avatar-tool-specific"}`;
  }
  let avatarEl = groupEl.querySelector(`.${mainAvatarContainerClass.split(" ")[0]}`);
  if (!avatarEl) {
    avatarEl = groupEl.createDiv({ cls: [mainAvatarContainerClass, specificAvatarRoleClass].join(" ") });
  } else {
    avatarEl.className = "";
    avatarEl.classList.add(...mainAvatarContainerClass.split(" "), ...specificAvatarRoleClass.split(" "));
  }
  avatarEl.empty();
  try {
    if (avatarTypeToUse === "image" && avatarContentToUse) {
      const imagePath = (0, import_obsidian6.normalizePath)(avatarContentToUse);
      const imageFile = app.vault.getAbstractFileByPath(imagePath);
      if (imageFile instanceof import_obsidian6.TFile) {
        const imageUrl = app.vault.getResourcePath(imageFile);
        avatarEl.createEl("img", {
          attr: { src: imageUrl, alt: isUser ? "User Avatar" : (avatarRoleType || "AI") + " Avatar" },
          cls: CSS_CLASSES.AVATAR_IMAGE || "avatar-image"
        });
        avatarEl.title = `Avatar from: ${imagePath}`;
      } else {
        plugin.logger.warn(`Avatar image file not found or not a TFile: ${imagePath}. Using fallback.`);
        throw new Error("Invalid image path or not a file.");
      }
    } else if (avatarTypeToUse === "icon" && avatarContentToUse) {
      (0, import_obsidian6.setIcon)(avatarEl.createSpan({ cls: CSS_CLASSES.AVATAR_ICON || "avatar-icon" }), avatarContentToUse);
      avatarEl.title = `Icon: ${avatarContentToUse}`;
    } else {
      let initials = avatarContentToUse == null ? void 0 : avatarContentToUse.substring(0, 2).toUpperCase();
      if (!initials) {
        if (isUser) {
          initials = "U";
        } else {
          initials = avatarRoleType ? avatarRoleType.substring(0, 1).toUpperCase() : "AI";
          if (initials.length > 2)
            initials = initials.substring(0, 2);
          if (!initials)
            initials = "AI";
        }
      }
      avatarEl.createDiv({ cls: CSS_CLASSES.AVATAR_INITIALS || "avatar-initials", text: initials });
      avatarEl.title = `Initials: ${initials}`;
    }
  } catch (e) {
    plugin.logger.warn(`Failed to render avatar (type: ${avatarTypeToUse}, content: ${avatarContentToUse}, roleType: ${avatarRoleType}):`, e.message);
    const fallbackIconName = avatarRoleType === "tool" ? "settings" : isUser ? "user-circle" : "bot";
    avatarEl.empty();
    (0, import_obsidian6.setIcon)(avatarEl.createSpan({ cls: CSS_CLASSES.AVATAR_ICON || "avatar-icon" }), fallbackIconName);
    avatarEl.title = `Fallback Avatar (Icon: ${fallbackIconName})`;
  }
}

// src/renderers/BaseMessageRenderer.ts
var import_obsidian7 = require("obsidian");
var BaseMessageRenderer = class {
  constructor(app, plugin, message, view) {
    this.app = app;
    this.plugin = plugin;
    this.message = message;
    this.view = view;
  }
  createMessageGroupWrapper(groupClasses = []) {
    const messageGroup = document.createElement("div");
    messageGroup.classList.add(CSS_CLASSES.MESSAGE_GROUP, ...groupClasses);
    messageGroup.setAttribute("data-timestamp", this.message.timestamp.getTime().toString());
    return messageGroup;
  }
  // --- ЗРОБЛЕНО СТАТИЧНИМ ---
  /**
   * Створює та додає елемент мітки часу до вказаного батьківського елемента.
   * @param parentElement - Елемент, куди додати мітку часу.
   * @param timestamp - Об'єкт Date для форматування.
   * @param view - Екземпляр OllamaView для доступу до форматера.
   */
  static addTimestamp(parentElement, timestamp, view) {
    if (parentElement.querySelector(`.${CSS_CLASSES.TIMESTAMP}`)) {
      return;
    }
    parentElement.createDiv({
      cls: CSS_CLASSES.TIMESTAMP,
      text: view.formatTime(timestamp)
      // Використовуємо view для форматування
    });
  }
  // --- КІНЕЦЬ ЗМІНИ ---
  addAvatar(messageGroup, isUser) {
    renderAvatar(this.app, this.plugin, messageGroup, isUser);
  }
  // addBaseActionButtons залишається методом екземпляра, бо залежить від this.message та this.view
  addBaseActionButtons(messageWrapper, contentToCopy) {
    const buttonsWrapper = messageWrapper.createDiv({ cls: "message-actions-wrapper" });
    const copyBtn = buttonsWrapper.createEl("button", { cls: CSS_CLASSES.COPY_BUTTON, attr: { "aria-label": "Copy", title: "Copy" } });
    (0, import_obsidian7.setIcon)(copyBtn, "copy");
    this.view.registerDomEvent(copyBtn, "click", (e) => {
      e.stopPropagation();
      this.view.handleCopyClick(contentToCopy, copyBtn);
    });
    const deleteBtn = buttonsWrapper.createEl("button", { cls: [CSS_CLASSES.DELETE_MESSAGE_BUTTON, CSS_CLASSES.DANGER_OPTION], attr: { "aria-label": "Delete message", title: "Delete Message" } });
    (0, import_obsidian7.setIcon)(deleteBtn, "trash");
    this.view.registerDomEvent(deleteBtn, "click", (e) => {
      e.stopPropagation();
      this.view.handleDeleteMessageClick(this.message);
    });
  }
  createMessageBubble(messageWrapper, messageClasses = []) {
    const messageEl = messageWrapper.createDiv({ cls: [CSS_CLASSES.MESSAGE, ...messageClasses] });
    const contentContainer = messageEl.createDiv({ cls: CSS_CLASSES.CONTENT_CONTAINER });
    const contentEl = contentContainer.createDiv({ cls: CSS_CLASSES.CONTENT });
    return { messageEl, contentContainer, contentEl };
  }
};

// src/renderers/UserMessageRenderer.ts
var import_obsidian8 = require("obsidian");
var CSS_CLASS_USER_GROUP = "user-message-group";
var CSS_CLASS_USER_MESSAGE = "user-message";
var CSS_CLASS_REGENERATE_BUTTON = "regenerate-button";
var UserMessageRenderer = class extends BaseMessageRenderer {
  constructor(app, plugin, message, view) {
    super(app, plugin, message, view);
    if (message.role !== "user") {
      throw new Error("UserMessageRenderer can only render messages with role 'user'.");
    }
  }
  render() {
    const messageGroup = this.createMessageGroupWrapper([CSS_CLASS_USER_GROUP]);
    this.addAvatar(messageGroup, true);
    const messageWrapper = messageGroup.createDiv({ cls: "message-wrapper" });
    messageWrapper.style.order = "1";
    const { messageEl, contentEl } = this.createMessageBubble(messageWrapper, [CSS_CLASS_USER_MESSAGE]);
    this.message.content.split("\n").forEach((line, i, arr) => {
      contentEl.appendText(line);
      if (i < arr.length - 1)
        contentEl.createEl("br");
    });
    this.addUserActionButtons(messageWrapper);
    BaseMessageRenderer.addTimestamp(messageEl, this.message.timestamp, this.view);
    return messageGroup;
  }
  /**
   * Додає кнопки дій, специфічні для повідомлення користувача (Regenerate, Copy, Delete).
   * @param messageWrapper - Обгортка повідомлення (div.message-wrapper).
   */
  addUserActionButtons(messageWrapper) {
    const buttonsWrapper = messageWrapper.createDiv({ cls: "message-actions-wrapper" });
    const finalContent = this.message.content;
    const regenerateBtn = buttonsWrapper.createEl("button", {
      cls: CSS_CLASS_REGENERATE_BUTTON,
      attr: { title: "Regenerate response" }
    });
    (0, import_obsidian8.setIcon)(regenerateBtn, "refresh-cw");
    this.view.registerDomEvent(regenerateBtn, "click", (e) => {
      e.stopPropagation();
      this.view.handleRegenerateClick(this.message);
    });
    const copyBtn = buttonsWrapper.createEl("button", {
      cls: CSS_CLASSES.COPY_BUTTON,
      // Використовуємо константу
      attr: { "aria-label": "Copy", title: "Copy" }
    });
    (0, import_obsidian8.setIcon)(copyBtn, "copy");
    this.view.registerDomEvent(copyBtn, "click", (e) => {
      e.stopPropagation();
      this.view.handleCopyClick(finalContent, copyBtn);
    });
    const deleteBtn = buttonsWrapper.createEl("button", {
      cls: [CSS_CLASSES.DELETE_MESSAGE_BUTTON, CSS_CLASSES.DANGER_OPTION],
      // Використовуємо константи
      attr: { "aria-label": "Delete message", title: "Delete Message" }
    });
    (0, import_obsidian8.setIcon)(deleteBtn, "trash");
    this.view.registerDomEvent(deleteBtn, "click", (e) => {
      e.stopPropagation();
      this.view.handleDeleteMessageClick(this.message);
    });
  }
};

// src/renderers/AssistantMessageRenderer.ts
var import_obsidian9 = require("obsidian");

// src/utils/toolParser.ts
function parseAllTextualToolCalls(text, logger) {
  const calls = [];
  if (!text || typeof text !== "string") {
    return calls;
  }
  const openTag = "<tool_call>";
  const closeTag = "</tool_call>";
  let currentIndex = 0;
  while (currentIndex < text.length) {
    const openTagIndex = text.indexOf(openTag, currentIndex);
    if (openTagIndex === -1) {
      break;
    }
    const closeTagIndex = text.indexOf(closeTag, openTagIndex + openTag.length);
    if (closeTagIndex === -1) {
      break;
    }
    const jsonString = text.substring(openTagIndex + openTag.length, closeTagIndex).trim();
    if (!jsonString) {
      currentIndex = closeTagIndex + closeTag.length;
      continue;
    }
    try {
      const parsedJson = JSON.parse(jsonString);
      if (parsedJson && typeof parsedJson.name === "string" && (typeof parsedJson.arguments === "object" || parsedJson.arguments === void 0 || parsedJson.arguments === null)) {
        calls.push({ name: parsedJson.name, arguments: parsedJson.arguments || {} });
      } else {
        logger.error("[toolParser] Parsed JSON does not match expected structure (name: string, arguments: object/undefined/null).", { jsonString, parsedJson });
      }
    } catch (e) {
      logger.error(`[toolParser] Failed to parse JSON from tool_call content. JSON string was: "${jsonString}". Error: ${e.message}`);
    }
    currentIndex = closeTagIndex + closeTag.length;
  }
  if (calls.length > 0) {
  } else if (text.includes(openTag)) {
  }
  return calls;
}

// src/renderers/AssistantMessageRenderer.ts
var AssistantMessageRenderer = class extends BaseMessageRenderer {
  constructor(app, plugin, message, view) {
    super(app, plugin, message, view);
    if (message.role !== "assistant") {
      throw new Error("AssistantMessageRenderer can only render messages with role 'assistant'.");
    }
  }
  static prepareDisplayContent(originalContent, assistantMessage, plugin, view) {
    const messageTimestampLog = assistantMessage.timestamp.getTime();
    let toolUsagePrefix = "\u2192 ";
    let toolMessageAction = "";
    const logger = plugin.logger;
    const ts = assistantMessage.timestamp.getTime();
    const decodedContent = decodeHtmlEntities(originalContent);
    const thinkDetection = detectThinkingTags(decodedContent);
    let contentAfterThinkStripping = thinkDetection.contentWithoutTags;
    const hasNativeToolCalls = !!(assistantMessage.tool_calls && assistantMessage.tool_calls.length > 0);
    const hasTextualToolCallTagsInProcessedContent = contentAfterThinkStripping.includes("<tool_call>");
    let finalDisplayContent = contentAfterThinkStripping;
    if (plugin.settings.enableToolUse && (hasNativeToolCalls || hasTextualToolCallTagsInProcessedContent)) {
      let toolUsageIndicatorActionText = "";
      const toolNamesExtracted = [];
      let accompanyingText = contentAfterThinkStripping;
      if (hasNativeToolCalls && assistantMessage.tool_calls) {
        assistantMessage.tool_calls.forEach((tc) => toolNamesExtracted.push(tc.function.name));
      } else if (hasTextualToolCallTagsInProcessedContent) {
        const parsedTextualCalls = parseAllTextualToolCalls(contentAfterThinkStripping, logger);
        parsedTextualCalls.forEach((ptc) => toolNamesExtracted.push(ptc.name));
        accompanyingText = contentAfterThinkStripping.replace(/<tool_call>[\s\S]*?<\/tool_call>/g, "").trim();
        if (toolNamesExtracted.length === 0 && (accompanyingText.includes("<tool_call>") || accompanyingText.includes("</tool_call>"))) {
          let tempText = accompanyingText;
          tempText = tempText.replace(/<tool_call>/g, "").replace(/<\/tool_call>/g, "").trim();
          accompanyingText = tempText;
        }
      }
      if (toolNamesExtracted.length > 0) {
        toolUsageIndicatorActionText = `Using tool${toolNamesExtracted.length > 1 ? "s" : ""}: ${toolNamesExtracted.join(", ")}...`;
      } else {
        toolUsageIndicatorActionText = "Attempting to use tool(s)...";
      }
      const toolUsageIndicatorHTML = `<span class="${CSS_CLASSES.ASSISTANT_TOOL_USAGE_INDICATOR || "assistant-tool-usage-indicator"}">\u2192 ${toolUsageIndicatorActionText}</span>`;
      if (accompanyingText && accompanyingText.trim().length > 0) {
        finalDisplayContent = `${toolUsageIndicatorHTML}

${accompanyingText.trim()}`;
      } else {
        finalDisplayContent = toolUsageIndicatorHTML;
      }
    }
    return finalDisplayContent;
  }
  async render() {
    const messageTimestampLog = this.message.timestamp.getTime();
    const messageGroup = this.createMessageGroupWrapper([CSS_CLASSES.OLLAMA_GROUP || "ollama-message-group"]);
    renderAvatar(this.app, this.plugin, messageGroup, false, "assistant");
    const messageWrapper = messageGroup.createDiv({ cls: CSS_CLASSES.MESSAGE_WRAPPER || "message-wrapper" });
    messageWrapper.style.order = "2";
    const { messageEl, contentEl } = this.createMessageBubble(messageWrapper, [
      CSS_CLASSES.OLLAMA_MESSAGE || "ollama-message"
    ]);
    contentEl.addClass(CSS_CLASSES.CONTENT_COLLAPSIBLE || "message-content-collapsible");
    const assistantMessage = this.message;
    const displayContent = AssistantMessageRenderer.prepareDisplayContent(
      this.message.content || "",
      assistantMessage,
      this.plugin,
      this.view
    );
    try {
      await renderMarkdownContent(this.app, this.view, this.plugin, contentEl, displayContent);
    } catch (error) {
      contentEl.setText(
        `[Error rendering assistant content: ${error instanceof Error ? error.message : String(error)}]`
      );
    }
    AssistantMessageRenderer.addAssistantActionButtons(messageEl, contentEl, assistantMessage, this.plugin, this.view);
    BaseMessageRenderer.addTimestamp(messageEl, this.message.timestamp, this.view);
    setTimeout(() => {
      if (messageEl.isConnected && contentEl.closest(`.${CSS_CLASSES.MESSAGE_GROUP || "message-group"}`)) {
        this.view.checkMessageForCollapsing(messageEl);
      }
    }, 70);
    return messageGroup;
  }
  static addAssistantActionButtons(messageElement, contentEl, message, plugin, view) {
    if (messageElement.querySelector(`.${CSS_CLASSES.MESSAGE_ACTIONS}`)) {
      return;
    }
    const buttonsWrapper = messageElement.createDiv({ cls: CSS_CLASSES.MESSAGE_ACTIONS });
    const originalLlMRawContent = message.content || "";
    const copyBtn = buttonsWrapper.createEl("button", {
      cls: [CSS_CLASSES.COPY_BUTTON || "copy-button", CSS_CLASSES.MESSAGE_ACTION_BUTTON || "message-action-button"],
      attr: { "aria-label": "Copy", title: "Copy" }
    });
    (0, import_obsidian9.setIcon)(copyBtn, "copy");
    view.registerDomEvent(copyBtn, "click", (e) => {
      e.stopPropagation();
      view.handleCopyClick(originalLlMRawContent, copyBtn);
    });
    if (plugin.settings.enableTranslation && (plugin.settings.translationProvider === "google" && plugin.settings.googleTranslationApiKey || plugin.settings.translationProvider === "ollama" && plugin.settings.ollamaTranslationModel) && originalLlMRawContent && originalLlMRawContent.trim()) {
      const translateBtn = buttonsWrapper.createEl("button", {
        cls: [
          CSS_CLASSES.TRANSLATE_BUTTON || "translate-button",
          CSS_CLASSES.MESSAGE_ACTION_BUTTON || "message-action-button"
        ],
        attr: { "aria-label": "Translate", title: "Translate" }
      });
      (0, import_obsidian9.setIcon)(translateBtn, "languages");
      view.registerDomEvent(translateBtn, "click", (e) => {
        e.stopPropagation();
        if (contentEl.isConnected) {
          view.handleTranslateClick(originalLlMRawContent, contentEl, translateBtn);
        } else {
          new import_obsidian9.Notice("Cannot translate: message content element not found.");
        }
      });
    }
    if (plugin.settings.enableSummarization && plugin.settings.summarizationModelName && originalLlMRawContent && originalLlMRawContent.trim()) {
      const summarizeBtn = buttonsWrapper.createEl("button", {
        cls: [
          CSS_CLASSES.SUMMARIZE_BUTTON || "summarize-button",
          CSS_CLASSES.MESSAGE_ACTION_BUTTON || "message-action-button"
        ],
        attr: { title: "Summarize message" }
      });
      (0, import_obsidian9.setIcon)(summarizeBtn, "scroll-text");
      view.registerDomEvent(summarizeBtn, "click", (e) => {
        e.stopPropagation();
        view.handleSummarizeClick(originalLlMRawContent, summarizeBtn);
      });
    }
    const originalContentContainsTextualToolCall = typeof originalLlMRawContent === "string" && originalLlMRawContent.includes("<tool_call>");
    if ((!message.tool_calls || message.tool_calls.length === 0) && !originalContentContainsTextualToolCall) {
      const regenerateBtn = buttonsWrapper.createEl("button", {
        cls: [
          CSS_CLASSES.REGENERATE_BUTTON || "regenerate-button",
          CSS_CLASSES.MESSAGE_ACTION_BUTTON || "message-action-button"
        ],
        attr: { "aria-label": "Regenerate response", title: "Regenerate Response" }
      });
      (0, import_obsidian9.setIcon)(regenerateBtn, "refresh-cw");
      view.registerDomEvent(regenerateBtn, "click", (e) => {
        e.stopPropagation();
        view.handleRegenerateClick(message);
      });
    }
    const deleteBtn = buttonsWrapper.createEl("button", {
      cls: [
        CSS_CLASSES.DELETE_MESSAGE_BUTTON || "delete-message-button",
        CSS_CLASSES.DANGER_OPTION || "danger-option",
        CSS_CLASSES.MESSAGE_ACTION_BUTTON || "message-action-button"
      ],
      attr: { "aria-label": "Delete message", title: "Delete Message" }
    });
    (0, import_obsidian9.setIcon)(deleteBtn, "trash");
    view.registerDomEvent(deleteBtn, "click", (e) => {
      e.stopPropagation();
      view.handleDeleteMessageClick(message);
    });
  }
};

// src/renderers/SystemMessageRenderer.ts
var import_obsidian10 = require("obsidian");
var SystemMessageRenderer = class extends BaseMessageRenderer {
  // Оновлений конструктор
  constructor(app, plugin, message, view) {
    super(app, plugin, message, view);
    if (message.role !== "system") {
      throw new Error("SystemMessageRenderer can only render messages with role 'system'.");
    }
  }
  /**
   * Визначає іконку на основі необов'язкової властивості 'type' у повідомленні.
   * За замовчуванням використовує 'info', якщо тип відсутній або не розпізнано.
   */
  getIconType() {
    const messageType = this.message.type;
    switch (messageType) {
      case "warning":
        return "alert-triangle";
      case "error":
        return "alert-circle";
      case "info":
      default:
        return "info";
    }
  }
  /**
   * Рендерить елемент групи системного повідомлення.
   */
  render() {
    const messageGroup = this.createMessageGroupWrapper([CSS_CLASSES.SYSTEM_GROUP]);
    const messageWrapper = messageGroup.createDiv({ cls: "message-wrapper" });
    const messageEl = messageWrapper.createDiv({ cls: `${CSS_CLASSES.MESSAGE} ${CSS_CLASSES.SYSTEM_MESSAGE}` });
    const contentContainer = messageEl.createDiv({ cls: CSS_CLASSES.CONTENT_CONTAINER });
    const iconSpan = contentContainer.createSpan({ cls: CSS_CLASSES.SYSTEM_ICON });
    (0, import_obsidian10.setIcon)(iconSpan, this.getIconType());
    contentContainer.createSpan({
      cls: CSS_CLASSES.SYSTEM_TEXT,
      text: this.message.content
      // Беремо контент з protected властивості базового класу
    });
    BaseMessageRenderer.addTimestamp(messageEl, this.message.timestamp, this.view);
    return messageGroup;
  }
};

// src/renderers/ErrorMessageRenderer.ts
var import_obsidian11 = require("obsidian");
var CSS_CLASS_ERROR_GROUP = "error-message-group";
var CSS_CLASS_ERROR_MESSAGE = "error-message";
var CSS_CLASS_ERROR_ICON = "error-icon";
var CSS_CLASS_ERROR_TEXT = "error-message-text";
var ErrorMessageRenderer = class extends BaseMessageRenderer {
  constructor(app, plugin, message, view) {
    super(app, plugin, message, view);
    if (message.role !== "error") {
      throw new Error("ErrorMessageRenderer can only render messages with role 'error'.");
    }
  }
  /**
   * Рендерить ОДНУ групу повідомлення про помилку.
   * Логіка групування та сумаризації керується ззовні (наприклад, OllamaView).
   */
  render() {
    const messageGroup = this.createMessageGroupWrapper([CSS_CLASS_ERROR_GROUP]);
    const messageWrapper = messageGroup.createDiv({ cls: "message-wrapper" });
    const { messageEl, contentContainer, contentEl } = this.createMessageBubble(messageWrapper, [CSS_CLASS_ERROR_MESSAGE]);
    contentEl.addClass(CSS_CLASS_ERROR_TEXT);
    (0, import_obsidian11.setIcon)(contentContainer.createSpan({ cls: CSS_CLASS_ERROR_ICON, prepend: true }), "alert-triangle");
    contentEl.setText(this.message.content);
    BaseMessageRenderer.addTimestamp(messageEl, this.message.timestamp, this.view);
    this.addErrorActionButtons(messageWrapper);
    return messageGroup;
  }
  /**
   * Додає кнопки дій, специфічні для повідомлення про помилку (наприклад, тільки Copy і Delete).
   * @param messageWrapper - Обгортка повідомлення (div.message-wrapper).
   */
  addErrorActionButtons(messageWrapper) {
    const buttonsWrapper = messageWrapper.createDiv({ cls: "message-actions-wrapper" });
    const finalContent = this.message.content;
    const copyBtn = buttonsWrapper.createEl("button", {
      cls: CSS_CLASSES.COPY_BUTTON,
      attr: { "aria-label": "Copy Error", title: "Copy Error" }
    });
    (0, import_obsidian11.setIcon)(copyBtn, "copy");
    this.view.registerDomEvent(copyBtn, "click", (e) => {
      e.stopPropagation();
      this.view.handleCopyClick(finalContent, copyBtn);
    });
    const deleteBtn = buttonsWrapper.createEl("button", {
      cls: [CSS_CLASSES.DELETE_MESSAGE_BUTTON, CSS_CLASSES.DANGER_OPTION],
      attr: { "aria-label": "Delete message", title: "Delete Message" }
    });
    (0, import_obsidian11.setIcon)(deleteBtn, "trash");
    this.view.registerDomEvent(deleteBtn, "click", (e) => {
      e.stopPropagation();
      this.view.handleDeleteMessageClick(this.message);
    });
  }
};

// src/SidebarManager.ts
var import_obsidian12 = require("obsidian");
var CSS_SIDEBAR_CONTAINER = "ollama-sidebar-container";
var CSS_ROLE_PANEL = "ollama-role-panel";
var CSS_CHAT_PANEL = "ollama-chat-panel";
var CSS_ROLE_PANEL_LIST = "ollama-role-panel-list";
var CSS_ROLE_PANEL_ITEM = "ollama-role-panel-item";
var CSS_ROLE_PANEL_ITEM_ICON = "ollama-role-panel-item-icon";
var CSS_ROLE_PANEL_ITEM_TEXT = "ollama-role-panel-item-text";
var CSS_ROLE_PANEL_ITEM_ACTIVE = "is-active";
var CSS_ROLE_PANEL_ITEM_CUSTOM = "is-custom";
var CSS_ROLE_PANEL_ITEM_NONE = "ollama-role-panel-item-none";
var CSS_CLASS_MENU_OPTION = "menu-option";
var CSS_SIDEBAR_SECTION_HEADER = "ollama-sidebar-section-header";
var CSS_SIDEBAR_SECTION_CONTENT = "ollama-sidebar-section-content";
var CSS_SECTION_TOGGLE_CHEVRON = "ollama-section-toggle-chevron";
var CSS_SIDEBAR_HEADER_ACTIONS = "ollama-sidebar-header-actions";
var CSS_SIDEBAR_HEADER_BUTTON = "ollama-sidebar-header-button";
var CSS_SIDEBAR_HEADER_LEFT = "ollama-sidebar-header-left";
var CSS_SIDEBAR_SECTION_CONTENT_HIDDEN = "ollama-sidebar-section-content-hidden";
var CSS_EXPANDED_CLASS = "is-expanded";
var CSS_CHAT_LIST_CONTAINER = "ollama-chat-list-container";
var CSS_HIERARCHY_ITEM = "ollama-hierarchy-item";
var CSS_FOLDER_ITEM = "ollama-folder-item";
var CSS_CHAT_ITEM = "ollama-chat-item";
var CSS_HIERARCHY_ITEM_CONTENT = "ollama-hierarchy-item-content";
var CSS_HIERARCHY_ITEM_CHILDREN = "ollama-hierarchy-item-children";
var CSS_HIERARCHY_ITEM_COLLAPSED = "is-collapsed";
var CSS_FOLDER_ICON = "ollama-folder-icon";
var CSS_HIERARCHY_ITEM_TEXT = "ollama-hierarchy-item-text";
var CSS_CHAT_ITEM_DETAILS = "ollama-chat-item-details";
var CSS_CHAT_ITEM_DATE = "ollama-chat-item-date";
var CSS_HIERARCHY_ITEM_OPTIONS = "ollama-hierarchy-item-options";
var CSS_HIERARCHY_INDENT_PREFIX = "ollama-indent-level-";
var CSS_FOLDER_ACTIVE_ANCESTOR = "is-active-ancestor";
var COLLAPSE_ICON_ACCORDION = "lucide-chevron-right";
var EXPAND_ICON_ACCORDION = "lucide-chevron-down";
var FOLDER_ICON_CLOSED = "lucide-folder";
var FOLDER_ICON_OPEN = "lucide-folder-open";
var CHAT_ICON = "lucide-message-square";
var CHAT_ICON_ACTIVE = "lucide-check";
var CSS_SIDEBAR_SECTION_ICON = "ollama-sidebar-section-icon";
var CHATS_SECTION_ICON = "lucide-messages-square";
var ROLES_SECTION_ICON = "lucide-users";
var SidebarManager = class {
  constructor(plugin, app, view) {
    this.draggedItemData = null;
    this.folderExpansionState = /* @__PURE__ */ new Map();
    this.updateCounter = 0;
    this.updateChatList = async () => {
      this.updateCounter++;
      const currentUpdateId = this.updateCounter;
      const container = this.chatPanelListContainerEl;
      if (!container || !this.plugin.chatManager) {
        return;
      }
      container.classList.add("is-loading");
      const currentScrollTop = container.scrollTop;
      container.empty();
      try {
        const hierarchy = await this.plugin.chatManager.getChatHierarchy();
        const currentActiveChatId = this.plugin.chatManager.getActiveChatId();
        const activeAncestorPaths = /* @__PURE__ */ new Set();
        if (currentActiveChatId) {
          const activeChat = await this.plugin.chatManager.getActiveChat();
          if (activeChat == null ? void 0 : activeChat.filePath) {
            let currentPath = activeChat.filePath;
            while (currentPath.includes("/")) {
              const parentPath = currentPath.substring(0, currentPath.lastIndexOf("/"));
              if (parentPath === "") {
                break;
              } else {
                const normalizedParentPath = (0, import_obsidian12.normalizePath)(parentPath);
                activeAncestorPaths.add(normalizedParentPath);
                currentPath = parentPath;
              }
            }
          } else if (activeChat) {
          }
        }
        if (hierarchy.length === 0) {
          container.createDiv({ cls: "menu-info-text", text: "No saved chats or folders yet." });
        } else {
          hierarchy.forEach(
            (node) => this.renderHierarchyNode(node, container, 0, currentActiveChatId, activeAncestorPaths, currentUpdateId)
          );
        }
      } catch (error) {
        container.empty();
        container.createDiv({ text: "Error loading chat structure.", cls: "menu-error-text" });
      } finally {
        container.classList.remove("is-loading");
        requestAnimationFrame(() => {
          if (container == null ? void 0 : container.isConnected) {
            container.scrollTop = currentScrollTop;
          }
        });
      }
    };
    this.updateRoleList = async () => {
      var _a, _b;
      const container = this.rolePanelListEl;
      if (!container || !this.plugin.chatManager) {
        return;
      }
      const currentScrollTop = container.scrollTop;
      container.empty();
      try {
        const roles = await this.plugin.listRoleFiles(true);
        const activeChat = await this.plugin.chatManager.getActiveChat();
        const currentRolePath = (_b = (_a = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _a.selectedRolePath) != null ? _b : this.plugin.settings.selectedRolePath;
        const noneOptionEl = container.createDiv({
          cls: [CSS_ROLE_PANEL_ITEM, CSS_ROLE_PANEL_ITEM_NONE, CSS_CLASS_MENU_OPTION]
        });
        const noneIconSpan = noneOptionEl.createSpan({ cls: [CSS_ROLE_PANEL_ITEM_ICON, "menu-option-icon"] });
        noneOptionEl.createSpan({ cls: [CSS_ROLE_PANEL_ITEM_TEXT, "menu-option-text"], text: "None" });
        (0, import_obsidian12.setIcon)(noneIconSpan, !currentRolePath ? "check" : "slash");
        if (!currentRolePath)
          noneOptionEl.addClass(CSS_ROLE_PANEL_ITEM_ACTIVE);
        this.view.registerDomEvent(noneOptionEl, "click", () => this.handleRolePanelItemClick(null, currentRolePath));
        roles.forEach((roleInfo) => {
          const roleOptionEl = container.createDiv({ cls: [CSS_ROLE_PANEL_ITEM, CSS_CLASS_MENU_OPTION] });
          const iconSpan = roleOptionEl.createSpan({ cls: [CSS_ROLE_PANEL_ITEM_ICON, "menu-option-icon"] });
          roleOptionEl.createSpan({ cls: [CSS_ROLE_PANEL_ITEM_TEXT, "menu-option-text"], text: roleInfo.name });
          if (roleInfo.isCustom)
            roleOptionEl.addClass(CSS_ROLE_PANEL_ITEM_CUSTOM);
          (0, import_obsidian12.setIcon)(iconSpan, roleInfo.path === currentRolePath ? "check" : roleInfo.isCustom ? "user" : "file-text");
          if (roleInfo.path === currentRolePath)
            roleOptionEl.addClass(CSS_ROLE_PANEL_ITEM_ACTIVE);
          this.view.registerDomEvent(
            roleOptionEl,
            "click",
            () => this.handleRolePanelItemClick(roleInfo, currentRolePath)
          );
        });
      } catch (error) {
        container.empty();
        container.createDiv({ text: "Error loading roles.", cls: "menu-error-text" });
      } finally {
        requestAnimationFrame(() => {
          if (container == null ? void 0 : container.isConnected) {
            container.scrollTop = currentScrollTop;
          }
        });
      }
    };
    this.handleRolePanelItemClick = async (roleInfo, currentRolePath) => {
      var _a, _b, _c, _d, _e;
      const newRolePath = (_a = roleInfo == null ? void 0 : roleInfo.path) != null ? _a : "";
      const roleNameForEvent = (_b = roleInfo == null ? void 0 : roleInfo.name) != null ? _b : "None";
      const normalizedCurrentRolePath = currentRolePath != null ? currentRolePath : "";
      if (newRolePath !== normalizedCurrentRolePath) {
        const activeChat = await ((_c = this.plugin.chatManager) == null ? void 0 : _c.getActiveChat());
        try {
          if (activeChat) {
            await this.plugin.chatManager.updateActiveChatMetadata({ selectedRolePath: newRolePath || void 0 });
          } else {
            this.plugin.settings.selectedRolePath = newRolePath || void 0;
            await this.plugin.saveSettings();
            this.plugin.emit("role-changed", roleNameForEvent);
            (_e = (_d = this.plugin.promptService) == null ? void 0 : _d.clearRoleCache) == null ? void 0 : _e.call(_d);
          }
          this.updateRoleList();
        } catch (error) {
          new import_obsidian12.Notice("Failed to set the role.");
        }
      } else {
      }
    };
    // src/SidebarManager.ts
    this.handleNewChatClick = async (targetFolderPath) => {
      var _a, _b;
      const folderPath = (_a = targetFolderPath != null ? targetFolderPath : this.plugin.chatManager.chatsFolderPath) != null ? _a : "/";
      try {
        const newChat = await this.plugin.chatManager.createNewChat(void 0, folderPath);
        if (newChat) {
          new import_obsidian12.Notice(`Created new chat: ${newChat.metadata.name}`);
          this.plugin.emit("focus-input-request");
          const parentPath = folderPath.substring(0, folderPath.lastIndexOf("/"));
          const normalizedParentPath = (0, import_obsidian12.normalizePath)(parentPath);
          const normalizedChatsFolderPath = (0, import_obsidian12.normalizePath)((_b = this.plugin.chatManager.chatsFolderPath) != null ? _b : "/");
          if (parentPath && normalizedParentPath !== "/" && normalizedParentPath !== normalizedChatsFolderPath) {
            this.folderExpansionState.set(normalizedParentPath, true);
          }
        }
      } catch (error) {
        new import_obsidian12.Notice(`Error creating new chat: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    };
    this.handleNewFolderClick = async (parentFolderPath) => {
      var _a;
      const targetParentPath = (_a = parentFolderPath != null ? parentFolderPath : this.plugin.chatManager.chatsFolderPath) != null ? _a : "/";
      new PromptModal(this.app, "Create New Folder", "Enter folder name:", "", async (newName) => {
        const trimmedName = newName == null ? void 0 : newName.trim();
        if (!trimmedName) {
          new import_obsidian12.Notice("Folder name cannot be empty.");
          return;
        }
        if (/[\\/?:*"<>|]/.test(trimmedName)) {
          new import_obsidian12.Notice("Folder name contains invalid characters.");
          return;
        }
        const newFolderPath = (0, import_obsidian12.normalizePath)(
          targetParentPath === "/" ? trimmedName : `${targetParentPath}/${trimmedName}`
        );
        try {
          const success = await this.plugin.chatManager.createFolder(newFolderPath);
          if (success) {
            new import_obsidian12.Notice(`Folder "${trimmedName}" created.`);
            if (targetParentPath && targetParentPath !== "/") {
              this.folderExpansionState.set(targetParentPath, true);
            }
          }
        } catch (error) {
          new import_obsidian12.Notice(`Error creating folder: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }).open();
    };
    this.handleRenameFolder = async (folderNode) => {
      const currentName = folderNode.name;
      const parentPath = folderNode.path.substring(0, folderNode.path.lastIndexOf("/")) || "/";
      new PromptModal(this.app, "Rename Folder", `New name for "${currentName}":`, currentName, async (newName) => {
        const trimmedName = newName == null ? void 0 : newName.trim();
        if (!trimmedName || trimmedName === currentName) {
          new import_obsidian12.Notice(trimmedName === currentName ? "Name unchanged." : "Rename cancelled.");
          return;
        }
        if (/[\\/?:*"<>|]/.test(trimmedName)) {
          new import_obsidian12.Notice("Folder name contains invalid characters.");
          return;
        }
        const newFolderPath = (0, import_obsidian12.normalizePath)(parentPath === "/" ? trimmedName : `${parentPath}/${trimmedName}`);
        try {
          const exists = await this.app.vault.adapter.exists(newFolderPath);
          if (exists) {
            new import_obsidian12.Notice(`A folder or file named "${trimmedName}" already exists here.`);
            return;
          }
        } catch (e) {
        }
        try {
          const success = await this.plugin.chatManager.renameFolder(folderNode.path, newFolderPath);
          if (success) {
            new import_obsidian12.Notice(`Folder renamed to "${trimmedName}".`);
            if (this.folderExpansionState.has(folderNode.path)) {
              const wasExpanded = this.folderExpansionState.get(folderNode.path);
              this.folderExpansionState.delete(folderNode.path);
              this.folderExpansionState.set(newFolderPath, wasExpanded);
            }
          }
        } catch (error) {
          new import_obsidian12.Notice(`Error renaming folder: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }).open();
    };
    this.handleDeleteFolder = async (folderNode) => {
      const folderName = folderNode.name;
      const folderPath = folderNode.path;
      if (folderPath === this.plugin.chatManager.chatsFolderPath) {
        new import_obsidian12.Notice("Cannot delete the main chat history folder.");
        return;
      }
      new ConfirmModal(
        this.app,
        "Delete Folder",
        `Delete folder "${folderName}" and ALL its contents (subfolders and chats)? This cannot be undone.`,
        async () => {
          const notice = new import_obsidian12.Notice(`Deleting folder "${folderName}"...`, 0);
          try {
            const success = await this.plugin.chatManager.deleteFolder(folderPath);
            if (success) {
              const keysToDelete = Array.from(this.folderExpansionState.keys()).filter((key) => key.startsWith(folderPath));
              keysToDelete.forEach((key) => this.folderExpansionState.delete(key));
            }
          } catch (error) {
            new import_obsidian12.Notice(`Error deleting folder: ${error instanceof Error ? error.message : "Unknown error"}`);
          } finally {
            notice.hide();
          }
        }
      ).open();
    };
    this.plugin = plugin;
    this.app = app;
    this.view = view;
  }
  createSidebarUI(parentElement) {
    this.containerEl = parentElement.createDiv({ cls: CSS_SIDEBAR_CONTAINER });
    const chatPanel = this.containerEl.createDiv({ cls: CSS_CHAT_PANEL });
    this.chatPanelHeaderEl = chatPanel.createDiv({
      cls: [CSS_SIDEBAR_SECTION_HEADER, CSS_CLASS_MENU_OPTION],
      attr: { "data-section-type": "chats", "data-collapsed": "false" }
      // За замовчуванням розгорнуто
    });
    const chatHeaderLeft = this.chatPanelHeaderEl.createDiv({ cls: CSS_SIDEBAR_HEADER_LEFT });
    (0, import_obsidian12.setIcon)(chatHeaderLeft.createSpan({ cls: CSS_SIDEBAR_SECTION_ICON }), CHATS_SECTION_ICON);
    chatHeaderLeft.createSpan({ cls: "menu-option-text", text: "Chats" });
    const chatHeaderActions = this.chatPanelHeaderEl.createDiv({ cls: CSS_SIDEBAR_HEADER_ACTIONS });
    this.newFolderSidebarButton = chatHeaderActions.createDiv({
      cls: [CSS_SIDEBAR_HEADER_BUTTON, "clickable-icon"],
      attr: { "aria-label": "New Folder", title: "New Folder" }
    });
    (0, import_obsidian12.setIcon)(this.newFolderSidebarButton, "lucide-folder-plus");
    this.newChatSidebarButton = chatHeaderActions.createDiv({
      cls: [CSS_SIDEBAR_HEADER_BUTTON, "clickable-icon"],
      attr: { "aria-label": "New Chat", title: "New Chat" }
    });
    (0, import_obsidian12.setIcon)(this.newChatSidebarButton, "lucide-plus-circle");
    const chatChevron = chatHeaderActions.createSpan({ cls: [CSS_SECTION_TOGGLE_CHEVRON, "clickable-icon"] });
    (0, import_obsidian12.setIcon)(chatChevron, EXPAND_ICON_ACCORDION);
    this.chatPanelListContainerEl = chatPanel.createDiv({
      cls: [CSS_CHAT_LIST_CONTAINER, CSS_SIDEBAR_SECTION_CONTENT, CSS_EXPANDED_CLASS]
      // Починаємо з розгорнутого стану
    });
    this.rootDropZoneEl = chatPanel.createDiv({ cls: "ollama-root-drop-zone" });
    this.view.registerDomEvent(this.rootDropZoneEl, "dragover", this.handleDragOverRootZone.bind(this));
    this.view.registerDomEvent(this.rootDropZoneEl, "dragenter", this.handleDragEnterRootZone.bind(this));
    this.view.registerDomEvent(this.rootDropZoneEl, "dragleave", this.handleDragLeaveRootZone.bind(this));
    this.view.registerDomEvent(this.rootDropZoneEl, "drop", this.handleDropRootZone.bind(this));
    const rolePanel = this.containerEl.createDiv({ cls: CSS_ROLE_PANEL });
    this.rolePanelHeaderEl = rolePanel.createDiv({
      cls: [CSS_SIDEBAR_SECTION_HEADER, CSS_CLASS_MENU_OPTION],
      attr: { "data-section-type": "roles", "data-collapsed": "true" }
      // За замовчуванням згорнуто
    });
    const roleHeaderLeft = this.rolePanelHeaderEl.createDiv({ cls: CSS_SIDEBAR_HEADER_LEFT });
    (0, import_obsidian12.setIcon)(roleHeaderLeft.createSpan({ cls: CSS_SIDEBAR_SECTION_ICON }), ROLES_SECTION_ICON);
    roleHeaderLeft.createSpan({ cls: "menu-option-text", text: "Roles" });
    const roleHeaderActions = this.rolePanelHeaderEl.createDiv({ cls: CSS_SIDEBAR_HEADER_ACTIONS });
    const roleChevron = roleHeaderActions.createSpan({ cls: [CSS_SECTION_TOGGLE_CHEVRON, "clickable-icon"] });
    (0, import_obsidian12.setIcon)(roleChevron, COLLAPSE_ICON_ACCORDION);
    this.rolePanelListEl = rolePanel.createDiv({
      cls: [CSS_ROLE_PANEL_LIST, CSS_SIDEBAR_SECTION_CONTENT]
      // За замовчуванням приховано
    });
    if (this.rolePanelHeaderEl.getAttribute("data-collapsed") === "true") {
      this.rolePanelListEl.addClass(CSS_SIDEBAR_SECTION_CONTENT_HIDDEN);
    }
    this.attachSidebarEventListeners();
    if (this.isSectionVisible("chats")) {
      this.updateChatList();
    } else {
    }
    if (this.isSectionVisible("roles")) {
      this.updateRoleList();
    } else {
    }
    return this.containerEl;
  }
  // --- Кінець createSidebarUI ---
  attachSidebarEventListeners() {
    if (!this.chatPanelHeaderEl || !this.rolePanelHeaderEl || !this.newChatSidebarButton || !this.newFolderSidebarButton) {
      return;
    }
    this.view.registerDomEvent(this.chatPanelHeaderEl, "click", () => this.toggleSection(this.chatPanelHeaderEl));
    this.view.registerDomEvent(this.rolePanelHeaderEl, "click", () => this.toggleSection(this.rolePanelHeaderEl));
    this.view.registerDomEvent(this.newChatSidebarButton, "click", (e) => {
      e.stopPropagation();
      this.handleNewChatClick(this.plugin.chatManager.chatsFolderPath);
    });
    this.view.registerDomEvent(this.newFolderSidebarButton, "click", (e) => {
      e.stopPropagation();
      this.handleNewFolderClick(this.plugin.chatManager.chatsFolderPath);
    });
  }
  isSectionVisible(type) {
    const headerEl = type === "chats" ? this.chatPanelHeaderEl : this.rolePanelHeaderEl;
    return (headerEl == null ? void 0 : headerEl.getAttribute("data-collapsed")) === "false";
  }
  // src/SidebarManager.ts
  renderHierarchyNode(node, parentElement, level, activeChatId, activeAncestorPaths, updateId) {
    var _a;
    const itemEl = parentElement.createDiv({ cls: [CSS_HIERARCHY_ITEM, `${CSS_HIERARCHY_INDENT_PREFIX}${level}`] });
    const itemContentEl = itemEl.createDiv({ cls: CSS_HIERARCHY_ITEM_CONTENT });
    itemEl.setAttr("draggable", "true");
    this.view.registerDomEvent(itemEl, "dragstart", (e) => this.handleDragStart(e, node));
    this.view.registerDomEvent(itemEl, "dragend", (e) => this.handleDragEnd(e));
    if (node.type === "folder") {
      itemEl.addClass(CSS_FOLDER_ITEM);
      itemEl.dataset.path = node.path;
      const isExpanded = (_a = this.folderExpansionState.get(node.path)) != null ? _a : false;
      if (!isExpanded) {
        itemEl.addClass(CSS_HIERARCHY_ITEM_COLLAPSED);
      }
      if (activeAncestorPaths.has(node.path)) {
        itemEl.addClass(CSS_FOLDER_ACTIVE_ANCESTOR);
      }
      const folderIcon = itemContentEl.createSpan({ cls: CSS_FOLDER_ICON });
      (0, import_obsidian12.setIcon)(folderIcon, isExpanded ? FOLDER_ICON_OPEN : FOLDER_ICON_CLOSED);
      itemContentEl.createSpan({ cls: CSS_HIERARCHY_ITEM_TEXT, text: node.name });
      const optionsBtn = itemContentEl.createEl("button", {
        cls: [CSS_HIERARCHY_ITEM_OPTIONS, "clickable-icon"],
        attr: { "aria-label": "Folder options", title: "More options" }
      });
      (0, import_obsidian12.setIcon)(optionsBtn, "lucide-more-horizontal");
      this.view.registerDomEvent(optionsBtn, "click", (e) => {
        e.stopPropagation();
        this.showFolderContextMenu(e, node);
      });
      this.view.registerDomEvent(itemEl, "dragover", this.handleDragOver);
      this.view.registerDomEvent(itemEl, "dragenter", (e) => this.handleDragEnter(e, node));
      this.view.registerDomEvent(itemEl, "dragleave", this.handleDragLeave);
      this.view.registerDomEvent(itemEl, "drop", (e) => this.handleDrop(e, node));
      this.view.registerDomEvent(itemContentEl, "contextmenu", (e) => {
        e.preventDefault();
        this.showFolderContextMenu(e, node);
      });
      this.view.registerDomEvent(itemContentEl, "click", (e) => {
        if (e.target instanceof Element && !e.target.closest(`.${CSS_HIERARCHY_ITEM_OPTIONS}`)) {
          this.handleToggleFolder(node.path);
        }
      });
      const childrenContainer = itemEl.createDiv({ cls: CSS_HIERARCHY_ITEM_CHILDREN });
      if (node.children && node.children.length > 0) {
        node.children.forEach(
          (childNode) => this.renderHierarchyNode(childNode, childrenContainer, level + 1, activeChatId, activeAncestorPaths, updateId)
        );
      }
    } else if (node.type === "chat") {
      itemEl.addClass(CSS_CHAT_ITEM);
      const chatMeta = node.metadata;
      itemEl.dataset.chatId = chatMeta.id;
      itemEl.dataset.filePath = node.filePath;
      const isActive = chatMeta.id === activeChatId;
      if (isActive) {
        itemEl.addClass(CSS_ROLE_PANEL_ITEM_ACTIVE);
      }
      const chatIcon = itemContentEl.createSpan({ cls: CSS_FOLDER_ICON });
      (0, import_obsidian12.setIcon)(chatIcon, isActive ? CHAT_ICON_ACTIVE : CHAT_ICON);
      itemContentEl.createSpan({ cls: CSS_HIERARCHY_ITEM_TEXT, text: chatMeta.name });
      const detailsWrapper = itemContentEl.createDiv({ cls: CSS_CHAT_ITEM_DETAILS });
      try {
        const lastModifiedDate = new Date(chatMeta.lastModified);
        const dateText = !isNaN(lastModifiedDate.getTime()) ? this.formatRelativeDate(lastModifiedDate) : "Invalid date";
        if (dateText === "Invalid date") {
        }
        detailsWrapper.createDiv({ cls: CSS_CHAT_ITEM_DATE, text: dateText });
      } catch (e) {
        detailsWrapper.createDiv({ cls: CSS_CHAT_ITEM_DATE, text: "Date error" });
      }
      const optionsBtn = itemContentEl.createEl("button", {
        cls: [CSS_HIERARCHY_ITEM_OPTIONS, "clickable-icon"],
        attr: { "aria-label": "Chat options", title: "More options" }
      });
      (0, import_obsidian12.setIcon)(optionsBtn, "lucide-more-horizontal");
      this.view.registerDomEvent(optionsBtn, "click", (e) => {
        e.stopPropagation();
        this.showChatContextMenu(e, chatMeta);
      });
      this.view.registerDomEvent(itemContentEl, "click", async (e) => {
        if (e.target instanceof Element && !e.target.closest(`.${CSS_HIERARCHY_ITEM_OPTIONS}`)) {
          if (chatMeta.id !== activeChatId) {
            await this.plugin.chatManager.setActiveChat(chatMeta.id);
          }
        }
      });
      this.view.registerDomEvent(itemContentEl, "contextmenu", (e) => {
        e.preventDefault();
        this.showChatContextMenu(e, chatMeta);
      });
    }
  }
  // --- Кінець методу renderHierarchyNode ---
  handleToggleFolder(folderPath) {
    var _a;
    const currentState = (_a = this.folderExpansionState.get(folderPath)) != null ? _a : false;
    const newState = !currentState;
    this.folderExpansionState.set(folderPath, newState);
    const folderItemEl = this.chatPanelListContainerEl.querySelector(
      `.ollama-folder-item[data-path="${folderPath}"]`
    );
    if (!folderItemEl) {
      this.updateChatList();
      return;
    }
    folderItemEl.classList.toggle(CSS_HIERARCHY_ITEM_COLLAPSED, !newState);
    const folderIconEl = folderItemEl.querySelector("." + CSS_FOLDER_ICON);
    if (folderIconEl) {
      (0, import_obsidian12.setIcon)(folderIconEl, newState ? FOLDER_ICON_OPEN : FOLDER_ICON_CLOSED);
    }
  }
  // Метод для розгортання/згортання секцій Chats/Roles (акордеон)
  async toggleSection(clickedHeaderEl) {
    const sectionType = clickedHeaderEl.getAttribute("data-section-type");
    const isCurrentlyCollapsed = clickedHeaderEl.getAttribute("data-collapsed") === "true";
    const iconEl = clickedHeaderEl.querySelector(`.${CSS_SECTION_TOGGLE_CHEVRON}`);
    let contentEl;
    let updateFunction;
    let otherHeaderEl;
    let otherContentEl;
    let otherSectionType = null;
    const chatHeader = this.chatPanelHeaderEl;
    const chatContent = this.chatPanelListContainerEl;
    const roleHeader = this.rolePanelHeaderEl;
    const roleContent = this.rolePanelListEl;
    if (sectionType === "chats") {
      contentEl = chatContent;
      updateFunction = this.updateChatList;
      otherHeaderEl = roleHeader;
      otherContentEl = roleContent;
      otherSectionType = "roles";
    } else {
      contentEl = roleContent;
      updateFunction = this.updateRoleList;
      otherHeaderEl = chatHeader;
      otherContentEl = chatContent;
      otherSectionType = "chats";
    }
    if (!contentEl || !iconEl || !updateFunction || !otherHeaderEl || !otherContentEl || !otherSectionType) {
      return;
    }
    const boundUpdateFunction = updateFunction.bind(this);
    if (isCurrentlyCollapsed) {
      if (otherHeaderEl.getAttribute("data-collapsed") === "false") {
        const otherIconEl = otherHeaderEl.querySelector(`.${CSS_SECTION_TOGGLE_CHEVRON}`);
        otherHeaderEl.setAttribute("data-collapsed", "true");
        if (otherIconEl)
          (0, import_obsidian12.setIcon)(otherIconEl, COLLAPSE_ICON_ACCORDION);
        otherContentEl.classList.remove(CSS_EXPANDED_CLASS);
        otherContentEl.classList.add(CSS_SIDEBAR_SECTION_CONTENT_HIDDEN);
        const otherHeaderButtons = otherHeaderEl.querySelectorAll(`.${CSS_SIDEBAR_HEADER_BUTTON}`);
        otherHeaderButtons.forEach((btn) => btn.style.display = "none");
      }
      clickedHeaderEl.setAttribute("data-collapsed", "false");
      (0, import_obsidian12.setIcon)(iconEl, EXPAND_ICON_ACCORDION);
      contentEl.classList.remove(CSS_SIDEBAR_SECTION_CONTENT_HIDDEN);
      const headerButtons = clickedHeaderEl.querySelectorAll(`.${CSS_SIDEBAR_HEADER_BUTTON}`);
      headerButtons.forEach((btn) => btn.style.display = "");
      try {
        await boundUpdateFunction();
        requestAnimationFrame(() => {
          if ((contentEl == null ? void 0 : contentEl.isConnected) && clickedHeaderEl.getAttribute("data-collapsed") === "false") {
            contentEl.classList.add(CSS_EXPANDED_CLASS);
          }
        });
      } catch (error) {
        contentEl.setText(`Error loading ${sectionType}.`);
        requestAnimationFrame(() => {
          if ((contentEl == null ? void 0 : contentEl.isConnected) && clickedHeaderEl.getAttribute("data-collapsed") === "false") {
            contentEl.classList.add(CSS_EXPANDED_CLASS);
          }
        });
      }
    } else {
      clickedHeaderEl.setAttribute("data-collapsed", "true");
      (0, import_obsidian12.setIcon)(iconEl, COLLAPSE_ICON_ACCORDION);
      contentEl.classList.remove(CSS_EXPANDED_CLASS);
      contentEl.classList.add(CSS_SIDEBAR_SECTION_CONTENT_HIDDEN);
      const headerButtons = clickedHeaderEl.querySelectorAll(`.${CSS_SIDEBAR_HEADER_BUTTON}`);
      headerButtons.forEach((btn) => btn.style.display = "none");
    }
  }
  // --- Кінець методу toggleSection ---
  // --- Решта методів без змін ---
  showFolderContextMenu(event, folderNode) {
    event.preventDefault();
    event.stopPropagation();
    const menu = new import_obsidian12.Menu();
    menu.addItem(
      (item) => item.setTitle("New Chat Here").setIcon("lucide-plus-circle").onClick(() => this.handleNewChatClick(folderNode.path))
    );
    menu.addItem(
      (item) => item.setTitle("New Folder Here").setIcon("lucide-folder-plus").onClick(() => this.handleNewFolderClick(folderNode.path))
    );
    menu.addSeparator();
    menu.addItem(
      (item) => item.setTitle("Rename Folder").setIcon("lucide-pencil").onClick(() => this.handleRenameFolder(folderNode))
    );
    menu.addItem((item) => {
      item.setTitle("Delete Folder").setIcon("lucide-trash-2").onClick(() => this.handleDeleteFolder(folderNode));
    });
    menu.showAtMouseEvent(event);
  }
  showChatContextMenu(event, chatMeta) {
    event.preventDefault();
    event.stopPropagation();
    const menu = new import_obsidian12.Menu();
    menu.addItem(
      (item) => item.setTitle("Clone Chat").setIcon("lucide-copy-plus").onClick(() => this.handleContextMenuClone(chatMeta.id))
    );
    menu.addItem(
      (item) => item.setTitle("Rename Chat").setIcon("lucide-pencil").onClick(() => this.handleContextMenuRename(chatMeta.id, chatMeta.name))
    );
    menu.addItem(
      (item) => item.setTitle("Export to Note").setIcon("lucide-download").onClick(() => this.exportSpecificChat(chatMeta.id))
    );
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle("Clear Messages").setIcon("lucide-trash").onClick(() => this.handleContextMenuClear(chatMeta.id, chatMeta.name));
    });
    menu.addItem((item) => {
      item.setTitle("Delete Chat").setIcon("lucide-trash-2").onClick(() => this.handleContextMenuDelete(chatMeta.id, chatMeta.name));
    });
    menu.showAtMouseEvent(event);
  }
  async handleContextMenuClone(chatId) {
    const notice = new import_obsidian12.Notice("Cloning chat...", 0);
    try {
      const c = await this.plugin.chatManager.cloneChat(chatId);
      if (c) {
        new import_obsidian12.Notice(`Chat cloned as "${c.metadata.name}"`);
        this.plugin.emit("focus-input-request");
      }
    } catch (e) {
    } finally {
      notice.hide();
    }
  }
  async handleContextMenuRename(chatId, currentName) {
    new PromptModal(this.app, "Rename Chat", `New name for "${currentName}":`, currentName, async (newName) => {
      const trimmedName = newName == null ? void 0 : newName.trim();
      if (!trimmedName || trimmedName === currentName) {
        new import_obsidian12.Notice(trimmedName === currentName ? `Name unchanged.` : `Rename cancelled.`);
      } else if (/[\\/?:*"<>|]/.test(trimmedName)) {
        new import_obsidian12.Notice("Chat name contains invalid characters.");
      } else {
        const success = await this.plugin.chatManager.renameChat(chatId, trimmedName);
      }
      this.plugin.emit("focus-input-request");
    }).open();
  }
  // Видалено явний updateChatList
  async exportSpecificChat(chatId) {
    var _a;
    const notice = new import_obsidian12.Notice(`Exporting chat...`, 0);
    try {
      const chat = await this.plugin.chatManager.getChat(chatId);
      if (!chat || chat.messages.length === 0) {
        new import_obsidian12.Notice("Chat is empty or not found, nothing to export.");
        notice.hide();
        return;
      }
      const md = this.formatChatToMarkdown(chat.messages, chat.metadata);
      const ts = new Date().toISOString().replace(/[:.]/g, "-");
      const safeName = chat.metadata.name.replace(/[\\/?:*"<>|]/g, "-");
      const filename = `ollama-chat-${safeName}-${ts}.md`;
      let fPath = (_a = this.plugin.settings.chatExportFolderPath) == null ? void 0 : _a.trim();
      let fFolder = null;
      if (fPath) {
        fPath = (0, import_obsidian12.normalizePath)(fPath);
        const af = this.app.vault.getAbstractFileByPath(fPath);
        if (!af) {
          try {
            await this.app.vault.createFolder(fPath);
            const newAf = this.app.vault.getAbstractFileByPath(fPath);
            if (newAf instanceof import_obsidian12.TFolder) {
              fFolder = newAf;
              new import_obsidian12.Notice(`Created export folder: ${fPath}`);
            } else {
              throw new Error("Failed to get created folder.");
            }
          } catch (err) {
            new import_obsidian12.Notice(`Export folder error. Saving to vault root.`);
            fFolder = this.app.vault.getRoot();
          }
        } else if (af instanceof import_obsidian12.TFolder) {
          fFolder = af;
        } else {
          new import_obsidian12.Notice(`Export path is not a folder. Saving to vault root.`);
          fFolder = this.app.vault.getRoot();
        }
      } else {
        fFolder = this.app.vault.getRoot();
      }
      if (!fFolder) {
        new import_obsidian12.Notice("Export folder error.");
        notice.hide();
        return;
      }
      const filePath = (0, import_obsidian12.normalizePath)(`${fFolder.path}/${filename}`);
      const file = await this.app.vault.create(filePath, md);
      new import_obsidian12.Notice(`Chat exported to ${file.path}`);
    } catch (e) {
      new import_obsidian12.Notice("Chat export failed.");
    } finally {
      notice.hide();
    }
  }
  async handleContextMenuClear(chatId, chatName) {
    new ConfirmModal(this.app, "Clear Messages", `Clear all messages in "${chatName}"?`, async () => {
      const notice = new import_obsidian12.Notice("Clearing messages...", 0);
      try {
        const success = await this.plugin.chatManager.clearChatMessagesById(chatId);
      } catch (e) {
        new import_obsidian12.Notice("Failed to clear messages.");
      } finally {
        notice.hide();
      }
    }).open();
  }
  async handleContextMenuDelete(chatId, chatName) {
    new ConfirmModal(this.app, "Delete Chat", `Delete chat "${chatName}"? This cannot be undone.`, async () => {
      const notice = new import_obsidian12.Notice("Deleting chat...", 0);
      try {
        const success = await this.plugin.chatManager.deleteChat(chatId);
      } catch (e) {
        new import_obsidian12.Notice("Failed to delete chat.");
      } finally {
        notice.hide();
      }
    }).open();
  }
  formatChatToMarkdown(messagesToFormat, metadata) {
    var _a;
    let localLastDate = null;
    const exportTimestamp = new Date();
    let markdown = `# AI Forge Chat: ${metadata.name}

`;
    markdown += `* **Chat ID:** ${metadata.id}
`;
    markdown += `* **Model:** ${metadata.modelName || "Default"}
`;
    markdown += `* **Role Path:** ${metadata.selectedRolePath || "None"}
`;
    markdown += `* **Temperature:** ${(_a = metadata.temperature) != null ? _a : this.plugin.settings.temperature}
`;
    markdown += `* **Created:** ${new Date(metadata.createdAt).toLocaleString()}
`;
    markdown += `* **Last Modified:** ${new Date(metadata.lastModified).toLocaleString()}
`;
    markdown += `* **Exported:** ${exportTimestamp.toLocaleString()}

`;
    markdown += `***

`;
    messagesToFormat.forEach((message) => {
      var _a2;
      if (!message || !((_a2 = message.content) == null ? void 0 : _a2.trim()) || !message.timestamp) {
        return;
      }
      let messageTimestamp;
      if (typeof message.timestamp === "string") {
        messageTimestamp = new Date(message.timestamp);
      } else if (message.timestamp instanceof Date) {
        messageTimestamp = message.timestamp;
      } else {
        return;
      }
      if (isNaN(messageTimestamp.getTime())) {
        return;
      }
      if (localLastDate === null || !this.isSameDay(localLastDate, messageTimestamp)) {
        if (localLastDate !== null)
          markdown += `***

`;
        markdown += `**${this.formatDateSeparator(messageTimestamp)}**
***

`;
        localLastDate = messageTimestamp;
      }
      const time = this.formatTime(messageTimestamp);
      let prefix = "";
      let contentPrefix = "";
      let content = message.content.trim();
      if (message.role === "assistant") {
        try {
          content = decodeHtmlEntities(content);
          if (detectThinkingTags(content).hasThinkingTags) {
            content = content.replace(/<thinking>[\s\S]*?<\/thinking>/g, "").trim();
            content = content.replace(/<think>[\s\S]*?<\/think>/g, "").trim();
          }
        } catch (e) {
        }
        if (!content)
          return;
      }
      switch (message.role) {
        case "user":
          prefix = `**User (${time}):**
`;
          break;
        case "assistant":
          prefix = `**Assistant (${time}):**
`;
          break;
        case "system":
          prefix = `> _[System (${time})]_ 
> `;
          contentPrefix = "> ";
          break;
        case "error":
          prefix = `> [!ERROR] Error (${time}):
> `;
          contentPrefix = "> ";
          break;
        default:
          prefix = `**${message.role} (${time}):**
`;
          break;
      }
      markdown += prefix;
      if (contentPrefix) {
        markdown += content.split("\n").map((line) => line.trim() ? `${contentPrefix}${line}` : contentPrefix.trim()).join(`
`) + "\n\n";
      } else if (content.includes("```")) {
        content = content.replace(/(\r?\n)*```/g, "\n\n```").replace(/```(\r?\n)*/g, "```\n\n").trim();
        markdown += content + "\n\n";
      } else {
        markdown += content.split("\n").map((line) => line.trim() ? line : "").join("\n") + "\n\n";
      }
    });
    return markdown.trim();
  }
  formatTime(date) {
    if (!(date instanceof Date) || isNaN(date.getTime()))
      return "??:??";
    return date.toLocaleTimeString(void 0, { hour: "numeric", minute: "2-digit", hour12: false });
  }
  formatDateSeparator(date) {
    if (!(date instanceof Date) || isNaN(date.getTime()))
      return "Unknown Date";
    const now = new Date();
    const yesterday = new Date(now);
    yesterday.setDate(now.getDate() - 1);
    if (this.isSameDay(date, now))
      return "Today";
    if (this.isSameDay(date, yesterday))
      return "Yesterday";
    const startOfToday = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const startOfGivenDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
    const diffDays = Math.floor((startOfToday.getTime() - startOfGivenDate.getTime()) / (1e3 * 60 * 60 * 24));
    if (diffDays > 1 && diffDays < 7) {
      return date.toLocaleDateString(void 0, { weekday: "long" });
    }
    return date.toLocaleDateString(void 0, { year: "numeric", month: "long", day: "numeric" });
  }
  formatRelativeDate(date) {
    if (!(date instanceof Date) || isNaN(date.getTime())) {
      return "Invalid date";
    }
    const now = new Date();
    const diffSeconds = Math.round((now.getTime() - date.getTime()) / 1e3);
    const diffMinutes = Math.floor(diffSeconds / 60);
    const diffHours = Math.floor(diffMinutes / 60);
    const diffDays = Math.floor(diffHours / 24);
    if (diffSeconds < 5)
      return "Just now";
    if (diffSeconds < 60)
      return `${diffSeconds}s ago`;
    if (diffMinutes < 60)
      return `${diffMinutes}m ago`;
    if (diffHours < 2)
      return `1h ago`;
    if (diffHours < 24)
      return `${diffHours}h ago`;
    if (diffDays === 1)
      return "Yesterday";
    if (diffDays < 7)
      return `${diffDays}d ago`;
    return date.toLocaleDateString(void 0, {
      month: "short",
      day: "numeric",
      year: date.getFullYear() !== now.getFullYear() ? "numeric" : void 0
    });
  }
  isSameDay(date1, date2) {
    if (!(date1 instanceof Date) || !(date2 instanceof Date) || isNaN(date1.getTime()) || isNaN(date2.getTime()))
      return false;
    return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate();
  }
  destroy() {
    var _a;
    (_a = this.containerEl) == null ? void 0 : _a.remove();
    this.folderExpansionState.clear();
  }
  // src/SidebarManager.ts
  handleDragStart(event, node) {
    if (!event.dataTransfer) {
      return;
    }
    let id;
    let path;
    let name;
    if (node.type === "chat") {
      id = node.metadata.id;
      path = node.filePath;
      name = node.metadata.name;
    } else {
      id = node.path;
      path = node.path;
      name = node.name;
    }
    this.draggedItemData = { type: node.type, id, path, name };
    event.dataTransfer.setData("text/plain", JSON.stringify(this.draggedItemData));
    event.dataTransfer.effectAllowed = "move";
    if (event.target instanceof HTMLElement) {
      event.target.addClass("is-dragging");
    }
    if (this.containerEl) {
      this.containerEl.classList.add("sidebar-drag-active");
    }
    event.stopPropagation();
  }
  // src/SidebarManager.ts
  handleDragEnd(event) {
    var _a;
    if (this.containerEl) {
      this.containerEl.classList.remove("sidebar-drag-active");
    }
    if (this.rootDropZoneEl) {
      this.rootDropZoneEl.removeClass("drag-over-root-target");
    }
    if (event.target instanceof HTMLElement) {
      event.target.removeClass("is-dragging");
    }
    (_a = this.containerEl) == null ? void 0 : _a.querySelectorAll(".drag-over-target").forEach((el) => el.removeClass("drag-over-target"));
    this.draggedItemData = null;
    this.plugin.logger.trace("Drag End: Cleaned up draggedItemData and styles.");
  }
  handleDragOver(event) {
    event.preventDefault();
    if (event.dataTransfer) {
      event.dataTransfer.dropEffect = "move";
    }
    event.stopPropagation();
  }
  handleDragEnter(event, targetNode) {
    event.preventDefault();
    const targetElement = event.currentTarget;
    if (!targetElement || !this.draggedItemData)
      return;
    let canDrop = false;
    if (this.draggedItemData.type === "chat") {
      canDrop = true;
    } else if (this.draggedItemData.type === "folder") {
      const draggedPath = this.draggedItemData.path;
      const targetPath = targetNode.path;
      if (draggedPath !== targetPath && !targetPath.startsWith(draggedPath + "/")) {
        canDrop = true;
      }
    }
    if (canDrop) {
      targetElement.addClass("drag-over-target");
    }
  }
  handleDragLeave(event) {
    const targetElement = event.currentTarget;
    if (targetElement) {
      targetElement.removeClass("drag-over-target");
    }
  }
  handleDragOverRoot(event) {
    event.preventDefault();
    if (event.dataTransfer) {
      event.dataTransfer.dropEffect = "move";
    }
    if (!this.draggedItemData) {
      event.currentTarget.removeClass("drag-over-root-target");
      return;
    }
    const rootFolderPath = (0, import_obsidian12.normalizePath)(this.plugin.chatManager.chatsFolderPath);
    const draggedPath = this.draggedItemData.path;
    let sourceParentPath = (0, import_obsidian12.normalizePath)(draggedPath.substring(0, draggedPath.lastIndexOf("/")) || "/");
    if (this.draggedItemData.type === "folder" && rootFolderPath === "/" && !draggedPath.includes("/")) {
      sourceParentPath = "/";
    }
    if (sourceParentPath === rootFolderPath) {
      event.currentTarget.removeClass("drag-over-root-target");
      this.plugin.logger.trace("[DragOverRoot] Item already at root, no highlight for root.");
    } else {
      event.currentTarget.addClass("drag-over-root-target");
      this.plugin.logger.trace("[DragOverRoot] Over root empty space/non-folder child, item not at root. Added root highlight.");
    }
  }
  // Цей метод викликається, коли миша ВХОДИТЬ в межі chatPanelListContainerEl
  // Може бути менш важливим, якщо handleDragOverRoot все коректно обробляє.
  handleDragEnterRoot(event) {
    event.preventDefault();
    this.plugin.logger.trace(`[DragEnterRoot] Mouse entered root container bounds.`);
    this.handleDragOverRoot(event);
  }
  handleDragLeaveRoot(event) {
    const listeningElement = event.currentTarget;
    if (!event.relatedTarget || !listeningElement.contains(event.relatedTarget)) {
      listeningElement.removeClass("drag-over-root-target");
    } else {
      this.plugin.logger.trace("[DragLeaveRoot] Mouse moved to a child within root. Highlight persists or handled by child.");
    }
  }
  async handleDrop(event, targetNode) {
    event.preventDefault();
    event.stopPropagation();
    const targetElement = event.currentTarget;
    targetElement.removeClass("drag-over-target");
    if (!this.draggedItemData || !event.dataTransfer) {
      this.draggedItemData = null;
      return;
    }
    const draggedData = { ...this.draggedItemData };
    this.draggedItemData = null;
    const targetFolderPath = targetNode.path;
    const sourceParentPath = (0, import_obsidian12.normalizePath)(draggedData.path.substring(0, draggedData.path.lastIndexOf("/")) || "/");
    if (draggedData.type === "folder" && draggedData.path === targetFolderPath) {
      return;
    }
    if (draggedData.type === "chat" && sourceParentPath === (0, import_obsidian12.normalizePath)(targetFolderPath)) {
      return;
    }
    if (draggedData.type === "folder" && targetFolderPath.startsWith(draggedData.path + "/")) {
      new import_obsidian12.Notice("Cannot move a folder inside itself or its descendants.");
      return;
    }
    let success = false;
    const noticeMessage = `Moving ${draggedData.type} "${draggedData.name}" to "${targetNode.name}"...`;
    const notice = new import_obsidian12.Notice(noticeMessage, 0);
    try {
      if (draggedData.type === "chat") {
        success = await this.plugin.chatManager.moveChat(draggedData.id, draggedData.path, targetFolderPath);
      } else if (draggedData.type === "folder") {
        const folderName = draggedData.name;
        const newPath = (0, import_obsidian12.normalizePath)(`${targetFolderPath}/${folderName}`);
        if (draggedData.path === newPath) {
          success = true;
        } else {
          const exists = await this.app.vault.adapter.exists(newPath);
          if (exists) {
            new import_obsidian12.Notice(`An item named "${folderName}" already exists in the folder "${targetNode.name}".`);
          } else {
            success = await this.plugin.chatManager.renameFolder(draggedData.path, newPath);
            if (success && this.folderExpansionState.has(draggedData.path)) {
              const wasExpanded = this.folderExpansionState.get(draggedData.path);
              this.folderExpansionState.delete(draggedData.path);
              this.folderExpansionState.set(newPath, wasExpanded);
            }
          }
        }
      }
    } catch (error) {
      new import_obsidian12.Notice(`Error moving ${draggedData.type}. Check console.`);
      success = false;
    } finally {
      notice.hide();
      if (success) {
      } else {
      }
    }
  }
  // --- Кінець handleDrop (для окремих папок) ---
  handleDragOverRootParent(event) {
    event.preventDefault();
    if (event.dataTransfer) {
      event.dataTransfer.dropEffect = "move";
    }
    if (!this.draggedItemData) {
      this.chatPanelListContainerEl.removeClass("drag-over-root-target");
      return;
    }
    const directTarget = event.target;
    if (this.chatPanelHeaderEl.contains(directTarget)) {
      this.chatPanelListContainerEl.removeClass("drag-over-root-target");
      this.plugin.logger.trace("[DragOverRootParent] Over chat panel header. No root highlight.");
      return;
    }
    const rootFolderPath = (0, import_obsidian12.normalizePath)(this.plugin.chatManager.chatsFolderPath);
    const draggedPath = this.draggedItemData.path;
    let sourceParentPath = (0, import_obsidian12.normalizePath)(draggedPath.substring(0, draggedPath.lastIndexOf("/")) || "/");
    if (this.draggedItemData.type === "folder" && rootFolderPath === "/" && !draggedPath.includes("/")) {
      sourceParentPath = "/";
    }
    if (this.draggedItemData.type === "folder" && rootFolderPath !== "/" && draggedPath.startsWith(rootFolderPath) && draggedPath.substring(rootFolderPath.length + 1).indexOf("/") === -1 && sourceParentPath === rootFolderPath) {
    }
    if (sourceParentPath === rootFolderPath) {
      this.chatPanelListContainerEl.removeClass("drag-over-root-target");
      this.plugin.logger.trace("[DragOverRootParent] Item already at root, removing root highlight.");
    } else {
      this.chatPanelListContainerEl.addClass("drag-over-root-target");
      this.plugin.logger.trace("[DragOverRootParent] Valid root drop target area. Added root highlight to list container.");
    }
  }
  handleDragEnterRootParent(event) {
    event.preventDefault();
    this.plugin.logger.trace(`[DragEnterRootParent] Mouse entered chatPanel bounds.`);
    this.handleDragOverRootParent(event);
  }
  handleDragLeaveRootParent(event) {
    const listeningElement = event.currentTarget;
    const relatedTarget = event.relatedTarget;
    this.plugin.logger.trace(`[DragLeaveRootParent] Event fired from chatPanel. Related target: ${relatedTarget ? relatedTarget.className : "null"}`);
    if (!relatedTarget || !listeningElement.contains(relatedTarget)) {
      this.chatPanelListContainerEl.removeClass("drag-over-root-target");
    }
  }
  async handleDropRootParent(event) {
    event.preventDefault();
    this.chatPanelListContainerEl.removeClass("drag-over-root-target");
    if (!this.draggedItemData) {
      return;
    }
    const directTarget = event.target;
    if (this.chatPanelHeaderEl.contains(directTarget)) {
      this.draggedItemData = null;
      return;
    }
    const draggedData = { ...this.draggedItemData };
    this.draggedItemData = null;
    const rootFolderPath = (0, import_obsidian12.normalizePath)(this.plugin.chatManager.chatsFolderPath);
    let sourceParentPath = (0, import_obsidian12.normalizePath)(draggedData.path.substring(0, draggedData.path.lastIndexOf("/")) || "/");
    if (draggedData.type === "folder" && rootFolderPath === "/" && !draggedData.path.includes("/")) {
      sourceParentPath = "/";
    }
    if (sourceParentPath === rootFolderPath) {
      return;
    }
    let success = false;
    const notice = new import_obsidian12.Notice(`Moving ${draggedData.type} to root...`, 0);
    try {
      if (draggedData.type === "chat") {
        success = await this.plugin.chatManager.moveChat(draggedData.id, draggedData.path, rootFolderPath);
      } else if (draggedData.type === "folder") {
        const folderName = draggedData.name;
        const newPathAtRoot = (0, import_obsidian12.normalizePath)(rootFolderPath === "/" ? folderName : `${rootFolderPath}/${folderName}`);
        if (draggedData.path === newPathAtRoot) {
          success = true;
        } else {
          const exists = await this.app.vault.adapter.exists(newPathAtRoot);
          if (exists) {
            new import_obsidian12.Notice(`An item named "${folderName}" already exists at the root.`);
          } else {
            success = await this.plugin.chatManager.renameFolder(draggedData.path, newPathAtRoot);
            if (success && this.folderExpansionState.has(draggedData.path)) {
              const wasExpanded = this.folderExpansionState.get(draggedData.path);
              this.folderExpansionState.delete(draggedData.path);
              this.folderExpansionState.set(newPathAtRoot, wasExpanded);
            }
          }
        }
      }
    } catch (error) {
      new import_obsidian12.Notice(`Error moving ${draggedData.type} to root. Check console.`);
      success = false;
    } finally {
      notice.hide();
      if (success) {
      } else {
      }
    }
  }
  // --- Обробники для СПЕЦІАЛЬНОЇ ЗОНИ СКИДАННЯ В КОРІНЬ ---
  handleDragOverRootZone(event) {
    event.preventDefault();
    if (event.dataTransfer) {
      event.dataTransfer.dropEffect = "move";
    }
  }
  handleDragEnterRootZone(event) {
    event.preventDefault();
    const targetElement = event.currentTarget;
    if (!this.draggedItemData) {
      return;
    }
    const rootFolderPath = (0, import_obsidian12.normalizePath)(this.plugin.chatManager.chatsFolderPath);
    const draggedPath = this.draggedItemData.path;
    let sourceParentPath = (0, import_obsidian12.normalizePath)(draggedPath.substring(0, draggedPath.lastIndexOf("/")) || "/");
    if (this.draggedItemData.type === "folder" && rootFolderPath === "/" && !draggedPath.includes("/")) {
      sourceParentPath = "/";
    }
    if (sourceParentPath === rootFolderPath) {
      targetElement.removeClass("drag-over-root-target");
      return;
    }
    targetElement.addClass("drag-over-root-target");
  }
  handleDragLeaveRootZone(event) {
    const targetElement = event.currentTarget;
    this.plugin.logger.trace(`[DragLeaveRootZone] Event fired.`);
    targetElement.removeClass("drag-over-root-target");
  }
  async handleDropRootZone(event) {
    event.preventDefault();
    const targetElement = event.currentTarget;
    targetElement.removeClass("drag-over-root-target");
    if (!this.draggedItemData) {
      return;
    }
    const draggedData = { ...this.draggedItemData };
    this.draggedItemData = null;
    const rootFolderPath = (0, import_obsidian12.normalizePath)(this.plugin.chatManager.chatsFolderPath);
    let sourceParentPath = (0, import_obsidian12.normalizePath)(draggedData.path.substring(0, draggedData.path.lastIndexOf("/")) || "/");
    if (draggedData.type === "folder" && rootFolderPath === "/" && !draggedData.path.includes("/")) {
      sourceParentPath = "/";
    }
    if (sourceParentPath === rootFolderPath) {
      return;
    }
    let success = false;
    const notice = new import_obsidian12.Notice(`Moving ${draggedData.type} to root...`, 0);
    try {
      if (draggedData.type === "chat") {
        success = await this.plugin.chatManager.moveChat(draggedData.id, draggedData.path, rootFolderPath);
      } else if (draggedData.type === "folder") {
        const folderName = draggedData.name;
        const newPathAtRoot = (0, import_obsidian12.normalizePath)(rootFolderPath === "/" ? folderName : `${rootFolderPath}/${folderName}`);
        if (draggedData.path === newPathAtRoot) {
          success = true;
        } else {
          const exists = await this.app.vault.adapter.exists(newPathAtRoot);
          if (exists) {
            new import_obsidian12.Notice(`An item named "${folderName}" already exists at the root.`);
          } else {
            success = await this.plugin.chatManager.renameFolder(draggedData.path, newPathAtRoot);
            if (success && this.folderExpansionState.has(draggedData.path)) {
              const wasExpanded = this.folderExpansionState.get(draggedData.path);
              this.folderExpansionState.delete(draggedData.path);
              this.folderExpansionState.set(newPathAtRoot, wasExpanded);
            }
          }
        }
      }
    } catch (error) {
      new import_obsidian12.Notice(`Error moving ${draggedData.type} to root. Check console.`);
      success = false;
    } finally {
      notice.hide();
      if (success) {
      } else {
      }
    }
  }
};

// src/DropdownMenuManager.ts
var import_obsidian13 = require("obsidian");
var CSS_CLASS_MENU_DROPDOWN = "menu-dropdown";
var CSS_CLASS_MENU_OPTION2 = "menu-option";
var CSS_CLASS_MENU_HEADER_ITEM = "menu-header-item";
var CSS_CLASS_SUBMENU_ICON = "submenu-icon";
var CSS_CLASS_SUBMENU_CONTENT = "submenu-content";
var CSS_CLASS_SETTINGS_OPTION = "settings-option";
var CSS_CLASS_MENU_SEPARATOR = "menu-separator";
var CSS_CLASS_CLEAR_CHAT_OPTION = "clear-chat-option";
var CSS_CLASS_EXPORT_CHAT_OPTION = "export-chat-option";
var CSS_CLASS_MODEL_OPTION = "model-option";
var CSS_CLASS_MODEL_LIST_CONTAINER = "model-list-container";
var CSS_CLASS_ROLE_OPTION = "role-option";
var CSS_CLASS_ROLE_LIST_CONTAINER = "role-list-container";
var CSS_CLASS_CHAT_OPTION = "chat-option";
var CSS_CLASS_CHAT_LIST_CONTAINER = "chat-list-container";
var CSS_CLASS_CHAT_LIST_SCROLLABLE = "chat-list-scrollable";
var CSS_CLASS_NEW_CHAT_OPTION = "new-chat-option";
var CSS_CLASS_RENAME_CHAT_OPTION = "rename-chat-option";
var CSS_CLASS_DELETE_CHAT_OPTION = "delete-chat-option";
var CSS_CLASS_CLONE_CHAT_OPTION = "clone-chat-option";
var CSS_CLASS_TOGGLE_VIEW_LOCATION = "toggle-view-location-option";
var CSS_CLASS_CHAT_LIST_ITEM = "ollama-chat-list-item";
var CSS_HR_AFTER_MODEL = "hr-after-model";
var CSS_HR_AFTER_ROLE = "hr-after-role";
var CSS_HR_AFTER_CHAT = "hr-after-chat";
var CSS_HR_AFTER_ACTIONS = "hr-after-actions";
var CSS_HR_AFTER_DANGER = "hr-after-danger";
var CSS_HR_AFTER_TOGGLE = "hr-after-toggle";
var CHAT_LIST_MAX_HEIGHT = "250px";
var DropdownMenuManager = class {
  constructor(plugin, app, view, parentElement, isSidebarLocation, isDesktop) {
    this.listeners = [];
    // --- Submenu Logic ---
    this.createSubmenuSection = (title, icon, listContainerClass, sectionClass) => {
      const section = this.menuDropdown.createDiv();
      if (sectionClass)
        section.addClass(sectionClass);
      const header = section.createDiv({
        cls: `${CSS_CLASS_MENU_OPTION2} ${CSS_CLASS_MENU_HEADER_ITEM}`
      });
      (0, import_obsidian13.setIcon)(header.createSpan({ cls: "menu-option-icon" }), icon);
      header.createSpan({ cls: "menu-option-text", text: title });
      (0, import_obsidian13.setIcon)(header.createSpan({ cls: CSS_CLASS_SUBMENU_ICON }), "chevron-right");
      const isChatList = listContainerClass === CSS_CLASS_CHAT_LIST_CONTAINER;
      const content = section.createDiv({
        cls: `${CSS_CLASS_SUBMENU_CONTENT} ${CSS_CLASSES.SUBMENU_CONTENT_HIDDEN} ${listContainerClass} ${isChatList ? CSS_CLASS_CHAT_LIST_SCROLLABLE : ""}`
      });
      content.style.maxHeight = "0";
      content.style.overflow = "hidden";
      content.style.transition = "max-height 0.3s ease-out, padding 0.3s ease-out";
      content.style.paddingTop = "0";
      content.style.paddingBottom = "0";
      return { header, content, section };
    };
    this.plugin = plugin;
    this.app = app;
    this.view = view;
    this.parentElement = parentElement;
    this.isSidebarLocation = isSidebarLocation;
    this.isDesktop = isDesktop;
  }
  // --- ОСНОВНИЙ МЕТОД СТВОРЕННЯ МЕНЮ З КЛАСАМИ ДЛЯ РОЗДІЛЬНИКІВ ---
  createMenuUI() {
    this.menuDropdown = this.parentElement.createEl("div", { cls: [CSS_CLASS_MENU_DROPDOWN, "ollama-chat-menu"] });
    this.menuDropdown.style.display = "none";
    this.menuDropdown.classList.toggle("is-desktop", this.isDesktop);
    this.menuDropdown.classList.toggle("is-mobile-tablet", !this.isDesktop);
    this.menuDropdown.classList.toggle("is-sidebar-location", this.isSidebarLocation);
    this.menuDropdown.classList.toggle("is-tab-location", !this.isSidebarLocation);
    const modelSection = this.createSubmenuSection("Select Model", "list-collapse", CSS_CLASS_MODEL_LIST_CONTAINER, "model-submenu-section");
    this.modelSubmenuHeader = modelSection.header;
    this.modelSubmenuContent = modelSection.content;
    this.menuDropdown.createEl("hr", { cls: [CSS_CLASS_MENU_SEPARATOR, CSS_HR_AFTER_MODEL] });
    const roleDropdownSection = this.createSubmenuSection("Select Role", "users", CSS_CLASS_ROLE_LIST_CONTAINER, "role-submenu-section");
    this.roleSubmenuHeader = roleDropdownSection.header;
    this.roleSubmenuContent = roleDropdownSection.content;
    this.menuDropdown.createEl("hr", { cls: [CSS_CLASS_MENU_SEPARATOR, CSS_HR_AFTER_ROLE] });
    const chatDropdownSection = this.createSubmenuSection("Load Chat", "messages-square", CSS_CLASS_CHAT_LIST_CONTAINER, "chat-submenu-section");
    this.chatSubmenuHeader = chatDropdownSection.header;
    this.chatSubmenuContent = chatDropdownSection.content;
    this.menuDropdown.createEl("hr", { cls: [CSS_CLASS_MENU_SEPARATOR, CSS_HR_AFTER_CHAT] });
    this.newChatOption = this.createActionItem("plus-circle", "New Chat", CSS_CLASS_NEW_CHAT_OPTION);
    this.renameChatOption = this.createActionItem("pencil", "Rename Chat", CSS_CLASS_RENAME_CHAT_OPTION);
    this.cloneChatOption = this.createActionItem("copy-plus", "Clone Chat", CSS_CLASS_CLONE_CHAT_OPTION);
    this.exportChatOption = this.createActionItem("download", "Export Chat to Note", CSS_CLASS_EXPORT_CHAT_OPTION);
    this.menuDropdown.createEl("hr", { cls: [CSS_CLASS_MENU_SEPARATOR, CSS_HR_AFTER_ACTIONS] });
    this.clearChatOption = this.createActionItem("trash", "Clear Messages", [CSS_CLASS_CLEAR_CHAT_OPTION, CSS_CLASSES.DANGER_OPTION]);
    this.deleteChatOption = this.createActionItem("trash-2", "Delete Chat", [CSS_CLASS_DELETE_CHAT_OPTION, CSS_CLASSES.DANGER_OPTION]);
    this.menuDropdown.createEl("hr", { cls: [CSS_CLASS_MENU_SEPARATOR, CSS_HR_AFTER_DANGER] });
    this.toggleViewLocationOption = this.menuDropdown.createEl("div", { cls: `${CSS_CLASS_MENU_OPTION2} ${CSS_CLASS_TOGGLE_VIEW_LOCATION}` });
    this.updateToggleViewLocationOption();
    this.menuDropdown.createEl("hr", { cls: [CSS_CLASS_MENU_SEPARATOR, CSS_HR_AFTER_TOGGLE] });
    this.settingsOption = this.createActionItem("settings", "Settings", CSS_CLASS_SETTINGS_OPTION);
  }
  // attachEventListeners залишається таким, як у попередній відповіді (додає слухачі до всіх)
  attachEventListeners() {
    if (!this.modelSubmenuHeader)
      console.error("Model header missing");
    if (!this.roleSubmenuHeader)
      console.error("Role header missing");
    if (!this.chatSubmenuHeader)
      console.error("Chat header missing");
    if (!this.newChatOption)
      console.error("New Chat missing");
    if (!this.renameChatOption)
      console.error("Rename Chat missing");
    if (!this.cloneChatOption)
      console.error("Clone Chat missing");
    if (!this.exportChatOption)
      console.error("Export Chat missing");
    if (!this.clearChatOption)
      console.error("Clear Chat missing");
    if (!this.deleteChatOption)
      console.error("Delete Chat missing");
    if (!this.toggleViewLocationOption)
      console.error("Toggle View missing");
    if (!this.settingsOption)
      console.error("Settings missing");
    if (!this.menuDropdown)
      console.error("menuDropdown missing!");
    if (this.modelSubmenuHeader) {
      this.registerListener(this.modelSubmenuHeader, "click", () => {
        this.toggleSubmenu(this.modelSubmenuHeader, this.modelSubmenuContent, "models");
      });
    }
    if (this.roleSubmenuHeader) {
      this.registerListener(this.roleSubmenuHeader, "click", () => {
        this.toggleSubmenu(this.roleSubmenuHeader, this.roleSubmenuContent, "roles");
      });
    }
    if (this.chatSubmenuHeader) {
      this.registerListener(this.chatSubmenuHeader, "click", () => {
        if (this.chatSubmenuContent) {
          this.toggleSubmenu(this.chatSubmenuHeader, this.chatSubmenuContent, "chats");
        }
      });
    }
    if (this.newChatOption)
      this.registerListener(this.newChatOption, "click", this.view.handleNewChatClick);
    if (this.renameChatOption)
      this.registerListener(this.renameChatOption, "click", () => this.view.handleRenameChatClick());
    if (this.cloneChatOption)
      this.registerListener(this.cloneChatOption, "click", this.view.handleCloneChatClick);
    if (this.exportChatOption)
      this.registerListener(this.exportChatOption, "click", this.view.handleExportChatClick);
    if (this.clearChatOption)
      this.registerListener(this.clearChatOption, "click", this.view.handleClearChatClick);
    if (this.deleteChatOption)
      this.registerListener(this.deleteChatOption, "click", this.view.handleDeleteChatClick);
    if (this.toggleViewLocationOption)
      this.registerListener(this.toggleViewLocationOption, "click", this.view.handleToggleViewLocationClick);
    if (this.settingsOption)
      this.registerListener(this.settingsOption, "click", this.view.handleSettingsClick);
  }
  createActionItem(icon, text, cssClass) {
    const itemEl = this.menuDropdown.createEl("div", {
      cls: Array.isArray(cssClass) ? [CSS_CLASS_MENU_OPTION2, ...cssClass] : [CSS_CLASS_MENU_OPTION2, cssClass]
    });
    (0, import_obsidian13.setIcon)(itemEl.createSpan({ cls: "menu-option-icon" }), icon);
    itemEl.createSpan({ cls: "menu-option-text", text });
    return itemEl;
  }
  registerListener(element, type, handler) {
    const eventHandler = handler;
    element.addEventListener(type, eventHandler);
    this.listeners.push({ element, type, handler: eventHandler });
  }
  destroy() {
    this.listeners.forEach(({ element, type, handler }) => {
      element.removeEventListener(type, handler);
    });
    this.listeners = [];
  }
  // --- Menu Visibility and State ---
  isMenuOpen() {
    return !!this.menuDropdown && this.menuDropdown.style.display === "block";
  }
  toggleMenu(event) {
    event.stopPropagation();
    if (!this.menuDropdown) {
      console.error("[DropdownMenuManager] menuDropdown missing!");
      return;
    }
    const isHidden = this.menuDropdown.style.display === "none";
    if (isHidden) {
      this.menuDropdown.style.display = "block";
      this.collapseAllSubmenus(null);
    } else {
      this.closeMenu();
    }
  }
  closeMenu() {
    if (this.menuDropdown) {
      this.menuDropdown.style.display = "none";
      this.collapseAllSubmenus(null);
    }
  }
  handleDocumentClick(event, menuButton) {
    var _a;
    if (this.isMenuOpen() && !(menuButton == null ? void 0 : menuButton.contains(event.target)) && !((_a = this.menuDropdown) == null ? void 0 : _a.contains(event.target))) {
      this.closeMenu();
    }
  }
  async toggleSubmenu(headerEl, contentEl, type) {
    if (!headerEl || !contentEl)
      return;
    const iconEl = headerEl.querySelector(`.${CSS_CLASS_SUBMENU_ICON}`);
    const isHidden = contentEl.style.maxHeight === "0px" || contentEl.classList.contains(CSS_CLASSES.SUBMENU_CONTENT_HIDDEN);
    if (isHidden) {
      this.collapseAllSubmenus(contentEl);
    }
    if (isHidden) {
      if (iconEl instanceof HTMLElement)
        (0, import_obsidian13.setIcon)(iconEl, "chevron-down");
      contentEl.empty();
      contentEl.createDiv({
        cls: "menu-loading",
        text: `Loading ${type}...`
      });
      contentEl.classList.remove(CSS_CLASSES.SUBMENU_CONTENT_HIDDEN);
      contentEl.style.maxHeight = "40px";
      contentEl.style.paddingTop = "5px";
      contentEl.style.paddingBottom = "5px";
      contentEl.style.overflowY = "hidden";
      try {
        switch (type) {
          case "models":
            await this.renderModelList();
            break;
          case "roles":
            await this.renderRoleList();
            break;
          case "chats":
            await this.renderChatListMenu();
            break;
        }
        requestAnimationFrame(() => {
          if (!contentEl.classList.contains(CSS_CLASSES.SUBMENU_CONTENT_HIDDEN)) {
            this.plugin.logger.trace(`[DropdownMenuManager] Setting submenu height for ${type}`);
            if (type === "chats") {
              contentEl.style.maxHeight = CHAT_LIST_MAX_HEIGHT;
              contentEl.style.overflowY = "auto";
            } else {
              contentEl.style.maxHeight = contentEl.scrollHeight + "px";
              contentEl.style.overflowY = "hidden";
            }
          }
        });
      } catch (error) {
        this.plugin.logger.error(`[DropdownMenuManager] Error rendering ${type} list:`, error);
        contentEl.empty();
        contentEl.createDiv({ cls: "menu-error-text", text: `Error loading ${type}.` });
        contentEl.style.maxHeight = "50px";
        contentEl.style.overflowY = "hidden";
      }
    } else {
      contentEl.classList.add(CSS_CLASSES.SUBMENU_CONTENT_HIDDEN);
      contentEl.style.maxHeight = "0";
      contentEl.style.paddingTop = "0";
      contentEl.style.paddingBottom = "0";
      contentEl.style.overflowY = "hidden";
      if (iconEl instanceof HTMLElement)
        (0, import_obsidian13.setIcon)(iconEl, "chevron-right");
    }
  }
  collapseAllSubmenus(exceptContent) {
    const submenus = [
      { header: this.modelSubmenuHeader, content: this.modelSubmenuContent },
      { header: this.roleSubmenuHeader, content: this.roleSubmenuContent },
      { header: this.chatSubmenuHeader, content: this.chatSubmenuContent }
    ];
    submenus.forEach((submenu) => {
      if (submenu.content && submenu.header && submenu.content !== exceptContent) {
        if (!submenu.content.classList.contains(CSS_CLASSES.SUBMENU_CONTENT_HIDDEN)) {
          this.plugin.logger.trace(`[DropdownMenuManager] Collapsing submenu.`);
          submenu.content.classList.add(CSS_CLASSES.SUBMENU_CONTENT_HIDDEN);
          submenu.content.style.maxHeight = "0";
          submenu.content.style.paddingTop = "0";
          submenu.content.style.paddingBottom = "0";
          submenu.content.style.overflowY = "hidden";
          const iconEl = submenu.header.querySelector(`.${CSS_CLASS_SUBMENU_ICON}`);
          if (iconEl instanceof HTMLElement) {
            (0, import_obsidian13.setIcon)(iconEl, "chevron-right");
          }
        }
      }
    });
  }
  // --- List Rendering / Update ---
  async renderModelList() {
    var _a, _b;
    const container = this.modelSubmenuContent;
    if (!container)
      return;
    container.empty();
    const modelIconMap = { llama: "box-minimal", mistral: "wind" };
    const defaultIcon = "box";
    try {
      const models = await this.plugin.ollamaService.getModels();
      const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
      const currentModelName = ((_b = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _b.modelName) || this.plugin.settings.modelName;
      if (models.length === 0) {
        container.createEl("div", { cls: "menu-info-text", text: "No models available." });
        return;
      }
      models.forEach((modelName) => {
        const optionEl = container.createDiv({ cls: `${CSS_CLASS_MENU_OPTION2} ${CSS_CLASS_MODEL_OPTION}` });
        const iconSpan = optionEl.createEl("span", { cls: "menu-option-icon" });
        let iconToUse = defaultIcon;
        if (modelName === currentModelName) {
          iconToUse = "check";
          optionEl.addClass("is-selected");
        } else {
          const l = modelName.toLowerCase();
          let f = false;
          for (const k in modelIconMap) {
            if (l.includes(k)) {
              iconToUse = modelIconMap[k];
              f = true;
              break;
            }
          }
          if (!f)
            iconToUse = defaultIcon;
        }
        try {
          (0, import_obsidian13.setIcon)(iconSpan, iconToUse);
        } catch (e) {
          iconSpan.style.minWidth = "18px";
        }
        optionEl.createEl("span", { cls: "menu-option-text", text: modelName });
        this.registerListener(optionEl, "click", async () => {
          var _a2, _b2;
          const latestChat = await ((_a2 = this.plugin.chatManager) == null ? void 0 : _a2.getActiveChat());
          const latestModel = ((_b2 = latestChat == null ? void 0 : latestChat.metadata) == null ? void 0 : _b2.modelName) || this.plugin.settings.modelName;
          if (modelName !== latestModel) {
            if (latestChat) {
              await this.plugin.chatManager.updateActiveChatMetadata({ modelName });
            } else {
              new import_obsidian13.Notice("Cannot set model: No active chat.");
            }
          }
          this.closeMenu();
        });
      });
    } catch (error) {
      this.plugin.logger.error("[DropdownMenuManager] Error rendering model list:", error);
      container.empty();
      container.createEl("div", { cls: "menu-error-text", text: "Error loading models." });
    }
  }
  async renderRoleList() {
    var _a, _b, _c;
    const container = this.roleSubmenuContent;
    if (!container)
      return;
    container.empty();
    try {
      const roles = await this.plugin.listRoleFiles(true);
      const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
      const currentChatRolePath = (_c = (_b = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _b.selectedRolePath) != null ? _c : this.plugin.settings.selectedRolePath;
      const noRoleOptionEl = container.createDiv({ cls: `${CSS_CLASS_MENU_OPTION2} ${CSS_CLASS_ROLE_OPTION}` });
      const noRoleIconSpan = noRoleOptionEl.createEl("span", { cls: "menu-option-icon" });
      if (!currentChatRolePath) {
        (0, import_obsidian13.setIcon)(noRoleIconSpan, "check");
        noRoleOptionEl.addClass("is-selected");
      } else {
        (0, import_obsidian13.setIcon)(noRoleIconSpan, "slash");
        noRoleIconSpan.style.minWidth = "18px";
      }
      noRoleOptionEl.createEl("span", { cls: "menu-option-text", text: "None" });
      this.registerListener(noRoleOptionEl, "click", async () => {
        var _a2, _b2, _c2, _d, _e;
        const newRolePath = "";
        const latestChat = await ((_a2 = this.plugin.chatManager) == null ? void 0 : _a2.getActiveChat());
        const latestRolePath = (_c2 = (_b2 = latestChat == null ? void 0 : latestChat.metadata) == null ? void 0 : _b2.selectedRolePath) != null ? _c2 : this.plugin.settings.selectedRolePath;
        if (latestRolePath !== newRolePath) {
          this.plugin.logger.trace(`Current path '${latestRolePath}', new path '${newRolePath}'`);
          if (latestChat) {
            await this.plugin.chatManager.updateActiveChatMetadata({ selectedRolePath: newRolePath });
          } else {
            this.plugin.settings.selectedRolePath = newRolePath;
            await this.plugin.saveSettings();
            this.plugin.emit("role-changed", "None");
            (_e = (_d = this.plugin.promptService) == null ? void 0 : _d.clearRoleCache) == null ? void 0 : _e.call(_d);
          }
        }
        this.closeMenu();
      });
      if (roles.length > 0)
        container.createEl("hr", { cls: CSS_CLASS_MENU_SEPARATOR });
      roles.forEach((roleInfo) => {
        const roleOptionEl = container.createDiv({ cls: `${CSS_CLASS_MENU_OPTION2} ${CSS_CLASS_ROLE_OPTION}` });
        if (roleInfo.isCustom)
          roleOptionEl.addClass("is-custom");
        const iconSpan = roleOptionEl.createEl("span", { cls: "menu-option-icon" });
        if (roleInfo.path === currentChatRolePath) {
          (0, import_obsidian13.setIcon)(iconSpan, "check");
          roleOptionEl.addClass("is-selected");
        } else {
          (0, import_obsidian13.setIcon)(iconSpan, roleInfo.isCustom ? "user" : "box");
          iconSpan.style.minWidth = "18px";
        }
        roleOptionEl.createEl("span", { cls: "menu-option-text", text: roleInfo.name });
        this.registerListener(roleOptionEl, "click", async () => {
          var _a2, _b2, _c2, _d, _e;
          this.plugin.logger.debug(`[DropdownMenuManager] Role selected: ${roleInfo.name} (${roleInfo.path})`);
          const newRolePath = roleInfo.path;
          const latestChat = await ((_a2 = this.plugin.chatManager) == null ? void 0 : _a2.getActiveChat());
          const latestRolePath = (_c2 = (_b2 = latestChat == null ? void 0 : latestChat.metadata) == null ? void 0 : _b2.selectedRolePath) != null ? _c2 : this.plugin.settings.selectedRolePath;
          if (latestRolePath !== newRolePath) {
            this.plugin.logger.trace(`Current path '${latestRolePath}', new path '${newRolePath}'`);
            if (latestChat) {
              await this.plugin.chatManager.updateActiveChatMetadata({ selectedRolePath: newRolePath });
            } else {
              this.plugin.settings.selectedRolePath = newRolePath;
              await this.plugin.saveSettings();
              this.plugin.emit("role-changed", roleInfo.name);
              (_e = (_d = this.plugin.promptService) == null ? void 0 : _d.clearRoleCache) == null ? void 0 : _e.call(_d);
            }
          }
          this.closeMenu();
        });
      });
    } catch (error) {
      this.plugin.logger.error("[DropdownMenuManager] Error rendering role list:", error);
      container.empty();
      container.createEl("div", { cls: "menu-error-text", text: "Error loading roles." });
    }
  }
  async renderChatListMenu() {
    var _a, _b;
    const container = this.chatSubmenuContent;
    if (!container) {
      return;
    }
    container.empty();
    try {
      const chats = ((_a = this.plugin.chatManager) == null ? void 0 : _a.listAvailableChats()) || [];
      const currentActiveId = (_b = this.plugin.chatManager) == null ? void 0 : _b.getActiveChatId();
      if (chats.length === 0) {
        container.createEl("div", { cls: "menu-info-text", text: "No saved chats." });
        return;
      }
      chats.forEach((chatMeta) => {
        const chatOptionEl = container.createDiv({
          cls: [CSS_CLASS_MENU_OPTION2, CSS_CLASS_CHAT_LIST_ITEM, CSS_CLASS_CHAT_OPTION]
        });
        const iconSpan = chatOptionEl.createEl("span", { cls: "menu-option-icon" });
        if (chatMeta.id === currentActiveId) {
          (0, import_obsidian13.setIcon)(iconSpan, "check");
          chatOptionEl.addClass("is-selected");
        } else {
          (0, import_obsidian13.setIcon)(iconSpan, "message-square");
        }
        const textSpan = chatOptionEl.createEl("span", { cls: "menu-option-text" });
        textSpan.createEl("div", { cls: "chat-option-name", text: chatMeta.name });
        const lastModifiedDate = new Date(chatMeta.lastModified);
        const dateText = !isNaN(lastModifiedDate.getTime()) ? this.view.formatRelativeDate(lastModifiedDate) : "Invalid date";
        if (dateText === "Invalid date") {
        }
        textSpan.createEl("div", { cls: "chat-option-date", text: dateText });
        this.registerListener(chatOptionEl, "click", async () => {
          var _a2;
          this.plugin.logger.debug(`[DropdownMenuManager] Chat selected: ${chatMeta.name} (${chatMeta.id})`);
          const latestActiveId = (_a2 = this.plugin.chatManager) == null ? void 0 : _a2.getActiveChatId();
          if (chatMeta.id !== latestActiveId) {
            await this.plugin.chatManager.setActiveChat(chatMeta.id);
          }
          this.closeMenu();
        });
      });
    } catch (error) {
      this.plugin.logger.error("[DropdownMenuManager] Error rendering chat list:", error);
      container.empty();
      container.createEl("div", { cls: "menu-error-text", text: "Error loading chats." });
    }
  }
  // --- UI Updates ---
  updateToggleViewLocationOption() {
    if (!this.toggleViewLocationOption)
      return;
    this.toggleViewLocationOption.empty();
    const iconSpan = this.toggleViewLocationOption.createSpan({ cls: "menu-option-icon" });
    const textSpan = this.toggleViewLocationOption.createSpan({ cls: "menu-option-text" });
    if (this.plugin.settings.openChatInTab) {
      (0, import_obsidian13.setIcon)(iconSpan, "sidebar-right");
      textSpan.setText("Show in Sidebar");
      this.toggleViewLocationOption.title = "Close tab and reopen in sidebar";
    } else {
      (0, import_obsidian13.setIcon)(iconSpan, "layout-list");
      textSpan.setText("Show in Tab");
      this.toggleViewLocationOption.title = "Close sidebar panel and reopen in tab";
    }
  }
  // --- Update Trigger Methods (Called by OllamaView) ---
  async updateModelListIfVisible() {
    if (this.isMenuOpen() && this.modelSubmenuContent && !this.modelSubmenuContent.classList.contains(CSS_CLASSES.SUBMENU_CONTENT_HIDDEN)) {
      await this.renderModelList();
      this.updateSubmenuHeight(this.modelSubmenuContent);
    }
  }
  async updateRoleListIfVisible() {
    if (this.isMenuOpen() && this.roleSubmenuContent && !this.roleSubmenuContent.classList.contains(CSS_CLASSES.SUBMENU_CONTENT_HIDDEN)) {
      await this.renderRoleList();
      this.updateSubmenuHeight(this.roleSubmenuContent);
    }
  }
  async updateChatListIfVisible() {
    if (this.isMenuOpen() && this.chatSubmenuContent && !this.chatSubmenuContent.classList.contains(CSS_CLASSES.SUBMENU_CONTENT_HIDDEN)) {
      await this.renderChatListMenu();
    }
  }
  updateSubmenuHeight(contentEl) {
    if (contentEl && !contentEl.classList.contains(CSS_CLASSES.SUBMENU_CONTENT_HIDDEN)) {
      requestAnimationFrame(() => {
        if (contentEl && !contentEl.classList.contains(CSS_CLASSES.SUBMENU_CONTENT_HIDDEN)) {
          this.plugin.logger.trace("[DropdownMenuManager] Updating submenu height.");
          if (!contentEl.classList.contains(CSS_CLASS_CHAT_LIST_CONTAINER)) {
            contentEl.style.maxHeight = contentEl.scrollHeight + "px";
          }
        }
      });
    }
  }
};

// src/renderers/ToolMessageRenderer.ts
var import_obsidian14 = require("obsidian");
var ToolMessageRenderer = class extends BaseMessageRenderer {
  constructor(app, plugin, message, view) {
    super(app, plugin, message, view);
  }
  render() {
    const messageGroupEl = this.createMessageGroupWrapper([CSS_CLASSES.TOOL_MESSAGE_GROUP || "tool-message-group"]);
    this.addAvatar(messageGroupEl, false);
    const messageWrapperEl = messageGroupEl.createDiv({ cls: CSS_CLASSES.MESSAGE_WRAPPER });
    const { messageEl, contentContainer, contentEl } = this.createMessageBubble(
      messageWrapperEl,
      [CSS_CLASSES.TOOL_MESSAGE]
    );
    this.renderToolSpecificContent(contentEl, this.message.content);
    BaseMessageRenderer.addTimestamp(messageEl, this.message.timestamp, this.view);
    this.addBaseActionButtons(messageEl, this.message.content);
    return messageGroupEl;
  }
  renderToolSpecificContent(contentEl, rawContentWithMarkers) {
    contentEl.empty();
    const toolHeader = contentEl.createDiv({ cls: CSS_CLASSES.TOOL_RESULT_HEADER });
    const iconSpan = toolHeader.createSpan({ cls: CSS_CLASSES.TOOL_RESULT_ICON });
    (0, import_obsidian14.setIcon)(iconSpan, "wrench");
    toolHeader.createSpan({
      text: `Tool Executed: ${this.message.name || "Unknown Tool"}`
    });
    const preEl = contentEl.createEl("pre", { cls: CSS_CLASSES.TOOL_RESULT_CONTENT });
    const codeEl = preEl.createEl("code");
    let displayContent = rawContentWithMarkers;
    const toolResultStartMarker = "[TOOL_RESULT]\n";
    const toolResultEndMarker = "\n[/TOOL_RESULT]";
    const toolErrorStartMarker = "[TOOL_ERROR]\n";
    const toolErrorEndMarker = "\n[/TOOL_ERROR]";
    if (displayContent.startsWith(toolResultStartMarker) && displayContent.endsWith(toolResultEndMarker)) {
      displayContent = displayContent.substring(toolResultStartMarker.length, displayContent.length - toolResultEndMarker.length);
    } else if (displayContent.startsWith(toolErrorStartMarker) && displayContent.endsWith(toolErrorEndMarker)) {
      displayContent = displayContent.substring(toolErrorStartMarker.length, displayContent.length - toolErrorEndMarker.length);
      preEl.addClass("tool-execution-error-display");
    }
    codeEl.setText(displayContent.trim());
  }
  // Перевизначаємо addAvatar, якщо потрібна особлива логіка для аватара інструменту.
  // Якщо стандартної логіки з BaseMessageRenderer + RendererUtils.renderAvatar достатньо,
  // цей метод можна не перевизначати (але тоді треба передавати isUser=false).
  // У вашому BaseMessageRenderer `addAvatar` не є абстрактним, тому його можна просто викликати.
  // Для прикладу, якщо RendererUtils.renderAvatar підтримує тип 'tool':
  // protected addAvatar(messageGroup: HTMLElement): void {
  //   RendererUtils.renderAvatar(this.app, this.plugin, messageGroup, false, 'tool');
  // }
  // Якщо ні, то виклик this.addAvatar(messageGroupEl, false); з render() використає реалізацію з BaseMessageRenderer.
};

// src/OllamaView.ts
var VIEW_TYPE_OLLAMA_PERSONAS = "ollama-personas-chat-view";
var SCROLL_THRESHOLD = 150;
var CSS_CLASS_TRANSLATING_INPUT = "translating-input";
var CSS_CLASS_EMPTY_STATE = "ollama-empty-state";
var CSS_CLASS_MESSAGE = "message";
var CSS_CLASS_ERROR_TEXT2 = "error-message-text";
var CSS_CLASS_TRANSLATION_CONTAINER = "translation-container";
var CSS_CLASS_TRANSLATION_CONTENT = "translation-content";
var CSS_CLASS_TRANSLATION_PENDING = "translation-pending";
var CSS_CLASS_RECORDING = "recording";
var CSS_CLASS_DISABLED = "disabled";
var CSS_CLASS_DATE_SEPARATOR = "chat-date-separator";
var CSS_CLASS_VISIBLE = "visible";
var CSS_CLASS_CONTENT_COLLAPSED = "message-content-collapsed";
var CSS_CLASS_MENU_OPTION3 = "menu-option";
var CSS_ROLE_PANEL_ITEM2 = "ollama-role-panel-item";
var CSS_ROLE_PANEL_ITEM_ICON2 = "ollama-role-panel-item-icon";
var CSS_ROLE_PANEL_ITEM_TEXT2 = "ollama-role-panel-item-text";
var CSS_ROLE_PANEL_ITEM_ACTIVE2 = "is-active";
var CSS_ROLE_PANEL_ITEM_CUSTOM2 = "is-custom";
var CSS_ROLE_PANEL_ITEM_NONE2 = "ollama-role-panel-item-none";
var CSS_CHAT_ITEM_OPTIONS = "ollama-chat-item-options";
var CSS_CLASS_CHAT_LIST_ITEM2 = "ollama-chat-list-item";
var CSS_CLASS_RESIZER_HANDLE = "ollama-resizer-handle";
var CSS_CLASS_RESIZING = "is-resizing";
var OllamaView = class extends import_obsidian15.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.isProcessing = false;
    this.scrollTimeout = null;
    this.speechWorker = null;
    this.mediaRecorder = null;
    this.audioStream = null;
    this.emptyStateEl = null;
    this.resizeTimeout = null;
    this.currentMessages = [];
    this.lastRenderedMessageDate = null;
    this.newMessagesIndicatorEl = null;
    this.userScrolledUp = false;
    this.lastProcessedChatId = null;
    this.currentAbortController = null;
    this.lastMessageElement = null;
    this.consecutiveErrorMessages = [];
    this.errorGroupElement = null;
    this.isSummarizingErrors = false;
    this.isRegenerating = false;
    this.messageAddedResolvers = /* @__PURE__ */ new Map();
    this.isChatListUpdateScheduled = false;
    this.chatListUpdateTimeoutId = null;
    this.activePlaceholder = null;
    this.isResizing = false;
    this.initialMouseX = 0;
    this.initialSidebarWidth = 0;
    this.cancelGeneration = () => {
      if (this.currentAbortController) {
        this.currentAbortController.abort();
      } else {
      }
    };
    this.handleMessageDeleted = (data) => {
      var _a;
      const currentActiveChatId = (_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChatId();
      if (data.chatId !== currentActiveChatId || !this.chatContainer) {
        return;
      }
      const timestampMs = data.timestamp.getTime();
      const selector = `.${CSS_CLASSES.MESSAGE_GROUP}[data-timestamp="${timestampMs}"]`;
      try {
        const messageGroupEl = this.chatContainer.querySelector(selector);
        if (messageGroupEl instanceof HTMLElement) {
          const currentScrollTop = this.chatContainer.scrollTop;
          const removedHeight = messageGroupEl.offsetHeight;
          const wasAboveViewport = messageGroupEl.offsetTop < currentScrollTop;
          messageGroupEl.remove();
          const initialLength = this.currentMessages.length;
          this.currentMessages = this.currentMessages.filter((msg) => msg.timestamp.getTime() !== timestampMs);
          if (wasAboveViewport) {
            const newScrollTop = currentScrollTop - removedHeight;
            this.chatContainer.scrollTop = newScrollTop >= 0 ? newScrollTop : 0;
          } else {
            this.chatContainer.scrollTop = currentScrollTop;
          }
          if (this.currentMessages.length === 0) {
            this.showEmptyState();
          }
        } else if (messageGroupEl) {
          this.loadAndDisplayActiveChat();
        } else {
        }
      } catch (error) {
        this.loadAndDisplayActiveChat();
      }
    };
    this.updateRolePanelList = async () => {
      var _a, _b, _c;
      const container = this.rolePanelListEl;
      if (!container || !this.plugin.chatManager) {
        return;
      }
      if (((_a = this.rolePanelHeaderEl) == null ? void 0 : _a.getAttribute("data-collapsed")) === "true") {
        return;
      }
      const currentScrollTop = container.scrollTop;
      container.empty();
      try {
        const roles = await this.plugin.listRoleFiles(true);
        const activeChat = await this.plugin.chatManager.getActiveChat();
        const currentRolePath = (_c = (_b = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _b.selectedRolePath) != null ? _c : this.plugin.settings.selectedRolePath;
        const noneOptionEl = container.createDiv({ cls: [CSS_ROLE_PANEL_ITEM2, CSS_ROLE_PANEL_ITEM_NONE2, "menu-option"] });
        const noneIconSpan = noneOptionEl.createSpan({ cls: [CSS_ROLE_PANEL_ITEM_ICON2, "menu-option-icon"] });
        noneOptionEl.createSpan({ cls: [CSS_ROLE_PANEL_ITEM_TEXT2, "menu-option-text"], text: "None" });
        if (!currentRolePath) {
          noneOptionEl.addClass(CSS_ROLE_PANEL_ITEM_ACTIVE2);
          (0, import_obsidian15.setIcon)(noneIconSpan, "check");
        } else {
          (0, import_obsidian15.setIcon)(noneIconSpan, "slash");
        }
        this.registerDomEvent(noneOptionEl, "click", () => this.handleRolePanelItemClick(null, currentRolePath));
        roles.forEach((roleInfo) => {
          const roleOptionEl = container.createDiv({ cls: [CSS_ROLE_PANEL_ITEM2, "menu-option"] });
          const iconSpan = roleOptionEl.createSpan({ cls: [CSS_ROLE_PANEL_ITEM_ICON2, "menu-option-icon"] });
          roleOptionEl.createSpan({ cls: [CSS_ROLE_PANEL_ITEM_TEXT2, "menu-option-text"], text: roleInfo.name });
          if (roleInfo.isCustom) {
            roleOptionEl.addClass(CSS_ROLE_PANEL_ITEM_CUSTOM2);
          }
          if (roleInfo.path === currentRolePath) {
            roleOptionEl.addClass(CSS_ROLE_PANEL_ITEM_ACTIVE2);
            (0, import_obsidian15.setIcon)(iconSpan, "check");
          } else {
            (0, import_obsidian15.setIcon)(iconSpan, roleInfo.isCustom ? "user" : "file-text");
          }
          this.registerDomEvent(roleOptionEl, "click", () => this.handleRolePanelItemClick(roleInfo, currentRolePath));
        });
      } catch (error) {
        container.empty();
        container.createDiv({ text: "Error loading roles.", cls: "menu-error-text" });
      } finally {
        requestAnimationFrame(() => {
          container.scrollTop = currentScrollTop;
        });
      }
    };
    this.handleRolePanelItemClick = async (roleInfo, currentRolePath) => {
      var _a, _b, _c, _d, _e;
      const newRolePath = (_a = roleInfo == null ? void 0 : roleInfo.path) != null ? _a : "";
      const roleNameForEvent = (_b = roleInfo == null ? void 0 : roleInfo.name) != null ? _b : "None";
      if (newRolePath !== currentRolePath) {
        const activeChat = await ((_c = this.plugin.chatManager) == null ? void 0 : _c.getActiveChat());
        try {
          if (activeChat) {
            await this.plugin.chatManager.updateActiveChatMetadata({
              selectedRolePath: newRolePath
            });
          } else {
            this.plugin.settings.selectedRolePath = newRolePath;
            await this.plugin.saveSettings();
            this.plugin.emit("role-changed", roleNameForEvent);
            (_e = (_d = this.plugin.promptService) == null ? void 0 : _d.clearRoleCache) == null ? void 0 : _e.call(_d);
          }
        } catch (error) {
          new import_obsidian15.Notice("Failed to set the role.");
        }
      } else {
      }
    };
    this.handleModelDisplayClick = async (event) => {
      var _a, _b;
      const menu = new import_obsidian15.Menu();
      let itemsAdded = false;
      const loadingNotice = new import_obsidian15.Notice("Loading models...", 0);
      try {
        const models = await this.plugin.ollamaService.getModels();
        const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
        const currentModelName = ((_b = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _b.modelName) || this.plugin.settings.modelName;
        loadingNotice.hide();
        if (models.length === 0) {
          menu.addItem((item) => item.setTitle("No models found").setDisabled(true));
          itemsAdded = true;
        } else {
          models.forEach((modelName) => {
            menu.addItem(
              (item) => item.setTitle(modelName).setIcon(modelName === currentModelName ? "check" : "radio-button").onClick(async () => {
                var _a2, _b2;
                const chatToUpdate = await ((_a2 = this.plugin.chatManager) == null ? void 0 : _a2.getActiveChat());
                const latestModelName = ((_b2 = chatToUpdate == null ? void 0 : chatToUpdate.metadata) == null ? void 0 : _b2.modelName) || this.plugin.settings.modelName;
                if (modelName !== latestModelName) {
                  if (chatToUpdate) {
                    await this.plugin.chatManager.updateActiveChatMetadata({
                      modelName
                    });
                  } else {
                    new import_obsidian15.Notice("Cannot set model: No active chat.");
                  }
                }
              })
            );
            itemsAdded = true;
          });
        }
      } catch (error) {
        loadingNotice.hide();
        console.error("Error loading models for model selection menu:", error);
        menu.addItem((item) => item.setTitle("Error loading models").setDisabled(true));
        itemsAdded = true;
        new import_obsidian15.Notice("Failed to load models. Check Ollama connection.");
      } finally {
        if (itemsAdded) {
          menu.showAtMouseEvent(event);
        } else {
          console.warn("Model menu was not shown because no items were added.");
        }
      }
    };
    this.handleKeyDown = (e) => {
      var _a;
      if (e.key === "Enter" && !e.shiftKey && !this.isProcessing && !((_a = this.sendButton) == null ? void 0 : _a.disabled)) {
        e.preventDefault();
        this.sendMessage();
      }
    };
    this.handleSendClick = () => {
      var _a;
      if (!this.isProcessing && !((_a = this.sendButton) == null ? void 0 : _a.disabled)) {
        this.sendMessage();
      } else {
      }
    };
    this.handleInputForResize = () => {
      if (this.resizeTimeout)
        clearTimeout(this.resizeTimeout);
      this.resizeTimeout = setTimeout(() => {
        this.adjustTextareaHeight();
        this.updateSendButtonState();
      }, 75);
    };
    this.handleVoiceClick = () => {
      this.toggleVoiceRecognition();
    };
    this.handleTranslateInputClick = async () => {
      const currentText = this.inputEl.value;
      const targetLang = this.plugin.settings.translationTargetLanguage;
      if (!currentText.trim()) {
        new import_obsidian15.Notice("Input is empty, nothing to translate.");
        return;
      }
      if (!this.plugin.settings.enableTranslation || this.plugin.settings.translationProvider === "none") {
        new import_obsidian15.Notice("Translation disabled or provider not selected in settings.");
        return;
      }
      if (!targetLang) {
        new import_obsidian15.Notice("Target language for translation is not set in settings.");
        return;
      }
      (0, import_obsidian15.setIcon)(this.translateInputButton, "loader");
      this.translateInputButton.disabled = true;
      this.translateInputButton.classList.add(CSS_CLASS_TRANSLATING_INPUT);
      this.translateInputButton.title = "Translating...";
      try {
        const translatedText = await this.plugin.translationService.translate(currentText, "English");
        if (translatedText !== null) {
          this.inputEl.value = translatedText;
          this.inputEl.dispatchEvent(new Event("input"));
          this.inputEl.focus();
          if (translatedText) {
            const end = translatedText.length;
            this.inputEl.setSelectionRange(end, end);
          }
        } else {
        }
      } catch (error) {
        new import_obsidian15.Notice("Input translation encountered an unexpected error.");
      } finally {
        (0, import_obsidian15.setIcon)(this.translateInputButton, "languages");
        this.translateInputButton.disabled = this.isProcessing;
        this.translateInputButton.classList.remove(CSS_CLASS_TRANSLATING_INPUT);
        this.translateInputButton.title = `Translate input to ${LANGUAGES[targetLang] || targetLang}`;
      }
    };
    this.handleNewChatClick = async () => {
      var _a;
      (_a = this.dropdownMenuManager) == null ? void 0 : _a.closeMenu();
      try {
        const newChat = await this.plugin.chatManager.createNewChat();
        if (newChat) {
          new import_obsidian15.Notice(`Created new chat: ${newChat.metadata.name}`);
          this.focusInput();
        } else {
          new import_obsidian15.Notice("Failed to create new chat.");
        }
      } catch (error) {
        new import_obsidian15.Notice("Error creating new chat.");
      }
    };
    this.handleRenameChatClick = async (chatIdToRename, currentChatName) => {
      var _a, _b;
      let chatId = chatIdToRename != null ? chatIdToRename : null;
      let currentName = currentChatName != null ? currentChatName : null;
      if (!chatId || !currentName) {
        const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
        if (!activeChat) {
          new import_obsidian15.Notice("No active chat to rename.");
          return;
        }
        chatId = activeChat.metadata.id;
        currentName = activeChat.metadata.name;
      }
      (_b = this.dropdownMenuManager) == null ? void 0 : _b.closeMenu();
      if (!chatId || currentName === null) {
        new import_obsidian15.Notice("Could not initiate rename process.");
        return;
      }
      new PromptModal(this.app, "Rename Chat", `Enter new name for "${currentName}":`, currentName, async (newName) => {
        let noticeMessage = "Rename cancelled or name unchanged.";
        const trimmedName = newName == null ? void 0 : newName.trim();
        if (trimmedName && trimmedName !== "" && trimmedName !== currentName) {
          const success = await this.plugin.chatManager.renameChat(chatId, trimmedName);
          if (success) {
            noticeMessage = `Chat renamed to "${trimmedName}"`;
          } else {
            noticeMessage = "Failed to rename chat.";
          }
        } else if (trimmedName && trimmedName === currentName) {
          noticeMessage = "Name unchanged.";
        } else if (newName === null || trimmedName === "") {
          noticeMessage = "Rename cancelled or invalid name entered.";
        }
        new import_obsidian15.Notice(noticeMessage);
        this.focusInput();
      }).open();
    };
    this.handleCloneChatClick = async () => {
      var _a, _b;
      (_a = this.dropdownMenuManager) == null ? void 0 : _a.closeMenu();
      const activeChat = await ((_b = this.plugin.chatManager) == null ? void 0 : _b.getActiveChat());
      if (!activeChat) {
        new import_obsidian15.Notice("No active chat to clone.");
        return;
      }
      const cloningNotice = new import_obsidian15.Notice("Cloning chat...", 0);
      try {
        const clonedChat = await this.plugin.chatManager.cloneChat(activeChat.metadata.id);
        if (clonedChat) {
          new import_obsidian15.Notice(`Chat cloned as "${clonedChat.metadata.name}" and activated.`);
        } else {
          new import_obsidian15.Notice("Failed to clone chat.");
        }
      } catch (error) {
        new import_obsidian15.Notice("An error occurred while cloning the chat.");
      } finally {
        cloningNotice.hide();
      }
    };
    this.handleClearChatClick = async () => {
      var _a, _b;
      (_a = this.dropdownMenuManager) == null ? void 0 : _a.closeMenu();
      const activeChat = await ((_b = this.plugin.chatManager) == null ? void 0 : _b.getActiveChat());
      if (activeChat) {
        const chatName = activeChat.metadata.name;
        new ConfirmModal(
          this.app,
          "Clear Chat Messages",
          `Are you sure you want to clear all messages in chat "${chatName}"?
This action cannot be undone.`,
          () => {
            this.plugin.chatManager.clearActiveChatMessages();
          }
        ).open();
      } else {
        new import_obsidian15.Notice("No active chat to clear.");
      }
    };
    this.handleDeleteChatClick = async () => {
      var _a, _b;
      (_a = this.dropdownMenuManager) == null ? void 0 : _a.closeMenu();
      const activeChat = await ((_b = this.plugin.chatManager) == null ? void 0 : _b.getActiveChat());
      if (activeChat) {
        const chatName = activeChat.metadata.name;
        new ConfirmModal(
          this.app,
          "Delete Chat",
          `Are you sure you want to delete chat "${chatName}"?
This action cannot be undone.`,
          async () => {
            const success = await this.plugin.chatManager.deleteChat(activeChat.metadata.id);
            if (success) {
              new import_obsidian15.Notice(`Chat "${chatName}" deleted.`);
            } else {
              new import_obsidian15.Notice(`Failed to delete chat "${chatName}".`);
            }
          }
        ).open();
      } else {
        new import_obsidian15.Notice("No active chat to delete.");
      }
    };
    this.handleExportChatClick = async () => {
      var _a, _b, _c;
      (_a = this.dropdownMenuManager) == null ? void 0 : _a.closeMenu();
      const activeChat = await ((_b = this.plugin.chatManager) == null ? void 0 : _b.getActiveChat());
      if (!activeChat || activeChat.messages.length === 0) {
        new import_obsidian15.Notice("Chat empty, nothing to export.");
        return;
      }
      try {
        const markdownContent = this.formatChatToMarkdown(activeChat.messages);
        const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
        const safeName = activeChat.metadata.name.replace(/[\\/?:*"<>|]/g, "-");
        const filename = `ollama-chat-${safeName}-${timestamp}.md`;
        let targetFolderPath = (_c = this.plugin.settings.chatExportFolderPath) == null ? void 0 : _c.trim();
        let targetFolder = null;
        if (targetFolderPath) {
          targetFolderPath = (0, import_obsidian15.normalizePath)(targetFolderPath);
          const abstractFile = this.app.vault.getAbstractFileByPath(targetFolderPath);
          if (!abstractFile) {
            try {
              await this.app.vault.createFolder(targetFolderPath);
              targetFolder = this.app.vault.getAbstractFileByPath(targetFolderPath);
              if (targetFolder) {
                new import_obsidian15.Notice(`Created export folder: ${targetFolderPath}`);
              } else {
                new import_obsidian15.Notice(`Error creating export folder. Saving to vault root.`);
                targetFolder = this.app.vault.getRoot();
              }
            } catch (err) {
              new import_obsidian15.Notice(`Error creating export folder. Saving to vault root.`);
              targetFolder = this.app.vault.getRoot();
            }
          } else if (abstractFile instanceof import_obsidian15.TFolder) {
            targetFolder = abstractFile;
          } else {
            new import_obsidian15.Notice(`Error: Export path is not a folder. Saving to vault root.`);
            targetFolder = this.app.vault.getRoot();
          }
        } else {
          targetFolder = this.app.vault.getRoot();
        }
        if (!targetFolder) {
          new import_obsidian15.Notice("Error determining export folder. Cannot save file.");
          return;
        }
        const filePath = (0, import_obsidian15.normalizePath)(`${targetFolder.path}/${filename}`);
        const existingFile = this.app.vault.getAbstractFileByPath(filePath);
        if (existingFile) {
        }
        const file = await this.app.vault.create(filePath, markdownContent);
        new import_obsidian15.Notice(`Chat exported to ${file.path}`);
      } catch (error) {
        if (error instanceof Error && error.message.includes("File already exists")) {
          new import_obsidian15.Notice("Error exporting chat: File already exists.");
        } else {
          new import_obsidian15.Notice("An unexpected error occurred during chat export.");
        }
      }
    };
    this.handleSettingsClick = async () => {
      var _a, _b, _c, _d, _e;
      (_a = this.dropdownMenuManager) == null ? void 0 : _a.closeMenu();
      (_c = (_b = this.app.setting) == null ? void 0 : _b.open) == null ? void 0 : _c.call(_b);
      (_e = (_d = this.app.setting) == null ? void 0 : _d.openTabById) == null ? void 0 : _e.call(_d, this.plugin.manifest.id);
    };
    this.handleDocumentClickForMenu = (e) => {
      var _a;
      (_a = this.dropdownMenuManager) == null ? void 0 : _a.handleDocumentClick(e, this.menuButton);
    };
    this.handleModelChange = async (modelName) => {
      var _a, _b, _c, _d;
      this.updateModelDisplay(modelName);
      try {
        const chat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
        const temp = (_c = (_b = chat == null ? void 0 : chat.metadata) == null ? void 0 : _b.temperature) != null ? _c : this.plugin.settings.temperature;
        this.updateTemperatureIndicator(temp);
        if (chat && this.currentMessages.length > 0) {
          await ((_d = this.plugin.chatManager) == null ? void 0 : _d.addMessageToActiveChat("system", `Model changed to: ${modelName}`, new Date()));
        }
      } catch (error) {
      }
    };
    this.handleRoleChange = async (roleName) => {
      var _a, _b;
      const displayRole = roleName || "None";
      this.updateInputPlaceholder(displayRole);
      this.updateRoleDisplay(displayRole);
      try {
        const chat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
        if (chat && this.currentMessages.length > 0) {
          await ((_b = this.plugin.chatManager) == null ? void 0 : _b.addMessageToActiveChat("system", `Role changed to: ${displayRole}`, new Date()));
        } else {
          new import_obsidian15.Notice(`Role set to: ${displayRole}`);
        }
      } catch (error) {
        new import_obsidian15.Notice(`Role set to: ${displayRole}`);
      }
    };
    this.handleRolesUpdated = () => {
      var _a, _b;
      (_a = this.plugin.promptService) == null ? void 0 : _a.clearRoleCache();
      if (this.dropdownMenuManager) {
        this.dropdownMenuManager.updateRoleListIfVisible().catch((e) => this.plugin.logger.error("Error updating role dropdown list:", e));
      }
      if ((_b = this.sidebarManager) == null ? void 0 : _b.isSectionVisible("roles")) {
        this.sidebarManager.updateRoleList().catch((e) => this.plugin.logger.error("Error updating role panel list:", e));
      } else {
      }
    };
    this.handleMessagesCleared = (chatId) => {
      var _a;
      if (chatId === ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChatId())) {
        this.clearChatContainerInternal();
        this.currentMessages = [];
        this.showEmptyState();
      }
    };
    this.handleVisibilityChange = () => {
      if (document.visibilityState === "visible" && this.leaf.view === this) {
        requestAnimationFrame(() => {
          var _a;
          this.guaranteedScrollToBottom(50, true);
          this.adjustTextareaHeight();
          (_a = this.inputEl) == null ? void 0 : _a.focus();
        });
      }
    };
    this.handleActiveLeafChange = (leaf) => {
      var _a;
      if ((leaf == null ? void 0 : leaf.view) === this) {
        (_a = this.inputEl) == null ? void 0 : _a.focus();
        setTimeout(() => this.guaranteedScrollToBottom(150, true), 100);
      }
    };
    this.handleWindowResize = () => {
      if (this.resizeTimeout)
        clearTimeout(this.resizeTimeout);
      this.resizeTimeout = setTimeout(() => this.adjustTextareaHeight(), 100);
    };
    this.handleScroll = () => {
      if (!this.chatContainer || !this.newMessagesIndicatorEl || !this.scrollToBottomButton)
        return;
      const threshold = 150;
      const atBottom = this.chatContainer.scrollHeight - this.chatContainer.scrollTop - this.chatContainer.clientHeight < threshold;
      const previousScrolledUp = this.userScrolledUp;
      this.userScrolledUp = !atBottom;
      if (previousScrolledUp && atBottom) {
        this.newMessagesIndicatorEl.classList.remove(CSS_CLASS_VISIBLE);
      }
      this.scrollToBottomButton.classList.toggle(CSS_CLASS_VISIBLE, this.userScrolledUp);
    };
    this.handleNewMessageIndicatorClick = () => {
      var _a, _b;
      if (this.chatContainer) {
        this.chatContainer.scrollTo({ top: this.chatContainer.scrollHeight, behavior: "smooth" });
      }
      (_a = this.newMessagesIndicatorEl) == null ? void 0 : _a.classList.remove(CSS_CLASS_VISIBLE);
      (_b = this.scrollToBottomButton) == null ? void 0 : _b.classList.remove(CSS_CLASS_VISIBLE);
      this.userScrolledUp = false;
    };
    this.handleScrollToBottomClick = () => {
      var _a, _b;
      if (this.chatContainer) {
        this.chatContainer.scrollTo({ top: this.chatContainer.scrollHeight, behavior: "smooth" });
      }
      (_a = this.scrollToBottomButton) == null ? void 0 : _a.classList.remove(CSS_CLASS_VISIBLE);
      (_b = this.newMessagesIndicatorEl) == null ? void 0 : _b.classList.remove(CSS_CLASS_VISIBLE);
      this.userScrolledUp = false;
    };
    this.adjustTextareaHeight = () => {
      requestAnimationFrame(() => {
        if (!this.inputEl)
          return;
        const textarea = this.inputEl;
        const computedStyle = window.getComputedStyle(textarea);
        const baseMinHeight = parseFloat(computedStyle.minHeight) || 40;
        const maxHeight = parseFloat(computedStyle.maxHeight);
        const currentScrollTop = textarea.scrollTop;
        textarea.style.height = "auto";
        const scrollHeight = textarea.scrollHeight;
        let targetHeight = Math.max(baseMinHeight, scrollHeight);
        let applyOverflow = false;
        if (!isNaN(maxHeight) && targetHeight > maxHeight) {
          targetHeight = maxHeight;
          applyOverflow = true;
        }
        textarea.style.height = `${targetHeight}px`;
        textarea.style.overflowY = applyOverflow ? "auto" : "hidden";
        textarea.scrollTop = currentScrollTop;
      });
    };
    this.handleChatListUpdated = () => {
      this.scheduleSidebarChatListUpdate();
      if (this.dropdownMenuManager) {
        this.dropdownMenuManager.updateChatListIfVisible().catch((e) => this.plugin.logger.error("Error updating chat dropdown list:", e));
      }
    };
    this.handleSettingsUpdated = async () => {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
      const currentModelName = ((_b = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _b.modelName) || this.plugin.settings.modelName;
      const currentRolePath = (_d = (_c = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _c.selectedRolePath) != null ? _d : this.plugin.settings.selectedRolePath;
      const currentRoleName = await this.findRoleNameByPath(currentRolePath);
      const currentTemperature = (_f = (_e = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _e.temperature) != null ? _f : this.plugin.settings.temperature;
      this.updateModelDisplay(currentModelName);
      this.updateRoleDisplay(currentRoleName);
      this.updateInputPlaceholder(currentRoleName);
      this.updateTemperatureIndicator(currentTemperature);
      this.updateToggleViewLocationOption();
      this.updateToggleLocationButton();
      if (this.dropdownMenuManager) {
        this.dropdownMenuManager.updateRoleListIfVisible().catch((e) => this.plugin.logger.error("Error updating role dropdown list:", e));
        this.dropdownMenuManager.updateModelListIfVisible().catch((e) => this.plugin.logger.error("Error updating model dropdown list:", e));
        this.dropdownMenuManager.updateToggleViewLocationOption();
      }
      if ((_g = this.sidebarManager) == null ? void 0 : _g.isSectionVisible("roles")) {
        await this.sidebarManager.updateRoleList().catch((e) => this.plugin.logger.error("Error updating role panel list:", e));
      } else {
      }
      if ((_h = this.sidebarManager) == null ? void 0 : _h.isSectionVisible("chats")) {
        await this.sidebarManager.updateChatList().catch((e) => this.plugin.logger.error("Error updating chat panel list:", e));
      } else {
      }
    };
    this.handleRoleDisplayClick = async (event) => {
      var _a, _b, _c;
      const menu = new import_obsidian15.Menu();
      let itemsAdded = false;
      try {
        const roles = await this.plugin.listRoleFiles(true);
        const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
        const currentRolePath = (_c = (_b = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _b.selectedRolePath) != null ? _c : this.plugin.settings.selectedRolePath;
        menu.addItem((item) => {
          item.setTitle("None").setIcon(!currentRolePath ? "check" : "slash").onClick(async () => {
            var _a2, _b2;
            const newRolePath = "";
            if (currentRolePath !== newRolePath) {
              if (activeChat) {
                await this.plugin.chatManager.updateActiveChatMetadata({
                  selectedRolePath: newRolePath
                });
              } else {
                this.plugin.settings.selectedRolePath = newRolePath;
                await this.plugin.saveSettings();
                this.plugin.emit("role-changed", "None");
                (_b2 = (_a2 = this.plugin.promptService) == null ? void 0 : _a2.clearRoleCache) == null ? void 0 : _b2.call(_a2);
              }
            }
          });
          itemsAdded = true;
        });
        if (roles.length > 0) {
          menu.addSeparator();
          itemsAdded = true;
        }
        roles.forEach((roleInfo) => {
          menu.addItem((item) => {
            item.setTitle(roleInfo.name).setIcon(roleInfo.path === currentRolePath ? "check" : roleInfo.isCustom ? "user" : "file-text").onClick(async () => {
              var _a2, _b2;
              const newRolePath = roleInfo.path;
              if (currentRolePath !== newRolePath) {
                if (activeChat) {
                  await this.plugin.chatManager.updateActiveChatMetadata({
                    selectedRolePath: newRolePath
                  });
                } else {
                  this.plugin.settings.selectedRolePath = newRolePath;
                  await this.plugin.saveSettings();
                  this.plugin.emit("role-changed", roleInfo.name);
                  (_b2 = (_a2 = this.plugin.promptService) == null ? void 0 : _a2.clearRoleCache) == null ? void 0 : _b2.call(_a2);
                }
              }
            });
            itemsAdded = true;
          });
        });
      } catch (error) {
        console.error("Error loading roles for role selection menu:", error);
        if (!itemsAdded) {
          menu.addItem((item) => item.setTitle("Error loading roles").setDisabled(true));
          itemsAdded = true;
        }
        new import_obsidian15.Notice("Failed to load roles.");
      } finally {
        if (itemsAdded) {
          menu.showAtMouseEvent(event);
        } else {
        }
      }
    };
    this.handleTemperatureClick = async () => {
      var _a, _b;
      const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
      if (!activeChat) {
        new import_obsidian15.Notice("Select or create a chat to change temperature.");
        return;
      }
      const currentTemp = (_b = activeChat.metadata.temperature) != null ? _b : this.plugin.settings.temperature;
      const currentTempString = currentTemp !== null && currentTemp !== void 0 ? String(currentTemp) : "";
      new PromptModal(
        this.app,
        "Set Temperature",
        `Enter new temperature (e.g., 0.7). Higher values = more creative, lower = more focused.`,
        currentTempString,
        async (newValue) => {
          if (newValue === null || newValue.trim() === "") {
            new import_obsidian15.Notice("Temperature change cancelled.");
            return;
          }
          const newTemp = parseFloat(newValue.trim());
          if (isNaN(newTemp) || newTemp < 0 || newTemp > 2) {
            new import_obsidian15.Notice("Invalid temperature. Please enter a number between 0.0 and 2.0.", 4e3);
            return;
          }
          try {
            await this.plugin.chatManager.updateActiveChatMetadata({
              temperature: newTemp
            });
            this.updateTemperatureIndicator(newTemp);
            new import_obsidian15.Notice(`Temperature set to ${newTemp} for chat "${activeChat.metadata.name}".`);
          } catch (error) {
            new import_obsidian15.Notice("Error setting temperature.");
          }
        }
      ).open();
    };
    this.handleToggleViewLocationClick = async () => {
      var _a;
      (_a = this.dropdownMenuManager) == null ? void 0 : _a.closeMenu();
      const currentSetting = this.plugin.settings.openChatInTab;
      const newSetting = !currentSetting;
      this.plugin.settings.openChatInTab = newSetting;
      await this.plugin.saveSettings();
      this.app.workspace.detachLeavesOfType(VIEW_TYPE_OLLAMA_PERSONAS);
      setTimeout(() => {
        this.plugin.activateView();
      }, 50);
    };
    this.updateChatPanelList = async () => {
      var _a;
      const container = this.chatPanelListEl;
      if (!container || !this.plugin.chatManager) {
        return;
      }
      if (((_a = this.chatPanelHeaderEl) == null ? void 0 : _a.getAttribute("data-collapsed")) === "true") {
        return;
      }
      const currentScrollTop = container.scrollTop;
      container.empty();
      try {
        const chats = this.plugin.chatManager.listAvailableChats() || [];
        const currentActiveId = this.plugin.chatManager.getActiveChatId();
        if (chats.length === 0) {
          container.createDiv({ cls: "menu-info-text", text: "No saved chats yet." });
        } else {
          chats.forEach((chatMeta) => {
            const chatOptionEl = container.createDiv({
              cls: [CSS_ROLE_PANEL_ITEM2, CSS_CLASS_MENU_OPTION3, CSS_CLASS_CHAT_LIST_ITEM2]
            });
            const iconSpan = chatOptionEl.createSpan({ cls: [CSS_ROLE_PANEL_ITEM_ICON2, "menu-option-icon"] });
            if (chatMeta.id === currentActiveId) {
              (0, import_obsidian15.setIcon)(iconSpan, "check");
              chatOptionEl.addClass(CSS_ROLE_PANEL_ITEM_ACTIVE2);
            } else {
              (0, import_obsidian15.setIcon)(iconSpan, "message-square");
            }
            const textWrapper = chatOptionEl.createDiv({ cls: "ollama-chat-item-text-wrapper" });
            textWrapper.createDiv({ cls: "chat-panel-item-name", text: chatMeta.name });
            const lastModifiedDate = new Date(chatMeta.lastModified);
            const dateText = !isNaN(lastModifiedDate.getTime()) ? this.formatRelativeDate(lastModifiedDate) : "Invalid date";
            if (dateText === "Invalid date") {
            }
            textWrapper.createDiv({ cls: "chat-panel-item-date", text: dateText });
            const optionsBtn = chatOptionEl.createEl("button", {
              cls: [CSS_CHAT_ITEM_OPTIONS, "clickable-icon"],
              attr: { "aria-label": "Chat options", title: "More options" }
            });
            (0, import_obsidian15.setIcon)(optionsBtn, "lucide-more-horizontal");
            this.registerDomEvent(chatOptionEl, "click", async (e) => {
              var _a2;
              if (!(e.target instanceof Element && e.target.closest(`.${CSS_CHAT_ITEM_OPTIONS}`))) {
                if (chatMeta.id !== ((_a2 = this.plugin.chatManager) == null ? void 0 : _a2.getActiveChatId())) {
                  await this.plugin.chatManager.setActiveChat(chatMeta.id);
                }
              }
            });
            this.registerDomEvent(optionsBtn, "click", (e) => {
              e.stopPropagation();
              this.showChatContextMenu(e, chatMeta);
            });
            this.registerDomEvent(chatOptionEl, "contextmenu", (e) => {
              this.showChatContextMenu(e, chatMeta);
            });
          });
        }
      } catch (error) {
        container.empty();
        container.createDiv({ text: "Error loading chats.", cls: "menu-error-text" });
      } finally {
        requestAnimationFrame(() => {
          if (container && container.isConnected) {
            container.scrollTop = currentScrollTop;
          }
        });
      }
    };
    this.handleMenuButtonClick = (e) => {
      var _a;
      (_a = this.dropdownMenuManager) == null ? void 0 : _a.toggleMenu(e);
    };
    this.onDragStart = (event) => {
      var _a;
      if (event.button !== 0)
        return;
      this.isResizing = true;
      this.initialMouseX = event.clientX;
      this.initialSidebarWidth = ((_a = this.sidebarRootEl) == null ? void 0 : _a.offsetWidth) || 250;
      event.preventDefault();
      event.stopPropagation();
      document.addEventListener("mousemove", this.boundOnDragMove, { capture: true });
      document.addEventListener("mouseup", this.boundOnDragEnd, { capture: true });
      document.body.style.cursor = "ew-resize";
      document.body.classList.add(CSS_CLASS_RESIZING);
    };
    this.onDragMove = (event) => {
      if (!this.isResizing || !this.sidebarRootEl)
        return;
      requestAnimationFrame(() => {
        if (!this.isResizing || !this.sidebarRootEl)
          return;
        const currentMouseX = event.clientX;
        const deltaX = currentMouseX - this.initialMouseX;
        let newWidth = this.initialSidebarWidth + deltaX;
        const minWidth = 150;
        const containerWidth = this.contentEl.offsetWidth;
        const maxWidth = Math.max(minWidth + 50, containerWidth * 0.6);
        if (newWidth < minWidth)
          newWidth = minWidth;
        if (newWidth > maxWidth)
          newWidth = maxWidth;
        this.sidebarRootEl.style.width = `${newWidth}px`;
        this.sidebarRootEl.style.minWidth = `${newWidth}px`;
      });
    };
    this.onDragEnd = () => {
      if (!this.isResizing)
        return;
      this.isResizing = false;
      document.removeEventListener("mousemove", this.boundOnDragMove, { capture: true });
      document.removeEventListener("mouseup", this.boundOnDragEnd, { capture: true });
      document.body.style.cursor = "";
      document.body.classList.remove(CSS_CLASS_RESIZING);
      this.saveWidthDebounced();
    };
    this.scheduleSidebarChatListUpdate = (delay = 50) => {
      if (this.chatListUpdateTimeoutId) {
        clearTimeout(this.chatListUpdateTimeoutId);
      } else {
        if (this.isChatListUpdateScheduled) {
          return;
        }
        this.isChatListUpdateScheduled = true;
      }
      this.chatListUpdateTimeoutId = setTimeout(() => {
        var _a;
        if ((_a = this.sidebarManager) == null ? void 0 : _a.isSectionVisible("chats")) {
          this.sidebarManager.updateChatList().catch((e) => this.plugin.logger.error("Error updating chat panel list via scheduleSidebarChatListUpdate:", e));
        }
        this.chatListUpdateTimeoutId = null;
        this.isChatListUpdateScheduled = false;
      }, delay);
    };
    this.handleActiveChatChanged = async (data) => {
      var _a, _b, _c, _d, _e, _f;
      if (this.isRegenerating && data.chatId === this.plugin.chatManager.getActiveChatId()) {
        this.lastProcessedChatId = data.chatId;
        return;
      }
      const chatSwitched = data.chatId !== this.lastProcessedChatId;
      let metadataWasUpdatedByLoad = false;
      if (chatSwitched || data.chatId !== null && data.chat === null) {
        this.lastProcessedChatId = data.chatId;
        const result = await this.loadAndDisplayActiveChat();
        metadataWasUpdatedByLoad = result.metadataUpdated;
      } else if (data.chatId !== null && data.chat !== null) {
        this.lastProcessedChatId = data.chatId;
        const chat = data.chat;
        const currentRolePath = (_b = (_a = chat.metadata) == null ? void 0 : _a.selectedRolePath) != null ? _b : this.plugin.settings.selectedRolePath;
        const currentRoleName = await this.findRoleNameByPath(currentRolePath);
        const currentModelName = ((_c = chat.metadata) == null ? void 0 : _c.modelName) || this.plugin.settings.modelName;
        const currentTemperature = (_e = (_d = chat.metadata) == null ? void 0 : _d.temperature) != null ? _e : this.plugin.settings.temperature;
        this.updateModelDisplay(currentModelName);
        this.updateRoleDisplay(currentRoleName);
        this.updateInputPlaceholder(currentRoleName);
        this.updateTemperatureIndicator(currentTemperature);
      } else if (data.chatId === null) {
        this.lastProcessedChatId = null;
        this.clearDisplayAndState();
      } else {
        this.lastProcessedChatId = data.chatId;
      }
      if (!metadataWasUpdatedByLoad) {
        this.scheduleSidebarChatListUpdate();
      } else {
      }
      if ((_f = this.sidebarManager) == null ? void 0 : _f.isSectionVisible("roles")) {
        this.sidebarManager.updateRoleList().catch((e) => this.plugin.logger.error("Error updating role panel list in handleActiveChatChanged:", e));
      }
      if (this.dropdownMenuManager) {
        this.dropdownMenuManager.updateRoleListIfVisible().catch((e) => this.plugin.logger.error("Error updating role dropdown list in handleActiveChatChanged:", e));
      }
    };
    this.plugin = plugin;
    this.app = plugin.app;
    this.initSpeechWorker();
    this.scrollListenerDebounced = (0, import_obsidian15.debounce)(this.handleScroll, 150, true);
    this.register(
      this.plugin.on("focus-input-request", () => {
        this.focusInput();
      })
    );
    this.boundOnDragMove = this.onDragMove.bind(this);
    this.boundOnDragEnd = this.onDragEnd.bind(this);
    this.saveWidthDebounced = (0, import_obsidian15.debounce)(() => {
      if (this.sidebarRootEl) {
        const newWidth = this.sidebarRootEl.offsetWidth;
        if (newWidth > 0 && newWidth !== this.plugin.settings.sidebarWidth) {
          this.plugin.settings.sidebarWidth = newWidth;
          this.plugin.saveSettings();
        }
      }
    }, 800);
  }
  getViewType() {
    return VIEW_TYPE_OLLAMA_PERSONAS;
  }
  getDisplayText() {
    return "AI Forge";
  }
  getIcon() {
    return "brain-circuit";
  }
  async onOpen() {
    this.createUIElements();
    const savedWidth = this.plugin.settings.sidebarWidth;
    if (this.sidebarRootEl && savedWidth && typeof savedWidth === "number" && savedWidth > 50) {
      this.sidebarRootEl.style.width = `${savedWidth}px`;
      this.sidebarRootEl.style.minWidth = `${savedWidth}px`;
    } else if (this.sidebarRootEl) {
      let defaultWidth = 250;
      try {
        const cssVarWidth = getComputedStyle(this.sidebarRootEl).getPropertyValue("--ai-forge-sidebar-width").trim();
        if (cssVarWidth && cssVarWidth.endsWith("px")) {
          const parsedWidth = parseInt(cssVarWidth, 10);
          if (!isNaN(parsedWidth) && parsedWidth > 50) {
            defaultWidth = parsedWidth;
          }
        }
      } catch (e) {
      }
      this.sidebarRootEl.style.width = `${defaultWidth}px`;
      this.sidebarRootEl.style.minWidth = `${defaultWidth}px`;
      if (!savedWidth) {
      }
    }
    try {
      const initialRolePath = this.plugin.settings.selectedRolePath;
      const initialRoleName = await this.findRoleNameByPath(initialRolePath);
      const initialModelName = this.plugin.settings.modelName;
      const initialTemperature = this.plugin.settings.temperature;
      this.updateInputPlaceholder(initialRoleName);
      this.updateRoleDisplay(initialRoleName);
      this.updateModelDisplay(initialModelName);
      this.updateTemperatureIndicator(initialTemperature);
    } catch (error) {
    }
    this.attachEventListeners();
    this.autoResizeTextarea();
    this.updateSendButtonState();
    try {
      await this.loadAndDisplayActiveChat();
    } catch (error) {
      this.showEmptyState();
    }
    setTimeout(() => {
      if (this.inputEl && this.leaf.view === this && document.body.contains(this.inputEl)) {
        this.inputEl.focus();
      } else {
      }
    }, 150);
    if (this.inputEl) {
      this.inputEl.dispatchEvent(new Event("input"));
    }
  }
  async onClose() {
    var _a, _b;
    document.removeEventListener("mousemove", this.boundOnDragMove, { capture: true });
    document.removeEventListener("mouseup", this.boundOnDragEnd, { capture: true });
    if (document.body.classList.contains(CSS_CLASS_RESIZING)) {
      document.body.style.cursor = "";
      document.body.classList.remove(CSS_CLASS_RESIZING);
    }
    this.isResizing = false;
    if (this.speechWorker) {
      this.speechWorker.terminate();
      this.speechWorker = null;
    }
    this.stopVoiceRecording(false);
    if (this.audioStream) {
      this.audioStream.getTracks().forEach((t) => t.stop());
      this.audioStream = null;
    }
    if (this.scrollTimeout)
      clearTimeout(this.scrollTimeout);
    if (this.resizeTimeout)
      clearTimeout(this.resizeTimeout);
    (_a = this.sidebarManager) == null ? void 0 : _a.destroy();
    (_b = this.dropdownMenuManager) == null ? void 0 : _b.destroy();
  }
  createUIElements() {
    this.contentEl.empty();
    const flexContainer = this.contentEl.createDiv({ cls: "ollama-container" });
    const isSidebarLocation = !this.plugin.settings.openChatInTab;
    const isDesktop = import_obsidian15.Platform.isDesktop;
    this.sidebarManager = new SidebarManager(this.plugin, this.app, this);
    this.sidebarRootEl = this.sidebarManager.createSidebarUI(flexContainer);
    const shouldShowInternalSidebar = isDesktop && !isSidebarLocation;
    if (this.sidebarRootEl) {
      this.sidebarRootEl.classList.toggle("internal-sidebar-hidden", !shouldShowInternalSidebar);
    } else {
    }
    this.resizerEl = flexContainer.createDiv({ cls: CSS_CLASS_RESIZER_HANDLE });
    this.resizerEl.title = "Drag to resize sidebar";
    this.resizerEl.classList.toggle("internal-sidebar-hidden", !shouldShowInternalSidebar);
    this.mainChatAreaEl = flexContainer.createDiv({ cls: "ollama-main-chat-area" });
    this.mainChatAreaEl.classList.toggle("full-width", !shouldShowInternalSidebar);
    this.chatContainerEl = this.mainChatAreaEl.createDiv({ cls: "ollama-chat-area-content" });
    this.chatContainer = this.chatContainerEl.createDiv({ cls: "ollama-chat-container" });
    this.newMessagesIndicatorEl = this.chatContainerEl.createDiv({ cls: "new-message-indicator" });
    (0, import_obsidian15.setIcon)(this.newMessagesIndicatorEl.createSpan({ cls: "indicator-icon" }), "arrow-down");
    this.newMessagesIndicatorEl.createSpan({ text: " New Messages" });
    this.scrollToBottomButton = this.chatContainerEl.createEl("button", {
      cls: ["scroll-to-bottom-button", "clickable-icon"],
      attr: { "aria-label": "Scroll to bottom", title: "Scroll to bottom" }
    });
    (0, import_obsidian15.setIcon)(this.scrollToBottomButton, "arrow-down");
    const inputContainer = this.mainChatAreaEl.createDiv({ cls: "chat-input-container" });
    this.inputEl = inputContainer.createEl("textarea", {
      attr: { placeholder: `Enter message text here...`, rows: 1 }
    });
    const controlsContainer = inputContainer.createDiv({ cls: "input-controls-container" });
    const leftControls = controlsContainer.createDiv({ cls: "input-controls-left" });
    this.translateInputButton = leftControls.createEl("button", {
      cls: "translate-input-button",
      attr: { "aria-label": "Translate input to English" }
    });
    (0, import_obsidian15.setIcon)(this.translateInputButton, "languages");
    this.translateInputButton.title = "Translate input to English";
    this.modelDisplayEl = leftControls.createDiv({ cls: "model-display" });
    this.modelDisplayEl.setText("...");
    this.modelDisplayEl.title = "Click to select model";
    this.roleDisplayEl = leftControls.createDiv({ cls: "role-display" });
    this.roleDisplayEl.setText("...");
    this.roleDisplayEl.title = "Click to select role";
    this.temperatureIndicatorEl = leftControls.createDiv({ cls: "temperature-indicator" });
    this.temperatureIndicatorEl.setText("?");
    this.temperatureIndicatorEl.title = "Click to set temperature";
    this.buttonsContainer = controlsContainer.createDiv({ cls: `buttons-container input-controls-right` });
    this.stopGeneratingButton = this.buttonsContainer.createEl("button", {
      cls: ["stop-generating-button", "danger-option"],
      attr: { "aria-label": "Stop Generation", title: "Stop Generation" }
    });
    (0, import_obsidian15.setIcon)(this.stopGeneratingButton, "square");
    this.stopGeneratingButton.hide();
    this.sendButton = this.buttonsContainer.createEl("button", { cls: "send-button", attr: { "aria-label": "Send" } });
    (0, import_obsidian15.setIcon)(this.sendButton, "send");
    this.voiceButton = this.buttonsContainer.createEl("button", {
      cls: "voice-button",
      attr: { "aria-label": "Voice Input" }
    });
    (0, import_obsidian15.setIcon)(this.voiceButton, "mic");
    this.toggleLocationButton = this.buttonsContainer.createEl("button", {
      cls: "toggle-location-button",
      attr: { "aria-label": "Toggle View Location" }
    });
    this.menuButton = this.buttonsContainer.createEl("button", { cls: "menu-button", attr: { "aria-label": "Menu" } });
    (0, import_obsidian15.setIcon)(this.menuButton, "more-vertical");
    this.updateToggleLocationButton();
    this.dropdownMenuManager = new DropdownMenuManager(
      this.plugin,
      this.app,
      this,
      inputContainer,
      isSidebarLocation,
      isDesktop
    );
    this.dropdownMenuManager.createMenuUI();
  }
  attachEventListeners() {
    var _a;
    if (this.resizerEl) {
      this.registerDomEvent(this.resizerEl, "mousedown", this.onDragStart);
    } else {
    }
    if (this.inputEl) {
      this.registerDomEvent(this.inputEl, "keydown", this.handleKeyDown);
      this.registerDomEvent(this.inputEl, "input", this.handleInputForResize);
    }
    if (this.sendButton) {
      this.registerDomEvent(this.sendButton, "click", this.handleSendClick);
    }
    if (this.stopGeneratingButton) {
      this.registerDomEvent(this.stopGeneratingButton, "click", this.cancelGeneration);
    }
    if (this.voiceButton) {
      this.registerDomEvent(this.voiceButton, "click", this.handleVoiceClick);
    }
    if (this.translateInputButton) {
      this.registerDomEvent(this.translateInputButton, "click", this.handleTranslateInputClick);
    }
    if (this.menuButton) {
      this.registerDomEvent(this.menuButton, "click", this.handleMenuButtonClick);
    }
    if (this.toggleLocationButton) {
      this.registerDomEvent(this.toggleLocationButton, "click", this.handleToggleViewLocationClick);
    }
    if (this.modelDisplayEl) {
      this.registerDomEvent(this.modelDisplayEl, "click", this.handleModelDisplayClick);
    }
    if (this.roleDisplayEl) {
      this.registerDomEvent(this.roleDisplayEl, "click", this.handleRoleDisplayClick);
    }
    if (this.temperatureIndicatorEl) {
      this.registerDomEvent(this.temperatureIndicatorEl, "click", this.handleTemperatureClick);
    }
    if (this.chatContainer) {
      this.registerDomEvent(this.chatContainer, "scroll", this.scrollListenerDebounced);
    }
    if (this.newMessagesIndicatorEl) {
      this.registerDomEvent(this.newMessagesIndicatorEl, "click", this.handleNewMessageIndicatorClick);
    }
    if (this.scrollToBottomButton) {
      this.registerDomEvent(this.scrollToBottomButton, "click", this.handleScrollToBottomClick);
    }
    this.registerDomEvent(window, "resize", this.handleWindowResize);
    this.registerDomEvent(document, "click", this.handleDocumentClickForMenu);
    this.registerDomEvent(document, "visibilitychange", this.handleVisibilityChange);
    this.registerEvent(this.app.workspace.on("active-leaf-change", this.handleActiveLeafChange));
    (_a = this.dropdownMenuManager) == null ? void 0 : _a.attachEventListeners();
    this.register(this.plugin.on("model-changed", (modelName) => this.handleModelChange(modelName)));
    this.register(this.plugin.on("role-changed", (roleName) => this.handleRoleChange(roleName)));
    this.register(this.plugin.on("roles-updated", () => this.handleRolesUpdated()));
    this.register(this.plugin.on("message-added", (data) => this.handleMessageAdded(data)));
    this.register(this.plugin.on("active-chat-changed", (data) => this.handleActiveChatChanged(data)));
    this.register(this.plugin.on("messages-cleared", (chatId) => this.handleMessagesCleared(chatId)));
    this.register(this.plugin.on("chat-list-updated", () => this.handleChatListUpdated()));
    this.register(this.plugin.on("settings-updated", () => this.handleSettingsUpdated()));
    this.register(this.plugin.on("message-deleted", (data) => this.handleMessageDeleted(data)));
    this.register(this.plugin.on("ollama-connection-error", () => {
    }));
  }
  updateToggleLocationButton() {
    if (!this.toggleLocationButton)
      return;
    let iconName;
    let titleText;
    if (this.plugin.settings.openChatInTab) {
      iconName = "sidebar-right";
      titleText = "Move to Sidebar";
    } else {
      iconName = "layout-list";
      titleText = "Move to Tab";
    }
    (0, import_obsidian15.setIcon)(this.toggleLocationButton, iconName);
    this.toggleLocationButton.setAttribute("aria-label", titleText);
    this.toggleLocationButton.title = titleText;
  }
  updateModelDisplay(modelName) {
    if (this.modelDisplayEl) {
      if (modelName) {
        const displayName = modelName;
        const shortName = displayName.replace(/:latest$/, "");
        this.modelDisplayEl.setText(shortName);
        this.modelDisplayEl.title = `Current model: ${displayName}. Click to change.`;
        this.modelDisplayEl.removeClass("model-not-available");
      } else {
        this.modelDisplayEl.setText("Not available");
        this.modelDisplayEl.title = "No Ollama models detected. Check Ollama connection and ensure models are installed.";
        this.modelDisplayEl.addClass("model-not-available");
      }
    } else {
      console.error("[OllamaView] modelDisplayEl is missing!");
    }
  }
  handleContextMenuRename(chatId, currentName) {
    this.handleRenameChatClick(chatId, currentName);
  }
  async addMessageStandard(message) {
    var _a, _b;
    const isNewDay = !this.lastRenderedMessageDate || !this.isSameDay(this.lastRenderedMessageDate, message.timestamp);
    if (isNewDay) {
      this.renderDateSeparator(message.timestamp);
      this.lastRenderedMessageDate = message.timestamp;
    } else if (!this.lastRenderedMessageDate && ((_a = this.chatContainer) == null ? void 0 : _a.children.length) === 0) {
      this.lastRenderedMessageDate = message.timestamp;
    }
    this.hideEmptyState();
    let messageGroupEl = null;
    try {
      let renderer = null;
      switch (message.role) {
        case "user":
          renderer = new UserMessageRenderer(this.app, this.plugin, message, this);
          break;
        case "assistant":
          renderer = new AssistantMessageRenderer(this.app, this.plugin, message, this);
          break;
        case "system":
          renderer = new SystemMessageRenderer(this.app, this.plugin, message, this);
          break;
        case "error":
          this.handleErrorMessage(message);
          return;
        case "tool":
          renderer = new ToolMessageRenderer(this.app, this.plugin, message, this);
          break;
        default:
          const unknownRoleGroup = (_b = this.chatContainer) == null ? void 0 : _b.createDiv({ cls: CSS_CLASSES.MESSAGE_GROUP });
          if (unknownRoleGroup && this.chatContainer) {
            renderAvatar(this.app, this.plugin, unknownRoleGroup, false);
            const wrapper = unknownRoleGroup.createDiv({ cls: CSS_CLASSES.MESSAGE_WRAPPER || "message-wrapper" });
            const msgBubble = wrapper.createDiv({ cls: `${CSS_CLASSES.MESSAGE} ${CSS_CLASSES.SYSTEM_MESSAGE}` });
            msgBubble.createDiv({
              cls: CSS_CLASSES.SYSTEM_MESSAGE_TEXT || "system-message-text",
              text: `Internal Plugin Error: Unknown message role received by renderer: '${message.role}'. Message content was logged.`
            });
            BaseMessageRenderer.addTimestamp(msgBubble, message.timestamp, this);
            this.chatContainer.appendChild(unknownRoleGroup);
            this.lastMessageElement = unknownRoleGroup;
          }
          return;
      }
      if (renderer) {
        const result = renderer.render();
        messageGroupEl = result instanceof Promise ? await result : result;
      } else {
        return;
      }
      if (messageGroupEl && this.chatContainer) {
        this.chatContainer.appendChild(messageGroupEl);
        this.lastMessageElement = messageGroupEl;
        if (!messageGroupEl.isConnected) {
        }
        messageGroupEl.classList.add(CSS_CLASSES.MESSAGE_ARRIVING || "message-arriving");
        setTimeout(() => messageGroupEl == null ? void 0 : messageGroupEl.classList.remove(CSS_CLASSES.MESSAGE_ARRIVING || "message-arriving"), 500);
        const isUserMessage = message.role === "user";
        if (!isUserMessage && this.userScrolledUp && this.newMessagesIndicatorEl) {
          this.newMessagesIndicatorEl.classList.add(CSS_CLASSES.VISIBLE || "visible");
        } else if (!this.userScrolledUp) {
          const scrollDelay = this.isProcessing && message.role === "assistant" ? 30 : isUserMessage ? 50 : 100;
          const forceScroll = this.isProcessing && message.role === "assistant" || message.role === "tool" ? true : !isUserMessage;
          this.guaranteedScrollToBottom(scrollDelay, forceScroll);
        }
        setTimeout(() => this.updateScrollStateAndIndicators(), 150);
      } else if (renderer) {
      }
    } catch (error) {
      try {
        const errorNotice = `Failed to render message (Role: ${message == null ? void 0 : message.role}). Check console for details.`;
        const errorMsgObject = {
          role: "error",
          content: errorNotice,
          timestamp: message.timestamp || new Date()
        };
        this.handleErrorMessage(errorMsgObject);
      } catch (criticalError) {
        new import_obsidian15.Notice("Critical error displaying message. Check console.");
      }
    }
  }
  updateInputPlaceholder(roleName) {
    if (this.inputEl) {
      this.inputEl.placeholder = `Enter message text here...`;
    }
  }
  autoResizeTextarea() {
    this.adjustTextareaHeight();
  }
  updateRoleDisplay(roleName) {
    if (this.roleDisplayEl) {
      const displayName = roleName || "None";
      this.roleDisplayEl.setText(displayName);
      this.roleDisplayEl.title = `Current role: ${displayName}. Click to change.`;
    }
  }
  updateSendButtonState() {
    if (!this.inputEl || !this.sendButton || !this.stopGeneratingButton) {
      return;
    }
    const generationInProgress = this.currentAbortController !== null;
    const isInputEmpty = this.inputEl.value.trim() === "";
    if (generationInProgress) {
      this.stopGeneratingButton.show();
      this.sendButton.hide();
      this.sendButton.disabled = true;
    } else {
      this.stopGeneratingButton.hide();
      this.sendButton.show();
      const sendShouldBeDisabled = isInputEmpty || this.isProcessing;
      this.sendButton.disabled = sendShouldBeDisabled;
      this.sendButton.classList.toggle(CSS_CLASSES.DISABLED, sendShouldBeDisabled);
    }
  }
  showEmptyState() {
    var _a, _b;
    if (this.currentMessages.length === 0 && !this.emptyStateEl && this.chatContainer) {
      this.chatContainer.empty();
      this.emptyStateEl = this.chatContainer.createDiv({
        cls: CSS_CLASS_EMPTY_STATE
      });
      this.emptyStateEl.createDiv({
        cls: "empty-state-message",
        text: "No messages yet"
      });
      const modelName = ((_b = (_a = this.plugin) == null ? void 0 : _a.settings) == null ? void 0 : _b.modelName) || "the AI";
      this.emptyStateEl.createDiv({
        cls: "empty-state-tip",
        text: `Type a message or use the menu options to start interacting with ${modelName}.`
      });
    }
  }
  hideEmptyState() {
    if (this.emptyStateEl) {
      this.emptyStateEl.remove();
      this.emptyStateEl = null;
    }
  }
  setLoadingState(isLoading) {
    this.isProcessing = isLoading;
    if (this.inputEl)
      this.inputEl.disabled = isLoading;
    this.updateSendButtonState();
    if (this.voiceButton) {
      this.voiceButton.disabled = isLoading;
      this.voiceButton.classList.toggle(CSS_CLASSES.DISABLED, isLoading);
    }
    if (this.translateInputButton) {
      this.translateInputButton.disabled = isLoading;
      this.translateInputButton.classList.toggle(CSS_CLASSES.DISABLED, isLoading);
    }
    if (this.menuButton) {
      this.menuButton.disabled = isLoading;
      this.menuButton.classList.toggle(CSS_CLASSES.DISABLED, isLoading);
    }
    if (this.chatContainer) {
      if (isLoading) {
        this.chatContainer.querySelectorAll(`.${CSS_CLASSES.SHOW_MORE_BUTTON}`).forEach((button) => {
          button.style.display = "none";
        });
      } else {
        this.checkAllMessagesForCollapsing();
      }
    }
  }
  async handleDeleteMessageClick(messageToDelete) {
    var _a;
    const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
    if (!activeChat) {
      new import_obsidian15.Notice("Cannot delete message: No active chat.");
      return;
    }
    new ConfirmModal(
      this.app,
      "Confirm Message Deletion",
      `Are you sure you want to delete this message?
"${messageToDelete.content.substring(0, 100)}${messageToDelete.content.length > 100 ? "..." : ""}"

This action cannot be undone.`,
      async () => {
        try {
          const deleteSuccess = await this.plugin.chatManager.deleteMessageByTimestamp(
            activeChat.metadata.id,
            messageToDelete.timestamp
          );
          if (deleteSuccess) {
            new import_obsidian15.Notice("Message deleted.");
          } else {
            new import_obsidian15.Notice("Failed to delete message.");
          }
        } catch (error) {
          new import_obsidian15.Notice("An error occurred while deleting the message.");
        }
      }
    ).open();
  }
  handleCopyClick(content, buttonEl) {
    let textToCopy = content;
    if (detectThinkingTags(decodeHtmlEntities(content)).hasThinkingTags) {
      textToCopy = decodeHtmlEntities(content).replace(/<think>[\s\S]*?<\/think>/g, "").trim();
    }
    navigator.clipboard.writeText(textToCopy).then(() => {
      (0, import_obsidian15.setIcon)(buttonEl, "check");
      buttonEl.setAttribute("title", "Copied!");
      setTimeout(() => {
        (0, import_obsidian15.setIcon)(buttonEl, "copy");
        buttonEl.setAttribute("title", "Copy");
      }, 2e3);
    }).catch((err) => {
      console.error("Copy failed:", err);
      new import_obsidian15.Notice("Failed to copy text.");
    });
  }
  async handleTranslateClick(originalContent, contentEl, buttonEl) {
    var _a, _b, _c, _d;
    const targetLang = this.plugin.settings.translationTargetLanguage;
    if (!this.plugin.settings.enableTranslation || this.plugin.settings.translationProvider === "none") {
      new import_obsidian15.Notice("Translation disabled or provider not selected in settings.");
      return;
    }
    if (!targetLang) {
      new import_obsidian15.Notice("Target language for translation is not set in settings.");
      return;
    }
    let textToTranslate = "";
    try {
      const decodedContent = decodeHtmlEntities(originalContent);
      if (detectThinkingTags(decodedContent).hasThinkingTags) {
        textToTranslate = decodedContent.replace(/<think>[\s\S]*?<\/think>/g, "").trim();
      } else {
        textToTranslate = decodedContent.trim();
      }
      if (!textToTranslate) {
        new import_obsidian15.Notice("Nothing to translate (content might be empty after removing internal tags).");
        return;
      }
    } catch (error) {
      new import_obsidian15.Notice("Failed to prepare text for translation.");
      return;
    }
    (_a = contentEl.querySelector(`.${CSS_CLASS_TRANSLATION_CONTAINER}`)) == null ? void 0 : _a.remove();
    const originalIcon = ((_b = buttonEl.querySelector(".svg-icon")) == null ? void 0 : _b.getAttribute("icon-name")) || "languages";
    (0, import_obsidian15.setIcon)(buttonEl, "loader");
    buttonEl.disabled = true;
    buttonEl.classList.add(CSS_CLASS_TRANSLATION_PENDING);
    const originalTitle = buttonEl.title;
    buttonEl.setAttribute("title", "Translating...");
    buttonEl.addClass("button-loading");
    try {
      const translatedText = await this.plugin.translationService.translate(textToTranslate, targetLang);
      if (!contentEl || !contentEl.isConnected) {
        return;
      }
      if (translatedText !== null) {
        const translationContainer = contentEl.createDiv({ cls: CSS_CLASS_TRANSLATION_CONTAINER });
        const translationContentEl = translationContainer.createDiv({ cls: CSS_CLASS_TRANSLATION_CONTENT });
        await import_obsidian15.MarkdownRenderer.render(
          this.app,
          translatedText,
          translationContentEl,
          (_d = (_c = this.plugin.app.vault.getRoot()) == null ? void 0 : _c.path) != null ? _d : "",
          this
        );
        fixBrokenTwemojiImages(translationContentEl);
        const targetLangName = LANGUAGES[targetLang] || targetLang;
        translationContainer.createEl("div", {
          cls: "translation-indicator",
          text: `[Translated to ${targetLangName}]`
        });
        this.guaranteedScrollToBottom(50, false);
      }
    } catch (error) {
    } finally {
      if (buttonEl == null ? void 0 : buttonEl.isConnected) {
        (0, import_obsidian15.setIcon)(buttonEl, originalIcon);
        buttonEl.disabled = false;
        buttonEl.classList.remove(CSS_CLASS_TRANSLATION_PENDING);
        buttonEl.setAttribute("title", originalTitle);
        buttonEl.removeClass("button-loading");
      }
    }
  }
  renderDateSeparator(date) {
    if (!this.chatContainer)
      return;
    this.chatContainer.createDiv({
      cls: CSS_CLASS_DATE_SEPARATOR,
      text: this.formatDateSeparator(date)
    });
  }
  initSpeechWorker() {
    try {
      const workerCode = `
             
             self.onmessage = async (event) => {
                 const { apiKey, audioBlob, languageCode = 'uk-UA' } = event.data;

                 if (!apiKey || apiKey.trim() === '') {
                     self.postMessage({ error: true, message: 'Google API Key is not configured. Please add it in plugin settings.' });
                     return;
                 }

                 const url = "https:

                 try {
                     const arrayBuffer = await audioBlob.arrayBuffer();

                     
                     
                     let base64Audio;
                     if (typeof TextDecoder !== 'undefined') { 
                             
                             const base64String = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
                             base64Audio = base64String;

                     } else {
                             
                             base64Audio = btoa(
                                 new Uint8Array(arrayBuffer).reduce((data, byte) => data + String.fromCharCode(byte), '')
                             );
                     }


                     const response = await fetch(url, {
                         method: 'POST',
                         body: JSON.stringify({
                             config: {
                                 encoding: 'WEBM_OPUS', 
                                 sampleRateHertz: 48000, 
                                 languageCode: languageCode,
                                 model: 'latest_long', 
                                 enableAutomaticPunctuation: true,
                             },
                             audio: { content: base64Audio },
                         }),
                         headers: { 'Content-Type': 'application/json' },
                     });

                     const responseData = await response.json();

                     if (!response.ok) {
                         
                         self.postMessage({
                             error: true,
                             message: "Error from Google Speech API: " + (responseData.error?.message || response.statusText || 'Unknown error')
                         });
                         return;
                     }

                     if (responseData.results && responseData.results.length > 0) {
                         const transcript = responseData.results
                             .map(result => result.alternatives[0].transcript)
                             .join(' ')
                             .trim();
                         self.postMessage(transcript); 
                     } else {
                         
                         self.postMessage({ error: true, message: 'No speech detected or recognized.' });
                     }
                 } catch (error) {
                     
                     self.postMessage({
                         error: true,
                         message: 'Error processing speech recognition: ' + (error instanceof Error ? error.message : String(error))
                     });
                 }
             };
           `;
      const workerBlob = new Blob([workerCode], {
        type: "application/javascript"
      });
      const workerUrl = URL.createObjectURL(workerBlob);
      this.speechWorker = new Worker(workerUrl);
      URL.revokeObjectURL(workerUrl);
      this.setupSpeechWorkerHandlers();
    } catch (error) {
      new import_obsidian15.Notice("Speech recognition feature failed to initialize.");
      this.speechWorker = null;
    }
  }
  setupSpeechWorkerHandlers() {
    if (!this.speechWorker)
      return;
    this.speechWorker.onmessage = (event) => {
      const data = event.data;
      if (data && typeof data === "object" && data.error) {
        new import_obsidian15.Notice(`Speech Recognition Error: ${data.message}`);
        this.updateInputPlaceholder(this.plugin.settings.modelName);
        this.updateSendButtonState();
        return;
      }
      if (typeof data === "string" && data.trim()) {
        const transcript = data.trim();
        this.insertTranscript(transcript);
      } else if (typeof data !== "string") {
      }
      this.updateSendButtonState();
    };
    this.speechWorker.onerror = () => {
      new import_obsidian15.Notice("An unexpected error occurred in the speech recognition worker.");
      this.updateInputPlaceholder(this.plugin.settings.modelName);
      this.stopVoiceRecording(false);
    };
  }
  insertTranscript(transcript) {
    var _a, _b;
    if (!this.inputEl)
      return;
    const currentVal = this.inputEl.value;
    const start = (_a = this.inputEl.selectionStart) != null ? _a : currentVal.length;
    const end = (_b = this.inputEl.selectionEnd) != null ? _b : currentVal.length;
    let textToInsert = transcript;
    const precedingChar = start > 0 ? currentVal[start - 1] : null;
    const followingChar = end < currentVal.length ? currentVal[end] : null;
    if (precedingChar && precedingChar !== " " && precedingChar !== "\n") {
      textToInsert = " " + textToInsert;
    }
    if (followingChar && followingChar !== " " && followingChar !== "\n" && !textToInsert.endsWith(" ")) {
      textToInsert += " ";
    }
    const newValue = currentVal.substring(0, start) + textToInsert + currentVal.substring(end);
    this.inputEl.value = newValue;
    const newCursorPos = start + textToInsert.length;
    this.inputEl.setSelectionRange(newCursorPos, newCursorPos);
    this.inputEl.focus();
    this.inputEl.dispatchEvent(new Event("input"));
  }
  async toggleVoiceRecognition() {
    if (this.mediaRecorder && this.mediaRecorder.state === "recording") {
      this.stopVoiceRecording(true);
    } else {
      await this.startVoiceRecognition();
    }
  }
  async startVoiceRecognition() {
    var _a;
    if (!this.speechWorker) {
      new import_obsidian15.Notice("\u0424\u0443\u043D\u043A\u0446\u0456\u044F \u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u0432\u0430\u043D\u043D\u044F \u043C\u043E\u0432\u043B\u0435\u043D\u043D\u044F \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u0430 (worker \u043D\u0435 \u0456\u043D\u0456\u0446\u0456\u0430\u043B\u0456\u0437\u043E\u0432\u0430\u043D\u043E).");
      return;
    }
    const speechApiKey = this.plugin.settings.googleApiKey;
    if (!speechApiKey) {
      new import_obsidian15.Notice(
        "\u041A\u043B\u044E\u0447 Google API \u0434\u043B\u044F \u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u0432\u0430\u043D\u043D\u044F \u043C\u043E\u0432\u043B\u0435\u043D\u043D\u044F \u043D\u0435 \u043D\u0430\u043B\u0430\u0448\u0442\u043E\u0432\u0430\u043D\u043E. \u0411\u0443\u0434\u044C \u043B\u0430\u0441\u043A\u0430, \u0434\u043E\u0434\u0430\u0439\u0442\u0435 \u0439\u043E\u0433\u043E \u0432 \u043D\u0430\u043B\u0430\u0448\u0442\u0443\u0432\u0430\u043D\u043D\u044F\u0445 \u043F\u043B\u0430\u0433\u0456\u043D\u0430."
      );
      return;
    }
    try {
      this.audioStream = await navigator.mediaDevices.getUserMedia({
        audio: true
      });
      let recorderOptions;
      const preferredMimeType = "audio/webm;codecs=opus";
      if (MediaRecorder.isTypeSupported(preferredMimeType)) {
        recorderOptions = { mimeType: preferredMimeType };
      } else {
        recorderOptions = void 0;
      }
      this.mediaRecorder = new MediaRecorder(this.audioStream, recorderOptions);
      const audioChunks = [];
      (_a = this.voiceButton) == null ? void 0 : _a.classList.add(CSS_CLASS_RECORDING);
      (0, import_obsidian15.setIcon)(this.voiceButton, "stop-circle");
      this.inputEl.placeholder = "Recording... Speak now.";
      this.mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          audioChunks.push(event.data);
        }
      };
      this.mediaRecorder.onstop = () => {
        var _a2;
        if (this.speechWorker && audioChunks.length > 0) {
          const audioBlob = new Blob(audioChunks, {
            type: ((_a2 = this.mediaRecorder) == null ? void 0 : _a2.mimeType) || "audio/webm"
          });
          this.inputEl.placeholder = "Processing speech...";
          this.speechWorker.postMessage({
            apiKey: speechApiKey,
            audioBlob,
            languageCode: this.plugin.settings.speechLanguage || "uk-UA"
          });
        } else if (audioChunks.length === 0) {
          this.getCurrentRoleDisplayName().then((roleName) => this.updateInputPlaceholder(roleName));
          this.updateSendButtonState();
        }
      };
      this.mediaRecorder.onerror = () => {
        new import_obsidian15.Notice("An error occurred during recording.");
        this.stopVoiceRecording(false);
      };
      this.mediaRecorder.start();
    } catch (error) {
      if (error instanceof DOMException && error.name === "NotAllowedError") {
        new import_obsidian15.Notice("Microphone access denied. Please grant permission.");
      } else if (error instanceof DOMException && error.name === "NotFoundError") {
        new import_obsidian15.Notice("Microphone not found. Please ensure it's connected and enabled.");
      } else {
        new import_obsidian15.Notice("Could not start voice recording.");
      }
      this.stopVoiceRecording(false);
    }
  }
  stopVoiceRecording(processAudio) {
    var _a, _b;
    if (this.mediaRecorder && this.mediaRecorder.state === "recording") {
      this.mediaRecorder.stop();
    } else if (!processAudio && ((_a = this.mediaRecorder) == null ? void 0 : _a.state) === "inactive") {
    }
    (_b = this.voiceButton) == null ? void 0 : _b.classList.remove(CSS_CLASS_RECORDING);
    (0, import_obsidian15.setIcon)(this.voiceButton, "mic");
    this.getCurrentRoleDisplayName().then((roleName) => this.updateInputPlaceholder(roleName));
    this.updateSendButtonState();
    if (this.audioStream) {
      this.audioStream.getTracks().forEach((track) => track.stop());
      this.audioStream = null;
    }
    this.mediaRecorder = null;
  }
  checkAllMessagesForCollapsing() {
    var _a;
    (_a = this.chatContainer) == null ? void 0 : _a.querySelectorAll(`.${CSS_CLASS_MESSAGE}`).forEach((msgEl) => {
      this.checkMessageForCollapsing(msgEl);
    });
  }
  toggleMessageCollapse(contentEl, buttonEl) {
    const maxHeightLimit = this.plugin.settings.maxMessageHeight;
    const isInitialExpandedState = buttonEl.hasAttribute("data-initial-state");
    if (isInitialExpandedState) {
      buttonEl.removeAttribute("data-initial-state");
      contentEl.style.maxHeight = `${maxHeightLimit}px`;
      contentEl.classList.add(CSS_CLASS_CONTENT_COLLAPSED);
      buttonEl.setText("Show More \u25BC");
      setTimeout(() => {
        contentEl.scrollIntoView({ behavior: "smooth", block: "nearest" });
      }, 310);
    } else {
      const isCollapsed = contentEl.classList.contains(CSS_CLASS_CONTENT_COLLAPSED);
      if (isCollapsed) {
        contentEl.style.maxHeight = "";
        contentEl.classList.remove(CSS_CLASS_CONTENT_COLLAPSED);
        buttonEl.setText("Show Less \u25B2");
      } else {
        contentEl.style.maxHeight = `${maxHeightLimit}px`;
        contentEl.classList.add(CSS_CLASS_CONTENT_COLLAPSED);
        buttonEl.setText("Show More \u25BC");
        setTimeout(() => {
          contentEl.scrollIntoView({ behavior: "smooth", block: "nearest" });
        }, 310);
      }
    }
  }
  getChatContainer() {
    return this.chatContainer;
  }
  clearChatContainerInternal() {
    this.currentMessages = [];
    this.lastRenderedMessageDate = null;
    if (this.chatContainer)
      this.chatContainer.empty();
    this.hideEmptyState();
    this.lastMessageElement = null;
    this.consecutiveErrorMessages = [];
    this.errorGroupElement = null;
    this.isSummarizingErrors = false;
  }
  clearDisplayAndState() {
    this.clearChatContainerInternal();
    this.showEmptyState();
    this.updateSendButtonState();
    setTimeout(() => this.focusInput(), 50);
  }
  scrollToBottom() {
    this.guaranteedScrollToBottom(50, true);
  }
  clearInputField() {
    if (this.inputEl) {
      this.inputEl.value = "";
      this.inputEl.dispatchEvent(new Event("input"));
    }
  }
  focusInput() {
    setTimeout(() => {
      var _a;
      (_a = this.inputEl) == null ? void 0 : _a.focus();
    }, 0);
  }
  guaranteedScrollToBottom(delay = 50, forceScroll = false) {
    if (this.scrollTimeout) {
      clearTimeout(this.scrollTimeout);
      this.scrollTimeout = null;
    }
    this.scrollTimeout = setTimeout(() => {
      requestAnimationFrame(() => {
        var _a, _b;
        if (this.chatContainer) {
          const threshold = 100;
          const isScrolledUp = this.chatContainer.scrollHeight - this.chatContainer.scrollTop - this.chatContainer.clientHeight > threshold;
          if (isScrolledUp !== this.userScrolledUp) {
            this.userScrolledUp = isScrolledUp;
            if (!isScrolledUp)
              (_a = this.newMessagesIndicatorEl) == null ? void 0 : _a.classList.remove(CSS_CLASS_VISIBLE);
          }
          if (forceScroll || !this.userScrolledUp || this.isProcessing) {
            const behavior = this.isProcessing ? "auto" : "smooth";
            this.chatContainer.scrollTo({
              top: this.chatContainer.scrollHeight,
              behavior
            });
            if (forceScroll) {
              this.userScrolledUp = false;
              (_b = this.newMessagesIndicatorEl) == null ? void 0 : _b.classList.remove(CSS_CLASS_VISIBLE);
            }
          }
        } else {
        }
      });
      this.scrollTimeout = null;
    }, delay);
  }
  formatTime(date) {
    return date.toLocaleTimeString(void 0, {
      hour: "numeric",
      minute: "2-digit"
    });
  }
  formatDateSeparator(date) {
    const now = new Date();
    const yesterday = new Date(now);
    yesterday.setDate(now.getDate() - 1);
    if (this.isSameDay(date, now))
      return "Today";
    else if (this.isSameDay(date, yesterday))
      return "Yesterday";
    else
      return date.toLocaleDateString(void 0, {
        weekday: "long",
        year: "numeric",
        month: "long",
        day: "numeric"
      });
  }
  formatRelativeDate(date) {
    if (!(date instanceof Date) || isNaN(date.getTime())) {
      return "Invalid date";
    }
    const now = new Date();
    const diffSeconds = Math.round((now.getTime() - date.getTime()) / 1e3);
    const diffDays = Math.floor(diffSeconds / (60 * 60 * 24));
    if (diffDays === 0) {
      const diffHours = Math.floor(diffSeconds / (60 * 60));
      if (diffHours < 1)
        return "Just now";
      if (diffHours === 1)
        return "1 hour ago";
      if (diffHours < now.getHours())
        return `${diffHours} hours ago`;
      else
        return "Today";
    } else if (diffDays === 1) {
      return "Yesterday";
    } else if (diffDays < 7) {
      return `${diffDays} days ago`;
    } else {
      return date.toLocaleDateString(void 0, {
        month: "short",
        day: "numeric"
      });
    }
  }
  isSameDay(date1, date2) {
    return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate();
  }
  formatChatToMarkdown(messagesToFormat) {
    let localLastDate = null;
    const exportTimestamp = new Date();
    let markdown = `# AI Forge Chat Export
> Exported on: ${exportTimestamp.toLocaleString(void 0)}

`;
    messagesToFormat.forEach((message) => {
      var _a;
      if (!((_a = message.content) == null ? void 0 : _a.trim()))
        return;
      if (localLastDate === null || !this.isSameDay(localLastDate, message.timestamp)) {
        if (localLastDate !== null)
          markdown += `***
`;
        markdown += `**${this.formatDateSeparator(message.timestamp)}**
***

`;
      }
      localLastDate = message.timestamp;
      const time = this.formatTime(message.timestamp);
      let prefix = "";
      let contentPrefix = "";
      let content = message.content.trim();
      if (message.role === "assistant") {
        content = decodeHtmlEntities(content).replace(/<think>[\s\S]*?<\/think>/g, "").trim();
        if (!content)
          return;
      }
      switch (message.role) {
        case "user":
          prefix = `**User (${time}):**
`;
          break;
        case "assistant":
          prefix = `**Assistant (${time}):**
`;
          break;
        case "system":
          prefix = `> _[System (${time})]_ 
> `;
          contentPrefix = "> ";
          break;
        case "error":
          prefix = `> [!ERROR] Error (${time}):
> `;
          contentPrefix = "> ";
          break;
      }
      markdown += prefix;
      if (contentPrefix) {
        markdown += content.split("\n").map((line) => line.trim() ? `${contentPrefix}${line}` : contentPrefix.trim()).join(`
`) + "\n\n";
      } else if (content.includes("```")) {
        content = content.replace(/(\n*\s*)```/g, "\n\n```").replace(/```(\s*\n*)/g, "```\n\n");
        markdown += content.trim() + "\n\n";
      } else {
        markdown += content.split("\n").map((line) => line.trim() ? line : "").join("\n") + "\n\n";
      }
    });
    return markdown.trim();
  }
  async getCurrentRoleDisplayName() {
    var _a, _b, _c, _d;
    try {
      const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
      const rolePath = (_c = (_b = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _b.selectedRolePath) != null ? _c : this.plugin.settings.selectedRolePath;
      if (rolePath) {
        const allRoles = await this.plugin.listRoleFiles(true);
        const foundRole = allRoles.find((role) => role.path === rolePath);
        if (foundRole) {
          return foundRole.name;
        } else {
          console.warn(`Role with path "${rolePath}" not found in listRoleFiles results.`);
          return ((_d = rolePath.split("/").pop()) == null ? void 0 : _d.replace(".md", "")) || "Selected Role";
        }
      }
    } catch (error) {
      console.error("Error getting current role display name:", error);
    }
    return "None";
  }
  updateTemperatureIndicator(temperature) {
    if (!this.temperatureIndicatorEl)
      return;
    const tempValue = temperature != null ? temperature : this.plugin.settings.temperature;
    const emoji = this.getTemperatureEmoji(tempValue);
    this.temperatureIndicatorEl.setText(emoji);
    this.temperatureIndicatorEl.title = `Temperature: ${tempValue.toFixed(1)}. Click to change.`;
  }
  getTemperatureEmoji(temperature) {
    if (temperature <= 0.4) {
      return "\u{1F9CA}";
    } else if (temperature > 0.4 && temperature <= 0.6) {
      return "\u{1F642}";
    } else {
      return "\u{1F92A}";
    }
  }
  updateToggleViewLocationOption() {
    var _a;
    (_a = this.dropdownMenuManager) == null ? void 0 : _a.updateToggleViewLocationOption();
  }
  async findRoleNameByPath(rolePath) {
    var _a;
    if (!rolePath) {
      return "None";
    }
    try {
      const allRoles = await this.plugin.listRoleFiles(true);
      const foundRole = allRoles.find((role) => role.path === rolePath);
      if (foundRole) {
        return foundRole.name;
      } else {
        const fileName = (_a = rolePath.split("/").pop()) == null ? void 0 : _a.replace(".md", "");
        return fileName || "Unknown Role";
      }
    } catch (error) {
      return "Error";
    }
  }
  showChatContextMenu(event, chatMeta) {
    event.preventDefault();
    const menu = new import_obsidian15.Menu();
    menu.addItem(
      (item) => item.setTitle("Clone Chat").setIcon("lucide-copy-plus").onClick(() => this.handleContextMenuClone(chatMeta.id))
    );
    menu.addItem(
      (item) => item.setTitle("Rename Chat").setIcon("lucide-pencil").onClick(() => this.handleContextMenuRename(chatMeta.id, chatMeta.name))
    );
    menu.addItem(
      (item) => item.setTitle("Export to Note").setIcon("lucide-download").onClick(() => this.exportSpecificChat(chatMeta.id))
    );
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle("Clear Messages").setIcon("lucide-trash").onClick(() => this.handleContextMenuClear(chatMeta.id, chatMeta.name));
      try {
        item.el.addClass("danger-option");
      } catch (e) {
      }
    });
    menu.addItem((item) => {
      item.setTitle("Delete Chat").setIcon("lucide-trash-2").onClick(() => this.handleContextMenuDelete(chatMeta.id, chatMeta.name));
      try {
        item.el.addClass("danger-option");
      } catch (e) {
      }
    });
    menu.showAtMouseEvent(event);
  }
  async handleContextMenuClone(chatId) {
    const cloningNotice = new import_obsidian15.Notice("Cloning chat...", 0);
    try {
      const clonedChat = await this.plugin.chatManager.cloneChat(chatId);
      if (clonedChat) {
        new import_obsidian15.Notice(`Chat cloned as "${clonedChat.metadata.name}" and activated.`);
      } else {
      }
    } catch (error) {
      new import_obsidian15.Notice("Error cloning chat.");
    } finally {
      cloningNotice.hide();
    }
  }
  async exportSpecificChat(chatId) {
    var _a;
    const exportingNotice = new import_obsidian15.Notice(`Exporting chat...`, 0);
    try {
      const chat = await this.plugin.chatManager.getChat(chatId);
      if (!chat || chat.messages.length === 0) {
        new import_obsidian15.Notice("Chat is empty or not found, nothing to export.");
        exportingNotice.hide();
        return;
      }
      const markdownContent = this.formatChatToMarkdown(chat.messages);
      const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
      const safeName = chat.metadata.name.replace(/[\\/?:*"<>|]/g, "-");
      const filename = `ollama-chat-${safeName}-${timestamp}.md`;
      let targetFolderPath = (_a = this.plugin.settings.chatExportFolderPath) == null ? void 0 : _a.trim();
      let targetFolder = null;
      if (targetFolderPath) {
        targetFolderPath = (0, import_obsidian15.normalizePath)(targetFolderPath);
        const abstractFile = this.app.vault.getAbstractFileByPath(targetFolderPath);
        if (!abstractFile) {
          try {
            await this.app.vault.createFolder(targetFolderPath);
            targetFolder = this.app.vault.getAbstractFileByPath(targetFolderPath);
            if (targetFolder)
              new import_obsidian15.Notice(`Created export folder: ${targetFolderPath}`);
          } catch (err) {
            new import_obsidian15.Notice(`Error creating export folder. Saving to vault root.`);
            targetFolder = this.app.vault.getRoot();
          }
        } else if (abstractFile instanceof import_obsidian15.TFolder) {
          targetFolder = abstractFile;
        } else {
          new import_obsidian15.Notice(`Error: Export path is not a folder. Saving to vault root.`);
          targetFolder = this.app.vault.getRoot();
        }
      } else {
        targetFolder = this.app.vault.getRoot();
      }
      if (!targetFolder) {
        new import_obsidian15.Notice("Error determining export folder.");
        exportingNotice.hide();
        return;
      }
      const filePath = (0, import_obsidian15.normalizePath)(`${targetFolder.path}/${filename}`);
      const existingFile = this.app.vault.getAbstractFileByPath(filePath);
      if (existingFile) {
      }
      const file = await this.app.vault.create(filePath, markdownContent);
      new import_obsidian15.Notice(`Chat exported to ${file.path}`);
    } catch (error) {
      new import_obsidian15.Notice("An error occurred during chat export.");
    } finally {
      exportingNotice.hide();
    }
  }
  async handleContextMenuClear(chatId, chatName) {
    new ConfirmModal(
      this.app,
      "Confirm Clear Messages",
      `Are you sure you want to clear all messages in chat "${chatName}"?
This action cannot be undone.`,
      async () => {
        const clearingNotice = new import_obsidian15.Notice("Clearing messages...", 0);
        try {
          const success = await this.plugin.chatManager.clearChatMessagesById(chatId);
          if (success) {
            new import_obsidian15.Notice(`Messages cleared for chat "${chatName}".`);
          } else {
            new import_obsidian15.Notice(`Failed to clear messages for chat "${chatName}".`);
          }
        } catch (error) {
          new import_obsidian15.Notice("Error clearing messages.");
        } finally {
          clearingNotice.hide();
        }
      }
    ).open();
  }
  async handleContextMenuDelete(chatId, chatName) {
    new ConfirmModal(
      this.app,
      "Confirm Delete Chat",
      `Are you sure you want to delete chat "${chatName}"?
This action cannot be undone.`,
      async () => {
        const deletingNotice = new import_obsidian15.Notice("Deleting chat...", 0);
        try {
          const success = await this.plugin.chatManager.deleteChat(chatId);
          if (success) {
            new import_obsidian15.Notice(`Chat "${chatName}" deleted.`);
          } else {
          }
        } catch (error) {
          new import_obsidian15.Notice("Error deleting chat.");
        } finally {
          deletingNotice.hide();
        }
      }
    ).open();
  }
  isChatScrolledUp() {
    if (!this.chatContainer)
      return false;
    const scrollableDistance = this.chatContainer.scrollHeight - this.chatContainer.clientHeight;
    if (scrollableDistance <= 0)
      return false;
    const distanceFromBottom = scrollableDistance - this.chatContainer.scrollTop;
    return distanceFromBottom >= SCROLL_THRESHOLD;
  }
  updateScrollStateAndIndicators() {
    var _a, _b;
    if (!this.chatContainer)
      return;
    const wasScrolledUp = this.userScrolledUp;
    this.userScrolledUp = this.isChatScrolledUp();
    (_a = this.scrollToBottomButton) == null ? void 0 : _a.classList.toggle(CSS_CLASS_VISIBLE, this.userScrolledUp);
    if (wasScrolledUp && !this.userScrolledUp) {
      (_b = this.newMessagesIndicatorEl) == null ? void 0 : _b.classList.remove(CSS_CLASS_VISIBLE);
    }
  }
  checkMessageForCollapsing(messageElOrGroupEl) {
    const messageGroupEl = messageElOrGroupEl.classList.contains(CSS_CLASSES.MESSAGE_GROUP) ? messageElOrGroupEl : messageElOrGroupEl.closest(`.${CSS_CLASSES.MESSAGE_GROUP}`);
    if (!messageGroupEl) {
      return;
    }
    const contentCollapsible = messageGroupEl.querySelector(`.${CSS_CLASSES.CONTENT_COLLAPSIBLE}`);
    const messageEl = messageGroupEl.querySelector(`.${CSS_CLASSES.MESSAGE}`);
    if (!contentCollapsible || !messageEl) {
      return;
    }
    const maxH = this.plugin.settings.maxMessageHeight;
    const isStreamingNow = this.isProcessing && messageGroupEl.classList.contains("placeholder") && messageGroupEl.hasAttribute("data-placeholder-timestamp") && contentCollapsible.classList.contains("streaming-text");
    if (isStreamingNow) {
      const existingButton = messageEl.querySelector(`.${CSS_CLASSES.SHOW_MORE_BUTTON}`);
      existingButton == null ? void 0 : existingButton.remove();
      contentCollapsible.style.maxHeight = "";
      contentCollapsible.classList.remove(CSS_CLASS_CONTENT_COLLAPSED);
      return;
    }
    if (maxH <= 0) {
      const existingButton = messageEl.querySelector(`.${CSS_CLASSES.SHOW_MORE_BUTTON}`);
      existingButton == null ? void 0 : existingButton.remove();
      contentCollapsible.style.maxHeight = "";
      contentCollapsible.classList.remove(CSS_CLASS_CONTENT_COLLAPSED);
      return;
    }
    requestAnimationFrame(() => {
      if (!contentCollapsible || !contentCollapsible.isConnected || !messageGroupEl.isConnected || !messageEl.isConnected)
        return;
      let existingButton = messageEl.querySelector(`.${CSS_CLASSES.SHOW_MORE_BUTTON}`);
      const previousMaxHeightStyle = contentCollapsible.style.maxHeight;
      contentCollapsible.style.maxHeight = "";
      const scrollHeight = contentCollapsible.scrollHeight;
      if (existingButton && previousMaxHeightStyle && !existingButton.classList.contains("explicitly-expanded")) {
        contentCollapsible.style.maxHeight = previousMaxHeightStyle;
      }
      if (scrollHeight > maxH) {
        if (!existingButton) {
          existingButton = messageEl.createEl("button", {
            cls: CSS_CLASSES.SHOW_MORE_BUTTON
          });
          this.registerDomEvent(existingButton, "click", () => {
            if (contentCollapsible.classList.contains(CSS_CLASSES.CONTENT_COLLAPSED)) {
              existingButton.classList.add("explicitly-expanded");
            } else {
              existingButton.classList.remove("explicitly-expanded");
            }
            this.toggleMessageCollapse(contentCollapsible, existingButton);
          });
          contentCollapsible.style.maxHeight = `${maxH}px`;
          contentCollapsible.classList.add(CSS_CLASSES.CONTENT_COLLAPSED);
          existingButton.setText("Show More \u25BC");
        } else {
          if (contentCollapsible.classList.contains(CSS_CLASSES.CONTENT_COLLAPSED)) {
            existingButton.setText("Show More \u25BC");
          } else {
            existingButton.setText("Show Less \u25B2");
          }
        }
      } else {
        if (existingButton) {
          existingButton.remove();
        }
        contentCollapsible.style.maxHeight = "";
        contentCollapsible.classList.remove(CSS_CLASSES.CONTENT_COLLAPSED);
      }
    });
  }
  async handleSummarizeClick(originalContent, buttonEl) {
    var _a;
    const summarizationModel = this.plugin.settings.summarizationModelName;
    if (!summarizationModel) {
      new import_obsidian15.Notice("Please select a summarization model in AI Forge settings (Productivity section).");
      return;
    }
    let textToSummarize = originalContent;
    if (detectThinkingTags(decodeHtmlEntities(originalContent)).hasThinkingTags) {
      textToSummarize = decodeHtmlEntities(originalContent).replace(/<think>[\s\S]*?<\/think>/g, "").trim();
    }
    if (!textToSummarize || textToSummarize.length < 50) {
      new import_obsidian15.Notice("Message is too short to summarize meaningfully.");
      return;
    }
    const originalIcon = ((_a = buttonEl.querySelector(".svg-icon")) == null ? void 0 : _a.getAttribute("icon-name")) || "scroll-text";
    (0, import_obsidian15.setIcon)(buttonEl, "loader");
    buttonEl.disabled = true;
    const originalTitle = buttonEl.title;
    buttonEl.title = "Summarizing...";
    buttonEl.addClass(CSS_CLASS_DISABLED);
    buttonEl.addClass("button-loading");
    try {
      const prompt = `Provide a concise summary of the following text:

"""
${textToSummarize}
"""

Summary:`;
      const requestBody = {
        model: summarizationModel,
        prompt,
        stream: false,
        temperature: 0.2,
        options: {
          num_ctx: this.plugin.settings.contextWindow > 2048 ? 2048 : this.plugin.settings.contextWindow
        }
      };
      const responseData = await this.plugin.ollamaService.generateRaw(requestBody);
      if (responseData && responseData.response) {
        new SummaryModal(this.plugin, "Message Summary", responseData.response.trim()).open();
      } else {
        throw new Error("Received empty response from summarization model.");
      }
    } catch (error) {
      let userMessage = "Summarization failed: ";
      if (error instanceof Error) {
        if (error.message.includes("404") || error.message.toLocaleLowerCase().includes("model not found")) {
          userMessage += `Model '${summarizationModel}' not found.`;
        } else if (error.message.includes("connect") || error.message.includes("fetch")) {
          userMessage += "Could not connect to Ollama server.";
        } else {
          userMessage += error.message;
        }
      } else {
        userMessage += "Unknown error occurred.";
      }
      new import_obsidian15.Notice(userMessage, 6e3);
    } finally {
      (0, import_obsidian15.setIcon)(buttonEl, originalIcon);
      buttonEl.disabled = false;
      buttonEl.title = originalTitle;
      buttonEl.removeClass(CSS_CLASS_DISABLED);
      buttonEl.removeClass("button-loading");
    }
  }
  /**
   * Створює нову групу для відображення помилок або оновлює існуючу.
   * Тепер використовує ErrorMessageRenderer для створення візуального блоку.
   * @param isContinuing Чи це продовження попередньої послідовності помилок.
   */
  renderOrUpdateErrorGroup(isContinuing) {
    if (!this.chatContainer)
      return;
    const errorsToDisplay = [...this.consecutiveErrorMessages];
    if (errorsToDisplay.length === 0) {
      return;
    }
    const errorCount = errorsToDisplay.length;
    const lastError = errorsToDisplay[errorCount - 1];
    let groupEl;
    let contentContainer = null;
    if (isContinuing && this.errorGroupElement) {
      groupEl = this.errorGroupElement;
      contentContainer = groupEl.querySelector(`.${CSS_CLASS_ERROR_TEXT2}`);
      if (contentContainer) {
        contentContainer.empty();
      } else {
        return;
      }
      this.updateErrorGroupTimestamp(groupEl, lastError.timestamp);
    } else {
      this.hideEmptyState();
      this.isSummarizingErrors = false;
      const renderer = new ErrorMessageRenderer(this.app, this.plugin, lastError, this);
      groupEl = renderer.render();
      contentContainer = groupEl.querySelector(`.${CSS_CLASS_ERROR_TEXT2}`);
      this.chatContainer.appendChild(groupEl);
      this.errorGroupElement = groupEl;
      this.lastMessageElement = groupEl;
    }
    if (contentContainer) {
      if (errorCount === 1) {
        contentContainer.setText(lastError.content);
      } else {
        contentContainer.setText(`Multiple errors occurred (${errorCount}). Summarizing...`);
        if (!this.isSummarizingErrors) {
          this.triggerErrorSummarization(groupEl, errorsToDisplay);
        }
      }
    } else {
    }
    this.guaranteedScrollToBottom(50, true);
  }
  updateErrorGroupTimestamp(groupEl, timestamp) {
    groupEl.setAttribute("data-timestamp", timestamp.getTime().toString());
    const timestampEl = groupEl.querySelector(`.${CSS_CLASSES.TIMESTAMP}`);
    if (timestampEl) {
      timestampEl.setText(this.formatTime(timestamp));
    }
  }
  async triggerErrorSummarization(targetGroupElement, errors) {
    const ENABLE_ERROR_SUMMARIZATION = false;
    if (!ENABLE_ERROR_SUMMARIZATION) {
      this.displayErrorListFallback(targetGroupElement, errors);
      return;
    }
    if (!this.plugin.settings.summarizationModelName || this.isSummarizingErrors) {
      if (!this.plugin.settings.summarizationModelName) {
        if (this.isSummarizingErrors)
          this.displayErrorListFallback(targetGroupElement, errors);
      }
      return;
    }
    this.isSummarizingErrors = true;
    try {
      const summary = await this.summarizeErrors(errors);
      const contentContainer = targetGroupElement.querySelector(`.${CSS_CLASSES.ERROR_TEXT}`);
      if (!contentContainer || !contentContainer.isConnected) {
        return;
      }
      contentContainer.empty();
      if (summary) {
        contentContainer.setText(`Multiple errors occurred. Summary:
${summary}`);
      } else {
        this.displayErrorListFallback(targetGroupElement, errors);
      }
    } catch (error) {
      this.displayErrorListFallback(targetGroupElement, errors);
    } finally {
      this.isSummarizingErrors = false;
    }
  }
  displayErrorListFallback(targetGroupElement, errors) {
    const contentContainer = targetGroupElement.querySelector(`.${CSS_CLASSES.ERROR_TEXT}`);
    if (!contentContainer || !contentContainer.isConnected) {
      if (!targetGroupElement.isConnected) {
      }
      return;
    }
    contentContainer.empty();
    const uniqueErrors = Array.from(new Set(errors.map((e) => e.content.trim())));
    contentContainer.createDiv({
      text: `Multiple errors occurred (${errors.length} total, ${uniqueErrors.length} unique):`,
      cls: "error-summary-header"
    });
    const listEl = contentContainer.createEl("ul");
    listEl.style.marginTop = "5px";
    listEl.style.paddingLeft = "20px";
    listEl.style.listStyle = "disc";
    uniqueErrors.forEach((errorMsg) => {
      const listItem = listEl.createEl("li");
      listItem.textContent = errorMsg;
    });
    this.guaranteedScrollToBottom(50, true);
  }
  /**
   * Виконує сумаризацію списку повідомлень про помилки за допомогою Ollama.
   * @param errors Масив повідомлень про помилки.
   * @returns Рядок з сумаризацією або null у разі помилки.
   */
  async summarizeErrors(errors) {
    var _a;
    const modelName = this.plugin.settings.summarizationModelName;
    if (!modelName)
      return null;
    if (errors.length < 2)
      return ((_a = errors[0]) == null ? void 0 : _a.content) || null;
    const uniqueErrorContents = Array.from(new Set(errors.map((e) => e.content.trim())));
    const errorsText = uniqueErrorContents.map((msg, index) => `Error ${index + 1}: ${msg}`).join("\n");
    const prompt = `Concisely summarize the following ${uniqueErrorContents.length} unique error messages reported by the system. Focus on the core issue(s):

${errorsText}

Summary:`;
    const requestBody = {
      model: modelName,
      prompt,
      stream: false,
      temperature: 0.2,
      options: {
        num_ctx: this.plugin.settings.contextWindow > 1024 ? 1024 : this.plugin.settings.contextWindow
      },
      system: "You are an assistant that summarizes lists of technical error messages accurately and concisely."
    };
    try {
      const responseData = await this.plugin.ollamaService.generateRaw(requestBody);
      if (responseData && responseData.response) {
        return responseData.response.trim();
      } else {
        return null;
      }
    } catch (error) {
      return null;
    }
  }
  handleErrorMessage(errorMessage) {
    if (errorMessage.role !== "error") {
      return;
    }
    this.consecutiveErrorMessages.push(errorMessage);
    const isContinuingError = this.lastMessageElement === this.errorGroupElement && this.errorGroupElement !== null;
    if (!isContinuingError) {
      this.errorGroupElement = null;
      this.consecutiveErrorMessages = [errorMessage];
    }
    try {
      this.renderOrUpdateErrorGroup(isContinuingError);
    } catch (error) {
      try {
      } catch (e) {
      }
    }
  }
  async sendMessage() {
    var _a;
    const userInputText = this.inputEl.value.trim();
    const requestTimestampId = Date.now();
    if (!userInputText || this.isProcessing || this.currentAbortController) {
      if (this.isProcessing || this.currentAbortController)
        new import_obsidian15.Notice("Please wait or cancel current operation.", 3e3);
      return;
    }
    let activeChat = await this.plugin.chatManager.getActiveChat();
    if (!activeChat) {
      activeChat = await this.plugin.chatManager.createNewChat();
      if (!activeChat) {
        new import_obsidian15.Notice("Error: No active chat and could not create one.");
        this.setLoadingState(false);
        return;
      }
      new import_obsidian15.Notice(`Started new chat: ${activeChat.metadata.name}`);
    }
    const userMessageTimestamp = new Date();
    this.clearInputField();
    this.currentAbortController = new AbortController();
    this.setLoadingState(true);
    this.hideEmptyState();
    const initialLlmResponsePlaceholderTs = Date.now();
    try {
      const userMessageAdded = await this.plugin.chatManager.addUserMessageAndAwaitRender(
        userInputText,
        userMessageTimestamp,
        requestTimestampId
      );
      if (!userMessageAdded) {
        throw new Error("User message processing failed in ChatManager.");
      }
      const chatStateForLlm = await this.plugin.chatManager.getActiveChatOrFail();
      if (!this.currentAbortController) {
        this.plugin.logger.error(
          "CRITICAL: AbortController not initialized in sendMessage before LlmInteractionCycle call."
        );
        throw new Error("AbortController not initialized in sendMessage");
      }
      await this._handleLlmInteractionCycle(chatStateForLlm, requestTimestampId, this.currentAbortController.signal);
    } catch (error) {
      if (this.activePlaceholder && this.activePlaceholder.timestamp === initialLlmResponsePlaceholderTs && this.activePlaceholder.groupEl.classList.contains("placeholder")) {
        if (this.activePlaceholder.groupEl.isConnected)
          this.activePlaceholder.groupEl.remove();
      }
      this.plugin.chatManager.rejectAndClearHMAResolver(
        userMessageTimestamp.getTime(),
        `Outer catch in sendMessage for user message (req: ${requestTimestampId})`
      );
      this.plugin.chatManager.rejectAndClearHMAResolver(
        initialLlmResponsePlaceholderTs,
        `Outer catch in sendMessage for initial placeholder (req: ${requestTimestampId})`
      );
      let errorMsgForChat;
      let errorMsgRole = "error";
      if (error.name === "AbortError" || ((_a = error.message) == null ? void 0 : _a.includes("aborted by user"))) {
        errorMsgForChat = "Message generation stopped.";
        errorMsgRole = "system";
      } else {
        errorMsgForChat = `Error: ${error.message || "Unknown error during processing."}`;
        new import_obsidian15.Notice(errorMsgForChat, 7e3);
      }
      const errorDisplayTimestamp = new Date();
      const errorDisplayMsg = {
        role: errorMsgRole,
        content: errorMsgForChat,
        timestamp: errorDisplayTimestamp
      };
      const hmaErrorPromise = new Promise((resolve, reject) => {
        this.plugin.chatManager.registerHMAResolver(errorDisplayMsg.timestamp.getTime(), resolve, reject);
        setTimeout(() => {
          if (this.plugin.chatManager.messageAddedResolvers.has(errorDisplayMsg.timestamp.getTime())) {
            this.plugin.chatManager.rejectAndClearHMAResolver(
              errorDisplayMsg.timestamp.getTime(),
              "HMA timeout for error display msg in sendMessage"
            );
          }
        }, 1e4);
      });
      await this.plugin.chatManager.addMessageToActiveChatPayload(errorDisplayMsg, true);
      try {
        await hmaErrorPromise;
      } catch (e_hma) {
        this.plugin.logger.warn("[SendMessage] HMA for error display message failed or timed out:", e_hma);
      }
    } finally {
      if (this.activePlaceholder && this.activePlaceholder.groupEl.classList.contains("placeholder")) {
        if (this.activePlaceholder.groupEl.isConnected)
          this.activePlaceholder.groupEl.remove();
      }
      this.activePlaceholder = null;
      this.currentAbortController = null;
      this.setLoadingState(false);
      requestAnimationFrame(() => this.updateSendButtonState());
      this.focusInput();
    }
  }
  async handleMessageAdded(data) {
    var _a, _b, _c;
    const messageForLog = data == null ? void 0 : data.message;
    const messageTimestampForLog = (_a = messageForLog == null ? void 0 : messageForLog.timestamp) == null ? void 0 : _a.getTime();
    const messageRoleForLog = messageForLog == null ? void 0 : messageForLog.role;
    try {
      if (!data || !data.message) {
        if (messageTimestampForLog)
          this.plugin.chatManager.invokeHMAResolver(messageTimestampForLog);
        return;
      }
      const { chatId: eventChatId, message } = data;
      const messageTimestampMs = message.timestamp.getTime();
      if (!this.chatContainer || !this.plugin.chatManager) {
        if (messageTimestampForLog)
          this.plugin.chatManager.invokeHMAResolver(messageTimestampForLog);
        return;
      }
      const activeChatId = this.plugin.chatManager.getActiveChatId();
      if (eventChatId !== activeChatId) {
        if (messageTimestampForLog)
          this.plugin.chatManager.invokeHMAResolver(messageTimestampForLog);
        return;
      }
      if (message.role === "assistant" && message.tool_calls && message.tool_calls.length > 0 && this.currentAbortController) {
        this.plugin.logger.debug(
          "[handleMessageAdded] Skipping render for assistant message with tool_calls.",
          message
        );
        if (messageTimestampForLog)
          this.plugin.chatManager.invokeHMAResolver(messageTimestampForLog);
        if (this.activePlaceholder && this.activePlaceholder.timestamp === messageTimestampMs) {
          if (this.activePlaceholder.groupEl.isConnected) {
            this.activePlaceholder.groupEl.remove();
          }
          this.activePlaceholder = null;
        }
        return;
      }
      const existingRenderedMessage = this.chatContainer.querySelector(
        `.${CSS_CLASSES.MESSAGE_GROUP}:not(.placeholder)[data-timestamp="${messageTimestampMs}"]`
      );
      if (existingRenderedMessage) {
        if (messageTimestampForLog)
          this.plugin.chatManager.invokeHMAResolver(messageTimestampForLog);
        return;
      }
      const alreadyInLogicCache = this.currentMessages.some(
        (m) => m.timestamp.getTime() === messageTimestampMs && m.role === message.role && m.content === message.content
      );
      const isPotentiallyAssistantForPlaceholder = message.role === "assistant" && ((_b = this.activePlaceholder) == null ? void 0 : _b.timestamp) === messageTimestampMs;
      if (alreadyInLogicCache && !isPotentiallyAssistantForPlaceholder) {
        if (messageTimestampForLog)
          this.plugin.chatManager.invokeHMAResolver(messageTimestampForLog);
        return;
      }
      if (!alreadyInLogicCache) {
        this.currentMessages.push(message);
      }
      if (isPotentiallyAssistantForPlaceholder && this.activePlaceholder) {
        const placeholderToUpdate = this.activePlaceholder;
        if (((_c = placeholderToUpdate.groupEl) == null ? void 0 : _c.isConnected) && placeholderToUpdate.contentEl && placeholderToUpdate.messageWrapper) {
          placeholderToUpdate.groupEl.classList.remove("placeholder");
          placeholderToUpdate.groupEl.removeAttribute("data-placeholder-timestamp");
          placeholderToUpdate.groupEl.setAttribute("data-timestamp", messageTimestampMs.toString());
          const messageDomElement = placeholderToUpdate.groupEl.querySelector(
            `.${CSS_CLASSES.MESSAGE}`
          );
          if (!messageDomElement) {
            if (placeholderToUpdate.groupEl.isConnected)
              placeholderToUpdate.groupEl.remove();
            this.activePlaceholder = null;
            await this.addMessageStandard(message);
          } else {
            placeholderToUpdate.contentEl.classList.remove("streaming-text");
            const dotsEl = placeholderToUpdate.contentEl.querySelector(`.${CSS_CLASSES.THINKING_DOTS}`);
            if (dotsEl) {
              dotsEl.remove();
            }
            try {
              const displayContent = AssistantMessageRenderer.prepareDisplayContent(
                message.content || "",
                message,
                this.plugin,
                this
              );
              placeholderToUpdate.contentEl.empty();
              await renderMarkdownContent(
                this.app,
                this,
                this.plugin,
                placeholderToUpdate.contentEl,
                displayContent
              );
              AssistantMessageRenderer.addAssistantActionButtons(
                messageDomElement,
                placeholderToUpdate.contentEl,
                message,
                this.plugin,
                this
              );
              BaseMessageRenderer.addTimestamp(messageDomElement, message.timestamp, this);
              this.lastMessageElement = placeholderToUpdate.groupEl;
              this.hideEmptyState();
              const finalMessageGroupElement = placeholderToUpdate.groupEl;
              this.activePlaceholder = null;
              setTimeout(() => {
                if (finalMessageGroupElement && finalMessageGroupElement.isConnected) {
                  this.checkMessageForCollapsing(finalMessageGroupElement);
                }
              }, 70);
              this.guaranteedScrollToBottom(100, true);
            } catch (renderError) {
              if (placeholderToUpdate.groupEl.isConnected)
                placeholderToUpdate.groupEl.remove();
              this.activePlaceholder = null;
              this.handleErrorMessage({
                role: "error",
                content: `Failed to finalize display for ts ${messageTimestampMs}: ${renderError.message}`,
                timestamp: new Date()
              });
            }
          }
        } else {
          this.activePlaceholder = null;
          await this.addMessageStandard(message);
        }
      } else {
        await this.addMessageStandard(message);
      }
    } catch (outerError) {
      this.handleErrorMessage({
        role: "error",
        content: `Internal error in handleMessageAdded for ${messageRoleForLog} msg (ts ${messageTimestampForLog}): ${outerError.message}`,
        timestamp: new Date()
      });
      this.plugin.logger.error("Outer error in handleMessageAdded", outerError, { messageData: data });
    } finally {
      if (messageTimestampForLog && this.plugin.chatManager.messageAddedResolvers.has(messageTimestampForLog)) {
        this.plugin.chatManager.invokeHMAResolver(messageTimestampForLog);
      }
    }
  }
  async loadAndDisplayActiveChat() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    let metadataUpdated = false;
    try {
      this.clearChatContainerInternal();
      this.lastMessageElement = null;
      this.consecutiveErrorMessages = [];
      this.errorGroupElement = null;
      let activeChat = null;
      let availableModels = [];
      let finalModelName = null;
      let finalRolePath = void 0;
      let finalRoleName = "None";
      let finalTemperature = void 0;
      let errorOccurredLoadingData = false;
      try {
        activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat()) || null;
        availableModels = await this.plugin.ollamaService.getModels();
        finalRolePath = ((_b = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _b.selectedRolePath) !== void 0 ? activeChat.metadata.selectedRolePath : this.plugin.settings.selectedRolePath;
        finalRoleName = await this.findRoleNameByPath(finalRolePath);
      } catch (error) {
        new import_obsidian15.Notice("Error connecting to Ollama or loading chat data.", 5e3);
        errorOccurredLoadingData = true;
        availableModels = availableModels || [];
        finalModelName = availableModels.includes(this.plugin.settings.modelName) ? this.plugin.settings.modelName : (_c = availableModels[0]) != null ? _c : null;
        finalTemperature = this.plugin.settings.temperature;
        finalRolePath = this.plugin.settings.selectedRolePath;
        finalRoleName = await this.findRoleNameByPath(finalRolePath);
        activeChat = null;
      }
      if (!errorOccurredLoadingData && activeChat) {
        let preferredModel = ((_d = activeChat.metadata) == null ? void 0 : _d.modelName) || this.plugin.settings.modelName;
        if (availableModels.length > 0) {
          if (preferredModel && availableModels.includes(preferredModel)) {
            finalModelName = preferredModel;
          } else {
            finalModelName = availableModels[0];
          }
        } else {
          finalModelName = null;
        }
        if (activeChat.metadata.modelName !== finalModelName && finalModelName !== null) {
          try {
            const updateSuccess = await this.plugin.chatManager.updateActiveChatMetadata({ modelName: finalModelName });
            if (updateSuccess) {
              metadataUpdated = true;
              const potentiallyUpdatedChat = await this.plugin.chatManager.getChat(activeChat.metadata.id);
              if (potentiallyUpdatedChat)
                activeChat = potentiallyUpdatedChat;
            } else {
            }
          } catch (updateError) {
          }
        }
        finalTemperature = (_f = (_e = activeChat.metadata) == null ? void 0 : _e.temperature) != null ? _f : this.plugin.settings.temperature;
      } else if (!errorOccurredLoadingData && !activeChat) {
        finalModelName = availableModels.includes(this.plugin.settings.modelName) ? this.plugin.settings.modelName : (_g = availableModels[0]) != null ? _g : null;
        finalTemperature = this.plugin.settings.temperature;
        finalRolePath = this.plugin.settings.selectedRolePath;
        finalRoleName = await this.findRoleNameByPath(finalRolePath);
      }
      if (activeChat && !errorOccurredLoadingData && ((_h = activeChat.messages) == null ? void 0 : _h.length) > 0) {
        this.hideEmptyState();
        this.currentMessages = [...activeChat.messages];
        this.lastRenderedMessageDate = null;
        for (const message of this.currentMessages) {
          let messageGroupEl = null;
          const isNewDay = !this.lastRenderedMessageDate || !this.isSameDay(this.lastRenderedMessageDate, message.timestamp);
          const isFirstMessageInContainer = this.chatContainer.children.length === 0;
          if (isNewDay || isFirstMessageInContainer) {
            if (isNewDay && this.chatContainer.children.length > 0) {
              this.renderDateSeparator(message.timestamp);
            }
            this.lastRenderedMessageDate = message.timestamp;
          }
          try {
            let renderer = null;
            switch (message.role) {
              case "user":
                renderer = new UserMessageRenderer(this.app, this.plugin, message, this);
                break;
              case "assistant":
                renderer = new AssistantMessageRenderer(this.app, this.plugin, message, this);
                break;
              case "system":
                renderer = new SystemMessageRenderer(this.app, this.plugin, message, this);
                break;
              case "error":
                this.handleErrorMessage(message);
                messageGroupEl = this.errorGroupElement;
                break;
              case "tool":
                renderer = new ToolMessageRenderer(this.app, this.plugin, message, this);
                break;
              default:
                const unknownRoleGroup = (_i = this.chatContainer) == null ? void 0 : _i.createDiv({ cls: CSS_CLASSES.MESSAGE_GROUP });
                if (unknownRoleGroup && this.chatContainer) {
                  renderAvatar(this.app, this.plugin, unknownRoleGroup, false);
                  const wrapper = unknownRoleGroup.createDiv({ cls: CSS_CLASSES.MESSAGE_WRAPPER || "message-wrapper" });
                  const msgBubble = wrapper.createDiv({ cls: `${CSS_CLASSES.MESSAGE} ${CSS_CLASSES.SYSTEM_MESSAGE}` });
                  msgBubble.createDiv({
                    cls: CSS_CLASSES.SYSTEM_MESSAGE_TEXT || "system-message-text",
                    text: `Unknown message role: ${message.role}`
                  });
                  BaseMessageRenderer.addTimestamp(msgBubble, message.timestamp, this);
                  this.chatContainer.appendChild(unknownRoleGroup);
                  messageGroupEl = unknownRoleGroup;
                }
                break;
            }
            if (renderer && message.role !== "error") {
              const result = renderer.render();
              messageGroupEl = result instanceof Promise ? await result : result;
            }
          } catch (renderError) {
            const errorDiv = this.chatContainer.createDiv({ cls: CSS_CLASSES.ERROR_MESSAGE || "render-error" });
            errorDiv.setText(`Error rendering message (role: ${message.role})`);
            messageGroupEl = errorDiv;
          }
          if (messageGroupEl) {
            if (messageGroupEl.parentElement !== this.chatContainer) {
              this.chatContainer.appendChild(messageGroupEl);
            }
            this.lastMessageElement = messageGroupEl;
          }
        }
        setTimeout(() => this.checkAllMessagesForCollapsing(), 100);
        setTimeout(() => {
          this.guaranteedScrollToBottom(100, true);
          setTimeout(() => {
            this.updateScrollStateAndIndicators();
          }, 150);
        }, 150);
      } else {
        this.showEmptyState();
        (_j = this.scrollToBottomButton) == null ? void 0 : _j.classList.remove(CSS_CLASSES.VISIBLE || "visible");
      }
      this.updateInputPlaceholder(finalRoleName);
      this.updateRoleDisplay(finalRoleName);
      this.updateModelDisplay(finalModelName);
      this.updateTemperatureIndicator(finalTemperature);
      if (finalModelName === null) {
        if (this.inputEl) {
          this.inputEl.disabled = true;
          this.inputEl.placeholder = "No models available...";
        }
        if (this.sendButton) {
          this.sendButton.disabled = true;
          this.sendButton.classList.add(CSS_CLASSES.DISABLED || "disabled");
        }
        if (this.isProcessing)
          this.setLoadingState(false);
      } else {
        if (this.inputEl && !this.isProcessing) {
          this.inputEl.disabled = false;
        }
        this.updateSendButtonState();
      }
    } catch (error) {
      this.clearChatContainerInternal();
      this.showEmptyState();
      if (this.chatContainer) {
        this.chatContainer.createDiv({
          cls: "fatal-error-message",
          text: "Failed to load chat content. Please check console."
        });
      }
      return { metadataUpdated: false };
    } finally {
    }
    return { metadataUpdated };
  }
  _managePlaceholder(turnTimestamp, requestTimestampId) {
    if (this.activePlaceholder && this.activePlaceholder.timestamp !== turnTimestamp) {
      if (this.activePlaceholder.groupEl.classList.contains("placeholder")) {
        if (this.activePlaceholder.groupEl.isConnected)
          this.activePlaceholder.groupEl.remove();
      }
      this.activePlaceholder = null;
    }
    if (!this.activePlaceholder) {
      const placeholderGroupEl = this.chatContainer.createDiv({
        cls: `${CSS_CLASSES.MESSAGE_GROUP} ${CSS_CLASSES.OLLAMA_GROUP} placeholder`
      });
      placeholderGroupEl.setAttribute("data-placeholder-timestamp", turnTimestamp.toString());
      renderAvatar(this.app, this.plugin, placeholderGroupEl, false, "assistant");
      const wrapperEl = placeholderGroupEl.createDiv({ cls: CSS_CLASSES.MESSAGE_WRAPPER || "message-wrapper" });
      wrapperEl.style.order = "2";
      const msgEl = wrapperEl.createDiv({ cls: `${CSS_CLASSES.MESSAGE} ${CSS_CLASSES.OLLAMA_MESSAGE}` });
      const contentContainerEl = msgEl.createDiv({ cls: CSS_CLASSES.CONTENT_CONTAINER });
      const contentPlaceholderEl = contentContainerEl.createDiv({
        cls: `${CSS_CLASSES.CONTENT} ${CSS_CLASSES.CONTENT_COLLAPSIBLE} streaming-text`
      });
      contentPlaceholderEl.empty();
      const dots = contentPlaceholderEl.createDiv({ cls: CSS_CLASSES.THINKING_DOTS });
      for (let i = 0; i < 3; i++)
        dots.createDiv({ cls: CSS_CLASSES.THINKING_DOT });
      this.activePlaceholder = {
        timestamp: turnTimestamp,
        groupEl: placeholderGroupEl,
        contentEl: contentPlaceholderEl,
        messageWrapper: wrapperEl
      };
      placeholderGroupEl.classList.add(CSS_CLASSES.MESSAGE_ARRIVING || "message-arriving");
      setTimeout(() => placeholderGroupEl == null ? void 0 : placeholderGroupEl.classList.remove(CSS_CLASSES.MESSAGE_ARRIVING || "message-arriving"), 500);
      this.guaranteedScrollToBottom(50, true);
    } else {
      this.activePlaceholder.contentEl.empty();
      const dots = this.activePlaceholder.contentEl.createDiv({ cls: CSS_CLASSES.THINKING_DOTS });
      for (let i = 0; i < 3; i++)
        dots.createDiv({ cls: CSS_CLASSES.THINKING_DOT });
      this.activePlaceholder.contentEl.classList.add("streaming-text");
      this.activePlaceholder.timestamp = turnTimestamp;
      this.activePlaceholder.groupEl.setAttribute("data-placeholder-timestamp", turnTimestamp.toString());
    }
  }
  async _processLlmStream(stream, currentTurnLlmResponseTs, requestTimestampId) {
    var _a, _b, _c, _d, _e;
    let accumulatedContent = "";
    let nativeToolCalls = null;
    let assistantMessageWithNativeCalls = null;
    let firstChunkForTurn = true;
    for await (const chunk of stream) {
      if ((_a = this.currentAbortController) == null ? void 0 : _a.signal.aborted) {
        throw new Error("aborted by user");
      }
      if (chunk.type === "error") {
        throw new Error(chunk.error);
      }
      if (((_b = this.activePlaceholder) == null ? void 0 : _b.timestamp) !== currentTurnLlmResponseTs) {
        if (chunk.type === "done")
          break;
        continue;
      }
      if (chunk.type === "content") {
        if ((_c = this.activePlaceholder) == null ? void 0 : _c.contentEl) {
          if (firstChunkForTurn) {
            const thinkingDots = this.activePlaceholder.contentEl.querySelector(`.${CSS_CLASSES.THINKING_DOTS}`);
            if (thinkingDots)
              thinkingDots.remove();
            firstChunkForTurn = false;
          }
          accumulatedContent += chunk.response;
          await renderMarkdownContent(
            this.app,
            this,
            this.plugin,
            this.activePlaceholder.contentEl,
            accumulatedContent
          );
          this.guaranteedScrollToBottom(30, true);
        }
      } else if (chunk.type === "tool_calls") {
        nativeToolCalls = chunk.calls;
        assistantMessageWithNativeCalls = chunk.assistant_message_with_calls;
        if (assistantMessageWithNativeCalls == null ? void 0 : assistantMessageWithNativeCalls.content) {
          if (firstChunkForTurn && ((_d = this.activePlaceholder) == null ? void 0 : _d.contentEl)) {
            const thinkingDots = this.activePlaceholder.contentEl.querySelector(`.${CSS_CLASSES.THINKING_DOTS}`);
            if (thinkingDots)
              thinkingDots.remove();
            firstChunkForTurn = false;
          }
          if (!accumulatedContent.endsWith(assistantMessageWithNativeCalls.content)) {
            accumulatedContent += assistantMessageWithNativeCalls.content;
          }
          if ((_e = this.activePlaceholder) == null ? void 0 : _e.contentEl) {
            await renderMarkdownContent(
              this.app,
              this,
              this.plugin,
              this.activePlaceholder.contentEl,
              accumulatedContent
            );
          }
        }
      } else if (chunk.type === "done") {
        break;
      }
    }
    return { accumulatedContent, nativeToolCalls, assistantMessageWithNativeCalls };
  }
  _determineToolCalls(nativeToolCalls, assistantMessageWithNativeCalls, accumulatedLlmContent, currentTurnLlmResponseTs, requestTimestampId) {
    let processedToolCallsThisTurn = nativeToolCalls;
    let isTextualFallbackUsed = false;
    let assistantMessageForHistory;
    if (!processedToolCallsThisTurn || processedToolCallsThisTurn.length === 0) {
      const parsedTextualCalls = parseAllTextualToolCalls(accumulatedLlmContent, this.plugin.logger);
      if (parsedTextualCalls.length > 0) {
        isTextualFallbackUsed = true;
        processedToolCallsThisTurn = parsedTextualCalls.map((tc, index) => ({
          type: "function",
          id: `texttool-${currentTurnLlmResponseTs}-${index}`,
          function: { name: tc.name, arguments: JSON.stringify(tc.arguments || {}) }
        }));
        assistantMessageForHistory = {
          role: "assistant",
          content: accumulatedLlmContent,
          timestamp: new Date(currentTurnLlmResponseTs)
        };
      } else {
        assistantMessageForHistory = {
          role: "assistant",
          content: accumulatedLlmContent,
          timestamp: new Date(currentTurnLlmResponseTs)
        };
      }
    } else {
      assistantMessageForHistory = assistantMessageWithNativeCalls || {
        role: "assistant",
        content: accumulatedLlmContent,
        timestamp: new Date(currentTurnLlmResponseTs),
        tool_calls: processedToolCallsThisTurn
      };
      assistantMessageForHistory.content = accumulatedLlmContent;
      assistantMessageForHistory.tool_calls = processedToolCallsThisTurn;
    }
    return { processedToolCallsThisTurn, assistantMessageForHistory, isTextualFallbackUsed };
  }
  // src/OllamaView.ts
  // ...
  async _executeAndRenderToolCycle(toolsToExecute, assistantMessageIntent, requestTimestampId, signal) {
    const currentViewInstance = this;
    for (const call of toolsToExecute) {
      if (signal.aborted)
        throw new Error("aborted by user");
      if (call.type === "function") {
        const toolName = call.function.name;
        let toolArgs = {};
        let toolResultContentForHistory = "";
        let parseErrorOccurred = false;
        try {
          toolArgs = JSON.parse(call.function.arguments || "{}");
        } catch (e) {
          const errorContent = `Error parsing arguments for tool ${toolName}: ${e.message}. Arguments string: "${call.function.arguments}"`;
          this.plugin.logger.error(`[ToolCycle] Arg Parsing Error for ${toolName}: ${errorContent}`);
          toolResultContentForHistory = `[TOOL_ERROR]
${errorContent}
[/TOOL_ERROR]`;
          parseErrorOccurred = true;
        }
        if (!parseErrorOccurred) {
          if (signal.aborted)
            throw new Error("aborted by user");
          const execResult = await currentViewInstance.plugin.agentManager.executeTool(toolName, toolArgs);
          if (execResult.success) {
            toolResultContentForHistory = `[TOOL_RESULT]
${execResult.result}
[/TOOL_RESULT]`;
          } else {
            toolResultContentForHistory = `[TOOL_ERROR]
Error executing tool ${toolName}: ${execResult.error || "Unknown tool error"}
[/TOOL_ERROR]`;
          }
        }
        const toolResponseTimestamp = new Date();
        const toolResponseMsg = {
          role: "tool",
          tool_call_id: call.id,
          name: toolName,
          content: toolResultContentForHistory,
          timestamp: toolResponseTimestamp
        };
        const toolResultHmaPromise = new Promise((resolve, reject) => {
          currentViewInstance.plugin.chatManager.registerHMAResolver(
            toolResponseMsg.timestamp.getTime(),
            resolve,
            reject
          );
          setTimeout(() => {
            if (currentViewInstance.plugin.chatManager.messageAddedResolvers.has(toolResponseMsg.timestamp.getTime())) {
              currentViewInstance.plugin.chatManager.rejectAndClearHMAResolver(
                toolResponseMsg.timestamp.getTime(),
                `HMA Timeout for tool result: ${toolName} in _executeAndRenderToolCycle`
              );
            }
          }, 1e4);
        });
        await currentViewInstance.plugin.chatManager.addMessageToActiveChatPayload(toolResponseMsg, true);
        try {
          await toolResultHmaPromise;
        } catch (hmaError) {
          this.plugin.logger.warn(`[ToolCycle] HMA for tool response ${toolName} failed or timed out:`, hmaError);
        }
      }
    }
  }
  // ... (решта методів OllamaView.ts) ...
  async _renderFinalAssistantText(finalContent, responseTimestampMs, requestTimestampId) {
    var _a, _b;
    const currentViewInstance = this;
    if (finalContent.trim()) {
      const finalAssistantMsg = {
        role: "assistant",
        content: finalContent,
        timestamp: new Date(responseTimestampMs)
      };
      const hmaPromise = new Promise((resolve, reject) => {
        currentViewInstance.plugin.chatManager.registerHMAResolver(responseTimestampMs, resolve, reject);
        setTimeout(() => {
          if (currentViewInstance.plugin.chatManager.messageAddedResolvers.has(responseTimestampMs)) {
            currentViewInstance.plugin.chatManager.rejectAndClearHMAResolver(
              responseTimestampMs,
              "HMA Timeout for final assistant message"
            );
          }
        }, 1e4);
      });
      await currentViewInstance.plugin.chatManager.addMessageToActiveChatPayload(finalAssistantMsg, true);
      await hmaPromise;
    } else if (!((_a = currentViewInstance.currentAbortController) == null ? void 0 : _a.signal.aborted)) {
      const emptyResponseMsgTimestamp = new Date();
      const emptyResponseMsg = {
        role: "system",
        content: "Assistant provided an empty response.",
        timestamp: emptyResponseMsgTimestamp
      };
      const hmaPromise = new Promise((resolve, reject) => {
        currentViewInstance.plugin.chatManager.registerHMAResolver(
          emptyResponseMsg.timestamp.getTime(),
          resolve,
          reject
        );
        setTimeout(() => {
          if (currentViewInstance.plugin.chatManager.messageAddedResolvers.has(emptyResponseMsg.timestamp.getTime())) {
            currentViewInstance.plugin.chatManager.rejectAndClearHMAResolver(
              emptyResponseMsg.timestamp.getTime(),
              "HMA timeout for empty sys msg"
            );
          }
        }, 1e4);
      });
      await currentViewInstance.plugin.chatManager.addMessageToActiveChatPayload(emptyResponseMsg, true);
      try {
        await hmaPromise;
      } catch (e_hma) {
      }
    }
    if (((_b = currentViewInstance.activePlaceholder) == null ? void 0 : _b.timestamp) === responseTimestampMs) {
      currentViewInstance.activePlaceholder = null;
    }
  }
  async handleRegenerateClick(messageToRegenerateFrom) {
    var _a;
    if (this.isRegenerating) {
      new import_obsidian15.Notice("Regeneration is already in progress. Please wait.", 3e3);
      return;
    }
    if (this.currentAbortController) {
      new import_obsidian15.Notice("Another generation process is currently active. Please wait or cancel it first.", 4e3);
      return;
    }
    const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
    if (!activeChat) {
      new import_obsidian15.Notice("Cannot regenerate: No active chat found.");
      return;
    }
    const chatId = activeChat.metadata.id;
    let anchorMessageIndex = activeChat.messages.findIndex(
      (msg) => msg.timestamp.getTime() === messageToRegenerateFrom.timestamp.getTime() && msg.role === messageToRegenerateFrom.role
    );
    if (anchorMessageIndex === -1) {
      new import_obsidian15.Notice("Error: Could not find the message to regenerate from in the current chat history.");
      this.plugin.logger.warn("Regeneration failed: Anchor message not found for regeneration.", {
        targetTimestamp: messageToRegenerateFrom.timestamp.getTime(),
        targetRole: messageToRegenerateFrom.role,
        activeChatId: chatId
        // Можна додати перші/останні кілька повідомлень з activeChat.messages для контексту, якщо потрібно
      });
      return;
    }
    let messageIndexToDeleteAfter = anchorMessageIndex;
    if (messageToRegenerateFrom.role === "assistant") {
      messageIndexToDeleteAfter = anchorMessageIndex - 1;
    }
    const hasMessagesAfterTargetPoint = activeChat.messages.length > messageIndexToDeleteAfter + 1;
    new ConfirmModal(
      this.app,
      "Confirm Regeneration",
      hasMessagesAfterTargetPoint ? "This will delete all messages after this point in the conversation and generate a new response. Are you sure you want to continue?" : "Are you sure you want to generate a new response for this prompt?",
      async () => {
        var _a2;
        this.isRegenerating = true;
        const regenerationGlobalRequestId = Date.now();
        this.currentAbortController = new AbortController();
        this.setLoadingState(true);
        const initialLlmResponsePlaceholderTsForRegen = Date.now();
        try {
          if (hasMessagesAfterTargetPoint) {
            const deleteSuccess = await this.plugin.chatManager.deleteMessagesAfter(chatId, messageIndexToDeleteAfter);
            if (!deleteSuccess) {
              throw new Error("Failed to delete subsequent messages. Regeneration cannot proceed.");
            }
          }
          await this.loadAndDisplayActiveChat();
          this.guaranteedScrollToBottom(50, true);
          const chatStateForLlm = await this.plugin.chatManager.getActiveChatOrFail();
          if (!chatStateForLlm) {
            throw new Error("Failed to reload chat state after preparing for regeneration.");
          }
          if (!this.currentAbortController) {
            this.plugin.logger.error(
              "CRITICAL: AbortController not initialized in handleRegenerateClick before LlmInteractionCycle call."
            );
            throw new Error("AbortController not initialized in handleRegenerateClick");
          }
          await this._handleLlmInteractionCycle(
            chatStateForLlm,
            regenerationGlobalRequestId,
            this.currentAbortController.signal
          );
        } catch (error) {
          if (this.activePlaceholder && this.activePlaceholder.timestamp === initialLlmResponsePlaceholderTsForRegen && this.activePlaceholder.groupEl.classList.contains("placeholder")) {
            if (this.activePlaceholder.groupEl.isConnected)
              this.activePlaceholder.groupEl.remove();
          }
          this.plugin.chatManager.rejectAndClearHMAResolver(
            initialLlmResponsePlaceholderTsForRegen,
            `Outer catch in handleRegenerateClick for initial placeholder (req: ${regenerationGlobalRequestId})`
          );
          let errorMsgForChat;
          let errorMsgRole = "error";
          if (error.name === "AbortError" || ((_a2 = error.message) == null ? void 0 : _a2.includes("aborted by user"))) {
            errorMsgForChat = "Regeneration process was stopped by the user.";
            errorMsgRole = "system";
          } else {
            errorMsgForChat = `Regeneration failed: ${error.message || "An unknown error occurred during processing."}`;
            new import_obsidian15.Notice(errorMsgForChat, 7e3);
          }
          const errorDisplayTimestamp = new Date();
          const errorDisplayMsg = {
            role: errorMsgRole,
            content: errorMsgForChat,
            timestamp: errorDisplayTimestamp
          };
          const hmaErrorPromise = new Promise((resolve, reject) => {
            this.plugin.chatManager.registerHMAResolver(errorDisplayMsg.timestamp.getTime(), resolve, reject);
            setTimeout(() => {
              if (this.plugin.chatManager.messageAddedResolvers.has(errorDisplayMsg.timestamp.getTime())) {
                this.plugin.chatManager.rejectAndClearHMAResolver(
                  errorDisplayMsg.timestamp.getTime(),
                  "HMA timeout for error display msg in handleRegenerateClick"
                );
              }
            }, 1e4);
          });
          await this.plugin.chatManager.addMessageToActiveChatPayload(errorDisplayMsg, true);
          try {
            await hmaErrorPromise;
          } catch (e_hma) {
            this.plugin.logger.warn("[Regenerate] HMA for error display message failed or timed out:", e_hma);
          }
        } finally {
          if (this.activePlaceholder && this.activePlaceholder.groupEl.classList.contains("placeholder")) {
            if (this.activePlaceholder.groupEl.isConnected) {
              this.activePlaceholder.groupEl.remove();
            }
          }
          this.activePlaceholder = null;
          this.currentAbortController = null;
          this.isRegenerating = false;
          this.setLoadingState(false);
          requestAnimationFrame(() => this.updateSendButtonState());
          this.focusInput();
        }
      }
    ).open();
  }
  async _handleLlmInteractionCycle(initialChatState, globalInteractionRequestId, signal) {
    let continueConversation = true;
    const maxTurns = 5;
    let turns = 0;
    let currentTurnLlmResponseTsForCatch = null;
    let chatStateForLlm = initialChatState;
    try {
      while (continueConversation && turns < maxTurns && !signal.aborted) {
        turns++;
        const currentTurnLlmResponseTs = Date.now();
        currentTurnLlmResponseTsForCatch = currentTurnLlmResponseTs;
        const currentTurnRequestId = globalInteractionRequestId + turns;
        this._managePlaceholder(currentTurnLlmResponseTs, currentTurnRequestId);
        chatStateForLlm = await this.plugin.chatManager.getActiveChatOrFail();
        const llmStream = this.plugin.ollamaService.generateChatResponseStream(
          chatStateForLlm,
          signal
          // Передаємо сигнал скасування в сервіс
        );
        const { accumulatedContent, nativeToolCalls, assistantMessageWithNativeCalls } = await this._processLlmStream(
          llmStream,
          currentTurnLlmResponseTs,
          currentTurnRequestId
          // _processLlmStream має внутрішньо обробляти сигнал, отриманий від ollamaService
        );
        if (signal.aborted)
          throw new Error("aborted by user");
        const toolCallCheckResult = this._determineToolCalls(
          nativeToolCalls,
          assistantMessageWithNativeCalls,
          accumulatedContent,
          currentTurnLlmResponseTs,
          currentTurnRequestId
        );
        if (toolCallCheckResult.processedToolCallsThisTurn && toolCallCheckResult.processedToolCallsThisTurn.length > 0) {
          const assistantMsgTsMs = toolCallCheckResult.assistantMessageForHistory.timestamp.getTime();
          const assistantHmaPromise = new Promise((resolve, reject) => {
            this.plugin.chatManager.registerHMAResolver(assistantMsgTsMs, resolve, reject);
            setTimeout(() => {
              if (this.plugin.chatManager.messageAddedResolvers.has(assistantMsgTsMs)) {
                this.plugin.chatManager.rejectAndClearHMAResolver(
                  assistantMsgTsMs,
                  `HMA Timeout for assistant tool intent (ts: ${assistantMsgTsMs}) in _handleLlmInteractionCycle`
                );
              }
            }, 1e4);
          });
          await this.plugin.chatManager.addMessageToActiveChatPayload(
            toolCallCheckResult.assistantMessageForHistory,
            true
          );
          await assistantHmaPromise;
          await this._executeAndRenderToolCycle(
            toolCallCheckResult.processedToolCallsThisTurn,
            toolCallCheckResult.assistantMessageForHistory,
            currentTurnRequestId,
            signal
            // Передаємо сигнал далі
          );
          continueConversation = true;
        } else {
          await this._renderFinalAssistantText(accumulatedContent, currentTurnLlmResponseTs, currentTurnRequestId);
          continueConversation = false;
        }
      }
      if (turns >= maxTurns && !signal.aborted) {
        const maxTurnsMsgTimestamp = new Date();
        const maxTurnsMsg = {
          role: "system",
          content: "Max processing turns reached. If the task is not complete, please try rephrasing or breaking it down.",
          timestamp: maxTurnsMsgTimestamp
        };
        const hmaMaxTurnsPromise = new Promise((resolve, reject) => {
          this.plugin.chatManager.registerHMAResolver(maxTurnsMsg.timestamp.getTime(), resolve, reject);
          setTimeout(() => {
            if (this.plugin.chatManager.messageAddedResolvers.has(maxTurnsMsg.timestamp.getTime())) {
              this.plugin.chatManager.rejectAndClearHMAResolver(
                maxTurnsMsg.timestamp.getTime(),
                "HMA timeout for max turns msg in _handleLlmInteractionCycle"
              );
            }
          }, 1e4);
        });
        await this.plugin.chatManager.addMessageToActiveChatPayload(maxTurnsMsg, true);
        try {
          await hmaMaxTurnsPromise;
        } catch (e_hma) {
          this.plugin.logger.warn("[LlmCycle] HMA for max turns message failed or timed out:", e_hma);
        }
      }
    } catch (error) {
      throw error;
    }
  }
};

// src/ragService.ts
var import_obsidian16 = require("obsidian");
var RagService = class {
  constructor(plugin) {
    this.chunkEmbeddings = [];
    this.isIndexing = false;
    this.embeddingModelName = "nomic-embed-text";
    this.plugin = plugin;
    this.adapter = plugin.app.vault.adapter;
    this.vault = plugin.app.vault;
    this.metadataCache = plugin.app.metadataCache;
    this.embeddingModelName = this.plugin.settings.ragEmbeddingModel || DEFAULT_SETTINGS.ragEmbeddingModel;
  }
  // src/ragService.ts -> splitIntoChunks (Версія 3 - Розділення за Заголовками)
  splitIntoChunks(text, chunkSize) {
    if (!text)
      return [];
    this.plugin.logger.debug(`[RagService Chunking v3] Input text length: ${text.length}`);
    const lines = text.split("\n");
    const chunks = [];
    let currentChunkLines = [];
    const minChunkLength = 15;
    for (const line of lines) {
      const trimmedLine = line.trim();
      const isHeading = trimmedLine.startsWith("# ");
      if (currentChunkLines.length > 0 && (isHeading || currentChunkLines.join("\n").length + trimmedLine.length + 1 > chunkSize)) {
        const chunkText = currentChunkLines.join("\n").trim();
        if (chunkText.length >= minChunkLength) {
          chunks.push(chunkText);
        } else {
          this.plugin.logger.debug(`[RagService Chunking v3] Skipping short chunk (length ${chunkText.length}): "${chunkText.substring(0, 70)}..."`);
        }
        currentChunkLines = [];
      }
      if (trimmedLine.length > 0) {
        if (trimmedLine.length <= chunkSize) {
          currentChunkLines.push(trimmedLine);
        } else {
          this.plugin.logger.debug(`[RagService Chunking v3] Line too long (${trimmedLine.length}), splitting...`);
          for (let i = 0; i < trimmedLine.length; i += chunkSize) {
            const subChunk = trimmedLine.substring(i, i + chunkSize);
            if (subChunk.length >= minChunkLength) {
              chunks.push(subChunk);
            }
          }
          currentChunkLines = [];
        }
      }
    }
    if (currentChunkLines.length > 0) {
      const chunkText = currentChunkLines.join("\n").trim();
      if (chunkText.length >= minChunkLength) {
        chunks.push(chunkText);
      } else {
        this.plugin.logger.debug(`[RagService Chunking v3] Skipping final short chunk (length ${chunkText.length}): "${chunkText.substring(0, 70)}..."`);
      }
    }
    this.plugin.logger.debug(`[RagService Chunking v3] Produced ${chunks.length} chunks after filtering (>=${minChunkLength} chars).`);
    return chunks;
  }
  /**
   * ОНОВЛЕНО: Індексує markdown файли, розпізнаючи тег 'personal-focus'.
   */
  async indexDocuments() {
    var _a, _b;
    if (!this.plugin.settings.ragEnabled || !this.plugin.settings.ragEnableSemanticSearch) {
      this.plugin.logger.debug("[RagService] RAG semantic indexing skipped (disabled in settings).");
      this.chunkEmbeddings = [];
      return;
    }
    if (this.isIndexing) {
      this.plugin.logger.warn("[RagService] Indexing already in progress.");
      return;
    }
    this.isIndexing = true;
    this.plugin.logger.info("[RagService] Starting semantic indexing...");
    const startTime = Date.now();
    this.embeddingModelName = this.plugin.settings.ragEmbeddingModel || DEFAULT_SETTINGS.ragEmbeddingModel;
    const chunkSize = this.plugin.settings.ragChunkSize || DEFAULT_SETTINGS.ragChunkSize;
    const personalFocusTag = "personal-focus";
    this.plugin.logger.debug(`[RagService] Using embedding model: ${this.embeddingModelName}, Chunk size: ${chunkSize}, Personal Focus Tag: '${personalFocusTag}'`);
    const newEmbeddings = [];
    try {
      const folderPath = this.plugin.settings.ragFolderPath;
      const files = await this.getMarkdownFiles(this.vault, folderPath);
      this.plugin.logger.debug(`[RagService] Found ${files.length} markdown files in "${folderPath}".`);
      let processedFiles = 0;
      let personalFocusFiles = 0;
      for (const file of files) {
        try {
          const content = await this.vault.read(file);
          const fileCache = this.metadataCache.getFileCache(file);
          const frontmatter = (fileCache == null ? void 0 : fileCache.frontmatter) || {};
          const isPersonal = frontmatter[personalFocusTag] === true;
          if (isPersonal) {
            personalFocusFiles++;
            this.plugin.logger.debug(`[RagService] File ${file.path} marked as personal focus.`);
          }
          let bodyContent = content;
          if (fileCache == null ? void 0 : fileCache.frontmatterPosition) {
            bodyContent = content.substring(fileCache.frontmatterPosition.end.offset).trim();
          }
          const chunks = this.splitIntoChunks(bodyContent, chunkSize);
          if (!chunks || chunks.length === 0) {
            continue;
          }
          const vectors = await this.plugin.ollamaService.generateEmbeddings(chunks, this.embeddingModelName);
          if (vectors && vectors.length === chunks.length) {
            const metadata = {
              ...frontmatter,
              // Копіюємо весь frontmatter
              path: file.path,
              filename: file.name,
              created: (_a = file.stat) == null ? void 0 : _a.ctime,
              modified: (_b = file.stat) == null ? void 0 : _b.mtime,
              isPersonalFocus: isPersonal
              // <-- Зберігаємо прапорець
            };
            for (let i = 0; i < chunks.length; i++) {
              newEmbeddings.push({
                text: chunks[i],
                vector: vectors[i],
                metadata
                // Всі чанки файлу мають однакові метадані
              });
            }
            processedFiles++;
          } else {
            this.plugin.logger.warn(`[RagService] Mismatch or error generating embeddings for ${file.path}. Expected ${chunks.length}, got ${vectors == null ? void 0 : vectors.length}`);
          }
        } catch (error) {
          this.plugin.logger.error(`[RagService] Error processing file ${file.path}:`, error);
        }
      }
      this.chunkEmbeddings = newEmbeddings;
      const duration = (Date.now() - startTime) / 1e3;
      this.plugin.logger.info(`[RagService] Semantic indexing complete in ${duration.toFixed(2)}s. Indexed ${this.chunkEmbeddings.length} chunks from ${processedFiles} files (${personalFocusFiles} personal focus files).`);
    } catch (error) {
      this.plugin.logger.error("[RagService] Error during indexing process:", error);
    } finally {
      this.isIndexing = false;
    }
  }
  async getMarkdownFiles(vault, folderPath) {
    const files = [];
    if (!folderPath) {
      this.plugin.logger.warn("[RagService] RAG folder path is not set.");
      return files;
    }
    const folder = vault.getAbstractFileByPath((0, import_obsidian16.normalizePath)(folderPath));
    if (!(folder instanceof import_obsidian16.TFolder)) {
      this.plugin.logger.warn(`[RagService] RAG folder path "${folderPath}" not found or is not a folder.`);
      return files;
    }
    const allFiles = vault.getMarkdownFiles();
    for (const file of allFiles) {
      if (file.path.startsWith(folder.path + "/")) {
        files.push(file);
      }
    }
    return files;
  }
  calculateCosineSimilarity(vecA, vecB) {
    if (!vecA || !vecB || vecA.length !== vecB.length || vecA.length === 0) {
      return 0;
    }
    let dotProduct = 0;
    let normA = 0;
    let normB = 0;
    for (let i = 0; i < vecA.length; i++) {
      dotProduct += vecA[i] * vecB[i];
      normA += vecA[i] * vecA[i];
      normB += vecB[i] * vecB[i];
    }
    if (normA === 0 || normB === 0)
      return 0;
    const magnitude = Math.sqrt(normA) * Math.sqrt(normB);
    if (magnitude === 0)
      return 0;
    return dotProduct / magnitude;
  }
  /**
   * Знаходить релевантні ЧАНКИ документів за допомогою семантичної подібності.
   * Повертає чанки з метаданими, включаючи прапорець isPersonalFocus.
   */
  async findRelevantDocuments(query, limit) {
    var _a;
    if (!this.plugin.settings.ragEnableSemanticSearch) {
      this.plugin.logger.debug("[RagService] Semantic search disabled, skipping retrieval.");
      return [];
    }
    if (!this.chunkEmbeddings || this.chunkEmbeddings.length === 0 || !query) {
      if (((_a = this.chunkEmbeddings) == null ? void 0 : _a.length) === 0)
        this.plugin.logger.warn("[RagService] No chunk embeddings available for search. Index might be empty or disabled.");
      return [];
    }
    this.plugin.logger.debug(`[RagService] Performing semantic search for query: "${query}"`);
    const startTime = Date.now();
    try {
      const queryEmbeddings = await this.plugin.ollamaService.generateEmbeddings([query], this.embeddingModelName);
      if (!queryEmbeddings || queryEmbeddings.length === 0 || !queryEmbeddings[0]) {
        this.plugin.logger.error("[RagService] Failed to generate embedding for the query.");
        return [];
      }
      const queryVector = queryEmbeddings[0];
      const scoredChunks = this.chunkEmbeddings.map((chunk) => {
        const similarity = this.calculateCosineSimilarity(queryVector, chunk.vector);
        return { ...chunk, score: similarity };
      });
      const similarityThreshold = this.plugin.settings.ragSimilarityThreshold || DEFAULT_SETTINGS.ragSimilarityThreshold;
      const relevantChunks = scoredChunks.filter((chunk) => chunk.score >= similarityThreshold);
      relevantChunks.sort((a, b) => b.score - a.score);
      const duration = Date.now() - startTime;
      this.plugin.logger.debug(`[RagService] Semantic search completed in ${duration}ms. Found ${relevantChunks.length} chunks above threshold ${similarityThreshold}.`);
      return relevantChunks.slice(0, limit);
    } catch (error) {
      this.plugin.logger.error("[RagService] Error during semantic search:", error);
      return [];
    }
  }
  /**
   * ОНОВЛЕНО: Готує контекст для LLM, розділяючи "особистий фокус" та "загальний" контекст.
   * @param query Запит користувача для пошуку релевантних чанків.
   * @returns Рядок з форматованим контекстом або порожній рядок.
   */
  async prepareContext(query) {
    if (!this.plugin.settings.ragEnabled || !this.plugin.settings.ragEnableSemanticSearch) {
      this.plugin.logger.debug("[RagService] Context preparation skipped (RAG or semantic search disabled).");
      return "";
    }
    const topK = this.plugin.settings.ragTopK || DEFAULT_SETTINGS.ragTopK;
    const relevantChunks = await this.findRelevantDocuments(query, topK);
    if (relevantChunks.length === 0) {
      this.plugin.logger.debug("[RagService] No relevant documents found for context.");
      return "";
    }
    this.plugin.logger.debug(`[RagService] Preparing context from ${relevantChunks.length} top chunks.`);
    const personalFocusChunks = [];
    const generalContextChunks = [];
    relevantChunks.forEach((chunk) => {
      if (chunk.metadata.isPersonalFocus) {
        personalFocusChunks.push(chunk);
      } else {
        generalContextChunks.push(chunk);
      }
    });
    let finalContext = "";
    if (personalFocusChunks.length > 0) {
      finalContext += "### Personal Focus Context (User's Life State & Goals):\n";
      finalContext += "IMPORTANT: This section contains key information about the user's current situation, priorities, and desired actions. Use it for strategic planning, progress tracking, and aligning suggestions with their core objectives.\n\n";
      personalFocusChunks.forEach((chunk, index) => {
        var _a, _b, _c;
        let header = `--- Chunk ${index + 1} from Personal Focus Note: ${((_a = chunk.metadata) == null ? void 0 : _a.filename) || chunk.metadata.path}`;
        header += ` (Score: ${(_c = (_b = chunk.score) == null ? void 0 : _b.toFixed(3)) != null ? _c : "N/A"}) ---
`;
        finalContext += header;
        finalContext += chunk.text.trim() + "\n\n";
      });
      this.plugin.logger.debug(`[RagService] Added ${personalFocusChunks.length} personal focus chunks to context.`);
    } else {
      this.plugin.logger.debug(`[RagService] No personal focus chunks found among relevant results.`);
    }
    if (generalContextChunks.length > 0) {
      if (finalContext) {
        finalContext += "---\n\n";
      }
      finalContext += "### General Context from User Notes:\n";
      finalContext += "This section contains potentially relevant background information from the user's general notes.\n\n";
      generalContextChunks.forEach((chunk, index) => {
        var _a, _b, _c, _d;
        let header = `--- Chunk ${index + 1} from: ${((_a = chunk.metadata) == null ? void 0 : _a.filename) || chunk.metadata.path}`;
        if (((_b = chunk.metadata) == null ? void 0 : _b["personal-logs"]) === true)
          header += ` [Type: Personal Log]`;
        header += ` (Score: ${(_d = (_c = chunk.score) == null ? void 0 : _c.toFixed(3)) != null ? _d : "N/A"}) ---
`;
        finalContext += header;
        finalContext += chunk.text.trim() + "\n\n";
      });
      this.plugin.logger.debug(`[RagService] Added ${generalContextChunks.length} general context chunks to context.`);
    } else {
      this.plugin.logger.debug(`[RagService] No general context chunks found among relevant results.`);
    }
    if (finalContext) {
      finalContext += "### End of Context\n";
    }
    return finalContext.trim();
  }
};

// src/OllamaService.ts
var OllamaService = class {
  constructor(plugin) {
    this.eventHandlers = {};
    this.plugin = plugin;
    if (!plugin.promptService) {
      const errorMsg = "[OllamaService] CRITICAL: PromptService not available on plugin instance during OllamaService construction!";
      throw new Error(errorMsg);
    }
    this.promptService = plugin.promptService;
    this.logger = plugin.logger;
  }
  on(event, callback) {
    if (!this.eventHandlers[event])
      this.eventHandlers[event] = [];
    this.eventHandlers[event].push(callback);
    return () => {
      var _a, _b;
      this.eventHandlers[event] = (_a = this.eventHandlers[event]) == null ? void 0 : _a.filter((h) => h !== callback);
      if (((_b = this.eventHandlers[event]) == null ? void 0 : _b.length) === 0)
        delete this.eventHandlers[event];
    };
  }
  emit(event, data) {
    const h = this.eventHandlers[event];
    if (h)
      h.slice().forEach((handler) => {
        try {
          handler(data);
        } catch (e) {
        }
      });
  }
  /**
   * Відправляє запит на генерацію відповіді Ollama і повертає асинхронний ітератор для отримання частин відповіді.
   * @param chat Поточний об'єкт чату.
   * @param signal AbortSignal для можливості переривання запиту.
   * @returns Асинхронний ітератор, що видає StreamChunk.
   */
  async *generateChatResponseStream(chat, signal) {
    var _a, _b, _c, _d, _e, _f;
    const requestTimestampId = Date.now();
    if (!chat) {
      yield { type: "error", error: "Chat object is null.", done: true };
      return;
    }
    if (!this.promptService) {
      yield { type: "error", error: "Prompt service is unavailable.", done: true };
      return;
    }
    const currentSettings = this.plugin.settings;
    const modelName = chat.metadata.modelName || currentSettings.modelName;
    const temperature = (_a = chat.metadata.temperature) != null ? _a : currentSettings.temperature;
    if (!modelName) {
      yield { type: "error", error: "No Ollama model selected.", done: true };
      return;
    }
    const url = `${this.plugin.settings.ollamaServerUrl}/api/generate`;
    const headers = { "Content-Type": "application/json" };
    try {
      const history = chat.getMessages();
      const systemPrompt = await this.promptService.getSystemPromptForAPI(chat.metadata);
      const promptBody = await this.promptService.preparePromptBody(history, chat.metadata);
      if (promptBody === null || promptBody === void 0) {
        yield { type: "error", error: "Could not generate prompt body.", done: true };
        return;
      }
      const requestBody = {
        model: modelName,
        prompt: promptBody,
        stream: true,
        temperature,
        options: { num_ctx: currentSettings.contextWindow },
        ...systemPrompt && { system: systemPrompt }
      };
      if (this.plugin.agentManager && this.plugin.settings.enableToolUse) {
        const agentTools = this.plugin.agentManager.getAllToolDefinitions();
        if (agentTools && agentTools.length > 0) {
          const modelDetails = await this.getModelDetails(modelName);
          const seemsToSupportTools = ((_c = (_b = modelDetails == null ? void 0 : modelDetails.details) == null ? void 0 : _b.family) == null ? void 0 : _c.toLowerCase().includes("llama3")) || ((_e = (_d = modelDetails == null ? void 0 : modelDetails.details) == null ? void 0 : _d.family) == null ? void 0 : _e.toLowerCase().includes("mistral")) || ((_f = modelDetails == null ? void 0 : modelDetails.details) == null ? void 0 : _f.parameter_size) && parseFloat(modelDetails.details.parameter_size.replace("B", "")) >= 7;
          if (seemsToSupportTools) {
            requestBody.tools = agentTools.map((tool) => ({ type: "function", function: tool }));
          } else {
          }
        }
      }
      const response = await fetch(url, {
        method: "POST",
        headers,
        body: JSON.stringify(requestBody),
        signal
      });
      if (!response.ok) {
        let errorText = `Ollama API error! Status: ${response.status}`;
        try {
          const errorJson = await response.json();
          errorText += `: ${(errorJson == null ? void 0 : errorJson.error) || response.statusText || "No details"}`;
        } catch (e) {
          errorText += `: ${response.statusText || "Could not parse error details"}`;
        }
        this.emit("connection-error", new Error(errorText));
        yield { type: "error", error: errorText, done: true };
        return;
      }
      if (!response.body) {
        yield { type: "error", error: "Response body is null.", done: true };
        return;
      }
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = "";
      let rawResponseAccumulator = "";
      while (true) {
        const { done, value } = await reader.read();
        if (signal == null ? void 0 : signal.aborted) {
          reader.cancel("Aborted by user");
          yield { type: "error", error: "Generation aborted by user.", done: true };
          return;
        }
        const decodedChunk = decoder.decode(value, { stream: !done });
        rawResponseAccumulator += decodedChunk;
        if (done) {
          buffer += decodedChunk;
          if (buffer.trim()) {
            try {
              const jsonChunk = JSON.parse(buffer.trim());
              if (jsonChunk.message && jsonChunk.message.tool_calls && jsonChunk.message.tool_calls.length > 0) {
                yield {
                  type: "tool_calls",
                  calls: jsonChunk.message.tool_calls,
                  assistant_message_with_calls: jsonChunk.message,
                  model: jsonChunk.model,
                  created_at: jsonChunk.created_at
                };
              } else if (typeof jsonChunk.response === "string") {
                yield {
                  type: "content",
                  response: jsonChunk.response,
                  done: jsonChunk.done || false,
                  model: jsonChunk.model,
                  created_at: jsonChunk.created_at
                };
              } else if (jsonChunk.error) {
                yield { type: "error", error: jsonChunk.error, done: true };
              }
            } catch (e) {
            }
          }
          break;
        }
        buffer += decoder.decode(value, { stream: true });
        let eolIndex;
        while ((eolIndex = buffer.indexOf("\n")) >= 0) {
          const line = buffer.substring(0, eolIndex).trim();
          buffer = buffer.substring(eolIndex + 1);
          if (line === "")
            continue;
          try {
            const jsonChunk = JSON.parse(line);
            if (jsonChunk.error) {
              yield { type: "error", error: jsonChunk.error, done: true };
              reader.cancel("Error received from Ollama stream");
              return;
            }
            if (jsonChunk.message && jsonChunk.message.tool_calls && jsonChunk.message.tool_calls.length > 0) {
              yield {
                type: "tool_calls",
                calls: jsonChunk.message.tool_calls,
                assistant_message_with_calls: jsonChunk.message,
                model: jsonChunk.model,
                created_at: jsonChunk.created_at
              };
              if (jsonChunk.done === true) {
                yield {
                  type: "done",
                  model: jsonChunk.model,
                  created_at: jsonChunk.created_at,
                  context: jsonChunk.context,
                  total_duration: jsonChunk.total_duration,
                  load_duration: jsonChunk.load_duration,
                  prompt_eval_count: jsonChunk.prompt_eval_count,
                  prompt_eval_duration: jsonChunk.prompt_eval_duration,
                  eval_count: jsonChunk.eval_count,
                  eval_duration: jsonChunk.eval_duration
                };
                return;
              }
            } else if (typeof jsonChunk.response === "string") {
              yield {
                type: "content",
                response: jsonChunk.response,
                done: jsonChunk.done || false,
                model: jsonChunk.model,
                created_at: jsonChunk.created_at
              };
              if (jsonChunk.done === true) {
              }
            } else if (jsonChunk.done === true) {
              yield {
                type: "done",
                model: jsonChunk.model,
                created_at: jsonChunk.created_at,
                context: jsonChunk.context,
                total_duration: jsonChunk.total_duration,
                load_duration: jsonChunk.load_duration,
                prompt_eval_count: jsonChunk.prompt_eval_count,
                prompt_eval_duration: jsonChunk.prompt_eval_duration,
                eval_count: jsonChunk.eval_count,
                eval_duration: jsonChunk.eval_duration
              };
              return;
            } else if (jsonChunk.message && (jsonChunk.message.content === null || jsonChunk.message.content === "") && !jsonChunk.message.tool_calls) {
            }
          } catch (e) {
          }
        }
      }
    } catch (error) {
      if (error.name === "AbortError") {
        yield { type: "error", error: "Generation aborted by user.", done: true };
      } else {
        let errorMessage = error instanceof Error ? error.message : "Unknown error generating stream.";
        if (errorMessage.includes("connect") || errorMessage.includes("fetch") || errorMessage.includes("NetworkError") || errorMessage.includes("Failed to fetch")) {
          errorMessage = `Connection Error: Failed to reach Ollama at ${this.plugin.settings.ollamaServerUrl}. Is it running?`;
          this.emit("connection-error", new Error(errorMessage));
        }
        yield { type: "error", error: errorMessage, done: true };
      }
    } finally {
    }
  }
  async generateRaw(requestBody) {
    var _a;
    if (!requestBody.model || !requestBody.prompt) {
      throw new Error("generateRaw requires 'model' and 'prompt' in requestBody");
    }
    requestBody.stream = false;
    if (!requestBody.system) {
      delete requestBody.system;
    }
    const url = `${this.plugin.settings.ollamaServerUrl}/api/generate`;
    const headers = { "Content-Type": "application/json" };
    try {
      const response = await fetch(url, {
        method: "POST",
        headers,
        body: JSON.stringify(requestBody)
      });
      if (!response.ok) {
        let errorText = `Ollama API error (generateRaw)! Status: ${response.status}`;
        try {
          const errorJson = await response.json();
          errorText += `: ${(errorJson == null ? void 0 : errorJson.error) || response.statusText || "No details"}`;
        } catch (e) {
          errorText += `: ${response.statusText || "Could not parse error details"}`;
        }
        this.emit("connection-error", new Error(errorText));
        throw new Error(errorText);
      }
      if (!response.body) {
        throw new Error("Response body is null (generateRaw)");
      }
      return await response.json();
    } catch (error) {
      const connectionErrorMsg = `Failed to connect/communicate with Ollama server at ${this.plugin.settings.ollamaServerUrl}. Is it running? (Endpoint: /api/generate, non-streamed)`;
      if (!((_a = error.message) == null ? void 0 : _a.includes("Ollama API error"))) {
        this.emit("connection-error", new Error(connectionErrorMsg));
      }
      throw new Error(error.message || connectionErrorMsg);
    }
  }
  async generateEmbeddings(prompts, model) {
    if (!prompts || prompts.length === 0)
      return [];
    const endpoint = "/api/embeddings";
    const url = `${this.plugin.settings.ollamaServerUrl}${endpoint}`;
    const headers = { "Content-Type": "application/json" };
    const embeddingsList = [];
    try {
      for (const prompt of prompts) {
        const trimmedPrompt = prompt.trim();
        if (!trimmedPrompt)
          continue;
        const requestBody = JSON.stringify({ model, prompt: trimmedPrompt });
        try {
          const response = await fetch(url, { method: "POST", headers, body: requestBody });
          if (!response.ok) {
            let errorText = `Ollama Embeddings API error! Status: ${response.status}`;
            try {
              const errJson = await response.json();
              errorText += `: ${(errJson == null ? void 0 : errJson.error) || "Details unavailable"}`;
            } catch (e) {
            }
            continue;
          }
          const embeddingResponse = await response.json();
          if (embeddingResponse && embeddingResponse.embedding) {
            embeddingsList.push(embeddingResponse.embedding);
          } else {
          }
        } catch (singleError) {
          this.emit("connection-error", new Error(singleError.message || "Embedding generation failed for a prompt"));
        }
      }
      return embeddingsList.length > 0 ? embeddingsList : null;
    } catch (error) {
      return null;
    }
  }
  async getModels(forceRefresh = false) {
    var _a;
    const endpoint = "/api/tags";
    const url = `${this.plugin.settings.ollamaServerUrl}${endpoint}`;
    let modelListResult = [];
    try {
      const response = await fetch(url, { method: "GET" });
      if (!response.ok) {
        let errorText = `Ollama Tags API error! Status: ${response.status}`;
        try {
          const errJson = await response.json();
          errorText += `: ${(errJson == null ? void 0 : errJson.error) || "Details unavailable"}`;
        } catch (e) {
        }
        this.emit("connection-error", new Error(errorText));
        return [];
      }
      const data = await response.json();
      if (data && Array.isArray(data.models)) {
        modelListResult = data.models.map((m) => m == null ? void 0 : m.name).filter((name) => typeof name === "string" && name.length > 0).sort();
      } else {
      }
    } catch (e) {
      const connectionErrorMsg = `Failed to connect or fetch models from Ollama server at ${this.plugin.settings.ollamaServerUrl}. (Endpoint: /api/tags)`;
      if (!((_a = e.message) == null ? void 0 : _a.includes("API error"))) {
        this.emit("connection-error", new Error(e.message || connectionErrorMsg));
      }
      return [];
    }
    return modelListResult;
  }
  async getModelDetails(modelName) {
    var _a;
    const endpoint = "/api/show";
    const url = `${this.plugin.settings.ollamaServerUrl}${endpoint}`;
    const headers = { "Content-Type": "application/json" };
    try {
      const response = await fetch(url, { method: "POST", headers, body: JSON.stringify({ name: modelName }) });
      if (!response.ok) {
        let errorText = `Ollama Show API error for model ${modelName}! Status: ${response.status}`;
        try {
          const errJson = await response.json();
          errorText += `: ${(errJson == null ? void 0 : errJson.error) || "Details unavailable"}`;
        } catch (e) {
        }
        if (response.status !== 404) {
          this.emit("connection-error", new Error(errorText));
        }
        return null;
      }
      const data = await response.json();
      return data;
    } catch (e) {
      const connectionErrorMsg = `Failed to connect or get details for model ${modelName} from Ollama server at ${this.plugin.settings.ollamaServerUrl}. (Endpoint: /api/show)`;
      if (!((_a = e.message) == null ? void 0 : _a.includes("API error"))) {
        this.emit("connection-error", new Error(e.message || connectionErrorMsg));
      }
      return null;
    }
  }
};

// src/PromptService.ts
var import_obsidian17 = require("obsidian");
var PromptService = class {
  constructor(plugin) {
    this.currentSystemPrompt = null;
    this.currentRolePath = null;
    this.roleCache = {};
    this.modelDetailsCache = {};
    this.plugin = plugin;
    this.app = plugin.app;
  }
  _countTokens(text) {
    if (!text)
      return 0;
    return Math.ceil(text.length / 4);
  }
  clearRoleCache() {
    this.roleCache = {};
    this.currentRolePath = null;
    this.currentSystemPrompt = null;
  }
  clearModelDetailsCache() {
    this.modelDetailsCache = {};
  }
  async getRoleDefinition(rolePath) {
    var _a, _b;
    const normalizedPath = rolePath ? (0, import_obsidian17.normalizePath)(rolePath) : null;
    if (normalizedPath === this.currentRolePath && normalizedPath && this.roleCache[normalizedPath]) {
      return this.roleCache[normalizedPath];
    }
    if (normalizedPath !== this.currentRolePath) {
      if (this.currentRolePath && this.roleCache[this.currentRolePath]) {
        delete this.roleCache[this.currentRolePath];
      }
      this.currentRolePath = normalizedPath;
      this.currentSystemPrompt = null;
    }
    if (!normalizedPath || !this.plugin.settings.followRole) {
      const definition = {
        systemPrompt: null,
        isProductivityPersona: false
      };
      return definition;
    }
    if (this.roleCache[normalizedPath]) {
      this.currentSystemPrompt = this.roleCache[normalizedPath].systemPrompt;
      return this.roleCache[normalizedPath];
    }
    const file = this.app.vault.getAbstractFileByPath(normalizedPath);
    if (file instanceof import_obsidian17.TFile) {
      try {
        const fileCache = this.app.metadataCache.getFileCache(file);
        const frontmatter = fileCache == null ? void 0 : fileCache.frontmatter;
        const content = await this.app.vault.cachedRead(file);
        const systemPromptBody = ((_a = fileCache == null ? void 0 : fileCache.frontmatterPosition) == null ? void 0 : _a.end) ? content.substring(fileCache.frontmatterPosition.end.offset).trim() : content.trim();
        const isProductivity = ((_b = frontmatter == null ? void 0 : frontmatter.assistant_type) == null ? void 0 : _b.toLowerCase()) === "productivity" || (frontmatter == null ? void 0 : frontmatter.is_planner) === true;
        const definition = {
          systemPrompt: systemPromptBody || null,
          isProductivityPersona: isProductivity
        };
        this.roleCache[normalizedPath] = definition;
        this.currentSystemPrompt = definition.systemPrompt;
        return definition;
      } catch (error) {
        new import_obsidian17.Notice(`Error loading role: ${file.basename}. Check console.`);
        this.currentSystemPrompt = null;
        return { systemPrompt: null, isProductivityPersona: false };
      }
    } else {
      this.currentSystemPrompt = null;
      return { systemPrompt: null, isProductivityPersona: false };
    }
  }
  async _isProductivityPersonaActive(rolePath) {
    var _a;
    if (!this.plugin.settings.enableProductivityFeatures) {
      return false;
    }
    const roleDefinition = await this.getRoleDefinition(rolePath);
    return (_a = roleDefinition == null ? void 0 : roleDefinition.isProductivityPersona) != null ? _a : false;
  }
  async getSystemPromptForAPI(chatMetadata) {
    var _a;
    const settings = this.plugin.settings;
    const selectedRolePath = chatMetadata.selectedRolePath !== void 0 && chatMetadata.selectedRolePath !== null ? chatMetadata.selectedRolePath : settings.selectedRolePath;
    let roleDefinition = null;
    if (selectedRolePath && settings.followRole) {
      roleDefinition = await this.getRoleDefinition(selectedRolePath);
    }
    const roleSystemPrompt = (roleDefinition == null ? void 0 : roleDefinition.systemPrompt) || null;
    const isProductivityActive = (_a = roleDefinition == null ? void 0 : roleDefinition.isProductivityPersona) != null ? _a : false;
    const ragInstructions = `
--- RAG Data Interpretation Rules ---
You will be provided context from the user's notes, potentially split into two sections:
1.  '### Personal Focus Context (User's Life State & Goals)':
    * This section contains HIGH-PRIORITY information reflecting the user's current situation, desired state, goals, priorities, and actions they believe they should take.
    * TREAT THIS SECTION AS THE PRIMARY SOURCE for understanding the user's core objectives and current life context.
    * Use this to align your suggestions, track progress on stated goals/priorities, and provide strategic guidance.
2.  '### General Context from User Notes':
    * This section contains potentially relevant background information from the user's general notes, identified based on semantic similarity to the current query.
    * Use this for supplementary details and broader context.

General Rules for BOTH Context Sections:
* Each context chunk originates from a specific file indicated in its header (e.g., "--- Chunk 1 from Personal Focus Note: My Goals.md ..."). You can refer to source files by name.
* Context from files/chunks marked with "[Type: Personal Log]" contains personal reflections, activities, or logs. Use this for analysis of personal state, mood, energy, and progress.
* Assume ANY bullet point item (lines starting with '-', '*', '+') OR any line containing one or more hash tags (#tag) represents a potential user goal, task, objective, idea, or key point. **Pay special attention to categorizing these:**
    * **Critical Goals/Tasks:** Identify these if the line contains tags like #critical, #critical\u{1F198} or keywords like "\u043A\u0440\u0438\u0442\u0438\u0447\u043D\u043E", "critical", "\u0442\u0435\u0440\u043C\u0456\u043D\u043E\u0432\u043E", "urgent". **Prioritize discussing these items, potential blockers, and progress.**
    * **Weekly Goals/Tasks:** Identify these if the line contains tags like #week, #weekly or keywords like "weekly", "\u0442\u0438\u0436\u043D\u0435\u0432\u0430", "\u0442\u0438\u0436\u043D\u0435\u0432\u0438\u0439". Consider their relevance for the current or upcoming week's planning.
    * Use the surrounding text and the source document name for context for all identified items.
* If the user asks about "available data", "all my notes", "summarize my RAG data", or similar general terms, base your answer on the ENTIRE provided context (both Personal Focus and General Context sections). Analyze themes across different chunks and documents.
--- End RAG Data Interpretation Rules ---
        `.trim();
    let systemPromptParts = [];
    if (settings.ragEnabled && this.plugin.ragService && settings.ragEnableSemanticSearch) {
      systemPromptParts.push(ragInstructions);
    }
    if (roleSystemPrompt) {
      systemPromptParts.push(roleSystemPrompt.trim());
    }
    let combinedBasePrompt = systemPromptParts.join("\n\n").trim();
    if (settings.enableToolUse && this.plugin.agentManager) {
      const agentTools = this.plugin.agentManager.getAllToolDefinitions();
      let toolUsageInstructions = "";
      if (agentTools.length > 0) {
        toolUsageInstructions = "\n\n--- Tool Usage Guidelines ---\n";
        toolUsageInstructions += "You have access to the following tools. ";
        toolUsageInstructions += "To use a tool, you MUST respond ONLY with a single JSON object representing the tool call, enclosed in <tool_call></tool_call> XML-like tags. Do NOT add any other text, explanation, or markdown formatting before or after these tags.\n";
        toolUsageInstructions += "The JSON object must have a 'name' property with the tool's name and an 'arguments' property containing an object of parameters for that tool.\n";
        toolUsageInstructions += "Example of a tool call response:\n";
        toolUsageInstructions += "<tool_call>\n";
        toolUsageInstructions += "{\n";
        toolUsageInstructions += '  "name": "example_tool_name",\n';
        toolUsageInstructions += '  "arguments": {\n';
        toolUsageInstructions += '    "parameter_1_name": "value_for_param1",\n';
        toolUsageInstructions += '    "parameter_2_name": true\n';
        toolUsageInstructions += "  }\n";
        toolUsageInstructions += "}\n";
        toolUsageInstructions += "</tool_call>\n\n";
        toolUsageInstructions += "After you make a tool call, the system will execute the tool and provide you with the result in a message with role 'tool'. This result will be clearly marked. For example:\n";
        toolUsageInstructions += '<message role="tool" tool_call_id="[some_id]" name="[tool_name]">\n';
        toolUsageInstructions += "[TOOL_RESULT]\n";
        toolUsageInstructions += "[The actual result from the tool will be here]\n";
        toolUsageInstructions += "[/TOOL_RESULT]\n";
        toolUsageInstructions += "</message>\n";
        toolUsageInstructions += "If there was an error during tool execution or argument parsing, the result will be marked like this:\n";
        toolUsageInstructions += '<message role="tool" tool_call_id="[some_id]" name="[tool_name]">\n';
        toolUsageInstructions += "[TOOL_ERROR]\n";
        toolUsageInstructions += "[Details of the error will be here]\n";
        toolUsageInstructions += "[/TOOL_ERROR]\n";
        toolUsageInstructions += "</message>\n";
        toolUsageInstructions += "You MUST analyze the content within [TOOL_RESULT]...[/TOOL_RESULT] (or [TOOL_ERROR]...[/TOOL_ERROR]) and use it to formulate your response to the user. Do not re-call the same tool with the exact same arguments if you have already received a result for it, unless the result was an error and you are correcting the arguments. If the tool result provides the necessary information, generate a final answer for the user. If you need more information or need to process the data further, you may call another tool or the same tool with different arguments.\n\n";
        toolUsageInstructions += "Available tools are:\n";
        agentTools.forEach((tool) => {
          toolUsageInstructions += `
Tool Name: "${tool.name}"
`;
          toolUsageInstructions += `  Description: ${tool.description}
`;
          toolUsageInstructions += `  Parameters Schema (JSON Schema format):
  ${JSON.stringify(
            tool.parameters,
            null,
            2
          ).replace(/\n/g, "\n  ")}
`;
        });
        toolUsageInstructions += "--- End Tool Usage Guidelines ---";
      } else {
        toolUsageInstructions = "\n\n--- Tool Usage Guidelines ---\nNo tools are currently available.\n--- End Tool Usage Guidelines ---";
      }
      if (combinedBasePrompt.length === 0) {
        combinedBasePrompt = "You are a helpful AI assistant." + toolUsageInstructions;
      } else {
        combinedBasePrompt += toolUsageInstructions;
      }
    } else if (combinedBasePrompt.length === 0) {
    }
    if (isProductivityActive && combinedBasePrompt && settings.enableProductivityFeatures) {
      const now = new Date();
      const formattedDate = now.toLocaleDateString(void 0, {
        weekday: "long",
        year: "numeric",
        month: "long",
        day: "numeric"
      });
      const formattedTime = now.toLocaleTimeString(void 0, { hour: "numeric", minute: "2-digit" });
      combinedBasePrompt = combinedBasePrompt.replace(/\[Current Time\]/gi, formattedTime);
      combinedBasePrompt = combinedBasePrompt.replace(/\[Current Date\]/gi, formattedDate);
    }
    const finalTrimmedPrompt = combinedBasePrompt.trim();
    return finalTrimmedPrompt.length > 0 ? finalTrimmedPrompt : null;
  }
  async preparePromptBody(history, chatMetadata) {
    var _a, _b;
    const settings = this.plugin.settings;
    const selectedRolePath = chatMetadata.selectedRolePath !== void 0 && chatMetadata.selectedRolePath !== null ? chatMetadata.selectedRolePath : settings.selectedRolePath;
    const isProductivityActive = await this._isProductivityPersonaActive(selectedRolePath);
    let taskContext = "";
    if (isProductivityActive && settings.enableProductivityFeatures && this.plugin.chatManager) {
      await ((_b = (_a = this.plugin).checkAndProcessTaskUpdate) == null ? void 0 : _b.call(_a));
      const taskState = this.plugin.chatManager.getCurrentTaskState();
      if (taskState && taskState.hasContent) {
        taskContext = "\n--- Today's Tasks Context ---\n";
        taskContext += `Urgent: ${taskState.urgent.join(", ") || "None"}
`;
        taskContext += `Other: ${taskState.regular.join(", ") || "None"}
`;
        taskContext += "--- End Tasks Context ---";
      }
    }
    const approxTaskTokens = this._countTokens(taskContext);
    const maxRagTokens = settings.ragEnabled ? settings.ragTopK * settings.ragChunkSize / 4 * 1.8 : 0;
    const maxHistoryTokens = settings.contextWindow - approxTaskTokens - maxRagTokens - 250;
    let processedHistoryString = "";
    if (isProductivityActive && settings.useAdvancedContextStrategy) {
      processedHistoryString = await this._buildAdvancedContext(history, chatMetadata, maxHistoryTokens);
    } else {
      processedHistoryString = this._buildSimpleContext(history, maxHistoryTokens);
    }
    let ragContext = "";
    if (settings.ragEnabled && this.plugin.ragService && settings.ragEnableSemanticSearch) {
      const lastUserMessage = history.findLast((m) => m.role === "user");
      if (lastUserMessage == null ? void 0 : lastUserMessage.content) {
        ragContext = await this.plugin.ragService.prepareContext(lastUserMessage.content);
      }
    }
    let finalPromptBodyParts = [];
    if (ragContext) {
      finalPromptBodyParts.push(ragContext);
    }
    if (taskContext) {
      finalPromptBodyParts.push(taskContext);
    }
    if (processedHistoryString) {
      finalPromptBodyParts.push(`### Conversation History:
${processedHistoryString}`);
    }
    const finalPromptBody = finalPromptBodyParts.join("\n\n").trim();
    if (!finalPromptBody) {
      return null;
    }
    return finalPromptBody;
  }
  // _buildSimpleContext та _buildAdvancedContext тепер мають отримувати повідомлення
  // з role: "tool", які вже відформатовані з маркерами [TOOL_RESULT] або [TOOL_ERROR]
  // з методу OllamaView._executeAndRenderToolCycle
  _buildSimpleContext(history, maxTokens) {
    let context = "";
    let currentTokens = 0;
    for (let i = history.length - 1; i >= 0; i--) {
      const message = history[i];
      if (message.role === "system" || message.role === "error")
        continue;
      let formattedMessage = "";
      if (message.role === "user") {
        formattedMessage = `User: ${message.content.trim()}`;
      } else if (message.role === "assistant") {
        if (message.tool_calls && message.tool_calls.length > 0) {
          const toolCallsString = JSON.stringify(message.tool_calls);
          formattedMessage = `Assistant:
<tool_calls>
${toolCallsString}
</tool_calls>`;
          if (message.content && message.content.trim() !== "") {
            formattedMessage = `Assistant: ${message.content.trim()}
<tool_calls>
${toolCallsString}
</tool_calls>`;
          }
        } else {
          formattedMessage = `Assistant: ${message.content.trim()}`;
        }
      } else if (message.role === "tool") {
        formattedMessage = `<message role="tool" tool_call_id="${message.tool_call_id}" name="${message.name}">
${message.content.trim()}
</message>`;
      }
      const messageTokens = this._countTokens(formattedMessage) + 5;
      if (currentTokens + messageTokens <= maxTokens) {
        context = formattedMessage + "\n\n" + context;
        currentTokens += messageTokens;
      } else {
        break;
      }
    }
    return context.trim();
  }
  async _buildAdvancedContext(history, chatMetadata, maxTokens) {
    const settings = this.plugin.settings;
    const processedParts = [];
    let currentTokens = 0;
    const keepN = Math.max(0, settings.keepLastNMessagesBeforeSummary || 3);
    const actualKeepN = Math.min(history.length, keepN);
    const messagesToKeep = history.slice(-actualKeepN);
    const messagesToProcess = history.slice(0, -actualKeepN);
    if (messagesToProcess.length > 0) {
      let olderContextTokens = 0;
      let olderContextContent = "";
      if (settings.enableSummarization) {
        const summary = await this._summarizeMessages(messagesToProcess, chatMetadata);
        if (summary) {
          olderContextContent = `[Summary of earlier conversation]:
${summary}`;
          olderContextTokens = this._countTokens(olderContextContent) + 10;
        }
      }
      if (!olderContextContent) {
        let includedOlderCount = 0;
        for (let i = messagesToProcess.length - 1; i >= 0; i--) {
          const message = messagesToProcess[i];
          if (message.role === "system" || message.role === "error")
            continue;
          let formattedMessage = "";
          if (message.role === "user") {
            formattedMessage = `User: ${message.content.trim()}`;
          } else if (message.role === "assistant") {
            if (message.tool_calls && message.tool_calls.length > 0) {
              const toolCallsString = JSON.stringify(message.tool_calls);
              formattedMessage = `Assistant:
<tool_calls>
${toolCallsString}
</tool_calls>`;
              if (message.content && message.content.trim() !== "") {
                formattedMessage = `Assistant: ${message.content.trim()}
<tool_calls>
${toolCallsString}
</tool_calls>`;
              }
            } else {
              formattedMessage = `Assistant: ${message.content.trim()}`;
            }
          } else if (message.role === "tool") {
            formattedMessage = `<message role="tool" tool_call_id="${message.tool_call_id}" name="${message.name}">
${message.content.trim()}
</message>`;
          }
          const messageTokens = this._countTokens(formattedMessage) + 5;
          if (currentTokens + olderContextTokens + messageTokens <= maxTokens) {
            olderContextContent = formattedMessage + "\n\n" + olderContextContent;
            olderContextTokens += messageTokens;
            includedOlderCount++;
          } else {
            break;
          }
        }
        if (includedOlderCount > 0) {
          olderContextContent = `[Start of older messages directly included]:
${olderContextContent.trim()}
[End of older messages]`;
          olderContextTokens += 10;
        }
      }
      if (olderContextContent && currentTokens + olderContextTokens <= maxTokens) {
        processedParts.push(olderContextContent);
        currentTokens += olderContextTokens;
      }
    }
    let keptMessagesString = "";
    let keptMessagesTokens = 0;
    for (let i = messagesToKeep.length - 1; i >= 0; i--) {
      const message = messagesToKeep[i];
      if (message.role === "system" || message.role === "error")
        continue;
      let formattedMessage = "";
      if (message.role === "user") {
        formattedMessage = `User: ${message.content.trim()}`;
      } else if (message.role === "assistant") {
        if (message.tool_calls && message.tool_calls.length > 0) {
          const toolCallsString = JSON.stringify(message.tool_calls);
          formattedMessage = `Assistant:
<tool_calls>
${toolCallsString}
</tool_calls>`;
          if (message.content && message.content.trim() !== "") {
            formattedMessage = `Assistant: ${message.content.trim()}
<tool_calls>
${toolCallsString}
</tool_calls>`;
          }
        } else {
          formattedMessage = `Assistant: ${message.content.trim()}`;
        }
      } else if (message.role === "tool") {
        formattedMessage = `<message role="tool" tool_call_id="${message.tool_call_id}" name="${message.name}">
${message.content.trim()}
</message>`;
      }
      const messageTokens = this._countTokens(formattedMessage) + 5;
      if (currentTokens + keptMessagesTokens + messageTokens <= maxTokens) {
        keptMessagesString = formattedMessage + "\n\n" + keptMessagesString;
        keptMessagesTokens += messageTokens;
      } else {
        break;
      }
    }
    if (keptMessagesString) {
      processedParts.push(keptMessagesString.trim());
      currentTokens += keptMessagesTokens;
    }
    return processedParts.join("\n\n").trim();
  }
  async _summarizeMessages(messagesToSummarize, chatMetadata) {
    if (!this.plugin.settings.enableSummarization || messagesToSummarize.length === 0) {
      return null;
    }
    const textToSummarize = messagesToSummarize.filter((m) => m.role === "user" || m.role === "assistant" || m.role === "tool").map((m) => {
      if (m.role === "user") {
        return `User: ${m.content.trim()}`;
      } else if (m.role === "assistant") {
        if (m.tool_calls && m.tool_calls.length > 0) {
          const toolCallsString = JSON.stringify(m.tool_calls);
          let contentPart = m.content && m.content.trim() !== "" ? `${m.content.trim()}
` : "";
          return `Assistant: ${contentPart}<tool_calls>
${toolCallsString}
</tool_calls>`;
        }
        return `Assistant: ${m.content.trim()}`;
      } else if (m.role === "tool") {
        return `<message role="tool" tool_call_id="${m.tool_call_id}" name="${m.name}">
${m.content.trim()}
</message>`;
      }
      return "";
    }).filter(Boolean).join("\n");
    if (!textToSummarize.trim()) {
      return null;
    }
    const summarizationPromptTemplate = this.plugin.settings.summarizationPrompt || "Summarize the following conversation concisely, preserving key information and tool usage context:\n\n{text_to_summarize}";
    const summarizationFullPrompt = summarizationPromptTemplate.replace("{text_to_summarize}", textToSummarize);
    const summarizationModelName = this.plugin.settings.summarizationModelName || chatMetadata.modelName || this.plugin.settings.modelName;
    const summarizationContextWindow = Math.min(this.plugin.settings.contextWindow || 4096, 4096);
    const requestBody = {
      model: summarizationModelName,
      prompt: summarizationFullPrompt,
      stream: false,
      temperature: 0.3,
      options: { num_ctx: summarizationContextWindow },
      system: "You are a helpful assistant specializing in concisely summarizing conversation history. Focus on extracting key points, decisions, unresolved questions, and the context of any tool calls and their results."
    };
    try {
      if (!this.plugin.ollamaService)
        return null;
      const responseData = await this.plugin.ollamaService.generateRaw(requestBody);
      if (responseData && typeof responseData.response === "string") {
        return responseData.response.trim();
      }
      return null;
    } catch (error) {
      return null;
    }
  }
};

// src/ChatManager.ts
var import_obsidian19 = require("obsidian");

// src/Chat.ts
var import_obsidian18 = require("obsidian");
var Chat = class {
  constructor(adapter, settings, data, filePath, logger) {
    this.adapter = adapter;
    this.pluginSettings = settings;
    this.filePath = (0, import_obsidian18.normalizePath)(filePath);
    this.metadata = data.metadata;
    this.messages = data.messages.map((m) => ({ ...m, timestamp: new Date(m.timestamp) }));
    this.logger = logger;
    this.debouncedSave = (0, import_obsidian18.debounce)(this._saveToFile.bind(this), 1500, true);
  }
  addMessage(role, content, timestamp = new Date()) {
    const newMessage = { role, content, timestamp };
    this.messages.push(newMessage);
    this.metadata.lastModified = timestamp.toISOString();
    this.save();
    return newMessage;
  }
  getMessages() {
    return [...this.messages];
  }
  clearMessages() {
    this.messages = [];
    this.metadata.lastModified = new Date().toISOString();
    this.save();
  }
  updateMetadata(updates) {
    let changed = false;
    const currentMeta = this.metadata;
    if (updates.name !== void 0 && updates.name !== currentMeta.name) {
      currentMeta.name = updates.name;
      changed = true;
    }
    if (updates.modelName !== void 0 && updates.modelName !== currentMeta.modelName) {
      currentMeta.modelName = updates.modelName;
      changed = true;
    }
    if (updates.selectedRolePath !== void 0 && updates.selectedRolePath !== currentMeta.selectedRolePath) {
      currentMeta.selectedRolePath = updates.selectedRolePath;
      changed = true;
    }
    if (updates.temperature !== void 0 && updates.temperature !== currentMeta.temperature) {
      currentMeta.temperature = updates.temperature;
      changed = true;
    }
    if (updates.contextWindow !== void 0 && updates.contextWindow !== currentMeta.contextWindow) {
      currentMeta.contextWindow = updates.contextWindow;
      changed = true;
    }
    if (changed) {
      this.metadata.lastModified = new Date().toISOString();
      this.save();
    }
    return changed;
  }
  save() {
    if (this.pluginSettings.saveMessageHistory) {
      this.debouncedSave();
    }
  }
  async saveImmediately() {
    if (!this.pluginSettings.saveMessageHistory) {
      return true;
    }
    return await this._saveToFile();
  }
  async _saveToFile() {
    const chatData = {
      metadata: this.metadata,
      messages: this.messages.map((m) => ({
        ...m,
        timestamp: m.timestamp.toISOString()
      }))
    };
    const jsonString = JSON.stringify(chatData, null, 2);
    try {
      const dirPath = this.filePath.substring(0, this.filePath.lastIndexOf("/"));
      if (dirPath && !await this.adapter.exists(dirPath)) {
        await this.adapter.mkdir(dirPath);
      }
      await this.adapter.write(this.filePath, jsonString);
      return true;
    } catch (error) {
      console.error(`[Chat ${this.metadata.id}] Error saving chat to ${this.filePath}:`, error);
      new import_obsidian18.Notice(`Error saving chat: ${this.metadata.name}. Check console.`);
      return false;
    }
  }
  static async loadFromFile(filePath, adapter, settings, logger) {
    var _a;
    const normPath = (0, import_obsidian18.normalizePath)(filePath);
    try {
      if (!await adapter.exists(normPath)) {
        return null;
      }
      const json = await adapter.read(normPath);
      const data = JSON.parse(json);
      if (((_a = data == null ? void 0 : data.metadata) == null ? void 0 : _a.id) && Array.isArray(data.messages)) {
        return new Chat(adapter, settings, data, normPath, logger);
      } else {
        new import_obsidian18.Notice(`Error loading chat: Invalid data structure in ${filePath}`);
        return null;
      }
    } catch (e) {
      console.error(`[Chat] Error loading or parsing file for static load: ${normPath}`, e);
      new import_obsidian18.Notice(`Error loading chat file: ${filePath}. ${e.message}`);
      return null;
    }
  }
  async deleteFile() {
    try {
      if (await this.adapter.exists(this.filePath)) {
        await this.adapter.remove(this.filePath);
        return true;
      }
      return true;
    } catch (e) {
      console.error(`[Chat ${this.metadata.id}] Error deleting file ${this.filePath}:`, e);
      new import_obsidian18.Notice(`Error deleting chat file: ${this.metadata.name}. Check console.`);
      return false;
    }
  }
  toJSON() {
    return {
      metadata: this.metadata,
      messages: this.messages
    };
  }
  recordActivity() {
    const oldLastModified = this.metadata.lastModified;
    this.metadata.lastModified = new Date().toISOString();
    const changed = oldLastModified !== this.metadata.lastModified;
    if (changed) {
      this.save();
    }
    return changed;
  }
};

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = { randomUUID };

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  var _a, _b, _c;
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = (_c = (_b = options.random) != null ? _b : (_a = options.rng) == null ? void 0 : _a.call(options)) != null ? _c : rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
    }
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// src/ChatManager.ts
var ChatManager = class {
  constructor(plugin) {
    this.chatsFolderPath = "/";
    this.chatIndex = {};
    this.activeChatId = null;
    this.activeChat = null;
    this.loadedChats = {};
    this.currentTaskState = null;
    this.messageAddedResolvers = /* @__PURE__ */ new Map();
    this.plugin = plugin;
    this.app = plugin.app;
    this.adapter = plugin.app.vault.adapter;
    this.logger = plugin.logger;
  }
  async initialize() {
    this.updateChatsFolderPath();
    await this.ensureFoldersExist();
    await this.loadChatIndex(true);
    const savedActiveId = await this.plugin.loadDataKey(ACTIVE_CHAT_ID_KEY);
    if (savedActiveId && this.chatIndex[savedActiveId]) {
      await this.setActiveChat(savedActiveId);
    } else {
      await this.plugin.saveDataKey(ACTIVE_CHAT_ID_KEY, null);
      const hierarchy = await this.getChatHierarchy();
      const firstChat = this.findFirstChatInHierarchy(hierarchy);
      if (firstChat) {
        await this.setActiveChat(firstChat.metadata.id);
      } else {
        await this.setActiveChat(null);
      }
    }
  }
  findFirstChatInHierarchy(nodes) {
    for (const node of nodes) {
      if (node.type === "chat") {
        if (!isNaN(new Date(node.metadata.lastModified).getTime())) {
          return node;
        } else {
        }
      } else if (node.type === "folder") {
        const chatInFolder = this.findFirstChatInHierarchy(node.children);
        if (chatInFolder) {
          return chatInFolder;
        }
      }
    }
    return null;
  }
  updateChatsFolderPath() {
    var _a;
    const settingsPath = (_a = this.plugin.settings.chatHistoryFolderPath) == null ? void 0 : _a.trim();
    this.chatsFolderPath = settingsPath ? (0, import_obsidian19.normalizePath)(settingsPath) : "/";
    if (this.chatsFolderPath !== "/" && this.chatsFolderPath.endsWith("/")) {
      this.chatsFolderPath = this.chatsFolderPath.slice(0, -1);
    }
    if (!this.chatsFolderPath) {
      this.chatsFolderPath = "/";
    }
  }
  updateTaskState(tasks) {
    this.currentTaskState = tasks;
  }
  getCurrentTaskState() {
    return this.currentTaskState;
  }
  async ensureFoldersExist() {
    var _a, _b;
    const historyPath = (_a = this.plugin.settings.chatHistoryFolderPath) == null ? void 0 : _a.trim();
    const exportPath = (_b = this.plugin.settings.chatExportFolderPath) == null ? void 0 : _b.trim();
    const checkAndCreate = async (folderPath, folderDesc) => {
      if (!folderPath || folderPath === "/")
        return;
      const normalized = (0, import_obsidian19.normalizePath)(folderPath);
      if (normalized.startsWith("..") || normalized.includes("\0")) {
        new import_obsidian19.Notice(`Error: Invalid path for ${folderDesc}.`);
        return;
      }
      try {
        const exists = await this.adapter.exists(normalized);
        if (!exists) {
          await this.adapter.mkdir(normalized);
        } else {
          const stat = await this.adapter.stat(normalized);
          if ((stat == null ? void 0 : stat.type) !== "folder") {
            new import_obsidian19.Notice(`Error: Path for ${folderDesc} is not a folder.`);
          } else {
          }
        }
      } catch (error) {
        new import_obsidian19.Notice(`Error accessing folder for ${folderDesc}. Check permissions.`);
      }
    };
    await checkAndCreate(historyPath, "Chat History");
    await checkAndCreate(exportPath, "Chat Export");
  }
  async loadChatIndex(forceScan = false) {
    var _a;
    const storedIndex = await this.plugin.loadDataKey(CHAT_INDEX_KEY);
    const settingsPath = (_a = this.plugin.settings.chatHistoryFolderPath) == null ? void 0 : _a.trim();
    const currentPath = settingsPath && settingsPath !== "/" ? (0, import_obsidian19.normalizePath)(settingsPath) : "/";
    if (currentPath !== this.chatsFolderPath) {
      this.updateChatsFolderPath();
      forceScan = true;
    }
    if (!forceScan && storedIndex && typeof storedIndex === "object" && Object.keys(storedIndex).length > 0) {
      const firstKey = Object.keys(storedIndex)[0];
      if (storedIndex[firstKey] && typeof storedIndex[firstKey].name === "string" && typeof storedIndex[firstKey].lastModified === "string" && typeof storedIndex[firstKey].createdAt === "string") {
        this.chatIndex = storedIndex;
        return;
      } else {
        forceScan = true;
      }
    } else if (!forceScan && storedIndex && typeof storedIndex === "object" && Object.keys(storedIndex).length === 0) {
      this.chatIndex = {};
      return;
    } else if (!forceScan) {
      forceScan = true;
    }
    if (forceScan) {
      await this.rebuildIndexFromFiles();
    }
  }
  async rebuildIndexFromFiles() {
    const newIndex = {};
    let chatsLoaded = 0;
    let filesScanned = 0;
    try {
      if (this.chatsFolderPath !== "/") {
        const exists = await this.adapter.exists(this.chatsFolderPath);
        if (!exists) {
          try {
            await this.adapter.mkdir(this.chatsFolderPath);
          } catch (mkdirError) {
            this.chatIndex = {};
            await this.saveChatIndex();
            return;
          }
        } else {
          const stat = await this.adapter.stat(this.chatsFolderPath);
          if ((stat == null ? void 0 : stat.type) !== "folder") {
            new import_obsidian19.Notice(`Error: Chat history path '${this.chatsFolderPath}' is not a folder.`);
            this.chatIndex = {};
            await this.saveChatIndex();
            return;
          }
        }
      }
      const scanAndIndex = async (folderPath) => {
        var _a;
        let listResult;
        try {
          listResult = await this.adapter.list(folderPath);
        } catch (listError) {
          if (listError.message && listError.message.includes("Not a directory")) {
          } else {
          }
          return;
        }
        for (const fullPath of listResult.files) {
          const fileName = fullPath.substring(fullPath.lastIndexOf("/") + 1);
          if (!fileName.endsWith(".json") || fileName.startsWith("."))
            continue;
          const uuidPattern = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\.json$/i;
          const oldPattern = /^chat_\d+_[a-zA-Z0-9]+\.json$/;
          if (!uuidPattern.test(fileName) && !oldPattern.test(fileName))
            continue;
          filesScanned++;
          const chatId = fileName.slice(0, -5);
          try {
            const jsonContent = await this.adapter.read(fullPath);
            const data = JSON.parse(jsonContent);
            if (((_a = data == null ? void 0 : data.metadata) == null ? void 0 : _a.id) === chatId && typeof data.metadata.name === "string" && data.metadata.name.trim() !== "" && typeof data.metadata.lastModified === "string" && !isNaN(new Date(data.metadata.lastModified).getTime()) && typeof data.metadata.createdAt === "string" && !isNaN(new Date(data.metadata.createdAt).getTime())) {
              const meta = data.metadata;
              newIndex[chatId] = {
                name: meta.name,
                lastModified: new Date(meta.lastModified).toISOString(),
                createdAt: new Date(meta.createdAt).toISOString(),
                modelName: meta.modelName,
                selectedRolePath: meta.selectedRolePath,
                temperature: meta.temperature,
                contextWindow: meta.contextWindow
              };
              chatsLoaded++;
            } else {
            }
          } catch (e) {
            if (e instanceof SyntaxError) {
            } else {
            }
          }
        }
        for (const subFolderPath of listResult.folders) {
          await scanAndIndex(subFolderPath);
        }
      };
      await scanAndIndex(this.chatsFolderPath);
      this.chatIndex = newIndex;
      await this.saveChatIndex();
    } catch (error) {
      if (error.code === "ENOENT") {
        new import_obsidian19.Notice(`Error: Chat history folder '${this.chatsFolderPath}' not found.`);
      } else if (error.code === "EPERM" || error.code === "EACCES") {
        new import_obsidian19.Notice("Permission error accessing chat history folder.");
      } else {
        new import_obsidian19.Notice("Error rebuilding chat index. Check console.");
      }
      this.chatIndex = {};
      await this.saveChatIndex();
    }
  }
  async saveChatIndex() {
    try {
      await this.plugin.saveDataKey(CHAT_INDEX_KEY, this.chatIndex);
    } catch (error) {
      new import_obsidian19.Notice("Error saving chat index. Changes might be lost.");
    }
  }
  getChatFilePath(id, folderPath) {
    const fileName = `${id}.json`;
    const targetFolder = (0, import_obsidian19.normalizePath)(folderPath);
    if (targetFolder === "/" || targetFolder === "") {
      return (0, import_obsidian19.normalizePath)(fileName);
    } else {
      return (0, import_obsidian19.normalizePath)(`${targetFolder}/${fileName}`);
    }
  }
  async _scanFolderRecursive(folderPath) {
    const children = [];
    let listResult;
    try {
      const exists = await this.adapter.exists(folderPath);
      if (!exists) {
        return [];
      }
      const stat = await this.adapter.stat(folderPath);
      if ((stat == null ? void 0 : stat.type) !== "folder") {
        return [];
      }
      listResult = await this.adapter.list(folderPath);
    } catch (error) {
      if (error.code === "EPERM" || error.code === "EACCES") {
        new import_obsidian19.Notice(`Permission error reading folder: ${folderPath}`);
      } else {
      }
      return [];
    }
    for (const subFolderPath of listResult.folders) {
      try {
        const subStat = await this.adapter.stat(subFolderPath);
        if ((subStat == null ? void 0 : subStat.type) === "folder") {
          const folderName = subFolderPath.substring(subFolderPath.lastIndexOf("/") + 1);
          const subChildren = await this._scanFolderRecursive(subFolderPath);
          children.push({
            type: "folder",
            name: folderName,
            path: subFolderPath,
            children: subChildren
          });
        } else {
        }
      } catch (statError) {
      }
    }
    for (const fullPath of listResult.files) {
      const fileName = fullPath.substring(fullPath.lastIndexOf("/") + 1);
      if (!fileName.endsWith(".json") || fileName.startsWith("."))
        continue;
      const uuidPattern = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\.json$/i;
      const oldPattern = /^chat_\d+_[a-zA-Z0-9]+\.json$/;
      if (!uuidPattern.test(fileName) && !oldPattern.test(fileName))
        continue;
      const chatId = fileName.slice(0, -5);
      const storedMeta = this.chatIndex[chatId];
      if (storedMeta) {
        if (isNaN(new Date(storedMeta.lastModified).getTime()) || isNaN(new Date(storedMeta.createdAt).getTime())) {
          continue;
        }
        const chatMetadata = {
          id: chatId,
          name: storedMeta.name,
          lastModified: storedMeta.lastModified,
          createdAt: storedMeta.createdAt,
          modelName: storedMeta.modelName,
          selectedRolePath: storedMeta.selectedRolePath,
          temperature: storedMeta.temperature,
          contextWindow: storedMeta.contextWindow
        };
        children.push({
          type: "chat",
          metadata: chatMetadata,
          filePath: fullPath
        });
      } else {
      }
    }
    children.sort((a, b) => {
      if (a.type === "folder" && b.type === "chat")
        return -1;
      if (a.type === "chat" && b.type === "folder")
        return 1;
      if (a.type === "folder" && b.type === "folder") {
        return a.name.localeCompare(b.name);
      }
      if (a.type === "chat" && b.type === "chat") {
        const dateA = new Date(a.metadata.lastModified).getTime();
        const dateB = new Date(b.metadata.lastModified).getTime();
        const validA = !isNaN(dateA);
        const validB = !isNaN(dateB);
        if (validA && validB)
          return dateB - dateA;
        if (validB)
          return 1;
        if (validA)
          return -1;
        return a.metadata.name.localeCompare(b.metadata.name);
      }
      return 0;
    });
    return children;
  }
  async getChatHierarchy() {
    await this.ensureFoldersExist();
    return await this._scanFolderRecursive(this.chatsFolderPath);
  }
  async saveChatAndUpdateIndex(chat) {
    try {
      await chat.save();
      const meta = chat.metadata;
      const storedMeta = {
        name: meta.name,
        lastModified: meta.lastModified,
        createdAt: meta.createdAt,
        modelName: meta.modelName,
        selectedRolePath: meta.selectedRolePath,
        temperature: meta.temperature,
        contextWindow: meta.contextWindow
      };
      const existingIndexEntry = this.chatIndex[meta.id];
      const indexNeedsUpdate = !existingIndexEntry || existingIndexEntry.name !== storedMeta.name || existingIndexEntry.lastModified !== storedMeta.lastModified || existingIndexEntry.createdAt !== storedMeta.createdAt || existingIndexEntry.modelName !== storedMeta.modelName || existingIndexEntry.selectedRolePath !== storedMeta.selectedRolePath || existingIndexEntry.temperature !== storedMeta.temperature || existingIndexEntry.contextWindow !== storedMeta.contextWindow;
      if (indexNeedsUpdate) {
        this.chatIndex[meta.id] = storedMeta;
        await this.saveChatIndex();
        this.plugin.emit("chat-list-updated");
      } else {
        this.logger.trace(`Index for chat ${meta.id} unchanged after save trigger, skipping index save/event.`);
      }
      return true;
    } catch (error) {
      return false;
    }
  }
  async createNewChat(name, folderPath) {
    const targetFolder = folderPath ? (0, import_obsidian19.normalizePath)(folderPath) : this.chatsFolderPath;
    const finalFolderPath = targetFolder === "" || targetFolder === "." ? "/" : targetFolder;
    try {
      await this.ensureSpecificFolderExists(finalFolderPath);
    } catch (folderError) {
      new import_obsidian19.Notice(`Failed to ensure target folder exists: ${finalFolderPath}`);
      return null;
    }
    try {
      const now = new Date();
      const newId = v4_default();
      const filePath = this.getChatFilePath(newId, finalFolderPath);
      const initialMetadata = {
        id: newId,
        name: name || `Chat ${now.toLocaleDateString()} ${now.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })}`,
        modelName: this.plugin.settings.modelName,
        selectedRolePath: this.plugin.settings.selectedRolePath,
        temperature: this.plugin.settings.temperature,
        contextWindow: this.plugin.settings.contextWindow,
        createdAt: now.toISOString(),
        lastModified: now.toISOString()
      };
      const constructorSettings = { ...this.plugin.settings };
      const chatData = { metadata: initialMetadata, messages: [] };
      const newChat = new Chat(this.adapter, constructorSettings, chatData, filePath, this.logger);
      const storedMeta = {
        name: initialMetadata.name,
        lastModified: initialMetadata.lastModified,
        createdAt: initialMetadata.createdAt,
        modelName: initialMetadata.modelName,
        selectedRolePath: initialMetadata.selectedRolePath,
        temperature: initialMetadata.temperature,
        contextWindow: initialMetadata.contextWindow
      };
      this.chatIndex[newId] = storedMeta;
      await this.saveChatIndex();
      const savedImmediately = await newChat.saveImmediately();
      if (!savedImmediately) {
        delete this.chatIndex[newId];
        await this.saveChatIndex();
        this.plugin.emit("chat-list-updated");
        new import_obsidian19.Notice("Error: Failed to save new chat file.");
        return null;
      }
      this.loadedChats[newId] = newChat;
      await this.setActiveChat(newId);
      return newChat;
    } catch (error) {
      new import_obsidian19.Notice("Error creating new chat session.");
      return null;
    }
  }
  async ensureSpecificFolderExists(folderPath) {
    if (!folderPath || folderPath === "/" || folderPath === ".")
      return;
    const normalized = (0, import_obsidian19.normalizePath)(folderPath);
    if (normalized.startsWith("..") || normalized.includes("\0")) {
      throw new Error("Invalid folder path specified.");
    }
    try {
      const exists = await this.adapter.exists(normalized);
      if (!exists) {
        await this.adapter.mkdir(normalized);
      } else {
        const stat = await this.adapter.stat(normalized);
        if ((stat == null ? void 0 : stat.type) !== "folder") {
          throw new Error(`Target path ${normalized} is not a folder.`);
        }
      }
    } catch (error) {
      throw new Error(
        `Failed to ensure target folder ${normalized} exists: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }
  listAvailableChats() {
    return Object.entries(this.chatIndex).map(([id, storedMeta]) => {
      if (!storedMeta || typeof storedMeta !== "object" || typeof storedMeta.name !== "string" || typeof storedMeta.lastModified !== "string" || typeof storedMeta.createdAt !== "string") {
        return null;
      }
      const lastModDate = new Date(storedMeta.lastModified);
      const createdDate = new Date(storedMeta.createdAt);
      if (isNaN(lastModDate.getTime()) || isNaN(createdDate.getTime())) {
        return null;
      }
      return {
        id,
        name: storedMeta.name,
        lastModified: storedMeta.lastModified,
        createdAt: storedMeta.createdAt,
        modelName: storedMeta.modelName,
        selectedRolePath: storedMeta.selectedRolePath,
        temperature: storedMeta.temperature,
        contextWindow: storedMeta.contextWindow
      };
    }).filter((chatMeta) => chatMeta !== null).sort((a, b) => {
      const dateA = new Date(a.lastModified).getTime();
      const dateB = new Date(b.lastModified).getTime();
      if (!isNaN(dateA) && !isNaN(dateB)) {
        if (dateB !== dateA)
          return dateB - dateA;
      } else if (!isNaN(dateB))
        return 1;
      else if (!isNaN(dateA))
        return -1;
      const createdA = new Date(a.createdAt).getTime();
      const createdB = new Date(b.createdAt).getTime();
      if (!isNaN(createdA) && !isNaN(createdB)) {
        return createdB - createdA;
      } else if (!isNaN(createdB))
        return 1;
      else if (!isNaN(createdA))
        return -1;
      return a.name.localeCompare(b.name);
    });
  }
  getActiveChatId() {
    return this.activeChatId;
  }
  async getActiveChatOrFail() {
    const chat = await this.getActiveChat();
    if (!chat) {
      throw new Error("No active chat found or it failed to load.");
    }
    return chat;
  }
  async addMessageToActiveChatPayload(messagePayload, emitEvent = true) {
    const operationTimestampId = messagePayload.timestamp.getTime();
    const activeChatInstance = await this.getActiveChat();
    if (!activeChatInstance) {
      return null;
    }
    if (!messagePayload.timestamp) {
      messagePayload.timestamp = new Date();
    }
    activeChatInstance.messages.push(messagePayload);
    const activityRecorded = activeChatInstance.recordActivity();
    if (activityRecorded) {
      const saveAndUpdateIndexSuccess = await this.saveChatAndUpdateIndex(activeChatInstance);
      if (!saveAndUpdateIndexSuccess) {
      }
    }
    if (emitEvent) {
      const currentActiveChatIdForEvent = this.activeChatId || activeChatInstance.metadata.id;
      this.plugin.emit("message-added", { chatId: currentActiveChatIdForEvent, message: messagePayload });
    }
    return messagePayload;
  }
  async getChat(id, filePath) {
    var _a;
    if (this.loadedChats[id]) {
      return this.loadedChats[id];
    }
    let actualFilePath = filePath;
    if (!actualFilePath) {
      try {
        const hierarchy = await this.getChatHierarchy();
        actualFilePath = (_a = this.findChatPathInHierarchy(id, hierarchy)) != null ? _a : void 0;
        if (actualFilePath) {
        } else {
        }
      } catch (hierarchyError) {
        actualFilePath = void 0;
      }
    }
    if (!actualFilePath && this.chatIndex[id]) {
      return null;
    }
    if (!this.chatIndex[id] && !actualFilePath) {
      return null;
    }
    if (!actualFilePath) {
      return null;
    }
    try {
      const chat = await Chat.loadFromFile(actualFilePath, this.adapter, this.plugin.settings, this.logger);
      if (chat) {
        this.loadedChats[id] = chat;
        const storedMeta = this.chatIndex[id];
        const currentMeta = chat.metadata;
        const indexNeedsUpdate = !storedMeta || storedMeta.name !== currentMeta.name || storedMeta.lastModified !== currentMeta.lastModified || storedMeta.createdAt !== currentMeta.createdAt || storedMeta.modelName !== currentMeta.modelName || storedMeta.selectedRolePath !== currentMeta.selectedRolePath || storedMeta.temperature !== currentMeta.temperature || storedMeta.contextWindow !== currentMeta.contextWindow;
        if (indexNeedsUpdate) {
          await this.saveChatAndUpdateIndex(chat);
        }
        return chat;
      } else {
        await this.deleteChatFileAndIndexEntry_NoEmit(id, actualFilePath, false);
        if (this.activeChatId === id) {
          await this.setActiveChat(null);
        }
        return null;
      }
    } catch (error) {
      if (error.code === "ENOENT") {
        await this.deleteChatFileAndIndexEntry_NoEmit(id, actualFilePath, false);
        if (this.activeChatId === id) {
          await this.setActiveChat(null);
        }
      }
      return null;
    }
  }
  findChatPathInHierarchy(chatId, nodes) {
    for (const node of nodes) {
      if (node.type === "chat" && node.metadata.id === chatId) {
        return node.filePath;
      } else if (node.type === "folder") {
        const pathInFolder = this.findChatPathInHierarchy(chatId, node.children);
        if (pathInFolder) {
          return pathInFolder;
        }
      }
    }
    return null;
  }
  async getActiveChat() {
    if (!this.activeChatId) {
      return null;
    }
    if (this.activeChat && this.activeChat.metadata.id === this.activeChatId) {
      return this.activeChat;
    }
    const chat = await this.getChat(this.activeChatId);
    if (chat) {
      this.activeChat = chat;
      return chat;
    } else {
      const hierarchy = await this.getChatHierarchy();
      const firstChat = this.findFirstChatInHierarchy(hierarchy);
      const nextActiveId = firstChat ? firstChat.metadata.id : null;
      await this.setActiveChat(nextActiveId);
      return this.activeChat;
    }
  }
  async setActiveChat(id) {
    const previousActiveId = this.activeChatId;
    if (id === previousActiveId) {
      if (id && !this.activeChat) {
        this.activeChat = await this.getChat(id);
      }
      return;
    }
    if (id && !this.chatIndex[id]) {
      await this.rebuildIndexFromFiles();
      if (!this.chatIndex[id]) {
        new import_obsidian19.Notice(`Error: Chat with ID ${id} not found. Cannot activate.`);
        return;
      }
    }
    this.activeChatId = id;
    this.activeChat = null;
    await this.plugin.saveDataKey(ACTIVE_CHAT_ID_KEY, id);
    let loadedChat = null;
    if (id) {
      loadedChat = await this.getChat(id);
      if (!loadedChat) {
        this.activeChatId = null;
        await this.plugin.saveDataKey(ACTIVE_CHAT_ID_KEY, null);
        id = null;
      } else {
        this.activeChat = loadedChat;
      }
    } else {
    }
    this.plugin.emit("active-chat-changed", { chatId: id, chat: this.activeChat });
  }
  async addMessageToActiveChat(role, content, timestamp, emitEvent = true, tool_calls, tool_call_id, name) {
    const messageTimestamp = timestamp || new Date();
    const newMessage = {
      role,
      content,
      timestamp: messageTimestamp
    };
    if (tool_calls && tool_calls.length > 0) {
      newMessage.tool_calls = tool_calls;
    }
    if (tool_call_id) {
      newMessage.tool_call_id = tool_call_id;
    }
    if (name) {
      newMessage.name = name;
    }
    return await this.addMessageToActiveChatPayload(newMessage, emitEvent);
  }
  async clearActiveChatMessages() {
    const activeChat = await this.getActiveChat();
    if (!activeChat) {
      return;
    }
    if (activeChat.messages.length === 0) {
      return;
    }
    activeChat.clearMessages();
    await this.saveChatAndUpdateIndex(activeChat);
    this.plugin.emit("messages-cleared", activeChat.metadata.id);
  }
  async updateActiveChatMetadata(metadataUpdate) {
    var _a, _b, _c, _d, _e;
    const activeChat = await this.getActiveChat();
    if (!activeChat) {
      new import_obsidian19.Notice("No active chat to update metadata for.");
      return false;
    }
    if (Object.keys(metadataUpdate).length === 0) {
      return false;
    }
    const oldRolePath = activeChat.metadata.selectedRolePath;
    const oldModelName = activeChat.metadata.modelName;
    const changed = activeChat.updateMetadata(metadataUpdate);
    if (changed) {
      await this.saveChatAndUpdateIndex(activeChat);
      const newMeta = activeChat.metadata;
      let roleChanged = false;
      let modelChanged = false;
      if (metadataUpdate.selectedRolePath !== void 0 && oldRolePath !== newMeta.selectedRolePath) {
        roleChanged = true;
      }
      if (metadataUpdate.modelName !== void 0 && oldModelName !== newMeta.modelName) {
        modelChanged = true;
      }
      if (roleChanged) {
        try {
          const rolePathArg = (_a = newMeta.selectedRolePath) != null ? _a : void 0;
          const newRoleName = await this.plugin.findRoleNameByPath(rolePathArg);
          this.plugin.emit("role-changed", newRoleName != null ? newRoleName : "None");
          (_c = (_b = this.plugin.promptService) == null ? void 0 : _b.clearRoleCache) == null ? void 0 : _c.call(_b);
        } catch (e) {
        }
      }
      if (modelChanged) {
        this.plugin.emit("model-changed", newMeta.modelName || "");
        (_e = (_d = this.plugin.promptService) == null ? void 0 : _d.clearModelDetailsCache) == null ? void 0 : _e.call(_d);
      }
      this.plugin.emit("active-chat-changed", { chatId: this.activeChatId, chat: activeChat });
      return true;
    } else {
      return false;
    }
  }
  /**
   * Допоміжний метод для видалення файлу чату та запису з індексу БЕЗ генерації подій.
   * @param id ID чату для видалення.
   * @param filePath Шлях до файлу чату (може бути null).
   * @param deleteFile Чи потрібно видаляти фізичний файл.
   * @returns true, якщо індекс chatIndex був змінений, false в іншому випадку.
   */
  async deleteChatFileAndIndexEntry_NoEmit(id, filePath, deleteFile = true) {
    const safeFilePath = filePath != null ? filePath : "unknown_path";
    let indexChanged = false;
    if (this.loadedChats[id]) {
      delete this.loadedChats[id];
    }
    if (this.chatIndex[id]) {
      delete this.chatIndex[id];
      indexChanged = true;
    } else {
    }
    if (deleteFile && filePath && typeof filePath === "string" && filePath !== "/" && !filePath.endsWith("/")) {
      try {
        const fileExists = await this.adapter.exists(filePath);
        if (fileExists) {
          const stat = await this.adapter.stat(filePath);
          if ((stat == null ? void 0 : stat.type) === "file") {
            await this.adapter.remove(filePath);
          } else {
          }
        } else {
        }
      } catch (e) {
        new import_obsidian19.Notice(`Error deleting file: ${filePath.split("/").pop()}`);
      }
    } else if (deleteFile && filePath) {
    }
    if (indexChanged) {
      await this.saveChatIndex();
    }
    return indexChanged;
  }
  async deleteChat(id) {
    const chatExistedInIndex = !!this.chatIndex[id];
    const wasActive = id === this.activeChatId;
    let filePath = null;
    try {
      const hierarchy = await this.getChatHierarchy();
      filePath = this.findChatPathInHierarchy(id, hierarchy);
      if (!filePath && chatExistedInIndex) {
      }
    } catch (hierarchyError) {
    }
    if (!filePath && !chatExistedInIndex) {
      return false;
    }
    let success = true;
    let eventToEmit = null;
    try {
      const indexWasChanged = await this.deleteChatFileAndIndexEntry_NoEmit(id, filePath, true);
      if (wasActive) {
        const newHierarchy = await this.getChatHierarchy();
        const firstChat = this.findFirstChatInHierarchy(newHierarchy);
        const nextActiveId = firstChat ? firstChat.metadata.id : null;
        await this.setActiveChat(nextActiveId);
      } else if (indexWasChanged) {
        eventToEmit = { name: "chat-list-updated", data: void 0 };
      }
    } catch (error) {
      new import_obsidian19.Notice(`Error deleting chat ${id}. Check console.`);
      success = false;
      await this.rebuildIndexFromFiles();
      eventToEmit = { name: "chat-list-updated", data: void 0 };
    } finally {
      if (eventToEmit) {
        this.plugin.emit(eventToEmit.name, eventToEmit.data);
      } else if (wasActive) {
      } else {
      }
      if (success && chatExistedInIndex) {
        new import_obsidian19.Notice(`Chat deleted.`);
      } else if (!chatExistedInIndex) {
      }
    }
    return success && chatExistedInIndex;
  }
  async cloneChat(chatIdToClone) {
    let originalFilePath = null;
    try {
      const hierarchy = await this.getChatHierarchy();
      originalFilePath = this.findChatPathInHierarchy(chatIdToClone, hierarchy);
    } catch (hierarchyError) {
      new import_obsidian19.Notice("Error finding original chat for cloning.");
      return null;
    }
    if (!originalFilePath) {
      new import_obsidian19.Notice("Original chat file path not found.");
      return null;
    }
    const originalChat = await this.getChat(chatIdToClone, originalFilePath);
    if (!originalChat) {
      new import_obsidian19.Notice("Original chat could not be loaded.");
      return null;
    }
    const targetFolder = originalFilePath.substring(0, originalFilePath.lastIndexOf("/")) || "/";
    const finalFolderPath = targetFolder === "" || targetFolder === "." ? "/" : targetFolder;
    try {
      await this.ensureSpecificFolderExists(finalFolderPath);
    } catch (folderError) {
      new import_obsidian19.Notice(`Failed to ensure target folder for clone: ${finalFolderPath}`);
      return null;
    }
    try {
      const clonedData = originalChat.toJSON();
      const now = new Date();
      const newId = v4_default();
      const newFilePath = this.getChatFilePath(newId, finalFolderPath);
      clonedData.metadata.id = newId;
      clonedData.metadata.name = `Copy of ${originalChat.metadata.name}`;
      clonedData.metadata.createdAt = now.toISOString();
      clonedData.metadata.lastModified = now.toISOString();
      clonedData.metadata.modelName = originalChat.metadata.modelName;
      clonedData.metadata.selectedRolePath = originalChat.metadata.selectedRolePath;
      clonedData.metadata.temperature = originalChat.metadata.temperature;
      clonedData.metadata.contextWindow = originalChat.metadata.contextWindow;
      const constructorSettings = { ...this.plugin.settings };
      const clonedChat = new Chat(this.adapter, constructorSettings, clonedData, newFilePath, this.logger);
      const storedMeta = {
        name: clonedData.metadata.name,
        lastModified: clonedData.metadata.lastModified,
        createdAt: clonedData.metadata.createdAt,
        modelName: clonedData.metadata.modelName,
        selectedRolePath: clonedData.metadata.selectedRolePath,
        temperature: clonedData.metadata.temperature,
        contextWindow: clonedData.metadata.contextWindow
      };
      this.chatIndex[newId] = storedMeta;
      await this.saveChatIndex();
      const savedImmediately = await clonedChat.saveImmediately();
      if (!savedImmediately) {
        delete this.chatIndex[newId];
        await this.saveChatIndex();
        this.plugin.emit("chat-list-updated");
        new import_obsidian19.Notice("Error: Failed to save the cloned chat file.");
        return null;
      }
      this.loadedChats[newId] = clonedChat;
      await this.setActiveChat(newId);
      return clonedChat;
    } catch (error) {
      new import_obsidian19.Notice("An error occurred while cloning the chat.");
      return null;
    }
  }
  async deleteMessagesAfter(chatId, messageIndexToDeleteAfter) {
    const chat = await this.getChat(chatId);
    if (!chat) {
      return false;
    }
    if (messageIndexToDeleteAfter >= chat.messages.length - 1) {
      return true;
    }
    if (messageIndexToDeleteAfter < -1) {
      return false;
    }
    const originalLength = chat.messages.length;
    const targetLength = messageIndexToDeleteAfter + 1;
    chat.messages.length = targetLength;
    chat.updateMetadata({});
    await this.saveChatAndUpdateIndex(chat);
    if (this.activeChatId === chatId) {
      this.activeChat = chat;
      this.plugin.emit("active-chat-changed", { chatId, chat });
    }
    return true;
  }
  async deleteMessageByTimestamp(chatId, timestampToDelete) {
    const chat = await this.getChat(chatId);
    if (!chat) {
      new import_obsidian19.Notice(`Error: Chat ${chatId} not found.`);
      return false;
    }
    const timeTarget = timestampToDelete.getTime();
    const tolerance = 1e3;
    let messageIndex = -1;
    for (let i = 0; i < chat.messages.length; i++) {
      const messageTime = chat.messages[i].timestamp.getTime();
      if (!isNaN(messageTime) && Math.abs(messageTime - timeTarget) < tolerance) {
        messageIndex = i;
        break;
      } else if (isNaN(messageTime)) {
      }
    }
    if (messageIndex === -1) {
      new import_obsidian19.Notice("Message not found.");
      return false;
    }
    return await this._performDeleteMessageByIndex(chat, messageIndex);
  }
  async _performDeleteMessageByIndex(chat, messageIndex) {
    const chatId = chat.metadata.id;
    try {
      if (messageIndex < 0 || messageIndex >= chat.messages.length) {
        return false;
      }
      const deletedMessage = chat.messages.splice(messageIndex, 1)[0];
      chat.updateMetadata({});
      await this.saveChatAndUpdateIndex(chat);
      if (this.activeChatId === chatId) {
        this.activeChat = chat;
        this.plugin.emit("active-chat-changed", { chatId, chat });
      }
      if (deletedMessage) {
        this.plugin.emit("message-deleted", { chatId, timestamp: deletedMessage.timestamp });
      }
      return true;
    } catch (error) {
      new import_obsidian19.Notice("Error deleting message.");
      return false;
    }
  }
  async clearChatMessagesById(chatId) {
    const chat = await this.getChat(chatId);
    if (!chat) {
      new import_obsidian19.Notice(`Error: Chat ${chatId} not found.`);
      return false;
    }
    if (chat.messages.length === 0) {
      return true;
    }
    try {
      chat.clearMessages();
      await this.saveChatAndUpdateIndex(chat);
      const isActive = chatId === this.activeChatId;
      if (isActive) {
        this.activeChat = chat;
        this.plugin.emit("messages-cleared", chatId);
      }
      new import_obsidian19.Notice(`Messages cleared for chat "${chat.metadata.name}".`);
      return true;
    } catch (error) {
      new import_obsidian19.Notice("Error clearing messages.");
      return false;
    }
  }
  async renameChat(chatId, newName) {
    const trimmedName = newName.trim();
    if (!trimmedName) {
      new import_obsidian19.Notice("Chat name cannot be empty.");
      return false;
    }
    if (/[\\/?:*"<>|]/.test(trimmedName)) {
      new import_obsidian19.Notice("Chat name contains invalid characters.");
      return false;
    }
    const chat = await this.getChat(chatId);
    if (!chat) {
      new import_obsidian19.Notice("Chat not found.");
      return false;
    }
    if (chat.metadata.name === trimmedName) {
      return true;
    }
    try {
      const changed = chat.updateMetadata({ name: trimmedName });
      if (changed) {
        await this.saveChatAndUpdateIndex(chat);
        if (this.activeChatId === chatId) {
          this.activeChat = chat;
          this.plugin.emit("active-chat-changed", { chatId, chat });
        }
        new import_obsidian19.Notice(`Chat renamed to "${trimmedName}".`);
        return true;
      } else {
        return false;
      }
    } catch (error) {
      new import_obsidian19.Notice("An error occurred while renaming the chat.");
      return false;
    }
  }
  /**
   * Створює нову папку за вказаним шляхом.
   * @param folderPath Повний, нормалізований шлях до папки, яку потрібно створити.
   * @returns true, якщо папка успішно створена, false в іншому випадку.
   */
  async createFolder(folderPath) {
    const normalizedPath = (0, import_obsidian19.normalizePath)(folderPath);
    if (!normalizedPath || normalizedPath === "/" || normalizedPath === ".") {
      new import_obsidian19.Notice("Invalid folder path.");
      return false;
    }
    if (normalizedPath.startsWith("..") || normalizedPath.includes("\0")) {
      new import_obsidian19.Notice("Invalid characters or path traversal detected.");
      return false;
    }
    try {
      const exists = await this.adapter.exists(normalizedPath);
      if (exists) {
        new import_obsidian19.Notice(`"${normalizedPath.split("/").pop()}" already exists.`);
        return false;
      }
      await this.adapter.mkdir(normalizedPath);
      this.plugin.emit("chat-list-updated");
      return true;
    } catch (error) {
      if (error.code === "EPERM" || error.code === "EACCES") {
        new import_obsidian19.Notice(`Permission error creating folder.`);
      } else {
        new import_obsidian19.Notice(`Failed to create folder: ${error.message || "Unknown error"}`);
      }
      return false;
    }
  }
  /**
   * Перейменовує або переміщує папку.
   * Важливо: Цей метод не оновлює індекс chatIndex автоматично для чатів всередині папки.
   * Найкраще викликати rebuildIndexFromFiles() після успішного перейменування або покладатися
   * на те, що getChatHierarchy() збиратиме актуальну структуру.
   * @param oldPath Повний, нормалізований старий шлях до папки.
   * @param newPath Повний, нормалізований новий шлях до папки.
   * @returns true, якщо перейменування/переміщення успішне, false в іншому випадку.
   */
  async renameFolder(oldPath, newPath) {
    const normOldPath = (0, import_obsidian19.normalizePath)(oldPath);
    const normNewPath = (0, import_obsidian19.normalizePath)(newPath);
    if (!normOldPath || normOldPath === "/" || !normNewPath || normNewPath === "/") {
      new import_obsidian19.Notice("Cannot rename root folder or use empty path.");
      return false;
    }
    if (normOldPath === normNewPath) {
      return true;
    }
    if (normNewPath.startsWith(normOldPath + "/")) {
      new import_obsidian19.Notice("Cannot move a folder inside itself.");
      return false;
    }
    try {
      const oldExists = await this.adapter.exists(normOldPath);
      if (!oldExists) {
        new import_obsidian19.Notice("Folder to rename not found.");
        return false;
      }
      const oldStat = await this.adapter.stat(normOldPath);
      if ((oldStat == null ? void 0 : oldStat.type) !== "folder") {
        new import_obsidian19.Notice("Item to rename is not a folder.");
        return false;
      }
      const newExists = await this.adapter.exists(normNewPath);
      if (newExists) {
        new import_obsidian19.Notice(`"${normNewPath.split("/").pop()}" already exists.`);
        return false;
      }
      await this.adapter.rename(normOldPath, normNewPath);
      Object.values(this.loadedChats).forEach((chat) => {
        if (chat.filePath.startsWith(normOldPath + "/")) {
          const relativePath = chat.filePath.substring(normOldPath.length);
          const updatedPath = (0, import_obsidian19.normalizePath)(normNewPath + relativePath);
          chat.filePath = updatedPath;
        }
      });
      this.plugin.emit("chat-list-updated");
      return true;
    } catch (error) {
      if (error.code === "EPERM" || error.code === "EACCES") {
        new import_obsidian19.Notice(`Permission error renaming folder.`);
      } else {
        new import_obsidian19.Notice(`Failed to rename folder: ${error.message || "Unknown error"}`);
      }
      return false;
    }
  }
  /**
   * Рекурсивно видаляє папку та весь її вміст (підпапки та чати).
   * @param folderPath Повний, нормалізований шлях до папки, яку потрібно видалити.
   * @returns true, якщо папка та її вміст успішно видалені, false в іншому випадку.
   */
  async deleteFolder(folderPath) {
    const normalizedPath = (0, import_obsidian19.normalizePath)(folderPath);
    if (!normalizedPath || normalizedPath === "/" || normalizedPath === ".") {
      new import_obsidian19.Notice("Cannot delete this folder.");
      return false;
    }
    if (normalizedPath === this.chatsFolderPath) {
      new import_obsidian19.Notice("Cannot delete the main chat history folder set in settings.");
      return false;
    }
    try {
      const exists = await this.adapter.exists(normalizedPath);
      if (!exists) {
        return true;
      }
      const stat = await this.adapter.stat(normalizedPath);
      if ((stat == null ? void 0 : stat.type) !== "folder") {
        new import_obsidian19.Notice("Item to delete is not a folder.");
        return false;
      }
      const chatIdsToDelete = [];
      const collectChatIds = async (currentPath) => {
        try {
          const list = await this.adapter.list(currentPath);
          for (const file of list.files) {
            const fileName = file.substring(file.lastIndexOf("/") + 1);
            if (fileName.endsWith(".json")) {
              const chatId = fileName.slice(0, -5);
              if (this.chatIndex[chatId]) {
                chatIdsToDelete.push(chatId);
              }
            }
          }
          for (const folder of list.folders) {
            await collectChatIds(folder);
          }
        } catch (listError) {
        }
      };
      await collectChatIds(normalizedPath);
      let activeChatWasDeleted = false;
      chatIdsToDelete.forEach((id) => {
        if (this.chatIndex[id]) {
          delete this.chatIndex[id];
        }
        if (this.loadedChats[id]) {
          delete this.loadedChats[id];
        }
        if (this.activeChatId === id) {
          activeChatWasDeleted = true;
          this.activeChatId = null;
          this.activeChat = null;
        }
      });
      await this.saveChatIndex();
      if (activeChatWasDeleted) {
        await this.plugin.saveDataKey(ACTIVE_CHAT_ID_KEY, null);
      }
      await this.adapter.rmdir(normalizedPath, true);
      this.plugin.emit("chat-list-updated");
      if (activeChatWasDeleted) {
        this.plugin.emit("active-chat-changed", { chatId: null, chat: null });
      }
      return true;
    } catch (error) {
      if (error.code === "EPERM" || error.code === "EACCES") {
        new import_obsidian19.Notice(`Permission error deleting folder.`);
      } else {
        new import_obsidian19.Notice(`Failed to delete folder: ${error.message || "Unknown error"}`);
      }
      await this.rebuildIndexFromFiles();
      return false;
    }
  }
  async moveChat(chatId, oldFilePath, newFolderPath) {
    const normOldPath = (0, import_obsidian19.normalizePath)(oldFilePath);
    const normNewFolderPath = (0, import_obsidian19.normalizePath)(newFolderPath);
    let newFilePath = null;
    if (!chatId || !oldFilePath || !newFolderPath) {
      new import_obsidian19.Notice("Move chat failed: Invalid data.");
      return false;
    }
    try {
      if (!await this.adapter.exists(normOldPath)) {
        new import_obsidian19.Notice("Move chat failed: Source file not found.");
        await this.rebuildIndexFromFiles();
        this.plugin.emit("chat-list-updated");
        return false;
      }
      const oldStat = await this.adapter.stat(normOldPath);
      if ((oldStat == null ? void 0 : oldStat.type) !== "file") {
        new import_obsidian19.Notice("Move chat failed: Source is not a file.");
        return false;
      }
      if (!await this.adapter.exists(normNewFolderPath)) {
        new import_obsidian19.Notice("Move chat failed: Target folder not found.");
        return false;
      }
      const newStat = await this.adapter.stat(normNewFolderPath);
      if ((newStat == null ? void 0 : newStat.type) !== "folder") {
        new import_obsidian19.Notice("Move chat failed: Target is not a folder.");
        return false;
      }
      const fileName = oldFilePath.substring(oldFilePath.lastIndexOf("/") + 1);
      newFilePath = (0, import_obsidian19.normalizePath)(`${normNewFolderPath}/${fileName}`);
      if (normOldPath === newFilePath) {
        return true;
      }
      if (await this.adapter.exists(newFilePath)) {
        new import_obsidian19.Notice(`Move chat failed: A file named "${fileName}" already exists in the target folder.`);
        return false;
      }
      await this.adapter.rename(normOldPath, newFilePath);
      if (this.loadedChats[chatId] && newFilePath) {
        this.loadedChats[chatId].filePath = newFilePath;
      }
      this.plugin.emit("chat-list-updated");
      return true;
    } catch (error) {
      const targetPathDesc = newFilePath != null ? newFilePath : normNewFolderPath;
      if (error.code === "EPERM" || error.code === "EACCES") {
        new import_obsidian19.Notice(`Permission error moving chat file.`);
      } else {
        new import_obsidian19.Notice(`Failed to move chat: ${error.message || "Unknown error"}`);
      }
      await this.rebuildIndexFromFiles();
      this.plugin.emit("chat-list-updated");
      return false;
    }
  }
  /**
   * Реєструє резолвер для події message-added.
   * Цей метод викликатиметься з OllamaView перед тим, як ChatManager додасть повідомлення.
   */
  registerHMAResolver(timestampMs, resolve, reject) {
    if (this.messageAddedResolvers.has(timestampMs)) {
    }
    this.messageAddedResolvers.set(timestampMs, { resolve, reject });
  }
  /**
   * Викликає та видаляє резолвер для події message-added.
   * Цей метод викликатиметься з OllamaView.handleMessageAdded.
   */
  invokeHMAResolver(timestampMs) {
    const resolverPair = this.messageAddedResolvers.get(timestampMs);
    if (resolverPair) {
      resolverPair.resolve();
      this.messageAddedResolvers.delete(timestampMs);
    } else {
    }
  }
  rejectAndClearHMAResolver(timestampMs, reason) {
    const resolverPair = this.messageAddedResolvers.get(timestampMs);
    if (resolverPair) {
      resolverPair.reject(new Error(reason));
      this.messageAddedResolvers.delete(timestampMs);
    }
  }
  /**
   * Додає повідомлення користувача до активного чату, зберігає його,
   * генерує подію "message-added" (для OllamaView.handleMessageAdded)
   * та повертає проміс, який вирішується, коли handleMessageAdded завершить рендеринг.
   * @param content Вміст повідомлення користувача.
   * @param timestamp Мітка часу повідомлення.
   * @param requestTimestampId Унікальний ID запиту для логування.
   * @returns Проміс, що вирішується після рендерингу, або null, якщо сталася помилка.
   */
  async addUserMessageAndAwaitRender(content, timestamp, requestTimestampId) {
    const activeChat = await this.getActiveChat();
    if (!activeChat) {
      return null;
    }
    const messageTimestampMs = timestamp.getTime();
    const userMessage = {
      role: "user",
      content,
      timestamp
    };
    const hmaPromise = new Promise((resolve, reject) => {
      this.registerHMAResolver(messageTimestampMs, resolve, reject);
      setTimeout(() => {
        if (this.messageAddedResolvers.has(messageTimestampMs)) {
          const reason = `HMA Timeout for UserMessage (ts: ${messageTimestampMs}) in ChatManager.`;
          this.rejectAndClearHMAResolver(messageTimestampMs, reason);
        }
      }, 1e4);
    });
    const addedMessage = await this.addMessageToActiveChatPayload(userMessage, true);
    if (!addedMessage) {
      this.rejectAndClearHMAResolver(messageTimestampMs, "Failed to add message payload to ChatManager.");
      return null;
    }
    try {
      await hmaPromise;
      return userMessage;
    } catch (error) {
      return null;
    }
  }
};

// src/main.ts
var import_child_process = require("child_process");

// src/TranslationService.ts
var import_obsidian20 = require("obsidian");
var GOOGLE_TRANSLATE_API_URL = "https://translation.googleapis.com/language/translate/v2";
var TranslationService = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  /**
   * Головний метод для перекладу тексту. Вибирає провайдера на основі налаштувань.
   * @param text Текст для перекладу.
   * @param targetLang Код цільової мови (e.g., 'uk', 'en'). Якщо не вказано, використовується з налаштувань.
   * @returns Перекладений текст або null у разі помилки/вимкнення.
   */
  async translate(text, targetLang) {
    const provider = this.plugin.settings.translationProvider;
    const finalTargetLang = targetLang || this.plugin.settings.translationTargetLanguage;
    if (provider === "none" || !this.plugin.settings.enableTranslation) {
      this.plugin.logger.debug("[TranslationService] Translation disabled or provider is 'none'.");
      return null;
    }
    if (!text || !text.trim()) {
      this.plugin.logger.debug("[TranslationService] Input text is empty.");
      return "";
    }
    if (!finalTargetLang) {
      this.plugin.logger.error("[TranslationService] Target language is not defined.");
      new import_obsidian20.Notice("Translation Error: Target language not configured.");
      return null;
    }
    this.plugin.logger.info(`[TranslationService] Requesting translation via '${provider}' to '${finalTargetLang}'.`);
    try {
      switch (provider) {
        case "google":
          const apiKey = this.plugin.settings.googleTranslationApiKey;
          if (!apiKey) {
            new import_obsidian20.Notice("Google Translation API Key is not configured.");
            this.plugin.logger.error("[TranslationService] Google API Key missing.");
            return null;
          }
          return await this._translateWithGoogle(text, finalTargetLang, apiKey);
        case "ollama":
          const model = this.plugin.settings.ollamaTranslationModel;
          if (!model) {
            new import_obsidian20.Notice("Ollama translation model is not selected in settings.");
            this.plugin.logger.error("[TranslationService] Ollama translation model missing.");
            return null;
          }
          return await this._translateWithOllama(text, finalTargetLang, model);
        default:
          this.plugin.logger.warn(`[TranslationService] Unknown translation provider: ${provider}`);
          return null;
      }
    } catch (error) {
      this.plugin.logger.error(`[TranslationService] General translation error for provider ${provider}:`, error);
      new import_obsidian20.Notice(`Translation failed: ${error instanceof Error ? error.message : "Unknown error"}`);
      return null;
    }
  }
  /**
   * Переклад за допомогою Google Translate API.
   */
  async _translateWithGoogle(text, targetLang, apiKey) {
    var _a, _b, _c, _d;
    if (targetLang === "English") {
      targetLang = "en";
    }
    this.plugin.logger.debug(`[_translateWithGoogle] Translating to ${targetLang}...`);
    try {
      const response = await fetch(`${GOOGLE_TRANSLATE_API_URL}?key=${apiKey}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ q: text, target: targetLang, format: "text" })
      });
      const data = await response.json();
      if (!response.ok) {
        const errorMsg = ((_a = data.error) == null ? void 0 : _a.message) || `HTTP error ${response.status}`;
        throw new Error(`Google API Error: ${errorMsg}`);
      }
      if ((_d = (_c = (_b = data.data) == null ? void 0 : _b.translations) == null ? void 0 : _c[0]) == null ? void 0 : _d.translatedText) {
        const translatedText = this.decodeHtmlEntities(data.data.translations[0].translatedText);
        this.plugin.logger.debug("[_translateWithGoogle] Translation successful.");
        return translatedText;
      } else {
        this.plugin.logger.error("[_translateWithGoogle] Unexpected response structure:", data);
        throw new Error("Unexpected response structure from Google API.");
      }
    } catch (error) {
      this.plugin.logger.error("[_translateWithGoogle] API call failed:", error);
      throw error;
    }
  }
  /**
   * Переклад за допомогою моделі Ollama.
   */
  async _translateWithOllama(text, targetLang, model) {
    this.plugin.logger.debug(`[_translateWithOllama] Translating to ${targetLang} using model ${model}...`);
    const targetLangName = LANGUAGES[targetLang] || targetLang;
    const prompt = `Translate the following text to ${targetLangName}. Output ONLY the translated text, without any introduction or explanation.

Text:
"""
${text}
"""

Translated Text:`;
    try {
      const requestBody = {
        model,
        prompt,
        stream: false,
        // Для перекладу зазвичай не потрібен стрімінг
        options: {
          temperature: 0.2,
          // Низька температура для більш точного перекладу
          num_predict: 1024
          // Обмеження довжини відповіді (можна налаштувати)
          // Можна додати stop tokens, якщо модель додає зайве
        }
      };
      this.plugin.logger.debug("Sending translation request to Ollama:", requestBody);
      const responseData = await this.plugin.ollamaService.generateRaw(requestBody);
      if (responseData && responseData.response) {
        const translatedText = responseData.response.trim();
        this.plugin.logger.debug(`[_translateWithOllama] Translation successful. Result length: ${translatedText.length}`);
        return translatedText;
      } else {
        this.plugin.logger.warn("[_translateWithOllama] Received empty response from Ollama model.");
        return null;
      }
    } catch (error) {
      this.plugin.logger.error(`[_translateWithOllama] Ollama request failed for model ${model}:`, error);
      throw error;
    }
  }
  // Допоміжна функція декодування HTML (без змін)
  decodeHtmlEntities(text) {
    if (typeof document !== "undefined") {
      const textArea = document.createElement("textarea");
      textArea.innerHTML = text;
      return textArea.value;
    } else {
      return text.replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&#39;/g, "'");
    }
  }
};

// src/examples/SimpleFileAgent.ts
var import_obsidian21 = require("obsidian");
var SimpleFileAgent = class {
  constructor() {
    this.id = "simple-file-agent";
    this.name = "Simple File Agent";
    this.description = "An agent that can read and list files in the vault.";
  }
  getTools() {
    return [
      {
        name: "readFileContent",
        description: "Reads the content of a specified file in the Obsidian vault.",
        parameters: {
          type: "object",
          properties: {
            filePath: {
              type: "string",
              description: "The full path to the file within the Obsidian vault (e.g., 'Notes/MyFile.md')."
            }
          },
          required: ["filePath"]
        }
      },
      {
        name: "listFiles",
        description: "Lists files in a specified folder of the Obsidian vault. Lists root if no path specified.",
        parameters: {
          type: "object",
          properties: {
            folderPath: {
              type: "string",
              description: "Optional. The path to the folder (e.g., 'Attachments/Images'). If omitted, lists root."
            }
          }
        }
      }
    ];
  }
  async executeTool(toolName, args, plugin) {
    switch (toolName) {
      case "readFileContent":
        if (!args.filePath || typeof args.filePath !== "string") {
          return "Error: 'filePath' argument is missing or not a string.";
        }
        try {
          const normalized = (0, import_obsidian21.normalizePath)(args.filePath);
          const file = plugin.app.vault.getAbstractFileByPath(normalized);
          if (file instanceof import_obsidian21.TFile) {
            const content = await plugin.app.vault.read(file);
            new import_obsidian21.Notice(`Agent read file: ${file.basename}`);
            return `Content of "${args.filePath}":
${content}`;
          } else {
            return `Error: File not found or is not a regular file at path: ${args.filePath}`;
          }
        } catch (e) {
          plugin.logger.error(`[SimpleFileAgent] Error reading file ${args.filePath}:`, e);
          return `Error reading file "${args.filePath}": ${e.message}`;
        }
      case "listFiles":
        try {
          const pathToList = args.folderPath ? (0, import_obsidian21.normalizePath)(args.folderPath) : "/";
          const folder = plugin.app.vault.getAbstractFileByPath(pathToList);
          if (folder && folder instanceof import_obsidian21.TFolder) {
            const files = folder.children.filter((f) => f instanceof import_obsidian21.TFile).map((f) => f.name);
            return `Files in "${pathToList}":
${files.join("\n")}`;
          } else if (pathToList === "/") {
            const files = plugin.app.vault.getFiles().map((f) => f.path);
            return `Files in vault root:
${files.join("\n")}`;
          } else {
            return `Error: Folder not found at path: ${args.folderPath || "(root)"}`;
          }
        } catch (e) {
          plugin.logger.error(`[SimpleFileAgent] Error listing files in ${args.folderPath || "(root)"}:`, e);
          return `Error listing files: ${e.message}`;
        }
      default:
        return `Error: Unknown tool "${toolName}" for SimpleFileAgent.`;
    }
  }
};

// src/examples/WeatherAgent.ts
var import_obsidian22 = require("obsidian");
var OPENWEATHERMAP_BASE_URL = "https://api.openweathermap.org/data/2.5";
var WeatherAgent = class {
  constructor() {
    this.id = "weather-agent";
    this.name = "Weather Agent";
    this.description = "An agent that can fetch weather forecasts from the internet.";
  }
  getTools() {
    return [
      {
        name: "getWeatherToday",
        description: "Gets today's weather forecast for a specified location. Uses default location from settings if not provided.",
        parameters: {
          type: "object",
          properties: {
            location: {
              // Залишаємо параметр, але він може бути не наданий
              type: "string",
              description: "Optional. The city name or location for the weather forecast (e.g., 'Kyiv', 'London'). If omitted, uses default from settings."
            }
          }
          // required: ["location"], // ВИДАЛЯЄМО required, щоб AI міг викликати без локації
        }
      },
      {
        name: "getWeatherTomorrow",
        description: "Gets tomorrow's weather forecast for a specified location. Uses default location from settings if not provided.",
        parameters: {
          type: "object",
          properties: {
            location: {
              type: "string",
              description: "Optional. The city name or location for the weather forecast. If omitted, uses default from settings."
            }
          }
          // required: ["location"], // ВИДАЛЯЄМО required
        }
      },
      {
        name: "getWeather5Days",
        description: "Gets the weather forecast for the next 5 days for a specified location. Uses default location from settings if not provided.",
        parameters: {
          type: "object",
          properties: {
            location: {
              type: "string",
              description: "Optional. The city name or location for the weather forecast. If omitted, uses default from settings."
            }
          }
          // required: ["location"], // ВИДАЛЯЄМО required
        }
      }
    ];
  }
  async executeTool(toolName, args, plugin) {
    const apiKey = plugin.settings.openWeatherMapApiKey;
    let locationToUse = args == null ? void 0 : args.location;
    if (!apiKey || apiKey === "YOUR_OPENWEATHERMAP_API_KEY") {
      return "\u041F\u043E\u043C\u0438\u043B\u043A\u0430: \u041D\u0435\u043E\u0431\u0445\u0456\u0434\u043D\u043E \u043D\u0430\u0434\u0430\u0442\u0438 API \u043A\u043B\u044E\u0447 OpenWeatherMap \u0443 \u043D\u0430\u043B\u0430\u0448\u0442\u0443\u0432\u0430\u043D\u043D\u044F\u0445 \u043F\u043B\u0430\u0433\u0456\u043D\u0430 Weather Agent.";
    }
    if (!locationToUse || typeof locationToUse !== "string" || locationToUse.trim() === "") {
      locationToUse = plugin.settings.weatherDefaultLocation;
      if (!locationToUse || locationToUse.trim() === "") {
        return "\u041F\u043E\u043C\u0438\u043B\u043A\u0430: \u041B\u043E\u043A\u0430\u0446\u0456\u044F \u043D\u0435 \u0432\u043A\u0430\u0437\u0430\u043D\u0430 \u0456 \u043B\u043E\u043A\u0430\u0446\u0456\u044F \u0437\u0430 \u0437\u0430\u043C\u043E\u0432\u0447\u0443\u0432\u0430\u043D\u043D\u044F\u043C \u043D\u0435 \u0432\u0441\u0442\u0430\u043D\u043E\u0432\u043B\u0435\u043D\u0430 \u0432 \u043D\u0430\u043B\u0430\u0448\u0442\u0443\u0432\u0430\u043D\u043D\u044F\u0445.";
      }
      new import_obsidian22.Notice(`\u0412\u0438\u043A\u043E\u0440\u0438\u0441\u0442\u043E\u0432\u0443\u0454\u0442\u044C\u0441\u044F \u043B\u043E\u043A\u0430\u0446\u0456\u044F \u0437\u0430 \u0437\u0430\u043C\u043E\u0432\u0447\u0443\u0432\u0430\u043D\u043D\u044F\u043C: ${locationToUse}`);
    }
    try {
      let url = "";
      let result = "";
      let forecastData;
      url = `${OPENWEATHERMAP_BASE_URL}/forecast?q=${encodeURIComponent(locationToUse)}&units=metric&appid=${apiKey}&lang=ua`;
      const response = await fetch(url);
      if (!response.ok) {
        let errorBody = await response.text();
        try {
          const errorJson = JSON.parse(errorBody);
          if (errorJson.message) {
            errorBody = errorJson.message;
          }
        } catch (e) {
        }
        throw new Error(`\u041F\u043E\u043C\u0438\u043B\u043A\u0430 HTTP: ${response.status} ${response.statusText}. \u0412\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u044C API: ${errorBody}`);
      }
      const data = await response.json();
      if (data.cod !== "200") {
        throw new Error(`\u041F\u043E\u043C\u0438\u043B\u043A\u0430 API: ${data.message || "\u041D\u0435\u0432\u0456\u0434\u043E\u043C\u0430 \u043F\u043E\u043C\u0438\u043B\u043A\u0430 API"}`);
      }
      forecastData = data.list;
      const city = data.city.name;
      result = `\u041F\u0440\u043E\u0433\u043D\u043E\u0437 \u043F\u043E\u0433\u043E\u0434\u0438 \u0434\u043B\u044F ${city}:

`;
      const now = new Date();
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);
      const dateOptions = { day: "2-digit", month: "2-digit", year: "numeric" };
      const timeOptions = { hour: "2-digit", minute: "2-digit", hour12: false };
      const dayOfWeekOptions = { weekday: "long" };
      switch (toolName) {
        case "getWeatherToday": {
          const todayForecast = forecastData.find((item) => {
            const itemDate = new Date(item.dt * 1e3);
            return itemDate >= now && itemDate.toDateString() === now.toDateString();
          }) || forecastData.find((item) => new Date(item.dt * 1e3).toDateString() === now.toDateString());
          if (todayForecast) {
            const date = new Date(todayForecast.dt * 1e3);
            const formattedDate = date.toLocaleDateString("uk-UA", dateOptions);
            const formattedTime = date.toLocaleTimeString("uk-UA", timeOptions);
            result += `\u0421\u044C\u043E\u0433\u043E\u0434\u043D\u0456 (${formattedDate}, ${formattedTime}): ${todayForecast.weather[0].description}, \u0422\u0435\u043C\u043F\u0435\u0440\u0430\u0442\u0443\u0440\u0430: ${todayForecast.main.temp}\xB0C, \u0412\u0456\u0434\u0447\u0443\u0432\u0430\u0454\u0442\u044C\u0441\u044F \u044F\u043A: ${todayForecast.main.feels_like}\xB0C, \u0412\u043E\u043B\u043E\u0433\u0456\u0441\u0442\u044C: ${todayForecast.main.humidity}%.`;
          } else {
            result += "\u041D\u0435 \u0432\u0434\u0430\u043B\u043E\u0441\u044F \u0437\u043D\u0430\u0439\u0442\u0438 \u043F\u0440\u043E\u0433\u043D\u043E\u0437 \u043D\u0430 \u0441\u044C\u043E\u0433\u043E\u0434\u043D\u0456 (\u043C\u043E\u0436\u043B\u0438\u0432\u043E, \u0432\u0441\u0456 \u043F\u0440\u043E\u0433\u043D\u043E\u0437\u0438 \u043D\u0430 \u0441\u044C\u043E\u0433\u043E\u0434\u043D\u0456 \u0432\u0436\u0435 \u043F\u0440\u043E\u0439\u0448\u043B\u0438 \u0437\u0430 \u0447\u0430\u0441\u043E\u043C).";
          }
          break;
        }
        case "getWeatherTomorrow": {
          const tomorrowForecast = forecastData.find((item) => {
            const itemDate = new Date(item.dt * 1e3);
            return itemDate.toDateString() === tomorrow.toDateString();
          });
          if (tomorrowForecast) {
            const date = new Date(tomorrowForecast.dt * 1e3);
            const formattedDate = date.toLocaleDateString("uk-UA", dateOptions);
            const formattedTime = date.toLocaleTimeString("uk-UA", timeOptions);
            result += `\u0417\u0430\u0432\u0442\u0440\u0430 (${formattedDate}, ${formattedTime}): ${tomorrowForecast.weather[0].description}, \u0422\u0435\u043C\u043F\u0435\u0440\u0430\u0442\u0443\u0440\u0430: ${tomorrowForecast.main.temp}\xB0C, \u0412\u0456\u0434\u0447\u0443\u0432\u0430\u0454\u0442\u044C\u0441\u044F \u044F\u043A: ${tomorrowForecast.main.feels_like}\xB0C, \u0412\u043E\u043B\u043E\u0433\u0456\u0441\u0442\u044C: ${tomorrowForecast.main.humidity}%.`;
          } else {
            result += "\u041D\u0435 \u0432\u0434\u0430\u043B\u043E\u0441\u044F \u0437\u043D\u0430\u0439\u0442\u0438 \u043F\u0440\u043E\u0433\u043D\u043E\u0437 \u043D\u0430 \u0437\u0430\u0432\u0442\u0440\u0430. API \u043C\u043E\u0436\u0435 \u043D\u0435 \u043D\u0430\u0434\u0430\u0432\u0430\u0442\u0438 \u0434\u0430\u043D\u0456 \u0442\u0430\u043A \u0434\u0430\u043B\u0435\u043A\u043E \u0432\u043F\u0435\u0440\u0435\u0434 \u0430\u0431\u043E \u0434\u043B\u044F \u0446\u044C\u043E\u0433\u043E \u043C\u0456\u0441\u0442\u0430.";
          }
          break;
        }
        case "getWeather5Days": {
          const dailyForecasts = {};
          const processedDays = /* @__PURE__ */ new Set();
          const now2 = new Date();
          let daysCount = 0;
          const maxDays = 5;
          for (const item of forecastData) {
            const itemDate = new Date(item.dt * 1e3);
            const dayKey = itemDate.toDateString();
            if (itemDate.getTime() < now2.getTime() && dayKey === now2.toDateString() && processedDays.has(dayKey)) {
              continue;
            }
            if (!processedDays.has(dayKey)) {
              if (dayKey === now2.toDateString() && itemDate.getTime() < now2.getTime() && !Object.values(dailyForecasts).some((df) => new Date(df.dt * 1e3).toDateString() === dayKey)) {
              } else if (dayKey === now2.toDateString() && itemDate.getTime() < now2.getTime()) {
                continue;
              }
              dailyForecasts[dayKey] = item;
              processedDays.add(dayKey);
              daysCount++;
            }
            if (daysCount >= maxDays) {
              break;
            }
          }
          if (Object.keys(dailyForecasts).length > 0) {
            const sortedDays = Object.keys(dailyForecasts).sort((a, b) => new Date(a).getTime() - new Date(b).getTime());
            for (const dayKey of sortedDays) {
              const item = dailyForecasts[dayKey];
              const date = new Date(item.dt * 1e3);
              const formattedDate = date.toLocaleDateString("uk-UA", dateOptions);
              const dayOfWeek = date.toLocaleDateString("uk-UA", dayOfWeekOptions);
              result += `- ${dayOfWeek}, ${formattedDate}: ${item.weather[0].description}, \u0422\u0435\u043C\u043F.: ${item.main.temp}\xB0C, \u0412\u043E\u043B\u043E\u0433.: ${item.main.humidity}%
`;
            }
          } else {
            result += "\u041D\u0435 \u0432\u0434\u0430\u043B\u043E\u0441\u044F \u043E\u0442\u0440\u0438\u043C\u0430\u0442\u0438 \u043F\u0440\u043E\u0433\u043D\u043E\u0437 \u043D\u0430 5 \u0434\u043D\u0456\u0432.";
          }
          break;
        }
        default:
          return `\u041F\u043E\u043C\u0438\u043B\u043A\u0430: \u041D\u0435\u0432\u0456\u0434\u043E\u043C\u0438\u0439 \u0456\u043D\u0441\u0442\u0440\u0443\u043C\u0435\u043D\u0442 "${toolName}" \u0434\u043B\u044F WeatherAgent.`;
      }
      return result;
    } catch (e) {
      plugin.logger.error(`[WeatherAgent] \u041F\u043E\u043C\u0438\u043B\u043A\u0430 \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043D\u044F \u043F\u043E\u0433\u043E\u0434\u0438 \u0434\u043B\u044F ${locationToUse}:`, e);
      return `\u041F\u043E\u043C\u0438\u043B\u043A\u0430 \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043D\u044F \u043F\u043E\u0433\u043E\u0434\u0438 \u0434\u043B\u044F "${locationToUse}": ${e.message}`;
    }
  }
};

// src/agents/AgentManager.ts
var AgentManager = class {
  constructor(plugin) {
    this.agents = /* @__PURE__ */ new Map();
    this.plugin = plugin;
    this.registerDefaultAgents();
  }
  registerDefaultAgents() {
    const fileAgent = new SimpleFileAgent();
    this.registerAgent(fileAgent);
    const weatherAgent = new WeatherAgent();
    this.registerAgent(weatherAgent);
  }
  registerAgent(agent) {
    if (this.agents.has(agent.id)) {
    }
    this.agents.set(agent.id, agent);
  }
  getAgent(id) {
    return this.agents.get(id);
  }
  /**
   * Збирає визначення всіх інструментів від усіх зареєстрованих агентів.
   */
  getAllToolDefinitions() {
    let allTools = [];
    this.agents.forEach((agent) => {
      try {
        const agentTools = agent.getTools();
        if (Array.isArray(agentTools)) {
          allTools = allTools.concat(agentTools);
        } else {
        }
      } catch (error) {
      }
    });
    const toolNames = /* @__PURE__ */ new Set();
    const uniqueTools = allTools.filter((tool) => {
      if (toolNames.has(tool.name)) {
        return false;
      }
      toolNames.add(tool.name);
      return true;
    });
    return uniqueTools;
  }
  /**
   * Виконує інструмент, знаходячи відповідний агент.
   * @param toolName Назва інструменту.
   * @param args Аргументи для інструменту (вже розпарсені з JSON-рядка).
   */
  async executeTool(toolName, args) {
    for (const agent of this.agents.values()) {
      const agentTool = agent.getTools().find((t) => t.name === toolName);
      if (agentTool) {
        try {
          const result = await agent.executeTool(toolName, args, this.plugin);
          return { success: true, result: typeof result === "string" ? result : JSON.stringify(result) };
        } catch (e) {
          return { success: false, result: "", error: e.message || "Unknown error during tool execution." };
        }
      }
    }
    return { success: false, result: "", error: `Tool "${toolName}" not found.` };
  }
};

// src/main.ts
var SESSIONS_INDEX_KEY = "chatIndex_v2";
var ACTIVE_CHAT_ID_KEY = "activeChatId_v2";
var CHAT_INDEX_KEY = "chatIndex_v2";
var OllamaPlugin2 = class extends import_obsidian23.Plugin {
  constructor() {
    super(...arguments);
    this.view = null;
    this.eventHandlers = {};
    this.roleListCache = null;
    this.roleCacheClearTimeout = null;
    this.indexUpdateTimeout = null;
    this.dailyTaskFilePath = null;
    this.taskFileContentCache = null;
    this.taskFileNeedsUpdate = false;
    this.taskCheckInterval = null;
    // Debounced функція оновлення для Vault Events
    this.debouncedIndexAndUIRebuild = (0, import_obsidian23.debounce)(
      async () => {
        if (this.chatManager) {
          await this.chatManager.rebuildIndexFromFiles();
        }
      },
      1500,
      true
    );
  }
  // --- Event Emitter Methods ---
  on(event, callback) {
    if (!this.eventHandlers[event])
      this.eventHandlers[event] = [];
    this.eventHandlers[event].push(callback);
    return () => {
      var _a, _b;
      this.eventHandlers[event] = (_a = this.eventHandlers[event]) == null ? void 0 : _a.filter((h) => h !== callback);
      if (((_b = this.eventHandlers[event]) == null ? void 0 : _b.length) === 0) {
        delete this.eventHandlers[event];
      }
    };
  }
  emit(event, data) {
    const handlers = this.eventHandlers[event];
    if (handlers) {
      handlers.slice().forEach((handler) => {
        try {
          handler(data);
        } catch (e) {
        }
      });
    }
  }
  // --------------------------
  isTaskFileUpdated() {
    return this.taskFileNeedsUpdate;
  }
  // src/main.ts
  async onload() {
    const initialSettingsData = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    const loggerSettings = {
      // Визначаємо рівень логування для консолі залежно від середовища
      consoleLogLevel: true ? initialSettingsData.consoleLogLevel || "INFO" : "DEBUG",
      fileLoggingEnabled: initialSettingsData.fileLoggingEnabled,
      fileLogLevel: initialSettingsData.fileLogLevel,
      logCallerInfo: initialSettingsData.logCallerInfo,
      logFilePath: initialSettingsData.logFilePath,
      logFileMaxSizeMB: initialSettingsData.logFileMaxSizeMB
    };
    this.logger = new Logger(this, loggerSettings);
    await this.loadSettingsAndMigrate();
    this.promptService = new PromptService(this);
    this.ollamaService = new OllamaService(this);
    this.translationService = new TranslationService(this);
    this.ragService = new RagService(this);
    this.chatManager = new ChatManager(this);
    this.agentManager = new AgentManager(this);
    this.agentManager.registerAgent(new SimpleFileAgent());
    await this.chatManager.initialize();
    this.logger.updateSettings({
      consoleLogLevel: this.settings.consoleLogLevel,
      fileLoggingEnabled: this.settings.fileLoggingEnabled,
      fileLogLevel: this.settings.fileLogLevel,
      logCallerInfo: this.settings.logCallerInfo,
      logFilePath: this.settings.logFilePath,
      logFileMaxSizeMB: this.settings.logFileMaxSizeMB
    });
    this.registerView(VIEW_TYPE_OLLAMA_PERSONAS, (leaf) => {
      this.view = new OllamaView(leaf, this);
      return this.view;
    });
    this.ollamaService.on("connection-error", (error) => {
      this.emit("ollama-connection-error", error.message || "Unknown connection error");
    });
    this.register(
      this.on("ollama-connection-error", async (message) => {
        if (this.chatManager) {
          await this.chatManager.addMessageToActiveChat("error", `Ollama Connection Error: ${message}`, new Date());
        } else {
          new import_obsidian23.Notice(`Ollama Connection Error: ${message}`);
        }
      })
    );
    this.register(this.on("active-chat-changed", this.handleActiveChatChangedLocally.bind(this)));
    this.register(
      this.on("settings-updated", () => {
        var _a, _b, _c, _d;
        this.logger.updateSettings({
          consoleLogLevel: this.settings.consoleLogLevel,
          fileLoggingEnabled: this.settings.fileLoggingEnabled,
          fileLogLevel: this.settings.fileLogLevel,
          logCallerInfo: this.settings.logCallerInfo,
          logFilePath: this.settings.logFilePath,
          logFileMaxSizeMB: this.settings.logFileMaxSizeMB
        });
        this.updateDailyTaskFilePath();
        this.loadAndProcessInitialTasks();
        this.updateOllamaServiceConfig();
        this.roleListCache = null;
        (_b = (_a = this.promptService) == null ? void 0 : _a.clearRoleCache) == null ? void 0 : _b.call(_a);
        this.emit("roles-updated");
        (_d = (_c = this.view) == null ? void 0 : _c.handleSettingsUpdated) == null ? void 0 : _d.call(_c);
      })
    );
    this.addRibbonIcon("brain-circuit", "Open AI Forge Chat", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-chat-view",
      name: "Open AI Forge Chat",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "index-rag-documents",
      name: "AI Forge: Index documents for RAG",
      callback: async () => {
        if (this.settings.ragEnabled) {
          await this.ragService.indexDocuments();
        } else {
          new import_obsidian23.Notice("RAG is disabled in settings.");
        }
      }
    });
    this.addCommand({
      id: "clear-active-chat-history",
      name: "AI Forge: Clear Active Chat History",
      callback: async () => {
        await this.clearMessageHistoryWithConfirmation();
      }
    });
    this.addCommand({
      id: "refresh-roles",
      name: "AI Forge: Refresh Roles List",
      callback: async () => {
        await this.listRoleFiles(true);
        this.emit("roles-updated");
        new import_obsidian23.Notice("Role list refreshed.");
      }
    });
    this.addCommand({
      id: "new-chat",
      name: "AI Forge: New Chat",
      callback: async () => {
        const newChat = await this.chatManager.createNewChat();
        if (newChat) {
          new import_obsidian23.Notice(`Created new chat: ${newChat.metadata.name}`);
        } else {
          new import_obsidian23.Notice("Failed to create new chat.");
        }
      }
    });
    this.addCommand({
      id: "switch-chat",
      name: "AI Forge: Switch Chat",
      callback: async () => {
        await this.showChatSwitcher();
      }
    });
    this.addCommand({
      id: "rename-active-chat",
      name: "AI Forge: Rename Active Chat",
      callback: async () => {
        await this.renameActiveChat();
      }
    });
    this.addCommand({
      id: "delete-active-chat",
      name: "AI Forge: Delete Active Chat",
      callback: async () => {
        await this.deleteActiveChatWithConfirmation();
      }
    });
    this.settingTab = new OllamaSettingTab(this.app, this);
    this.addSettingTab(this.settingTab);
    this.app.workspace.onLayoutReady(async () => {
      if (this.settings.ragEnabled && this.settings.ragAutoIndexOnStartup) {
        setTimeout(() => {
          var _a;
          (_a = this.ragService) == null ? void 0 : _a.indexDocuments();
        }, 5e3);
      }
    });
    this.registerVaultListeners();
    const debouncedRoleClear = (0, import_obsidian23.debounce)(() => {
      var _a, _b;
      this.roleListCache = null;
      (_b = (_a = this.promptService) == null ? void 0 : _a.clearRoleCache) == null ? void 0 : _b.call(_a);
      this.emit("roles-updated");
    }, 1500, true);
    const handleModifyEvent = (file) => {
      if (file instanceof import_obsidian23.TFile) {
        this.handleRoleOrRagFileChange(file.path, debouncedRoleClear, false);
        this.handleTaskFileModify(file);
      }
    };
    const handleDeleteEvent = (file) => {
      var _a;
      this.handleRoleOrRagFileChange(file.path, debouncedRoleClear, true);
      if (this.settings.enableProductivityFeatures && file.path === this.dailyTaskFilePath) {
        this.dailyTaskFilePath = null;
        this.taskFileContentCache = null;
        this.taskFileNeedsUpdate = false;
        (_a = this.chatManager) == null ? void 0 : _a.updateTaskState(null);
      }
    };
    const handleRenameEvent = (file, oldPath) => {
      this.handleRoleOrRagFileChange(file.path, debouncedRoleClear, false);
      this.handleRoleOrRagFileChange(oldPath, debouncedRoleClear, true);
      if (this.settings.enableProductivityFeatures) {
        if (oldPath === this.dailyTaskFilePath) {
          this.updateDailyTaskFilePath();
          this.loadAndProcessInitialTasks();
        } else if (file.path === this.dailyTaskFilePath) {
          this.taskFileNeedsUpdate = true;
          this.checkAndProcessTaskUpdate();
        }
      }
    };
    const handleCreateEvent = (file) => {
      this.handleRoleOrRagFileChange(file.path, debouncedRoleClear, false);
      if (this.settings.enableProductivityFeatures && file.path === this.dailyTaskFilePath) {
        this.taskFileNeedsUpdate = true;
        this.checkAndProcessTaskUpdate();
      }
    };
    this.registerEvent(this.app.vault.on("modify", handleModifyEvent));
    this.registerEvent(this.app.vault.on("delete", handleDeleteEvent));
    this.registerEvent(this.app.vault.on("rename", handleRenameEvent));
    this.registerEvent(this.app.vault.on("create", handleCreateEvent));
    this.updateDailyTaskFilePath();
    await this.loadAndProcessInitialTasks();
    if (this.settings.enableProductivityFeatures) {
      this.taskCheckInterval = setInterval(() => this.checkAndProcessTaskUpdate(), 5e3);
      this.registerInterval(this.taskCheckInterval);
    }
  }
  // --- кінець onload ---
  registerVaultListeners() {
    const handleFileCreateDelete = (file) => {
      if (!file || !this.chatManager || !this.settings.chatHistoryFolderPath)
        return;
      const historyPath = (0, import_obsidian23.normalizePath)(this.settings.chatHistoryFolderPath);
      if (file.path.startsWith(historyPath + "/") && (file.path.toLowerCase().endsWith(".json") || file instanceof import_obsidian23.TFolder)) {
        this.debouncedIndexAndUIRebuild();
      }
    };
    const handleFileRename = (file, oldPath) => {
      if (!file || !this.chatManager || !this.settings.chatHistoryFolderPath)
        return;
      const historyPath = (0, import_obsidian23.normalizePath)(this.settings.chatHistoryFolderPath);
      const isInHistoryNew = file.path.startsWith(historyPath + "/");
      const isInHistoryOld = oldPath.startsWith(historyPath + "/");
      if ((isInHistoryNew || isInHistoryOld) && file.path !== historyPath && oldPath !== historyPath) {
        this.debouncedIndexAndUIRebuild();
      }
    };
    this.registerEvent(this.app.vault.on("create", handleFileCreateDelete));
    this.registerEvent(this.app.vault.on("delete", handleFileCreateDelete));
    this.registerEvent(this.app.vault.on("rename", handleFileRename));
  }
  // --- Логіка файлу завдань ---
  updateDailyTaskFilePath() {
    var _a, _b, _c;
    const folderPath = (_a = this.settings.ragFolderPath) == null ? void 0 : _a.trim();
    const fileName = (_b = this.settings.dailyTaskFileName) == null ? void 0 : _b.trim();
    const newPath = folderPath && fileName ? (0, import_obsidian23.normalizePath)(`${folderPath}/${fileName}`) : null;
    if (newPath !== this.dailyTaskFilePath) {
      this.dailyTaskFilePath = newPath;
      this.taskFileContentCache = null;
      this.taskFileNeedsUpdate = true;
    } else if (!newPath && this.dailyTaskFilePath !== null) {
      this.dailyTaskFilePath = null;
      this.taskFileContentCache = null;
      (_c = this.chatManager) == null ? void 0 : _c.updateTaskState(null);
      this.taskFileNeedsUpdate = false;
    }
  }
  handleTaskFileModify(file) {
    if (this.settings.enableProductivityFeatures && file.path === this.dailyTaskFilePath) {
      if (!this.taskFileNeedsUpdate) {
        this.taskFileNeedsUpdate = true;
      }
    }
  }
  async loadAndProcessInitialTasks() {
    var _a, _b, _c, _d;
    if (!this.settings.enableProductivityFeatures || !this.dailyTaskFilePath) {
      if (this.taskFileContentCache !== null) {
        this.taskFileContentCache = null;
        (_a = this.chatManager) == null ? void 0 : _a.updateTaskState(null);
      }
      this.taskFileNeedsUpdate = false;
      return;
    }
    try {
      const fileExists = await this.app.vault.adapter.exists(this.dailyTaskFilePath);
      if (fileExists) {
        const content = await this.app.vault.adapter.read(this.dailyTaskFilePath);
        if (content !== this.taskFileContentCache || this.taskFileContentCache === null) {
          this.taskFileContentCache = content;
          const tasks = this.parseTasks(content);
          (_b = this.chatManager) == null ? void 0 : _b.updateTaskState(tasks);
          this.taskFileNeedsUpdate = false;
        } else {
          this.taskFileNeedsUpdate = false;
        }
      } else {
        if (this.taskFileContentCache !== null) {
          this.taskFileContentCache = null;
          (_c = this.chatManager) == null ? void 0 : _c.updateTaskState(null);
        }
        this.taskFileNeedsUpdate = false;
      }
    } catch (error) {
      if (this.taskFileContentCache !== null) {
        this.taskFileContentCache = null;
        (_d = this.chatManager) == null ? void 0 : _d.updateTaskState(null);
      }
      this.taskFileNeedsUpdate = false;
    }
  }
  parseTasks(content) {
    const lines = content.split("\n");
    const urgent = [];
    const regular = [];
    let hasContent = false;
    for (const line of lines) {
      const trimmedLine = line.trim();
      if (!trimmedLine)
        continue;
      hasContent = true;
      if (trimmedLine.startsWith("- [x]") || trimmedLine.startsWith("- [X]"))
        continue;
      let taskText = trimmedLine;
      let isUrgent = false;
      if (taskText.startsWith("!") || taskText.toLowerCase().includes("[urgent]")) {
        isUrgent = true;
        taskText = taskText.replace(/^!/, "").replace(/\[urgent\]/i, "").trim();
      }
      if (taskText.startsWith("- [ ]")) {
        taskText = taskText.substring(taskText.indexOf("]") + 1).trim();
      } else if (taskText.startsWith("- ")) {
        taskText = taskText.substring(1).trim();
      }
      if (taskText.length > 0) {
        if (isUrgent) {
          urgent.push(taskText);
        } else {
          regular.push(taskText);
        }
      }
    }
    const hasActualTasks = urgent.length > 0 || regular.length > 0;
    return { urgent, regular, hasContent: hasActualTasks };
  }
  async checkAndProcessTaskUpdate() {
    if (this.taskFileNeedsUpdate && this.settings.enableProductivityFeatures) {
      await this.loadAndProcessInitialTasks();
    } else {
    }
  }
  // --- Кінець логіки файлу завдань ---
  // Обробник змін для ролей та RAG
  handleRoleOrRagFileChange(changedPath, debouncedRoleClear, isDeletion = false) {
    const normPath = (0, import_obsidian23.normalizePath)(changedPath);
    const userRolesPath = this.settings.userRolesFolderPath ? (0, import_obsidian23.normalizePath)(this.settings.userRolesFolderPath) : null;
    const builtInRolesPath = this.manifest.dir ? (0, import_obsidian23.normalizePath)(`${this.manifest.dir}/roles`) : null;
    let isRoleFile = false;
    if (normPath.toLowerCase().endsWith(".md")) {
      if (userRolesPath && normPath.startsWith(userRolesPath + "/")) {
        if (normPath.substring(userRolesPath.length + 1).indexOf("/") === -1) {
          isRoleFile = true;
        }
      } else if (builtInRolesPath && normPath.startsWith(builtInRolesPath + "/")) {
        if (normPath.substring(builtInRolesPath.length + 1).indexOf("/") === -1) {
          isRoleFile = true;
        }
      }
    }
    if (userRolesPath && normPath === userRolesPath) {
      isRoleFile = true;
    }
    if (isRoleFile) {
      debouncedRoleClear();
    }
    const ragFolderPath = this.settings.ragFolderPath ? (0, import_obsidian23.normalizePath)(this.settings.ragFolderPath) : null;
    if (this.settings.ragEnabled && ragFolderPath && (normPath.startsWith(ragFolderPath + "/") || normPath === ragFolderPath)) {
      if (normPath !== this.dailyTaskFilePath) {
        this.debounceIndexUpdate();
      } else {
      }
    }
  }
  async onunload() {
    this.app.workspace.getLeavesOfType(VIEW_TYPE_OLLAMA_PERSONAS).forEach((l) => l.detach());
    this.view = null;
    if (this.indexUpdateTimeout)
      clearTimeout(this.indexUpdateTimeout);
    if (this.roleCacheClearTimeout)
      clearTimeout(this.roleCacheClearTimeout);
    if (this.taskCheckInterval)
      clearInterval(this.taskCheckInterval);
    this.eventHandlers = {};
    try {
      if (this.chatManager && this.settings.saveMessageHistory) {
        const lastActiveId = this.chatManager.getActiveChatId();
        if (lastActiveId !== void 0 && lastActiveId !== null) {
          await this.saveDataKey(ACTIVE_CHAT_ID_KEY, lastActiveId);
        } else {
          await this.saveDataKey(ACTIVE_CHAT_ID_KEY, null);
        }
      } else {
        await this.saveDataKey(ACTIVE_CHAT_ID_KEY, null);
      }
    } catch (error) {
    }
  }
  updateOllamaServiceConfig() {
    var _a;
    if (this.ollamaService) {
      (_a = this.promptService) == null ? void 0 : _a.clearModelDetailsCache();
    }
  }
  debounceIndexUpdate() {
    if (this.indexUpdateTimeout)
      clearTimeout(this.indexUpdateTimeout);
    this.indexUpdateTimeout = setTimeout(async () => {
      if (this.settings.ragEnabled && this.ragService) {
        await this.ragService.indexDocuments();
      } else {
      }
      this.indexUpdateTimeout = null;
    }, 3e4);
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const viewType = VIEW_TYPE_OLLAMA_PERSONAS;
    const existingLeaves = workspace.getLeavesOfType(viewType);
    if (existingLeaves.length > 0) {
      leaf = existingLeaves[0];
    } else {
      if (this.settings.openChatInTab) {
        leaf = workspace.getLeaf("tab");
      } else {
        leaf = workspace.getRightLeaf(false);
        if (!leaf) {
          leaf = workspace.getLeaf("tab");
        } else {
        }
      }
      if (leaf) {
        try {
          await leaf.setViewState({ type: viewType, active: true });
        } catch (e) {
          new import_obsidian23.Notice("Error opening AI Forge view.");
          return;
        }
      } else {
        new import_obsidian23.Notice("Could not open AI Forge view.");
        return;
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
      setTimeout(() => {
        if (leaf && leaf.view instanceof OllamaView) {
          this.view = leaf.view;
          this.emit("focus-input-request");
        } else {
          this.view = null;
        }
      }, 50);
    }
  }
  async loadSettingsAndMigrate() {
    const loadedData = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS, loadedData);
    this.updateOllamaServiceConfig();
    this.updateDailyTaskFilePath();
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.emit("settings-updated");
  }
  async saveDataKey(key, value) {
    try {
      const data = await this.loadData() || {};
      data[key] = value;
      await this.saveData(data);
    } catch (error) {
    }
  }
  async loadDataKey(key) {
    try {
      const data = await this.loadData() || {};
      const value = data[key];
      return value;
    } catch (error) {
      return void 0;
    }
  }
  async clearMessageHistoryWithConfirmation() {
    if (!this.chatManager) {
      new import_obsidian23.Notice("Error: Chat Manager not ready.");
      return;
    }
    const activeChat = await this.chatManager.getActiveChat();
    if (activeChat && activeChat.messages.length > 0) {
      new ConfirmModal(this.app, "Clear History", `Clear messages in "${activeChat.metadata.name}"?`, async () => {
        await this.chatManager.clearActiveChatMessages();
        new import_obsidian23.Notice(`History cleared for "${activeChat.metadata.name}".`);
      }).open();
    } else if (activeChat) {
      new import_obsidian23.Notice("Chat history is already empty.");
    } else {
      new import_obsidian23.Notice("No active chat to clear.");
    }
  }
  async listRoleFiles(forceRefresh = false) {
    if (this.roleListCache && !forceRefresh) {
      return this.roleListCache;
    }
    const roles = [];
    const addedNamesLowerCase = /* @__PURE__ */ new Set();
    const adapter = this.app.vault.adapter;
    const pluginDir = this.manifest.dir;
    const builtInRoleName = "Productivity Assistant";
    const builtInRoleFileName = "Productivity_Assistant.md";
    let builtInRolePath = null;
    if (pluginDir) {
      builtInRolePath = (0, import_obsidian23.normalizePath)(`${pluginDir}/roles/${builtInRoleFileName}`);
      try {
        if (await adapter.exists(builtInRolePath)) {
          const stat = await adapter.stat(builtInRolePath);
          if ((stat == null ? void 0 : stat.type) === "file") {
            roles.push({ name: builtInRoleName, path: builtInRolePath, isCustom: false });
            addedNamesLowerCase.add(builtInRoleName.toLowerCase());
          }
        }
      } catch (error) {
      }
    }
    const userRolesFolderPath = this.settings.userRolesFolderPath ? (0, import_obsidian23.normalizePath)(this.settings.userRolesFolderPath) : null;
    if (userRolesFolderPath && userRolesFolderPath !== "/") {
      try {
        const folderExists = await adapter.exists(userRolesFolderPath);
        const folderStat = folderExists ? await adapter.stat(userRolesFolderPath) : null;
        if ((folderStat == null ? void 0 : folderStat.type) === "folder") {
          const listResult = await adapter.list(userRolesFolderPath);
          for (const filePath of listResult.files) {
            if (filePath.toLowerCase().endsWith(".md") && filePath.substring(userRolesFolderPath.length + 1).indexOf("/") === -1 && filePath !== builtInRolePath) {
              const fileName = filePath.substring(filePath.lastIndexOf("/") + 1);
              const roleName = fileName.slice(0, -3);
              if (!addedNamesLowerCase.has(roleName.toLowerCase())) {
                roles.push({ name: roleName, path: filePath, isCustom: true });
                addedNamesLowerCase.add(roleName.toLowerCase());
              } else {
              }
            }
          }
        }
      } catch (e) {
      }
    }
    roles.sort((a, b) => a.name.localeCompare(b.name));
    this.roleListCache = roles;
    return roles;
  }
  async executeSystemCommand(command) {
    var _a;
    if (!(command == null ? void 0 : command.trim())) {
      return { stdout: "", stderr: "Empty command.", error: new Error("Empty command.") };
    }
    if (typeof process === "undefined" || !((_a = process == null ? void 0 : process.versions) == null ? void 0 : _a.node)) {
      new import_obsidian23.Notice("Cannot execute system command: Node.js environment is required.");
      return { stdout: "", stderr: "Node.js required.", error: new Error("Node.js required.") };
    }
    return new Promise((resolve) => {
      (0, import_child_process.exec)(command, (error, stdout, stderr) => {
        if (error) {
          if (stderr && stderr.trim())
            resolve({ stdout: stdout.toString(), stderr: stderr.toString(), error });
        }
      });
    });
  }
  async showChatSwitcher() {
    new import_obsidian23.Notice("Switch Chat UI not implemented yet.");
  }
  async renameActiveChat() {
    if (!this.chatManager) {
      new import_obsidian23.Notice("Error: Chat manager is not ready.");
      return;
    }
    const activeChat = await this.chatManager.getActiveChat();
    if (!activeChat) {
      new import_obsidian23.Notice("No active chat to rename.");
      return;
    }
    const currentName = activeChat.metadata.name;
    const chatId = activeChat.metadata.id;
    new PromptModal(this.app, "Rename Chat", `Enter new name for "${currentName}":`, currentName, async (newName) => {
      const trimmedName = newName == null ? void 0 : newName.trim();
      if (trimmedName && trimmedName !== "" && trimmedName !== currentName) {
        const success = await this.chatManager.renameChat(chatId, trimmedName);
        if (!success) {
        }
      } else if (newName === null || trimmedName === "") {
        new import_obsidian23.Notice("Rename cancelled or invalid name entered.");
      } else {
        new import_obsidian23.Notice("Name unchanged.");
      }
    }).open();
  }
  async deleteActiveChatWithConfirmation() {
    if (!this.chatManager) {
      new import_obsidian23.Notice("Error: Chat manager is not ready.");
      return;
    }
    const activeChat = await this.chatManager.getActiveChat();
    if (!activeChat) {
      new import_obsidian23.Notice("No active chat to delete.");
      return;
    }
    const chatName = activeChat.metadata.name;
    const chatId = activeChat.metadata.id;
    new ConfirmModal(
      this.app,
      "Delete Chat",
      `Are you sure you want to delete chat "${chatName}"?
This action cannot be undone.`,
      async () => {
        const success = await this.chatManager.deleteChat(chatId);
        if (!success) {
        }
      }
    ).open();
  }
  async handleActiveChatChangedLocally(data) {
    if (this.settings.saveMessageHistory) {
      await this.saveDataKey(ACTIVE_CHAT_ID_KEY, data.chatId);
    } else {
      await this.saveDataKey(ACTIVE_CHAT_ID_KEY, null);
    }
  }
  findRoleNameByPath(rolePath) {
    var _a;
    if (!rolePath)
      return "None";
    const cachedRole = (_a = this.roleListCache) == null ? void 0 : _a.find((rl) => rl.path === rolePath);
    if (cachedRole) {
      return cachedRole.name;
    }
    try {
      const fileName = rolePath.substring(rolePath.lastIndexOf("/") + 1);
      const roleName = fileName.endsWith(".md") ? fileName.slice(0, -3) : fileName;
      return roleName || "Unknown Role";
    } catch (e) {
      return "Unknown Role";
    }
  }
};
