/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => OllamaPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// ollamaView.ts
var import_obsidian2 = require("obsidian");

// messageService.ts
var import_obsidian = require("obsidian");
var MessageService = class {
  constructor(plugin) {
    this.view = null;
    this.messages = [];
    this.isProcessing = false;
    this.messagesPairCount = 0;
    this.plugin = plugin;
  }
  // Set the view reference
  setView(view) {
    this.view = view;
  }
  // Load message history from storage
  async loadMessageHistory() {
    if (!this.view)
      return;
    try {
      const history = await this.plugin.loadMessageHistory();
      if (Array.isArray(history) && history.length > 0) {
        this.messages = [];
        this.view.clearChatContainer();
        for (const msg of history) {
          const message = {
            ...msg,
            timestamp: new Date(msg.timestamp)
          };
          this.messages.push(message);
          this.renderMessage(message);
        }
        this.view.scrollToBottom();
        this.initializeThinkingBlocks();
      } else {
        this.view.showEmptyState();
      }
    } catch (error) {
      console.error("Error loading message history:", error);
      this.view.showEmptyState();
    }
  }
  // Save message history to storage
  async saveMessageHistory() {
    if (this.messages.length === 0)
      return;
    try {
      const serializedMessages = this.messages.map((msg) => ({
        role: msg.role,
        content: msg.content,
        timestamp: msg.timestamp.toISOString()
      }));
      await this.plugin.saveMessageHistory(JSON.stringify(serializedMessages));
    } catch (error) {
      console.error("Error saving message history:", error);
    }
  }
  // Send a message from the user to Ollama
  async sendMessage(content) {
    if (this.isProcessing || !content.trim() || !this.view)
      return;
    this.view.clearInputField();
    this.view.hideEmptyState();
    await this.processWithOllama(content);
  }
  // Add a message to the chat and render it
  addMessage(role, content) {
    const message = {
      role,
      content,
      timestamp: new Date()
    };
    this.messages.push(message);
    this.renderMessage(message);
    if (role === "assistant" /* ASSISTANT */ && this.messages.length >= 2) {
      if (this.messages[this.messages.length - 2].role === "user" /* USER */) {
        this.messagesPairCount++;
      }
    }
    this.saveMessageHistory();
    setTimeout(() => {
      if (this.view) {
        this.view.scrollToBottom();
      }
    }, 100);
  }
  // Reset the chat history
  clearChatMessages() {
    this.messages = [];
    if (this.view) {
      this.view.clearChatContainer();
      this.view.showEmptyState();
    }
  }
  // Render a message in the chat container
  renderMessage(message) {
    console.log(`messageService.ts -> renderMessage: this.view: ${this.view}`);
    if (!this.view)
      return;
    const isUser = message.role === "user" /* USER */;
    const isError = message.role === "error" /* ERROR */;
    const isSystem = message.role === "system" /* SYSTEM */;
    const isFirstInGroup = this.isFirstMessageInGroup(message);
    const isLastInGroup = this.isLastMessageInGroup(message);
    let messageGroup;
    const lastGroup = this.view.getChatContainer().lastElementChild;
    if (isFirstInGroup) {
      let groupClass = "message-group ";
      if (isUser) {
        groupClass += "user-message-group";
      } else if (isAssistant(message.role)) {
        groupClass += "ollama-message-group";
      } else if (isError) {
        groupClass += "error-message-group";
      } else if (isSystem) {
        groupClass += "system-message-group";
      }
      messageGroup = this.view.createGroupElement(groupClass);
    } else {
      messageGroup = lastGroup;
    }
    let messageClass = "message ";
    if (isUser) {
      messageClass += "user-message bubble user-bubble";
    } else if (isAssistant(message.role)) {
      messageClass += "ollama-message bubble ollama-bubble";
    } else if (isError) {
      messageClass += "error-message bubble error-bubble";
    } else if (isSystem) {
      messageClass += "system-message bubble system-bubble";
    }
    if (isLastInGroup) {
      if (isUser) {
        messageClass += " user-message-tail";
      } else if (isAssistant(message.role)) {
        messageClass += " ollama-message-tail";
      } else if (isError) {
        messageClass += " error-message-tail";
      } else if (isSystem) {
        messageClass += " system-message-tail";
      }
    }
    const messageEl = this.view.createMessageElement(messageGroup, messageClass);
    const contentContainer = this.view.createContentContainer(messageEl);
    const contentEl = this.view.createContentElement(contentContainer);
    if (isAssistant(message.role)) {
      const decodedContent = this.decodeHtmlEntities(message.content);
      const hasThinkingTags = message.content.includes("<think>") || decodedContent.includes("<think>");
      if (hasThinkingTags) {
        const contentToProcess = hasThinkingTags && !message.content.includes("<thing>") ? decodedContent : message.content;
        const processedContent = this.processThinkingTags(contentToProcess);
        contentEl.innerHTML = processedContent;
        this.addThinkingToggleListeners(contentEl);
      } else {
        this.renderMarkdown(message.content, contentEl);
      }
    } else if (isError) {
      const errorIconSpan = contentEl.createSpan({ cls: "error-icon" });
      (0, import_obsidian.setIcon)(errorIconSpan, "alert-triangle");
      const messageSpan = contentEl.createSpan({
        cls: "error-message-text",
        text: message.content
      });
    } else if (isSystem) {
      const infoIconSpan = contentEl.createSpan({ cls: "system-icon" });
      (0, import_obsidian.setIcon)(infoIconSpan, "info");
      const messageSpan = contentEl.createSpan({
        cls: "system-message-text",
        text: message.content
      });
    } else {
      message.content.split("\n").forEach((line, index, array) => {
        contentEl.createSpan({ text: line });
        if (index < array.length - 1) {
          contentEl.createEl("br");
        }
      });
    }
    if (!isSystem) {
      const copyButton = this.createCopyButton(contentContainer, message);
    }
    if (isLastInGroup) {
      messageEl.createDiv({
        cls: "message-timestamp",
        text: this.formatTime(message.timestamp)
      });
    }
  }
  // Create a copy button for the message
  createCopyButton(container, message) {
    const copyButton = container.createEl("button", {
      cls: "copy-button",
      attr: { title: "Copy message" }
    });
    (0, import_obsidian.setIcon)(copyButton, "copy");
    copyButton.addEventListener("click", () => {
      let textToCopy = message.content;
      if (isAssistant(message.role) && textToCopy.includes("<think>")) {
        textToCopy = textToCopy.replace(/<think>[\s\S]*?<\/think>/g, "");
      }
      navigator.clipboard.writeText(textToCopy);
      copyButton.setText("Copied!");
      setTimeout(() => {
        copyButton.empty();
        (0, import_obsidian.setIcon)(copyButton, "copy");
      }, 2e3);
    });
    return copyButton;
  }
  // Process request with Ollama
  async processWithOllama(content) {
    if (!this.view)
      return;
    this.isProcessing = true;
    const loadingMessageEl = this.view.addLoadingIndicator();
    setTimeout(async () => {
      var _a, _b;
      try {
        let useSystemPrompt = false;
        if (this.plugin.settings.followRole) {
          const systemPromptInterval = this.plugin.settings.systemPromptInterval || 0;
          if (systemPromptInterval === 0) {
            useSystemPrompt = true;
          } else if (systemPromptInterval > 0) {
            useSystemPrompt = this.messagesPairCount % systemPromptInterval === 0;
          }
        }
        const isNewConversation = this.messages.length <= 1;
        const formattedPrompt = await this.plugin.promptService.prepareFullPrompt(
          content,
          isNewConversation
        );
        const requestBody = {
          model: this.plugin.settings.modelName,
          prompt: formattedPrompt,
          stream: false,
          temperature: this.plugin.settings.temperature || 0.2,
          options: {
            num_ctx: this.plugin.settings.contextWindow || 8192
          }
        };
        if (useSystemPrompt) {
          const systemPrompt = this.plugin.promptService.getSystemPrompt();
          if (systemPrompt) {
            requestBody.system = systemPrompt;
          }
        }
        const data = await this.plugin.apiService.generateResponse(requestBody);
        (_a = this.view) == null ? void 0 : _a.removeLoadingIndicator(loadingMessageEl);
        this.addMessage("assistant" /* ASSISTANT */, data.response);
        this.initializeThinkingBlocks();
      } catch (error) {
        console.error("Error processing request with Ollama:", error);
        (_b = this.view) == null ? void 0 : _b.removeLoadingIndicator(loadingMessageEl);
        const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
        this.addMessage(
          "error" /* ERROR */,
          `Connection error with Ollama: ${errorMessage}. Please check the settings and ensure the server is running.`
        );
      } finally {
        this.isProcessing = false;
      }
    }, 0);
  }
  addSystemMessage(content) {
    this.addMessage("system" /* SYSTEM */, content);
  }
  removeLoadingMessage(loadingMessageEl) {
    if (loadingMessageEl && loadingMessageEl.parentNode) {
      loadingMessageEl.parentNode.removeChild(loadingMessageEl);
    }
  }
  isFirstMessageInGroup(message) {
    const index = this.messages.indexOf(message);
    if (index === 0)
      return true;
    const prevMessage = this.messages[index - 1];
    return prevMessage.role !== message.role;
  }
  isLastMessageInGroup(message) {
    const index = this.messages.indexOf(message);
    if (index === this.messages.length - 1)
      return true;
    const nextMessage = this.messages[index + 1];
    return nextMessage.role !== message.role;
  }
  formatTime(date) {
    return date.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
  }
  decodeHtmlEntities(text) {
    const textArea = document.createElement("textarea");
    textArea.innerHTML = text;
    return textArea.value;
  }
  renderMarkdown(content, element) {
    if (!this.view)
      return;
    import_obsidian.MarkdownRenderer.renderMarkdown(content, element, "", this.view);
  }
  processThinkingTags(content) {
    if (!content.includes("<think>")) {
      return content;
    }
    const parts = [];
    let currentPosition = 0;
    const thinkingRegex = /<think>([\s\S]*?)<\/think>/g;
    let match;
    while ((match = thinkingRegex.exec(content)) !== null) {
      if (match.index > currentPosition) {
        const textBefore = content.substring(currentPosition, match.index);
        parts.push(this.markdownToHtml(textBefore));
      }
      const thinkingContent = match[1];
      const foldableHtml = `
          <div class="thinking-block">
            <div class="thinking-header" data-fold-state="expanded">
              <div class="thinking-toggle">\u25BC</div>
              <div class="thinking-title">Thinking</div>
            </div>
            <div class="thinking-content">${this.markdownToHtml(
        thinkingContent
      )}</div>
          </div>
        `;
      parts.push(foldableHtml);
      currentPosition = match.index + match[0].length;
    }
    if (currentPosition < content.length) {
      const textAfter = content.substring(currentPosition);
      parts.push(this.markdownToHtml(textAfter));
    }
    return parts.join("");
  }
  markdownToHtml(markdown) {
    if (!markdown || markdown.trim() === "" || !this.view)
      return "";
    const tempDiv = document.createElement("div");
    import_obsidian.MarkdownRenderer.renderMarkdown(markdown, tempDiv, "", this.view);
    return tempDiv.innerHTML;
  }
  addThinkingToggleListeners(contentEl) {
    const thinkingHeaders = contentEl.querySelectorAll(".thinking-header");
    thinkingHeaders.forEach((header) => {
      header.addEventListener("click", () => {
        const content = header.nextElementSibling;
        const toggleIcon = header.querySelector(
          ".thinking-toggle"
        );
        if (!content || !toggleIcon)
          return;
        const isFolded = header.getAttribute("data-fold-state") === "folded";
        if (isFolded) {
          content.style.display = "block";
          toggleIcon.textContent = "\u25BC";
          header.setAttribute("data-fold-state", "expanded");
        } else {
          content.style.display = "none";
          toggleIcon.textContent = "\u25BA";
          header.setAttribute("data-fold-state", "folded");
        }
      });
    });
  }
  initializeThinkingBlocks() {
    if (!this.view)
      return;
    setTimeout(() => {
      if (!this.view)
        return;
      const thinkingHeaders = this.view.getChatContainer().querySelectorAll(".thinking-header");
      thinkingHeaders.forEach((header) => {
        const content = header.nextElementSibling;
        const toggleIcon = header.querySelector(
          ".thinking-toggle"
        );
        if (!content || !toggleIcon)
          return;
        content.style.display = "none";
        toggleIcon.textContent = "\u25BA";
        header.setAttribute("data-fold-state", "folded");
      });
    }, 100);
  }
};
function isAssistant(role) {
  return role === "assistant" /* ASSISTANT */;
}

// ollamaView.ts
var VIEW_TYPE_OLLAMA = "ollama-chat-view";
var CSS_CLASS_CONTAINER = "ollama-container";
var CSS_CLASS_CHAT_CONTAINER = "ollama-chat-container";
var CSS_CLASS_INPUT_CONTAINER = "chat-input-container";
var CSS_CLASS_BUTTONS_CONTAINER = "buttons-container";
var CSS_CLASS_SEND_BUTTON = "send-button";
var CSS_CLASS_VOICE_BUTTON = "voice-button";
var CSS_CLASS_MENU_BUTTON = "menu-button";
var CSS_CLASS_MENU_DROPDOWN = "menu-dropdown";
var CSS_CLASS_MENU_OPTION = "menu-option";
var CSS_CLASS_SETTINGS_OPTION = "settings-option";
var CSS_CLASS_EMPTY_STATE = "ollama-empty-state";
var CSS_CLASS_MESSAGE_GROUP = "message-group";
var CSS_CLASS_USER_GROUP = "user-message-group";
var CSS_CLASS_OLLAMA_GROUP = "ollama-message-group";
var CSS_CLASS_MESSAGE = "message";
var CSS_CLASS_USER_MESSAGE = "user-message";
var CSS_CLASS_OLLAMA_MESSAGE = "ollama-message";
var CSS_CLASS_BUBBLE = "bubble";
var CSS_CLASS_USER_BUBBLE = "user-bubble";
var CSS_CLASS_OLLAMA_BUBBLE = "ollama-bubble";
var CSS_CLASS_TAIL_USER = "user-message-tail";
var CSS_CLASS_TAIL_OLLAMA = "ollama-message-tail";
var CSS_CLASS_CONTENT_CONTAINER = "message-content-container";
var CSS_CLASS_CONTENT = "message-content";
var CSS_CLASS_THINKING_DOTS = "thinking-dots";
var CSS_CLASS_THINKING_DOT = "thinking-dot";
var CSS_CLASS_THINKING_BLOCK = "thinking-block";
var CSS_CLASS_THINKING_HEADER = "thinking-header";
var CSS_CLASS_THINKING_TOGGLE = "thinking-toggle";
var CSS_CLASS_THINKING_TITLE = "thinking-title";
var CSS_CLASS_THINKING_CONTENT = "thinking-content";
var CSS_CLASS_TIMESTAMP = "message-timestamp";
var CSS_CLASS_COPY_BUTTON = "copy-button";
var CSS_CLASS_TEXTAREA_EXPANDED = "expanded";
var CSS_CLASS_BUTTONS_LOW = "low";
var CSS_CLASS_RECORDING = "recording";
var _OllamaView = class extends import_obsidian2.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    // Added for easier access
    // Use MessageService directly for messages if appropriate, or keep local copy
    // Assuming MessageService is the source of truth, potentially remove local `messages`
    // For this optimization, we'll keep the local `messages` array as the structure relies on it.
    this.messages = [];
    this.isProcessing = false;
    this.scrollTimeout = null;
    // Keep singleton pattern as is
    // Speech Recognition related
    this.speechWorker = null;
    // Initialize as null
    this.mediaRecorder = null;
    this.audioStream = null;
    // Store stream for cleanup
    this.messagesPairCount = 0;
    // Make readonly
    this.emptyStateEl = null;
    // Debounce/Throttle timers
    this.resizeTimeout = null;
    // --- Event Handlers ---
    this.handleKeyDown = (e) => {
      if (e.key === "Enter" && !e.shiftKey && !this.isProcessing) {
        e.preventDefault();
        this.sendMessage();
      }
    };
    this.handleSendClick = () => {
      if (!this.isProcessing) {
        this.sendMessage();
      }
    };
    this.handleVoiceClick = () => {
      this.toggleVoiceRecognition();
    };
    this.handleMenuClick = (e) => {
      e.stopPropagation();
      const isHidden = this.menuDropdown.style.display === "none";
      this.menuDropdown.style.display = isHidden ? "block" : "none";
    };
    this.handleSettingsClick = async () => {
      this.closeMenu();
      const setting = this.app.setting;
      if (setting) {
        await setting.open();
        setting.openTabById("obsidian-ollama-duet");
      } else {
        new import_obsidian2.Notice("Could not open settings.");
      }
    };
    this.handleDocumentClickForMenu = (e) => {
      if (this.menuDropdown.style.display === "block" && !this.menuButton.contains(e.target) && !this.menuDropdown.contains(e.target)) {
        this.closeMenu();
      }
    };
    this.handleModelChange = (modelName) => {
      this.updateInputPlaceholder(modelName);
      if (this.messages.length > 0) {
        this.messageService.addSystemMessage(`Model changed to: ${modelName}`);
      }
    };
    this.handleVisibilityChange = () => {
      if (document.visibilityState === "visible") {
        requestAnimationFrame(() => {
          this.guaranteedScrollToBottom(50);
          this.adjustTextareaHeight();
        });
      }
    };
    this.handleActiveLeafChange = () => {
      var _a;
      if (this.app.workspace.getActiveViewOfType(_OllamaView) === this) {
        setTimeout(() => this.guaranteedScrollToBottom(100), 100);
        (_a = this.inputEl) == null ? void 0 : _a.focus();
      }
    };
    // Debounced handlers for resize/input
    this.handleInputForResize = () => {
      if (this.resizeTimeout)
        clearTimeout(this.resizeTimeout);
      this.resizeTimeout = setTimeout(() => this.adjustTextareaHeight(), 50);
    };
    this.handleWindowResize = () => {
      if (this.resizeTimeout)
        clearTimeout(this.resizeTimeout);
      this.resizeTimeout = setTimeout(() => this.adjustTextareaHeight(), 100);
    };
    // Renamed from adjustHeight for clarity
    this.adjustTextareaHeight = () => {
      requestAnimationFrame(() => {
        if (!this.inputEl || !this.buttonsContainer)
          return;
        const viewHeight = this.contentEl.clientHeight;
        const maxHeight = Math.max(100, viewHeight * 0.6);
        this.inputEl.style.height = "auto";
        const scrollHeight = this.inputEl.scrollHeight;
        const newHeight = Math.min(scrollHeight, maxHeight);
        this.inputEl.style.height = `${newHeight}px`;
        if (newHeight > 45) {
          this.buttonsContainer.classList.add(CSS_CLASS_BUTTONS_LOW);
        } else {
          this.buttonsContainer.classList.remove(CSS_CLASS_BUTTONS_LOW);
        }
        this.inputEl.classList.toggle(CSS_CLASS_TEXTAREA_EXPANDED, scrollHeight > maxHeight);
      });
    };
    this.plugin = plugin;
    if (_OllamaView.instance && _OllamaView.instance !== this) {
      console.warn("Replacing existing OllamaView instance. This might indicate an issue if not intended.");
    }
    _OllamaView.instance = this;
    this.messageService = new MessageService(plugin);
    this.messageService.setView(this);
    if (this.plugin.apiService) {
      this.plugin.apiService.setOllamaView(this);
    }
    this.initSpeechWorker();
  }
  // --- Obsidian View Lifecycle Methods ---
  getViewType() {
    return VIEW_TYPE_OLLAMA;
  }
  getDisplayText() {
    return "Ollama Chat";
  }
  getIcon() {
    return "message-square";
  }
  async onOpen() {
    var _a, _b;
    this.createUIElements();
    this.updateInputPlaceholder(this.plugin.settings.modelName);
    this.attachEventListeners();
    this.autoResizeTextarea();
    await this.loadAndRenderHistory();
    (_a = this.inputEl) == null ? void 0 : _a.focus();
    this.guaranteedScrollToBottom(150);
    (_b = this.inputEl) == null ? void 0 : _b.dispatchEvent(new Event("input"));
  }
  // Cleanup resources when the view is closed
  async onClose() {
    console.log("OllamaView onClose: Cleaning up resources.");
    if (this.speechWorker) {
      this.speechWorker.terminate();
      this.speechWorker = null;
      console.log("Speech worker terminated.");
    }
    this.stopVoiceRecording(false);
    if (this.audioStream) {
      this.audioStream.getTracks().forEach((track) => track.stop());
      this.audioStream = null;
      console.log("Audio stream stopped.");
    }
    if (this.scrollTimeout)
      clearTimeout(this.scrollTimeout);
    if (this.resizeTimeout)
      clearTimeout(this.resizeTimeout);
    if (_OllamaView.instance === this) {
      _OllamaView.instance = null;
    }
  }
  // --- UI Creation and Management ---
  createUIElements() {
    this.contentEl.empty();
    this.chatContainerEl = this.contentEl.createDiv({ cls: CSS_CLASS_CONTAINER });
    this.chatContainer = this.chatContainerEl.createDiv({ cls: CSS_CLASS_CHAT_CONTAINER });
    const inputContainer = this.chatContainerEl.createDiv({ cls: CSS_CLASS_INPUT_CONTAINER });
    this.inputEl = inputContainer.createEl("textarea", {
      attr: { placeholder: `Text to ${this.plugin.settings.modelName}...` }
      // Initial placeholder
    });
    this.buttonsContainer = inputContainer.createDiv({ cls: CSS_CLASS_BUTTONS_CONTAINER });
    this.sendButton = this.buttonsContainer.createEl("button", { cls: CSS_CLASS_SEND_BUTTON });
    (0, import_obsidian2.setIcon)(this.sendButton, "send");
    this.voiceButton = this.buttonsContainer.createEl("button", { cls: CSS_CLASS_VOICE_BUTTON });
    (0, import_obsidian2.setIcon)(this.voiceButton, "microphone");
    this.menuButton = this.buttonsContainer.createEl("button", { cls: CSS_CLASS_MENU_BUTTON });
    (0, import_obsidian2.setIcon)(this.menuButton, "more-vertical");
    this.menuDropdown = inputContainer.createEl("div", { cls: CSS_CLASS_MENU_DROPDOWN });
    this.menuDropdown.style.display = "none";
    this.settingsOption = this.menuDropdown.createEl("div", { cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_SETTINGS_OPTION}` });
    const settingsIcon = this.settingsOption.createEl("span", { cls: "menu-option-icon" });
    (0, import_obsidian2.setIcon)(settingsIcon, "settings");
    this.settingsOption.createEl("span", { cls: "menu-option-text", text: "Settings" });
  }
  attachEventListeners() {
    this.inputEl.addEventListener("keydown", this.handleKeyDown);
    this.sendButton.addEventListener("click", this.handleSendClick);
    this.voiceButton.addEventListener("click", this.handleVoiceClick);
    this.menuButton.addEventListener("click", this.handleMenuClick);
    this.settingsOption.addEventListener("click", this.handleSettingsClick);
    this.inputEl.addEventListener("input", this.handleInputForResize);
    this.registerDomEvent(window, "resize", this.handleWindowResize);
    this.registerEvent(this.app.workspace.on("resize", this.handleWindowResize));
    this.registerDomEvent(document, "click", this.handleDocumentClickForMenu);
    this.register(this.plugin.on("model-changed", this.handleModelChange));
    this.registerDomEvent(document, "visibilitychange", this.handleVisibilityChange);
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", this.handleActiveLeafChange)
    );
  }
  // --- UI Update Methods ---
  updateInputPlaceholder(modelName) {
    if (this.inputEl) {
      this.inputEl.placeholder = `Text to ${modelName}...`;
    }
  }
  closeMenu() {
    if (this.menuDropdown) {
      this.menuDropdown.style.display = "none";
    }
  }
  autoResizeTextarea() {
    this.adjustTextareaHeight();
  }
  showEmptyState() {
    if (this.messages.length === 0 && !this.emptyStateEl && this.chatContainer) {
      this.chatContainer.empty();
      this.emptyStateEl = this.chatContainer.createDiv({ cls: CSS_CLASS_EMPTY_STATE });
      this.emptyStateEl.createDiv({ cls: "empty-state-message", text: "No messages yet" });
      this.emptyStateEl.createDiv({
        cls: "empty-state-tip",
        text: `Type a message or use voice input to chat with ${this.plugin.settings.modelName}`
      });
    }
  }
  hideEmptyState() {
    if (this.emptyStateEl) {
      this.emptyStateEl.remove();
      this.emptyStateEl = null;
    }
  }
  // --- Message Handling ---
  async loadAndRenderHistory() {
    try {
      await this.messageService.loadMessageHistory();
      if (this.messages.length === 0) {
        this.showEmptyState();
      } else {
        this.hideEmptyState();
      }
    } catch (error) {
      console.error("Error loading message history:", error);
      new import_obsidian2.Notice("Failed to load chat history.");
      this.showEmptyState();
    }
  }
  async saveMessageHistory() {
    if (this.messages.length === 0)
      return;
    try {
      const serializedMessages = this.messages.map((msg) => ({
        role: msg.role,
        content: msg.content,
        timestamp: msg.timestamp.toISOString()
        // ISO format is standard
      }));
      await this.plugin.saveMessageHistory(JSON.stringify(serializedMessages));
    } catch (error) {
      console.error("Error saving message history:", error);
      new import_obsidian2.Notice("Failed to save chat history.");
    }
  }
  // Centralized message sending logic
  async sendMessage() {
    const content = this.inputEl.value.trim();
    if (!content || this.isProcessing)
      return;
    this.isProcessing = true;
    this.hideEmptyState();
    const messageContent = this.inputEl.value;
    this.clearInputField();
    try {
      this.internalAddMessage("user", messageContent);
      await this.messageService.sendMessage(content);
    } catch (error) {
      console.error("Error sending message:", error);
      new import_obsidian2.Notice("Failed to send message. Please try again.");
      this.internalAddMessage("assistant", "Error: Could not send message.");
    } finally {
      this.isProcessing = false;
      this.inputEl.focus();
      this.adjustTextareaHeight();
    }
  }
  // Internal method to add message to local state and render
  // Called by sendMessage (user) and MessageService (assistant/system)
  internalAddMessage(role, content) {
    const message = {
      role,
      content,
      timestamp: new Date()
    };
    this.messages.push(message);
    if (role === "assistant" && this.messages.length >= 2) {
      const prevMessage = this.messages[this.messages.length - 2];
      if (prevMessage && prevMessage.role === "user") {
        this.messagesPairCount++;
      }
    }
    this.renderMessage(message);
    this.hideEmptyState();
    this.saveMessageHistory();
    const forceScroll = role === "assistant";
    this.guaranteedScrollToBottom(forceScroll ? 100 : 50, forceScroll);
  }
  // --- Rendering Logic ---
  // Combined logic to render any message type
  renderMessage(message) {
    const isUser = message.role === "user";
    const messageIndex = this.messages.indexOf(message);
    if (messageIndex === -1)
      return;
    const prevMessage = messageIndex > 0 ? this.messages[messageIndex - 1] : null;
    const nextMessage = messageIndex < this.messages.length - 1 ? this.messages[messageIndex + 1] : null;
    const isFirstInGroup = !prevMessage || prevMessage.role !== message.role;
    const isLastInGroup = !nextMessage || nextMessage.role !== message.role;
    let messageGroup;
    const lastGroup = this.chatContainer.lastElementChild;
    if (isFirstInGroup || !lastGroup || !lastGroup.classList.contains(isUser ? CSS_CLASS_USER_GROUP : CSS_CLASS_OLLAMA_GROUP)) {
      messageGroup = this.chatContainer.createDiv({
        cls: `${CSS_CLASS_MESSAGE_GROUP} ${isUser ? CSS_CLASS_USER_GROUP : CSS_CLASS_OLLAMA_GROUP}`
      });
    } else {
      messageGroup = lastGroup;
      const prevMessageEl = messageGroup.lastElementChild;
      if (prevMessageEl) {
        prevMessageEl.classList.remove(CSS_CLASS_TAIL_USER, CSS_CLASS_TAIL_OLLAMA);
      }
    }
    const messageEl = messageGroup.createDiv({
      cls: `${CSS_CLASS_MESSAGE} ${CSS_CLASS_BUBBLE} ${isUser ? CSS_CLASS_USER_MESSAGE + " " + CSS_CLASS_USER_BUBBLE : CSS_CLASS_OLLAMA_MESSAGE + " " + CSS_CLASS_OLLAMA_BUBBLE}`
    });
    if (isLastInGroup) {
      messageEl.classList.add(isUser ? CSS_CLASS_TAIL_USER : CSS_CLASS_TAIL_OLLAMA);
    }
    const contentContainer = messageEl.createDiv({ cls: CSS_CLASS_CONTENT_CONTAINER });
    const contentEl = contentContainer.createDiv({ cls: CSS_CLASS_CONTENT });
    if (message.role === "assistant") {
      this.renderAssistantContent(contentEl, message.content);
    } else {
      message.content.split("\n").forEach((line, index, array) => {
        contentEl.appendText(line);
        if (index < array.length - 1) {
          contentEl.createEl("br");
        }
      });
    }
    const copyButton = contentContainer.createEl("button", {
      cls: CSS_CLASS_COPY_BUTTON,
      attr: { title: "Copy" }
      // Use English or i18n
    });
    (0, import_obsidian2.setIcon)(copyButton, "copy");
    copyButton.addEventListener("click", () => this.handleCopyClick(message.content, copyButton));
    if (isLastInGroup) {
      messageEl.createDiv({
        cls: CSS_CLASS_TIMESTAMP,
        text: this.formatTime(message.timestamp)
      });
    }
  }
  renderAssistantContent(containerEl, content) {
    const decodedContent = this.decodeHtmlEntities(content);
    const hasThinking = this.detectThinkingTags(decodedContent);
    if (hasThinking.hasThinkingTags) {
      const processedHtml = this.processThinkingTags(decodedContent);
      containerEl.innerHTML = processedHtml;
      this.addThinkingToggleListeners(containerEl);
    } else {
      import_obsidian2.MarkdownRenderer.renderMarkdown(content, containerEl, this.plugin.app.vault.getRoot().path, this);
    }
  }
  handleCopyClick(content, buttonEl) {
    let textToCopy = content;
    if (this.detectThinkingTags(this.decodeHtmlEntities(content)).hasThinkingTags) {
      textToCopy = this.decodeHtmlEntities(content).replace(/<think>[\s\S]*?<\/think>/g, "").trim();
    }
    navigator.clipboard.writeText(textToCopy).then(() => {
      buttonEl.setText("Copied!");
      (0, import_obsidian2.setIcon)(buttonEl, "check");
      setTimeout(() => {
        buttonEl.setText("");
        (0, import_obsidian2.setIcon)(buttonEl, "copy");
      }, 2e3);
    }).catch((err) => {
      console.error("Failed to copy text: ", err);
      new import_obsidian2.Notice("Failed to copy text.");
    });
  }
  // --- Thinking Tag Processing ---
  processThinkingTags(content) {
    const thinkingRegex = /<think>([\s\S]*?)<\/think>/g;
    let lastIndex = 0;
    const parts = [];
    let match;
    while ((match = thinkingRegex.exec(content)) !== null) {
      if (match.index > lastIndex) {
        parts.push(this.markdownToHtml(content.substring(lastIndex, match.index)));
      }
      const thinkingContent = match[1];
      const foldableHtml = `
            <div class="${CSS_CLASS_THINKING_BLOCK}">
                <div class="${CSS_CLASS_THINKING_HEADER}" data-fold-state="folded">
                    <div class="${CSS_CLASS_THINKING_TOGGLE}">\u25BA</div>
                    <div class="${CSS_CLASS_THINKING_TITLE}">Thinking</div>
                </div>
                <div class="${CSS_CLASS_THINKING_CONTENT}" style="display: none;">
                    ${this.markdownToHtml(thinkingContent)}
                </div>
            </div>
        `;
      parts.push(foldableHtml);
      lastIndex = thinkingRegex.lastIndex;
    }
    if (lastIndex < content.length) {
      parts.push(this.markdownToHtml(content.substring(lastIndex)));
    }
    return parts.join("");
  }
  // Renders markdown to HTML (using Obsidian's renderer)
  markdownToHtml(markdown) {
    var _a, _b;
    if (!markdown || markdown.trim() === "")
      return "";
    const tempDiv = document.createElement("div");
    const contextFilePath = (_b = (_a = this.app.workspace.getActiveFile()) == null ? void 0 : _a.path) != null ? _b : "";
    import_obsidian2.MarkdownRenderer.renderMarkdown(markdown, tempDiv, contextFilePath, this);
    return tempDiv.innerHTML;
  }
  // Adds click listeners to thinking block headers
  addThinkingToggleListeners(contentEl) {
    const thinkingHeaders = contentEl.querySelectorAll(`.${CSS_CLASS_THINKING_HEADER}`);
    thinkingHeaders.forEach((header) => {
      header.addEventListener("click", () => {
        const content = header.nextElementSibling;
        const toggleIcon = header.querySelector(`.${CSS_CLASS_THINKING_TOGGLE}`);
        if (!content || !toggleIcon)
          return;
        const isFolded = header.getAttribute("data-fold-state") === "folded";
        if (isFolded) {
          content.style.display = "block";
          toggleIcon.textContent = "\u25BC";
          header.setAttribute("data-fold-state", "expanded");
        } else {
          content.style.display = "none";
          toggleIcon.textContent = "\u25BA";
          header.setAttribute("data-fold-state", "folded");
        }
      });
    });
  }
  // Utility to decode HTML entities (safer than innerHTML)
  decodeHtmlEntities(text) {
    if (typeof document === "undefined")
      return text;
    const textArea = document.createElement("textarea");
    textArea.innerHTML = text;
    return textArea.value;
  }
  // Detects if thinking tags are present (checks common variations)
  detectThinkingTags(content) {
    if (/<think>[\s\S]*?<\/think>/gi.test(content)) {
      return { hasThinkingTags: true, format: "standard" };
    }
    return { hasThinkingTags: false, format: "none" };
  }
  // --- Speech Recognition ---
  initSpeechWorker() {
    try {
      const bufferToBase64 = (buffer) => {
        let binary = "";
        const bytes = new Uint8Array(buffer);
        const len = bytes.byteLength;
        for (let i = 0; i < len; i++) {
          binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
      };
      const workerCode = `
        // Worker Scope
        self.onmessage = async (event) => {
          const { apiKey, audioBlob, languageCode = 'uk-UA' } = event.data;

          if (!apiKey || apiKey.trim() === '') {
            self.postMessage({ error: true, message: 'Google API Key is not configured. Please add it in plugin settings.' });
            return;
          }

          const url = "https://speech.googleapis.com/v1/speech:recognize?key=" + apiKey;

          try {
            const arrayBuffer = await audioBlob.arrayBuffer();

            // Optimized Base64 Conversion (using helper if needed, or direct if worker supports TextDecoder efficiently)
            // Simpler approach: pass buffer directly if API allows, or use efficient base64:
            let base64Audio;
            if (typeof TextDecoder !== 'undefined') { // Browser environment check
                 // Modern approach (often faster if native)
                 const base64String = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
                 base64Audio = base64String;

            } else {
                 // Fallback (similar to original, ensure correctness)
                 base64Audio = btoa(
                   new Uint8Array(arrayBuffer).reduce((data, byte) => data + String.fromCharCode(byte), '')
                 );
            }


            const response = await fetch(url, {
              method: 'POST',
              body: JSON.stringify({
                config: {
                  encoding: 'WEBM_OPUS', // Ensure this matches MediaRecorder output
                  sampleRateHertz: 48000, // Match sample rate if possible
                  languageCode: languageCode,
                  model: 'latest_long', // Consider other models if needed
                  enableAutomaticPunctuation: true,
                },
                audio: { content: base64Audio },
              }),
              headers: { 'Content-Type': 'application/json' },
            });

            const responseData = await response.json();

            if (!response.ok) {
              console.error("Google Speech API Error:", responseData);
              self.postMessage({
                error: true,
                message: "Error from Google Speech API: " + (responseData.error?.message || response.statusText || 'Unknown error')
              });
              return;
            }

            if (responseData.results && responseData.results.length > 0) {
              const transcript = responseData.results
                .map(result => result.alternatives[0].transcript)
                .join(' ')
                .trim();
              self.postMessage(transcript); // Send back only the transcript string
            } else {
               // Handle cases where API returns ok but no results (e.g., silence)
               self.postMessage({ error: true, message: 'No speech detected or recognized.' });
            }
          } catch (error) {
             console.error("Error in speech worker processing:", error);
             self.postMessage({
               error: true,
               message: 'Error processing speech recognition: ' + (error instanceof Error ? error.message : String(error))
             });
          }
        };
      `;
      const workerBlob = new Blob([workerCode], { type: "application/javascript" });
      const workerUrl = URL.createObjectURL(workerBlob);
      this.speechWorker = new Worker(workerUrl);
      URL.revokeObjectURL(workerUrl);
      this.setupSpeechWorkerHandlers();
      console.log("Speech worker initialized.");
    } catch (error) {
      console.error("Failed to initialize speech worker:", error);
      new import_obsidian2.Notice("Speech recognition feature failed to initialize.");
      this.speechWorker = null;
    }
  }
  setupSpeechWorkerHandlers() {
    if (!this.speechWorker)
      return;
    this.speechWorker.onmessage = (event) => {
      const data = event.data;
      if (data && typeof data === "object" && data.error) {
        console.error("Speech recognition error:", data.message);
        new import_obsidian2.Notice(`Speech Recognition Error: ${data.message}`);
        this.updateInputPlaceholder(this.plugin.settings.modelName);
        return;
      }
      if (typeof data === "string" && data.trim()) {
        const transcript = data.trim();
        this.insertTranscript(transcript);
      } else if (typeof data !== "string") {
        console.warn("Received unexpected data format from speech worker:", data);
      }
    };
    this.speechWorker.onerror = (error) => {
      console.error("Unhandled worker error:", error);
      new import_obsidian2.Notice("An unexpected error occurred in the speech recognition worker.");
      this.updateInputPlaceholder(this.plugin.settings.modelName);
      this.stopVoiceRecording(false);
    };
  }
  // Inserts recognized text into the input field
  insertTranscript(transcript) {
    var _a, _b;
    if (!this.inputEl)
      return;
    const currentVal = this.inputEl.value;
    const start = (_a = this.inputEl.selectionStart) != null ? _a : currentVal.length;
    const end = (_b = this.inputEl.selectionEnd) != null ? _b : currentVal.length;
    let textToInsert = transcript;
    const precedingChar = start > 0 ? currentVal[start - 1] : null;
    const followingChar = end < currentVal.length ? currentVal[end] : null;
    if (precedingChar && precedingChar !== " " && precedingChar !== "\n") {
      textToInsert = " " + textToInsert;
    }
    if (followingChar && followingChar !== " " && followingChar !== "\n" && !textToInsert.endsWith(" ")) {
      textToInsert += " ";
    }
    const newValue = currentVal.substring(0, start) + textToInsert + currentVal.substring(end);
    this.inputEl.value = newValue;
    const newCursorPos = start + textToInsert.length;
    this.inputEl.setSelectionRange(newCursorPos, newCursorPos);
    this.inputEl.focus();
    this.inputEl.dispatchEvent(new Event("input"));
  }
  // Toggles voice recording state
  async toggleVoiceRecognition() {
    if (this.mediaRecorder && this.mediaRecorder.state === "recording") {
      this.stopVoiceRecording(true);
    } else {
      await this.startVoiceRecognition();
    }
  }
  // Starts the voice recording process
  // Починає процес розпізнавання голосу
  async startVoiceRecognition() {
    var _a, _b, _c;
    if (!this.speechWorker) {
      new import_obsidian2.Notice("\u0424\u0443\u043D\u043A\u0446\u0456\u044F \u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u0432\u0430\u043D\u043D\u044F \u043C\u043E\u0432\u043B\u0435\u043D\u043D\u044F \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u0430 (worker \u043D\u0435 \u0456\u043D\u0456\u0446\u0456\u0430\u043B\u0456\u0437\u043E\u0432\u0430\u043D\u043E).");
      console.error("\u0421\u043F\u0440\u043E\u0431\u0430 \u0440\u043E\u0437\u043F\u043E\u0447\u0430\u0442\u0438 \u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u0432\u0430\u043D\u043D\u044F \u0433\u043E\u043B\u043E\u0441\u0443 \u0431\u0435\u0437 \u0456\u043D\u0456\u0446\u0456\u0430\u043B\u0456\u0437\u043E\u0432\u0430\u043D\u043E\u0433\u043E worker'\u0430.");
      return;
    }
    if (!this.plugin.settings.googleApiKey) {
      new import_obsidian2.Notice("\u041A\u043B\u044E\u0447 Google API \u043D\u0435 \u043D\u0430\u043B\u0430\u0448\u0442\u043E\u0432\u0430\u043D\u043E. \u0411\u0443\u0434\u044C \u043B\u0430\u0441\u043A\u0430, \u0434\u043E\u0434\u0430\u0439\u0442\u0435 \u0439\u043E\u0433\u043E \u0432 \u043D\u0430\u043B\u0430\u0448\u0442\u0443\u0432\u0430\u043D\u043D\u044F\u0445 \u043F\u043B\u0430\u0433\u0456\u043D\u0430 \u0434\u043B\u044F \u0432\u0438\u043A\u043E\u0440\u0438\u0441\u0442\u0430\u043D\u043D\u044F \u0433\u043E\u043B\u043E\u0441\u043E\u0432\u043E\u0433\u043E \u0432\u0432\u043E\u0434\u0443.");
      return;
    }
    try {
      this.audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      let recorderOptions;
      const preferredMimeType = "audio/webm;codecs=opus";
      if (MediaRecorder.isTypeSupported(preferredMimeType)) {
        console.log(`\u0412\u0438\u043A\u043E\u0440\u0438\u0441\u0442\u043E\u0432\u0443\u0454\u0442\u044C\u0441\u044F \u043F\u0456\u0434\u0442\u0440\u0438\u043C\u0443\u0432\u0430\u043D\u0438\u0439 mimeType: ${preferredMimeType}`);
        recorderOptions = { mimeType: preferredMimeType };
      } else {
        console.warn(`${preferredMimeType} \u043D\u0435 \u043F\u0456\u0434\u0442\u0440\u0438\u043C\u0443\u0454\u0442\u044C\u0441\u044F, \u0432\u0438\u043A\u043E\u0440\u0438\u0441\u0442\u043E\u0432\u0443\u0454\u0442\u044C\u0441\u044F \u0441\u0442\u0430\u043D\u0434\u0430\u0440\u0442\u043D\u0438\u0439 \u0431\u0440\u0430\u0443\u0437\u0435\u0440\u0430.`);
        recorderOptions = void 0;
      }
      this.mediaRecorder = new MediaRecorder(this.audioStream, recorderOptions);
      const audioChunks = [];
      (_a = this.voiceButton) == null ? void 0 : _a.classList.add(CSS_CLASS_RECORDING);
      (0, import_obsidian2.setIcon)(this.voiceButton, "stop-circle");
      this.inputEl.placeholder = "\u0417\u0430\u043F\u0438\u0441... \u0413\u043E\u0432\u043E\u0440\u0456\u0442\u044C \u0437\u0430\u0440\u0430\u0437.";
      this.mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          audioChunks.push(event.data);
        }
      };
      this.mediaRecorder.onstop = () => {
        var _a2;
        console.log("MediaRecorder \u0437\u0443\u043F\u0438\u043D\u0435\u043D\u043E.");
        if (this.speechWorker && audioChunks.length > 0) {
          const audioBlob = new Blob(audioChunks, { type: ((_a2 = this.mediaRecorder) == null ? void 0 : _a2.mimeType) || "audio/webm" });
          console.log(`\u0412\u0456\u0434\u043F\u0440\u0430\u0432\u043A\u0430 \u0430\u0443\u0434\u0456\u043E blob \u0434\u043E worker: type=${audioBlob.type}, size=${audioBlob.size}`);
          this.inputEl.placeholder = "\u041E\u0431\u0440\u043E\u0431\u043A\u0430 \u043C\u043E\u0432\u043B\u0435\u043D\u043D\u044F...";
          this.speechWorker.postMessage({
            apiKey: this.plugin.settings.googleApiKey,
            audioBlob,
            languageCode: this.plugin.settings.speechLanguage || "uk-UA"
            // Використати мову з налаштувань або українську за замовчуванням
          });
        } else if (audioChunks.length === 0) {
          console.log("\u0410\u0443\u0434\u0456\u043E\u0434\u0430\u043D\u0456 \u043D\u0435 \u0437\u0430\u043F\u0438\u0441\u0430\u043D\u043E.");
          this.updateInputPlaceholder(this.plugin.settings.modelName);
        }
      };
      this.mediaRecorder.onerror = (event) => {
        console.error("\u041F\u043E\u043C\u0438\u043B\u043A\u0430 MediaRecorder:", event);
        new import_obsidian2.Notice("\u041F\u0456\u0434 \u0447\u0430\u0441 \u0437\u0430\u043F\u0438\u0441\u0443 \u0441\u0442\u0430\u043B\u0430\u0441\u044F \u043F\u043E\u043C\u0438\u043B\u043A\u0430.");
        this.stopVoiceRecording(false);
      };
      this.mediaRecorder.start();
      console.log("\u0417\u0430\u043F\u0438\u0441 \u0440\u043E\u0437\u043F\u043E\u0447\u0430\u0442\u043E. MimeType:", (_c = (_b = this.mediaRecorder) == null ? void 0 : _b.mimeType) != null ? _c : "\u0441\u0442\u0430\u043D\u0434\u0430\u0440\u0442\u043D\u0438\u0439");
    } catch (error) {
      console.error("\u041F\u043E\u043C\u0438\u043B\u043A\u0430 \u0434\u043E\u0441\u0442\u0443\u043F\u0443 \u0434\u043E \u043C\u0456\u043A\u0440\u043E\u0444\u043E\u043D\u0430 \u0430\u0431\u043E \u0437\u0430\u043F\u0443\u0441\u043A\u0443 \u0437\u0430\u043F\u0438\u0441\u0443:", error);
      if (error instanceof DOMException && error.name === "NotAllowedError") {
        new import_obsidian2.Notice("\u0414\u043E\u0441\u0442\u0443\u043F \u0434\u043E \u043C\u0456\u043A\u0440\u043E\u0444\u043E\u043D\u0430 \u0437\u0430\u0431\u043E\u0440\u043E\u043D\u0435\u043D\u043E. \u0411\u0443\u0434\u044C \u043B\u0430\u0441\u043A\u0430, \u043D\u0430\u0434\u0430\u0439\u0442\u0435 \u0434\u043E\u0437\u0432\u0456\u043B \u0443 \u043D\u0430\u043B\u0430\u0448\u0442\u0443\u0432\u0430\u043D\u043D\u044F\u0445 \u0431\u0440\u0430\u0443\u0437\u0435\u0440\u0430/\u0441\u0438\u0441\u0442\u0435\u043C\u0438.");
      } else if (error instanceof DOMException && error.name === "NotFoundError") {
        new import_obsidian2.Notice("\u041C\u0456\u043A\u0440\u043E\u0444\u043E\u043D \u043D\u0435 \u0437\u043D\u0430\u0439\u0434\u0435\u043D\u043E. \u0411\u0443\u0434\u044C \u043B\u0430\u0441\u043A\u0430, \u043F\u0435\u0440\u0435\u043A\u043E\u043D\u0430\u0439\u0442\u0435\u0441\u044F, \u0449\u043E \u043C\u0456\u043A\u0440\u043E\u0444\u043E\u043D \u043F\u0456\u0434\u043A\u043B\u044E\u0447\u0435\u043D\u043E \u0442\u0430 \u0443\u0432\u0456\u043C\u043A\u043D\u0435\u043D\u043E.");
      } else {
        new import_obsidian2.Notice("\u041D\u0435 \u0432\u0434\u0430\u043B\u043E\u0441\u044F \u0440\u043E\u0437\u043F\u043E\u0447\u0430\u0442\u0438 \u0437\u0430\u043F\u0438\u0441 \u0433\u043E\u043B\u043E\u0441\u0443.");
      }
      this.stopVoiceRecording(false);
    }
  }
  // Stops the voice recording
  stopVoiceRecording(processAudio) {
    var _a;
    console.log(`Stopping voice recording. Process audio: ${processAudio}`);
    if (this.mediaRecorder && this.mediaRecorder.state === "recording") {
      this.mediaRecorder.stop();
    }
    (_a = this.voiceButton) == null ? void 0 : _a.classList.remove(CSS_CLASS_RECORDING);
    (0, import_obsidian2.setIcon)(this.voiceButton, "microphone");
    this.updateInputPlaceholder(this.plugin.settings.modelName);
    if (this.audioStream) {
      this.audioStream.getTracks().forEach((track) => track.stop());
      this.audioStream = null;
      console.log("Audio stream tracks stopped.");
    }
    this.mediaRecorder = null;
  }
  // --- Helpers & Utilities ---
  getChatContainer() {
    return this.chatContainer;
  }
  clearChatContainer() {
    this.messages = [];
    this.messagesPairCount = 0;
    if (this.chatContainer) {
      this.chatContainer.empty();
    }
    this.showEmptyState();
    this.saveMessageHistory();
  }
  // Add a loading indicator (dots animation)
  addLoadingIndicator() {
    this.hideEmptyState();
    const messageGroup = this.chatContainer.createDiv({
      cls: `${CSS_CLASS_MESSAGE_GROUP} ${CSS_CLASS_OLLAMA_GROUP}`
      // Belongs to assistant
    });
    const messageEl = messageGroup.createDiv({
      cls: `${CSS_CLASS_MESSAGE} ${CSS_CLASS_OLLAMA_MESSAGE} ${CSS_CLASS_TAIL_OLLAMA}`
      // Has tail initially
    });
    const dotsContainer = messageEl.createDiv({ cls: CSS_CLASS_THINKING_DOTS });
    for (let i = 0; i < 3; i++) {
      dotsContainer.createDiv({ cls: CSS_CLASS_THINKING_DOT });
    }
    this.guaranteedScrollToBottom(50, true);
    return messageGroup;
  }
  removeLoadingIndicator(loadingEl) {
    if (loadingEl && loadingEl.parentNode) {
      loadingEl.remove();
    }
  }
  scrollToBottom() {
    this.guaranteedScrollToBottom();
  }
  clearInputField() {
    if (this.inputEl) {
      this.inputEl.value = "";
      this.inputEl.dispatchEvent(new Event("input"));
    }
  }
  // Creates elements for MessageService to populate
  // Consider if MessageService should be more passive (return data)
  // vs active (directly manipulating view elements via these methods)
  // Keeping existing pattern for now.
  createGroupElement(className) {
    return this.chatContainer.createDiv({ cls: className });
  }
  createMessageElement(parent, className) {
    return parent.createDiv({ cls: className });
  }
  createContentContainer(parent) {
    return parent.createDiv({ cls: CSS_CLASS_CONTENT_CONTAINER });
  }
  createContentElement(parent) {
    return parent.createDiv({ cls: CSS_CLASS_CONTENT });
  }
  // Ensures scrolling happens after potential DOM updates
  // Add a forceScroll parameter (defaulting to false)
  guaranteedScrollToBottom(delay = 50, forceScroll = false) {
    if (this.scrollTimeout) {
      clearTimeout(this.scrollTimeout);
    }
    this.scrollTimeout = setTimeout(() => {
      requestAnimationFrame(() => {
        if (this.chatContainer) {
          const scrollThreshold = 100;
          const isScrolledUp = this.chatContainer.scrollHeight - this.chatContainer.scrollTop - this.chatContainer.clientHeight > scrollThreshold;
          if (forceScroll || !isScrolledUp || this.isProcessing) {
            this.chatContainer.scrollTop = this.chatContainer.scrollHeight;
          }
        }
      });
    }, delay);
  }
  formatTime(date) {
    return date.toLocaleTimeString(void 0, { hour: "2-digit", minute: "2-digit" });
  }
  // --- Methods previously part of OllamaView called by MessageService ---
  // These methods now act more directly or are handled internally
  // No longer needed directly if MessageService calls internalAddMessage
  // public addMessage(role: "user" | "assistant", content: string): void {
  //   this.internalAddMessage(role, content);
  // }
  // Replaced by addLoadingIndicator/removeLoadingIndicator
  // public addLoadingMessage1(): HTMLElement {
  //     return this.addLoadingIndicator();
  // }
  // Method likely used by MessageService or API service to update view state
  setLoadingState(isLoading) {
    this.isProcessing = isLoading;
    if (this.inputEl)
      this.inputEl.disabled = isLoading;
    if (this.sendButton)
      this.sendButton.disabled = isLoading;
  }
};
var OllamaView = _OllamaView;
OllamaView.instance = null;

// settings.ts
var import_obsidian3 = require("obsidian");
var DEFAULT_SETTINGS = {
  modelName: "mistral",
  ollamaServerUrl: "http://localhost:11434",
  logFileSizeLimit: 1024,
  saveMessageHistory: true,
  ragEnabled: false,
  ragFolderPath: "data",
  contextWindowSize: 5,
  googleApiKey: "",
  speechLanguage: "uk-UA",
  maxRecordingTime: 15,
  silenceDetection: true,
  followRole: true,
  useDefaultRoleDefinition: true,
  customRoleFilePath: "",
  systemPromptInterval: 0,
  temperature: 0.1,
  contextWindow: 8192
};
var OllamaSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  getDisplayText() {
    return "Ollama";
  }
  getId() {
    return "ollama-plugin";
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian3.Setting(containerEl).setName("Ollama Server URL").setDesc(
      "IP address and port where Ollama is running (e.g. http://192.168.1.10:11434)"
    ).addText(
      (text) => text.setPlaceholder("http://localhost:11434").setValue(this.plugin.settings.ollamaServerUrl).onChange(async (value) => {
        this.plugin.settings.ollamaServerUrl = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Server Connection").setDesc("Reconnect to local model server and refresh available models").addButton(
      (button) => button.setButtonText("Reconnect").setIcon("refresh-cw").onClick(async () => {
        try {
          new import_obsidian3.Notice("Connecting to Ollama server...");
          const response = await fetch(
            `${this.plugin.settings.ollamaServerUrl}/api/tags`,
            {
              method: "GET",
              headers: { "Content-Type": "application/json" }
            }
          );
          if (response.ok) {
            new import_obsidian3.Notice("Successfully connected to Ollama server!");
            containerEl.empty();
            this.display();
          } else {
            new import_obsidian3.Notice(
              "Failed to connect to Ollama server. Check the URL and ensure the server is running."
            );
            this.plugin.apiService.emit("connection-error");
          }
        } catch (error) {
          new import_obsidian3.Notice(
            "Connection error. Please check the server URL and your network connection."
          );
          this.plugin.apiService.emit("connection-error");
        }
      })
    );
    let availableModels = [];
    try {
      availableModels = await this.plugin.apiService.getModels();
    } catch (error) {
      console.error("Error fetching available models:", error);
      this.plugin.apiService.emit("connection-error");
    }
    const selectedModel = availableModels.includes(
      this.plugin.settings.modelName
    ) ? this.plugin.settings.modelName : availableModels.length > 0 ? availableModels[0] : "";
    const modelSetting = new import_obsidian3.Setting(containerEl).setName("Model Name").setDesc("Select the language model to use");
    const dropdown = modelSetting.addDropdown((dropdown2) => {
      const selectEl = dropdown2.selectEl;
      while (selectEl.firstChild) {
        selectEl.removeChild(selectEl.firstChild);
      }
      availableModels.forEach((model) => {
        dropdown2.addOption(model, model);
      });
      if (availableModels.length === 0) {
        dropdown2.addOption("", "No models available");
      }
      dropdown2.setValue(selectedModel);
      dropdown2.onChange(async (value) => {
        this.plugin.settings.modelName = value;
        this.plugin.emit("model-changed", value);
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian3.Setting(containerEl).setName("Save Message History").setDesc("Save chat message history between sessions").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.saveMessageHistory).onChange(async (value) => {
        this.plugin.settings.saveMessageHistory = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Log File Size Limit").setDesc(
      "Maximum size of message history log file in KB (1024 KB = 1 MB)"
    ).addSlider(
      (slider) => slider.setLimits(256, 10240, 256).setValue(this.plugin.settings.logFileSizeLimit).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.logFileSizeLimit = value;
        await this.plugin.saveSettings();
      })
    ).addExtraButton(
      (button) => button.setIcon("reset").setTooltip("Reset to default (1024 KB)").onClick(async () => {
        this.plugin.settings.logFileSizeLimit = DEFAULT_SETTINGS.logFileSizeLimit;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Clear History").setDesc("Delete all chat history").addButton(
      (button) => button.setButtonText("Clear").onClick(async () => {
        await this.plugin.clearMessageHistory();
        new import_obsidian3.Notice("Chat history cleared.");
      })
    );
    containerEl.createEl("h3", { text: "Role Configuration" });
    new import_obsidian3.Setting(containerEl).setName("Enable Role Definition").setDesc("Make Ollama follow a defined role from a file").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.followRole).onChange(async (value) => {
        this.plugin.settings.followRole = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Use Default Role Definition").setDesc("Use the default role definition file from the plugin folder").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.useDefaultRoleDefinition).onChange(async (value) => {
        this.plugin.settings.useDefaultRoleDefinition = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Custom Role Definition Path").setDesc(
      "Path to a custom role definition file (relative to vault root)"
    ).addText(
      (text) => text.setPlaceholder("folder/role.md").setValue(this.plugin.settings.customRoleFilePath).onChange(async (value) => {
        this.plugin.settings.customRoleFilePath = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("System Prompt Interval").setDesc("Number of message pairs between system prompt resends. 0 - with every request, negative - never send").addText(
      (text) => text.setValue(String(this.plugin.settings.systemPromptInterval || 0)).onChange(async (value) => {
        this.plugin.settings.systemPromptInterval = parseInt(value) || 0;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "RAG Configuration" });
    new import_obsidian3.Setting(containerEl).setName("Enable RAG").setDesc("Use Retrieval Augmented Generation with your notes").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.ragEnabled).onChange(async (value) => {
        this.plugin.settings.ragEnabled = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("AI Assistant Path").setDesc(
      "Path to the folder containing assistant settings. RAG documents will be loaded from 'data' subfolder (relative to vault root)"
    ).addText(
      (text) => text.setPlaceholder("").setValue(this.plugin.settings.ragFolderPath).onChange(async (value) => {
        this.plugin.settings.ragFolderPath = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Context Window Size").setDesc("Number of relevant documents to include in context").addSlider(
      (slider) => slider.setLimits(1, 10, 1).setValue(this.plugin.settings.contextWindowSize).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.contextWindowSize = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Speech Recognition" });
    new import_obsidian3.Setting(containerEl).setName("Google API Key").setDesc("API key for Google Speech-to-Text service").addText(
      (text) => text.setPlaceholder("Enter your Google API key").setValue(this.plugin.settings.googleApiKey).onChange(async (value) => {
        this.plugin.settings.googleApiKey = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Speech Recognition Language").setDesc(
      "Language code for Google Speech-to-Text (e.g., uk-UA, en-US, ru-RU)"
    ).addText(
      (text) => text.setPlaceholder("uk-UA").setValue(this.plugin.settings.speechLanguage).onChange(async (value) => {
        this.plugin.settings.speechLanguage = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Maximum Recording Time").setDesc(
      "Maximum time (in seconds) to record before automatically stopping"
    ).addSlider(
      (slider) => slider.setLimits(5, 60, 5).setValue(this.plugin.settings.maxRecordingTime).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.maxRecordingTime = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Advanced Configuration" });
    new import_obsidian3.Setting(containerEl).setName("AI context window").setDesc("Model context window size (recommended > 8192)").addText(
      (text) => text.setValue(String(this.plugin.settings.contextWindow || 8192)).onChange(async (value) => {
        this.plugin.settings.contextWindow = parseInt(value) || 8192;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Temperature").setDesc("Controls randomness in model responses (0.0-1.0)").addSlider(
      (slider) => slider.setLimits(0, 1, 0.1).setValue(this.plugin.settings.temperature).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.temperature = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

// ragService.ts
var RagService = class {
  constructor(plugin) {
    this.documents = [];
    this.isIndexing = false;
    this.plugin = plugin;
  }
  /**
   * Index all markdown files in the specified folder path
   */
  async indexDocuments() {
    var _a, _b;
    if (this.isIndexing)
      return;
    this.isIndexing = true;
    try {
      const folderPath = this.plugin.settings.ragFolderPath;
      const vault = this.plugin.app.vault;
      console.log(`AI Assistant path: "${folderPath}" (RAG documents will be loaded from 'data' subfolder)`);
      const allFiles = vault.getFiles();
      console.log(`Total files in vault: ${allFiles.length}`);
      const files = await this.getMarkdownFiles(vault, folderPath);
      console.log(`Found ${files.length} markdown files from "${folderPath}"`);
      console.log(`Indexing ${files.length} markdown files from ${folderPath}`);
      this.documents = [];
      for (const file of files) {
        try {
          const content = await vault.read(file);
          this.documents.push({
            path: file.path,
            content,
            metadata: {
              filename: file.name,
              created: (_a = file.stat) == null ? void 0 : _a.ctime,
              modified: (_b = file.stat) == null ? void 0 : _b.mtime
            }
          });
        } catch (error) {
          console.error(`Error reading file ${file.path}:`, error);
        }
      }
      console.log(`Indexed ${this.documents.length} documents for RAG`);
    } catch (error) {
      console.error("Error indexing documents:", error);
    } finally {
      this.isIndexing = false;
    }
  }
  /**
   * Get all markdown files in the specified folder path
   */
  async getMarkdownFiles(vault, folderPath) {
    const files = [];
    if (!folderPath) {
      return files;
    }
    let normalizedFolderPath = folderPath;
    if (!normalizedFolderPath.endsWith("/")) {
      normalizedFolderPath += "/";
    }
    const dataFolderPath = normalizedFolderPath + "data/";
    console.log(`Looking for markdown files in: "${dataFolderPath}"`);
    const allFiles = vault.getFiles();
    for (const file of allFiles) {
      if (file.extension === "md" && file.path.startsWith(dataFolderPath)) {
        console.log(`Adding file: ${file.path}`);
        files.push(file);
      }
    }
    return files;
  }
  /**
   * Simple search implementation to find relevant documents for a query
   * Later this could be replaced with a more sophisticated vector search
   */
  findRelevantDocuments(query, limit = 5) {
    if (!this.documents.length) {
      return [];
    }
    const scoredDocs = this.documents.map((doc) => {
      const lowerContent = doc.content.toLowerCase();
      const lowerQuery = query.toLowerCase();
      const terms = lowerQuery.split(/\s+/);
      let score = 0;
      for (const term of terms) {
        if (term.length > 2) {
          const regex = new RegExp(term, "gi");
          const matches = lowerContent.match(regex);
          if (matches) {
            score += matches.length;
          }
        }
      }
      return { doc, score };
    });
    return scoredDocs.sort((a, b) => b.score - a.score).slice(0, limit).map((item) => item.doc);
  }
  /**
   * Prepare context from relevant documents
   */
  prepareContext(query) {
    if (!this.plugin.settings.ragEnabled || this.documents.length === 0) {
      return "";
    }
    const limit = this.plugin.settings.contextWindowSize;
    const relevantDocs = this.findRelevantDocuments(query, limit);
    if (relevantDocs.length === 0) {
      return "";
    }
    let context = "### Context:\n\n";
    relevantDocs.forEach((doc, index) => {
      var _a;
      context += `Document ${index + 1} (${(_a = doc.metadata) == null ? void 0 : _a.filename}):
`;
      const maxChars = 1500;
      const content = doc.content.length > maxChars ? doc.content.substring(0, maxChars) + "..." : doc.content;
      context += content + "\n\n";
    });
    context += "### End of context\n\n";
    return context;
  }
};

// stateManager.ts
var StateManager = class {
  constructor() {
    this.state = {
      currentPhase: "next goal choosing",
      currentGoal: "Identify if there are any urgent tasks",
      userActivity: "talking with AI",
      hasUrgentTasks: "unknown",
      urgentTasksList: [],
      currentUrgentTask: null,
      planExists: "unknown",
      lastUpdateTime: new Date()
    };
  }
  // Singleton паттерн для доступа к состоянию
  static getInstance() {
    if (!StateManager.instance) {
      StateManager.instance = new StateManager();
    }
    return StateManager.instance;
  }
  // Получить текущее состояние
  getState() {
    this.state.lastUpdateTime = new Date();
    return { ...this.state };
  }
  // Обновить состояние
  updateState(newState) {
    this.state = {
      ...this.state,
      ...newState,
      lastUpdateTime: new Date()
    };
  }
  // Добавление задачи в список срочных задач
  addUrgentTask(task) {
    if (!this.state.urgentTasksList.includes(task)) {
      this.state.urgentTasksList.push(task);
      if (!this.state.currentUrgentTask && this.state.urgentTasksList.length > 0) {
        this.state.currentUrgentTask = this.state.urgentTasksList[0];
      }
      this.state.hasUrgentTasks = true;
    }
  }
  // Удаление задачи из списка и обновление текущей задачи
  completeUrgentTask(task) {
    const index = this.state.urgentTasksList.indexOf(task);
    if (index !== -1) {
      this.state.urgentTasksList.splice(index, 1);
      if (this.state.urgentTasksList.length > 0) {
        this.state.currentUrgentTask = this.state.urgentTasksList[0];
      } else {
        this.state.currentUrgentTask = null;
        this.state.hasUrgentTasks = false;
      }
    }
  }
  // Получить состояние в формате для вставки в сообщение
  getStateFormatted() {
    const currentTime = new Date().toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
    return `- **[day phase]** ${this.state.currentPhase}
  - **[next goal]** ${this.state.currentGoal}
  - **[user activity]** ${this.state.userActivity}
  - **[AI time]** ${currentTime}`;
  }
  // Анализ сообщения пользователя для обновления состояния
  processUserMessage(message) {
  }
  // Сохранение состояния в локальное хранилище
  saveStateToStorage() {
    localStorage.setItem("assistantState", JSON.stringify(this.state));
  }
  // Загрузка состояния из локального хранилища
  loadStateFromStorage() {
    const savedState = localStorage.getItem("assistantState");
    if (savedState) {
      try {
        const parsedState = JSON.parse(savedState);
        parsedState.lastUpdateTime = new Date(parsedState.lastUpdateTime);
        this.state = parsedState;
        return true;
      } catch (e) {
        console.error("Error parsing saved state:", e);
      }
    }
    return false;
  }
};

// promptService.ts
var import_obsidian4 = require("obsidian");
var path = __toESM(require("path"));
var PromptService = class {
  // Reference to the plugin for accessing services
  constructor(plugin) {
    this.systemPrompt = null;
    this.stateManager = StateManager.getInstance();
    this.plugin = plugin;
  }
  /**
   * Set plugin reference for accessing services
   */
  setPlugin(plugin) {
    this.plugin = plugin;
  }
  /**
   * Set system prompt to be used with each request
   */
  setSystemPrompt(prompt) {
    this.systemPrompt = prompt;
  }
  /**
   * Get system prompt if set
   */
  getSystemPrompt() {
    return this.systemPrompt;
  }
  /**
   * Format user prompt with necessary context and state information
   */
  formatPrompt(userInput, isNewConversation = false) {
    this.stateManager.processUserMessage(userInput);
    if (isNewConversation) {
      return userInput;
    }
    return userInput;
  }
  /**
   * Enhance prompt with RAG context if available
   */
  enhanceWithRagContext(prompt, ragContext) {
    if (!ragContext) {
      return prompt;
    }
    return `Context information:
${ragContext}

User message: ${prompt}`;
  }
  /**
   * Prepare request body for model API call
   */
  prepareRequestBody(modelName, prompt, temperature = 0.2) {
    const requestBody = {
      model: modelName,
      prompt,
      stream: false,
      temperature
    };
    if (this.systemPrompt) {
      requestBody.system = this.systemPrompt;
    }
    return requestBody;
  }
  /**
   * Process response from language model
   */
  processModelResponse(response) {
    const textArea = document.createElement("textarea");
    textArea.innerHTML = response;
    const decodedResponse = textArea.value;
    return decodedResponse.includes("<think>") ? decodedResponse : response;
  }
  /**
   * Get default role definition from plugin folder
   */
  async getDefaultRoleDefinition() {
    if (!this.plugin) {
      return null;
    }
    try {
      const pluginFolder = this.plugin.manifest.dir;
      const rolePath = "default-role.md";
      const fullPath = path.join(pluginFolder, rolePath);
      let content;
      try {
        content = await this.plugin.app.vault.adapter.read(fullPath);
      } catch (readError) {
        console.log("Couldn't read file, attempting to create it");
        try {
          const defaultContent = "# Default AI Role\n\nYou are a helpful assistant.";
          const exists = await this.plugin.app.vault.adapter.exists(fullPath);
          if (!exists) {
            await this.plugin.app.vault.adapter.write(fullPath, defaultContent);
            content = defaultContent;
          } else {
            console.error("File exists but couldn't be read:", fullPath);
            return null;
          }
        } catch (createError) {
          console.error("Error creating default role file:", createError);
          return null;
        }
      }
      if (content) {
        const currentTime = new Date().toLocaleTimeString();
        content += `
AI time is ${currentTime} now`;
        return content;
      }
      return null;
    } catch (error) {
      console.error("Error handling default role definition:", error);
      return null;
    }
  }
  /**
   * Get custom role definition from specified path
   */
  async getCustomRoleDefinition() {
    if (!this.plugin || !this.plugin.settings.customRoleFilePath) {
      return null;
    }
    try {
      const customPath = this.plugin.settings.customRoleFilePath;
      const file = this.plugin.app.vault.getAbstractFileByPath(customPath);
      if (file instanceof import_obsidian4.TFile) {
        let content = await this.plugin.app.vault.read(file);
        const currentTime = new Date().toLocaleTimeString();
        content += `
AI time is ${currentTime} now`;
        return content;
      }
      return null;
    } catch (error) {
      console.error("Error reading custom role definition:", error);
      return null;
    }
  }
  /**
   * Get role definition based on settings
   */
  async getRoleDefinition() {
    if (!this.plugin || !this.plugin.settings.followRole) {
      return null;
    }
    try {
      if (this.plugin.settings.useDefaultRoleDefinition) {
        return await this.getDefaultRoleDefinition();
      } else if (this.plugin.settings.customRoleFilePath) {
        return await this.getCustomRoleDefinition();
      }
      return null;
    } catch (error) {
      console.error("Error reading role definition:", error);
      return null;
    }
  }
  /**
   * Prepare a complete prompt with all enhancements (RAG, role definition, etc.)
   */
  async prepareFullPrompt(content, isNewConversation = false) {
    if (!this.plugin) {
      return this.formatPrompt(content, isNewConversation);
    }
    try {
      const roleDefinition = await this.getRoleDefinition();
      if (roleDefinition) {
        this.setSystemPrompt(roleDefinition);
      }
    } catch (error) {
      console.error("Error getting role definition:", error);
    }
    let formattedPrompt = this.formatPrompt(content, isNewConversation);
    if (this.plugin.settings.ragEnabled && this.plugin.ragService) {
      try {
        if (this.plugin.ragService.findRelevantDocuments("test").length === 0) {
          await this.plugin.ragService.indexDocuments();
        }
        const ragContext = this.plugin.ragService.prepareContext(content);
        if (ragContext) {
          formattedPrompt = this.enhanceWithRagContext(formattedPrompt, ragContext);
        }
      } catch (error) {
        console.error("Error processing RAG:", error);
      }
    }
    return formattedPrompt;
  }
};

// apiServices.ts
var ApiService = class {
  constructor(baseUrl, plugin) {
    this.ollamaView = null;
    this.eventHandlers = {};
    this.baseUrl = baseUrl;
    this.stateManager = StateManager.getInstance();
    this.promptService = new PromptService(plugin);
    this.stateManager.loadStateFromStorage();
  }
  on(event, callback) {
    if (!this.eventHandlers[event]) {
      this.eventHandlers[event] = [];
    }
    this.eventHandlers[event].push(callback);
    return () => {
      this.eventHandlers[event] = this.eventHandlers[event].filter(
        (handler) => handler !== callback
      );
    };
  }
  emit(event, data) {
    const handlers = this.eventHandlers[event];
    if (handlers) {
      handlers.forEach((handler) => handler(data));
    }
  }
  getPromptService() {
    return this.promptService;
  }
  setOllamaView(view) {
    this.ollamaView = view;
  }
  /**
   * Set system prompt to be used with each request
   */
  setSystemPrompt(prompt) {
    this.promptService.setSystemPrompt(prompt);
  }
  /**
   * Set base URL for the API
   */
  setBaseUrl(url) {
    this.baseUrl = url;
  }
  /**
   * Set plugin reference for prompt service
   */
  setPlugin(plugin) {
    this.promptService.setPlugin(plugin);
  }
  /**
   * Generate response from Ollama
   */
  async generateResponse(requestBody) {
    const response = await fetch(`${this.baseUrl}/api/generate`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(requestBody)
    });
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`HTTP error! Status: ${response.status}, ${errorText}`);
    }
    const data = await response.json();
    data.response = this.promptService.processModelResponse(data.response);
    this.stateManager.saveStateToStorage();
    return {
      model: requestBody.model,
      response: this.promptService.processModelResponse(data.response)
    };
  }
  /**
   * Get available models from Ollama
   */
  async getModels() {
    try {
      const response = await fetch(`${this.baseUrl}/api/tags`, {
        method: "GET",
        headers: { "Content-Type": "application/json" }
      });
      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
      const data = await response.json();
      if (Array.isArray(data.models)) {
        return data.models.map(
          (model) => typeof model === "object" ? model.name : model
        );
      }
      return [];
    } catch (error) {
      console.error("Error fetching models:", error);
      return [];
    }
  }
  /**
   * Reset assistant state to initial values
   */
  resetState() {
    const initialState = {
      currentPhase: "next goal choosing",
      currentGoal: "Identify if there are any urgent tasks",
      userActivity: "talking with AI",
      hasUrgentTasks: "unknown",
      urgentTasksList: [],
      currentUrgentTask: null,
      planExists: "unknown"
    };
    this.stateManager.updateState(initialState);
    this.stateManager.saveStateToStorage();
    if (this.ollamaView) {
      this.ollamaView.messagesPairCount = 0;
    }
  }
};

// main.ts
var OllamaPlugin = class extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    this.view = null;
    this.eventHandlers = {};
    this.documents = [];
    this.embeddings = [];
    // Add debouncing to prevent excessive indexing
    this.indexUpdateTimeout = null;
  }
  on(event, callback) {
    if (!this.eventHandlers[event]) {
      this.eventHandlers[event] = [];
    }
    this.eventHandlers[event].push(callback);
    return () => {
      this.eventHandlers[event] = this.eventHandlers[event].filter(
        (handler) => handler !== callback
      );
    };
  }
  emit(event, data) {
    const handlers = this.eventHandlers[event];
    if (handlers) {
      handlers.forEach((handler) => handler(data));
    }
  }
  async onload() {
    console.log("Ollama Plugin Loaded!");
    await this.loadSettings();
    this.apiService = new ApiService(this.settings.ollamaServerUrl);
    this.ragService = new RagService(this);
    this.promptService = new PromptService(this);
    this.messageService = new MessageService(this);
    this.registerView(VIEW_TYPE_OLLAMA, (leaf) => {
      this.view = new OllamaView(leaf, this);
      this.messageService.setView(this.view);
      return this.view;
    });
    this.addCommand({
      id: "change-model",
      name: "Change Ollama Model",
      callback: async () => {
        const newModel = "llama2:13b";
        this.settings.modelName = newModel;
        await this.saveSettings();
        this.emit("model-changed", newModel);
      }
    });
    this.apiService.on("connection-error", (error) => {
      this.messageService.addMessage(
        "error" /* ERROR */,
        `Failed to connect to Ollama: ${error.message}`
      );
    });
    this.addRibbonIcon("message-square", "\u0412\u0456\u0434\u043A\u0440\u0438\u0442\u0438 Ollama", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-ollama-view",
      name: "\u0412\u0456\u0434\u043A\u0440\u0438\u0442\u0438 Ollama Chat",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "index-rag-documents",
      name: "\u0406\u043D\u0434\u0435\u043A\u0441\u0443\u0432\u0430\u0442\u0438 \u0434\u043E\u043A\u0443\u043C\u0435\u043D\u0442\u0438 \u0434\u043B\u044F RAG",
      callback: async () => {
        await this.ragService.indexDocuments();
      }
    });
    this.settingTab = new OllamaSettingTab(this.app, this);
    this.addSettingTab(this.settingTab);
    this.app.workspace.onLayoutReady(() => {
      const existingLeaf = this.app.workspace.getLeavesOfType(VIEW_TYPE_OLLAMA)[0];
      if (!existingLeaf) {
        this.activateView();
      } else {
      }
      if (this.settings.ragEnabled) {
        this.ragService.indexDocuments();
      }
    });
    this.registerEvent(
      this.app.vault.on("modify", () => {
        if (this.settings.ragEnabled) {
          this.debounceIndexUpdate();
        }
      })
    );
  }
  // Update API service when settings change
  updateApiService() {
    this.apiService.setBaseUrl(this.settings.ollamaServerUrl);
  }
  debounceIndexUpdate() {
    if (this.indexUpdateTimeout) {
      clearTimeout(this.indexUpdateTimeout);
    }
    this.indexUpdateTimeout = setTimeout(() => {
      this.ragService.indexDocuments();
      this.indexUpdateTimeout = null;
    }, 3e4);
  }
  async activateView() {
    var _a;
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(VIEW_TYPE_OLLAMA)[0];
    if (!leaf) {
      console.log("Creating new Ollama view leaf");
      leaf = (_a = workspace.getRightLeaf(false)) != null ? _a : workspace.getLeaf();
      await leaf.setViewState({ type: VIEW_TYPE_OLLAMA, active: true });
    } else {
      console.log("Ollama view leaf already exists");
    }
    workspace.revealLeaf(leaf);
    if (this.view) {
      this.messageService.setView(this.view);
    }
    return leaf;
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.updateApiService();
  }
  getOllamaApiUrl() {
    return this.settings.ollamaServerUrl || DEFAULT_SETTINGS.ollamaServerUrl;
  }
  // Function to save message history
  async saveMessageHistory(messages) {
    if (!this.settings.saveMessageHistory)
      return;
    try {
      const basePath = this.app.vault.configDir + "/plugins/obsidian-ollama-duet";
      const logPath = basePath + "/chat_history.json";
      const adapter = this.app.vault.adapter;
      let fileExists = await adapter.exists(logPath);
      let fileSize = 0;
      if (fileExists) {
        const stat = await adapter.stat(logPath);
        fileSize = (stat == null ? void 0 : stat.size) ? stat.size / 1024 : 0;
      }
      if (fileSize > this.settings.logFileSizeLimit) {
        if (fileExists) {
          const backupPath = logPath + ".backup";
          if (await adapter.exists(backupPath)) {
            await adapter.remove(backupPath);
          }
          await adapter.copy(logPath, backupPath);
        }
        await adapter.write(logPath, messages);
      } else {
        if (!fileExists) {
          await adapter.write(logPath, messages);
        } else {
          const existingData = await adapter.read(logPath);
          try {
            const existingMessages = JSON.parse(existingData);
            const newMessages = JSON.parse(messages);
            const merged = JSON.stringify([...existingMessages, ...newMessages]);
            if (merged.length / 1024 > this.settings.logFileSizeLimit) {
              const allMessages = [...existingMessages, ...newMessages];
              let trimmedMessages = allMessages;
              while (JSON.stringify(trimmedMessages).length / 1024 > this.settings.logFileSizeLimit) {
                trimmedMessages = trimmedMessages.slice(1);
              }
              await adapter.write(logPath, JSON.stringify(trimmedMessages));
            } else {
              await adapter.write(logPath, merged);
            }
          } catch (e) {
            console.error("Error parsing message history:", e);
            await adapter.write(logPath, messages);
          }
        }
      }
    } catch (error) {
      console.error("Failed to save message history:", error);
    }
  }
  async loadMessageHistory() {
    if (!this.settings.saveMessageHistory)
      return [];
    try {
      const logPath = this.app.vault.configDir + "/plugins/obsidian-ollama-duet/chat_history.json";
      const adapter = this.app.vault.adapter;
      if (await adapter.exists(logPath)) {
        const data = await adapter.read(logPath);
        return JSON.parse(data);
      }
    } catch (error) {
      console.error("Failed to load message history:", error);
    }
    return [];
  }
  async clearMessageHistory() {
    try {
      const logPath = this.app.vault.configDir + "/plugins/obsidian-ollama-duet/chat_history.json";
      const adapter = this.app.vault.adapter;
      if (await adapter.exists(logPath)) {
        await adapter.remove(logPath);
        if (this.view) {
          this.view.clearChatContainer();
        }
      }
    } catch (error) {
      console.error("Failed to clear message history:", error);
    }
  }
};
