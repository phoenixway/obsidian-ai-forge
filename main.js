/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  ACTIVE_CHAT_ID_KEY: () => ACTIVE_CHAT_ID_KEY,
  CHAT_INDEX_KEY: () => CHAT_INDEX_KEY,
  SESSIONS_INDEX_KEY: () => SESSIONS_INDEX_KEY,
  default: () => OllamaPlugin2
});
module.exports = __toCommonJS(main_exports);
var import_obsidian20 = require("obsidian");

// src/OllamaView.ts
var import_obsidian14 = require("obsidian");

// src/ConfirmModal.ts
var import_obsidian = require("obsidian");
var ConfirmModal = class extends import_obsidian.Modal {
  constructor(app, title, message, onConfirm) {
    super(app);
    this.title = title;
    this.message = message;
    this.onConfirm = onConfirm;
    this.title = title;
    this.message = message;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl, titleEl } = this;
    titleEl.setText(this.title);
    contentEl.createEl("p", { text: this.message });
    new import_obsidian.Setting(contentEl).addButton((button) => button.setButtonText("Confirm").setCta().onClick(() => {
      this.onConfirm();
      this.close();
    })).addButton((button) => button.setButtonText("Cancel").onClick(() => {
      this.close();
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/PromptModal.ts
var import_obsidian2 = require("obsidian");
var PromptModal = class extends import_obsidian2.Modal {
  constructor(app, title, promptText, initialValue = "", onSubmit) {
    super(app);
    this.title = title;
    this.promptText = promptText;
    this.initialValue = initialValue;
    this.onSubmit = onSubmit;
    // Приватний метод для обробки відправки (щоб уникнути дублювання коду для кнопки та Enter)
    this.submitInput = () => {
      this.onSubmit(this.inputValue);
      this.close();
    };
    this.title = title;
    this.promptText = promptText;
    this.inputValue = initialValue;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl, titleEl } = this;
    let textInput;
    titleEl.setText(this.title);
    if (this.promptText) {
      contentEl.createEl("p", { text: this.promptText });
    }
    new import_obsidian2.Setting(contentEl).setName("New value:").addText((text) => {
      textInput = text;
      text.setValue(this.inputValue).onChange((value) => {
        this.inputValue = value;
      });
      text.inputEl.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          this.submitInput();
        }
      });
    });
    new import_obsidian2.Setting(contentEl).addButton((button) => button.setButtonText("Submit").setCta().onClick(this.submitInput)).addButton((button) => button.setButtonText("Cancel").onClick(() => {
      this.close();
    }));
    setTimeout(() => {
      var _a, _b;
      (_a = textInput == null ? void 0 : textInput.inputEl) == null ? void 0 : _a.focus();
      (_b = textInput == null ? void 0 : textInput.inputEl) == null ? void 0 : _b.select();
    }, 50);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/settings.ts
var import_obsidian4 = require("obsidian");

// src/Logger.ts
var import_obsidian3 = require("obsidian");
var LogLevel = /* @__PURE__ */ ((LogLevel3) => {
  LogLevel3[LogLevel3["DEBUG"] = 1] = "DEBUG";
  LogLevel3[LogLevel3["INFO"] = 2] = "INFO";
  LogLevel3[LogLevel3["WARN"] = 3] = "WARN";
  LogLevel3[LogLevel3["ERROR"] = 4] = "ERROR";
  LogLevel3[LogLevel3["TRACE"] = 6] = "TRACE";
  LogLevel3[LogLevel3["NONE"] = 5] = "NONE";
  return LogLevel3;
})(LogLevel || {});
var Logger = class {
  constructor(plugin, initialSettings) {
    this.consoleLogLevel = 2 /* INFO */;
    this.fileLogLevel = 3 /* WARN */;
    this.fileLoggingEnabled = false;
    this.logCallerInfo = false;
    this.logFileMaxSizeMB = 5;
    this.logQueue = [];
    this.isWritingToFile = false;
    this.writeDebounceTimeout = null;
    this.plugin = plugin;
    this.adapter = plugin.app.vault.adapter;
    this.logFilePath = (0, import_obsidian3.normalizePath)(initialSettings.logFilePath || `${this.plugin.manifest.dir}/ai-forge.log`);
    this.logFileMaxSizeMB = initialSettings.logFileMaxSizeMB || 5;
    this.updateSettings(initialSettings);
    if (this.fileLoggingEnabled) {
      this.rotateLogFileIfNeeded().then(() => {
        this.info("Logger initialized & file rotation checked.");
      });
    } else {
      this.info("Logger initialized.");
    }
  }
  // --- ДОДАНО: Публічний метод для отримання шляху ---
  getLogFilePath() {
    return this.logFilePath;
  }
  // --- КІНЕЦЬ ДОДАНОГО МЕТОДУ ---
  getLogLevelName(level) {
    return LogLevel[level] || "UNKNOWN";
  }
  getLogLevelFromString(levelString, defaultLevel = 2 /* INFO */) {
    return LogLevel[levelString == null ? void 0 : levelString.toUpperCase()] || defaultLevel;
  }
  updateSettings(settings) {
    if (settings.consoleLogLevel !== void 0) {
      this.consoleLogLevel = this.getLogLevelFromString(settings.consoleLogLevel, 2 /* INFO */);
      console.log(`[Logger] Console log level set to: ${this.getLogLevelName(this.consoleLogLevel)}`);
    }
    if (settings.fileLogLevel !== void 0) {
      this.fileLogLevel = this.getLogLevelFromString(settings.fileLogLevel, 3 /* WARN */);
      console.log(`[Logger] File log level set to: ${this.getLogLevelName(this.fileLogLevel)}`);
    }
    if (settings.fileLoggingEnabled !== void 0) {
      const wasEnabled = this.fileLoggingEnabled;
      this.fileLoggingEnabled = settings.fileLoggingEnabled;
      console.log(`[Logger] File logging enabled: ${this.fileLoggingEnabled}`);
      if (!wasEnabled && this.fileLoggingEnabled) {
        this.rotateLogFileIfNeeded();
      }
    }
    if (settings.logCallerInfo !== void 0) {
      this.logCallerInfo = settings.logCallerInfo;
      console.log(`[Logger] Log Caller Info enabled: ${this.logCallerInfo}`);
    }
    if (settings.logFilePath !== void 0) {
      this.logFilePath = (0, import_obsidian3.normalizePath)(settings.logFilePath || `${this.plugin.manifest.dir}/ai-forge.log`);
    }
    if (settings.logFileMaxSizeMB !== void 0) {
      this.logFileMaxSizeMB = settings.logFileMaxSizeMB || 5;
      console.log(`[Logger] Log file max size updated to: ${this.logFileMaxSizeMB} MB`);
    }
  }
  getCallerInfo() {
    return "unknown";
  }
  debug(...args) {
    this.log(1 /* DEBUG */, console.debug, ...args);
  }
  info(...args) {
    this.log(2 /* INFO */, console.info, ...args);
  }
  warn(...args) {
    this.log(3 /* WARN */, console.warn, ...args);
  }
  error(...args) {
    this.log(4 /* ERROR */, console.error, ...args);
  }
  trace(...args) {
    this.log(6 /* TRACE */, console.error, ...args);
  }
  log(level, consoleMethod, ...args) {
    const caller = this.getCallerInfo();
    if (level >= this.consoleLogLevel) {
      const prefix = this.logCallerInfo && caller !== "unknown" ? `[${this.getLogLevelName(level)}] [${caller}]` : `[${this.getLogLevelName(level)}]`;
      consoleMethod(prefix, ...args);
    }
    if (this.fileLoggingEnabled && level >= this.fileLogLevel) {
      this.queueOrWriteToFile(level, caller, args);
    }
  }
  queueOrWriteToFile(level, caller, args) {
  }
  triggerWriteToFile() {
  }
  async rotateLogFileIfNeeded() {
  }
};

// src/settings.ts
var LANGUAGES = {
  af: "Afrikaans",
  sq: "Albanian",
  am: "Amharic",
  ar: "Arabic",
  hy: "Armenian",
  az: "Azerbaijani",
  eu: "Basque",
  be: "Belarusian",
  bn: "Bengali",
  bs: "Bosnian",
  bg: "Bulgarian",
  ca: "Catalan",
  ceb: "Cebuano",
  ny: "Chichewa",
  "zh-CN": "Chinese (Simplified)",
  "zh-TW": "Chinese (Traditional)",
  co: "Corsican",
  hr: "Croatian",
  cs: "Czech",
  da: "Danish",
  nl: "Dutch",
  en: "English",
  eo: "Esperanto",
  et: "Estonian",
  tl: "Filipino",
  fi: "Finnish",
  fr: "French",
  fy: "Frisian",
  gl: "Galician",
  ka: "Georgian",
  de: "German",
  el: "Greek",
  gu: "Gujarati",
  ht: "Haitian Creole",
  ha: "Hausa",
  haw: "Hawaiian",
  iw: "Hebrew",
  he: "Hebrew",
  hi: "Hindi",
  hmn: "Hmong",
  hu: "Hungarian",
  is: "Icelandic",
  ig: "Igbo",
  id: "Indonesian",
  ga: "Irish",
  it: "Italian",
  ja: "Japanese",
  jw: "Javanese",
  kn: "Kannada",
  kk: "Kazakh",
  km: "Khmer",
  rw: "Kinyarwanda",
  ko: "Korean",
  ku: "Kurdish (Kurmanji)",
  ky: "Kyrgyz",
  lo: "Lao",
  la: "Latin",
  lv: "Latvian",
  lt: "Lithuanian",
  lb: "Luxembourgish",
  mk: "Macedonian",
  mg: "Malagasy",
  ms: "Malay",
  ml: "Malayalam",
  mt: "Maltese",
  mi: "Maori",
  mr: "Marathi",
  mn: "Mongolian",
  my: "Myanmar (Burmese)",
  ne: "Nepali",
  no: "Norwegian",
  or: "Odia (Oriya)",
  ps: "Pashto",
  fa: "Persian",
  pl: "Polish",
  pt: "Portuguese",
  pa: "Punjabi",
  ro: "Romanian",
  ru: "Russian",
  sm: "Samoan",
  gd: "Scots Gaelic",
  sr: "Serbian",
  st: "Sesotho",
  sn: "Shona",
  sd: "Sindhi",
  si: "Sinhala",
  sk: "Slovak",
  sl: "Slovenian",
  so: "Somali",
  es: "Spanish",
  su: "Sundanese",
  sw: "Swahili",
  sv: "Swedish",
  tg: "Tajik",
  ta: "Tamil",
  tt: "Tatar",
  te: "Telugu",
  th: "Thai",
  tr: "Turkish",
  tk: "Turkmen",
  uk: "Ukrainian",
  ur: "Urdu",
  ug: "Uyghur",
  uz: "Uzbek",
  vi: "Vietnamese",
  cy: "Welsh",
  xh: "Xhosa",
  yi: "Yiddish",
  yo: "Yoruba",
  zu: "Zulu"
};
var DEFAULT_SETTINGS = {
  // Connection & Model
  ollamaServerUrl: "http://localhost:11434",
  modelName: "",
  temperature: 0.7,
  contextWindow: 4096,
  // Roles
  userRolesFolderPath: "/etc/ai-forge/roles",
  // Приклад шляху
  selectedRolePath: "",
  followRole: true,
  // Storage & History
  saveMessageHistory: true,
  chatHistoryFolderPath: "/etc/ai-forge/chats",
  // Приклад шляху
  chatExportFolderPath: "/etc/ai-forge/xports",
  // Приклад шляху
  // View Behavior
  openChatInTab: false,
  maxMessageHeight: 300,
  // Appearance
  userAvatarType: "initials",
  userAvatarContent: "U",
  aiAvatarType: "icon",
  aiAvatarContent: "bot",
  // RAG
  ragEnabled: false,
  ragFolderPath: "etc/ai-forge/rag",
  // Приклад шляху
  ragEnableSemanticSearch: true,
  ragEmbeddingModel: "nomic-embed-text",
  ragChunkSize: 512,
  ragSimilarityThreshold: 0.5,
  ragTopK: 3,
  maxCharsPerDoc: 1500,
  // Productivity
  enableProductivityFeatures: false,
  dailyTaskFileName: "Tasks_Today.md",
  useAdvancedContextStrategy: false,
  enableSummarization: false,
  summarizationPrompt: "Summarize the key points discussed so far in this conversation:\n\n{text_to_summarize}",
  keepLastNMessagesBeforeSummary: 10,
  summarizationChunkSize: 1500,
  summarizationModelName: "",
  // Speech & Translation
  googleApiKey: "",
  speechLanguage: "uk-UA",
  enableTranslation: false,
  translationTargetLanguage: "uk",
  googleTranslationApiKey: "",
  // Logger Settings
  consoleLogLevel: "INFO",
  fileLoggingEnabled: false,
  fileLogLevel: "WARN",
  logCallerInfo: false,
  logFilePath: "",
  // Logger сам підставить шлях до папки плагіна
  logFileMaxSizeMB: 5,
  fallbackSummarizationModelName: "http://localhost:11434",
  fixBrokenEmojis: true,
  translationProvider: "ollama",
  // За замовчуванням вимкнено
  ollamaTranslationModel: "",
  sidebarWidth: void 0
  // Або null. Означає, що ширина не встановлена користувачем
};
var OllamaSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.debouncedUpdateChatPath = (0, import_obsidian4.debounce)(
      async () => {
        this.plugin.logger.debug("Debounced: Updating chat path and ensuring folder exists...");
        if (this.plugin.chatManager) {
          this.plugin.chatManager.updateChatsFolderPath();
          await this.plugin.chatManager.ensureFoldersExist();
        }
      },
      1e3,
      true
    );
    this.debouncedUpdateRolePath = (0, import_obsidian4.debounce)(
      async () => {
        this.plugin.logger.debug("Debounced: Refreshing role list due to path change...");
        await this.plugin.listRoleFiles(true);
        this.plugin.emit("roles-updated");
      },
      1e3,
      true
    );
    this.debouncedUpdateRagPath = (0, import_obsidian4.debounce)(
      async () => {
        this.plugin.logger.debug("Debounced: Re-indexing RAG due to path change...");
        if (this.plugin.settings.ragEnabled && this.plugin.ragService) {
          await this.plugin.ragService.indexDocuments();
        }
      },
      1e3,
      true
    );
  }
  // Допоміжна функція для створення заголовків секцій
  createSectionHeader(text) {
    this.containerEl.createEl("h3", { text }).addClass("ai-forge-settings-header");
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "AI Forge Settings" });
    this.createSectionHeader("Connection & Model Defaults");
    new import_obsidian4.Setting(containerEl).setName("Ollama Server URL").setDesc("The URL of your running Ollama server (e.g., http://localhost:11434 or http://192.168.X.X:11434).").addText(
      (text) => text.setPlaceholder(DEFAULT_SETTINGS.ollamaServerUrl).setValue(this.plugin.settings.ollamaServerUrl).onChange(async (value) => {
        let url = value.trim();
        if (url && !url.startsWith("http://") && !url.startsWith("https://")) {
          url = "http://" + url;
        }
        if (url.endsWith("/")) {
          url = url.slice(0, -1);
        }
        this.plugin.settings.ollamaServerUrl = url || DEFAULT_SETTINGS.ollamaServerUrl;
        await this.plugin.saveSettings();
      })
    );
    let modelDropdown = null;
    const updateOptions = async (dropdown, button) => {
      if (!dropdown)
        return;
      const currentVal = this.plugin.settings.modelName;
      dropdown.selectEl.innerHTML = "";
      dropdown.addOption("", "Loading models...");
      dropdown.setDisabled(true);
      button == null ? void 0 : button.setDisabled(true).setIcon("loader");
      try {
        const models = await this.plugin.ollamaService.getModels();
        dropdown.selectEl.innerHTML = "";
        dropdown.addOption("", "-- Select default model --");
        if (models && models.length > 0) {
          models.forEach((modelName) => {
            dropdown.addOption(modelName, modelName);
          });
          dropdown.setValue(models.includes(currentVal) ? currentVal : "");
        } else {
          dropdown.addOption("", "No models found");
          dropdown.setValue("");
        }
      } catch (error) {
        this.plugin.logger.error("Error fetching models for settings:", error);
        dropdown.selectEl.innerHTML = "";
        dropdown.addOption("", "Error loading models!");
        dropdown.setValue("");
      } finally {
        dropdown.setDisabled(false);
        button == null ? void 0 : button.setDisabled(false).setIcon("refresh-cw");
      }
    };
    new import_obsidian4.Setting(containerEl).setName("Default Model Name").setDesc("The default Ollama model for new chats.").addDropdown(async (dropdown) => {
      modelDropdown = dropdown;
      dropdown.onChange(async (value) => {
        this.plugin.settings.modelName = value;
        await this.plugin.saveSettings();
      });
      await updateOptions(dropdown);
    }).addExtraButton((button) => {
      button.setIcon("refresh-cw").setTooltip("Refresh model list").onClick(async () => {
        await updateOptions(modelDropdown, button);
        new import_obsidian4.Notice("Model list refreshed!");
      });
    });
    new import_obsidian4.Setting(containerEl).setName("Default Temperature").setDesc("Controls randomness (0.0 = deterministic, >1.0 = creative).").addSlider(
      (slider) => slider.setLimits(0, 2, 0.1).setValue(this.plugin.settings.temperature).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.temperature = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Context Window Size (Tokens)").setDesc("Max tokens model considers. Requires restart/reload if changed while model is loaded.").addText(
      (text) => text.setPlaceholder(DEFAULT_SETTINGS.contextWindow.toString()).setValue(this.plugin.settings.contextWindow.toString()).onChange(async (value) => {
        const num = parseInt(value.trim(), 10);
        this.plugin.settings.contextWindow = !isNaN(num) && num > 0 ? num : DEFAULT_SETTINGS.contextWindow;
        await this.plugin.saveSettings();
      })
    );
    this.createSectionHeader("View Behavior");
    new import_obsidian4.Setting(containerEl).setName("Open Chat in Main Tab").setDesc("ON: Open in a main tab. OFF: Open in the right sidebar.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.openChatInTab).onChange(async (value) => {
        this.plugin.settings.openChatInTab = value;
        await this.plugin.saveSettings();
        new import_obsidian4.Notice("Chat view location setting saved. Re-open the view to apply.", 5e3);
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Max Message Height (pixels)").setDesc("Collapse longer messages with 'Show More'. 0 disables.").addText(
      (text) => text.setPlaceholder("Example: 300").setValue(this.plugin.settings.maxMessageHeight.toString()).onChange(async (value) => {
        var _a, _b;
        const num = parseInt(value.trim(), 10);
        this.plugin.settings.maxMessageHeight = !isNaN(num) && num >= 0 ? num : DEFAULT_SETTINGS.maxMessageHeight;
        await this.plugin.saveSettings();
        (_b = (_a = this.plugin.view) == null ? void 0 : _a.checkAllMessagesForCollapsing) == null ? void 0 : _b.call(_a);
      })
    );
    this.createSectionHeader("Appearance");
    new import_obsidian4.Setting(containerEl).setName("User Avatar Style").addDropdown(
      (dropdown) => dropdown.addOption("initials", "Initials").addOption("icon", "Icon").addOption("image", "Image (Vault Path)").setValue(this.plugin.settings.userAvatarType).onChange(async (value) => {
        this.plugin.settings.userAvatarType = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    const userAvatarSetting = new import_obsidian4.Setting(containerEl).setDesc(" ");
    userAvatarSetting.controlEl.addClass("ai-forge-avatar-content-setting");
    if (this.plugin.settings.userAvatarType === "initials") {
      userAvatarSetting.setName("User Initials").setDesc("Max 2 chars.");
      userAvatarSetting.addText(
        (text) => text.setValue(this.plugin.settings.userAvatarContent).onChange(async (value) => {
          this.plugin.settings.userAvatarContent = value.trim().substring(0, 2) || DEFAULT_SETTINGS.userAvatarContent;
          await this.plugin.saveSettings();
        })
      );
    } else if (this.plugin.settings.userAvatarType === "icon") {
      userAvatarSetting.setName("User Icon ID").setDesc('Obsidian icon ID (e.g., "user").');
      userAvatarSetting.addText(
        (text) => text.setPlaceholder("user").setValue(this.plugin.settings.userAvatarContent).onChange(async (value) => {
          this.plugin.settings.userAvatarContent = value.trim() || "user";
          await this.plugin.saveSettings();
        })
      );
    } else if (this.plugin.settings.userAvatarType === "image") {
      userAvatarSetting.setName("User Avatar Image Path");
      userAvatarSetting.setDesc("Full path to the image file (png/jpeg/jpg) within your vault.");
      userAvatarSetting.addText(
        (text) => text.setPlaceholder("e.g., Assets/Images/user.png").setValue(this.plugin.settings.userAvatarContent).onChange(async (value) => {
          const normalizedPath = (0, import_obsidian4.normalizePath)(value.trim());
          if (normalizedPath === "" || /\.(png|jpg|jpeg)$/i.test(normalizedPath)) {
            this.plugin.settings.userAvatarContent = normalizedPath;
          } else {
            new import_obsidian4.Notice("Invalid path. Please provide a path to a .png or .jpeg/jpg file, or leave empty.");
            text.setValue(this.plugin.settings.userAvatarContent);
            return;
          }
          await this.plugin.saveSettings();
        })
      );
    }
    new import_obsidian4.Setting(containerEl).setName("AI Avatar Style").addDropdown(
      (dropdown) => dropdown.addOption("initials", "Initials").addOption("icon", "Icon").addOption("image", "Image (Vault Path)").setValue(this.plugin.settings.aiAvatarType).onChange(async (value) => {
        this.plugin.settings.aiAvatarType = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    const aiAvatarSetting = new import_obsidian4.Setting(containerEl).setDesc(" ");
    aiAvatarSetting.controlEl.addClass("ai-forge-avatar-content-setting");
    if (this.plugin.settings.aiAvatarType === "initials") {
      aiAvatarSetting.setName("AI Initials").setDesc("Max 2 chars.");
      aiAvatarSetting.addText(
        (text) => text.setValue(this.plugin.settings.aiAvatarContent).onChange(async (value) => {
          this.plugin.settings.aiAvatarContent = value.trim().substring(0, 2) || DEFAULT_SETTINGS.aiAvatarContent;
          await this.plugin.saveSettings();
        })
      );
    } else if (this.plugin.settings.aiAvatarType === "icon") {
      aiAvatarSetting.setName("AI Icon ID").setDesc('Obsidian icon ID (e.g., "bot").');
      aiAvatarSetting.addText(
        (text) => text.setPlaceholder("bot").setValue(this.plugin.settings.aiAvatarContent).onChange(async (value) => {
          this.plugin.settings.aiAvatarContent = value.trim() || "bot";
          await this.plugin.saveSettings();
        })
      );
    } else if (this.plugin.settings.aiAvatarType === "image") {
      aiAvatarSetting.setName("AI Avatar Image Path");
      aiAvatarSetting.setDesc("Full path to the image file (png/jpeg/jpg) within your vault.");
      aiAvatarSetting.addText(
        (text) => text.setPlaceholder("e.g., Assets/Images/ai.png").setValue(this.plugin.settings.aiAvatarContent).onChange(async (value) => {
          const normalizedPath = (0, import_obsidian4.normalizePath)(value.trim());
          if (normalizedPath === "" || /\.(png|jpg|jpeg)$/i.test(normalizedPath)) {
            this.plugin.settings.aiAvatarContent = normalizedPath;
          } else {
            new import_obsidian4.Notice("Invalid path. Please provide a path to a .png or .jpeg/jpg file, or leave empty.");
            text.setValue(this.plugin.settings.aiAvatarContent);
            return;
          }
          await this.plugin.saveSettings();
        })
      );
    }
    this.createSectionHeader("Roles & Personas");
    new import_obsidian4.Setting(containerEl).setName("Custom Roles Folder Path").setDesc("Folder with custom role (.md) files.").addText(
      (text) => text.setPlaceholder(DEFAULT_SETTINGS.userRolesFolderPath).setValue(this.plugin.settings.userRolesFolderPath).onChange(async (value) => {
        this.plugin.settings.userRolesFolderPath = (0, import_obsidian4.normalizePath)(value.trim()) || DEFAULT_SETTINGS.userRolesFolderPath;
        await this.plugin.saveSettings();
        this.debouncedUpdateRolePath();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Always Apply Selected Role").setDesc("Always use the selected role as system prompt.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.followRole).onChange(async (value) => {
        this.plugin.settings.followRole = value;
        await this.plugin.saveSettings();
      })
    );
    this.createSectionHeader("Storage & History");
    new import_obsidian4.Setting(containerEl).setName("Save Message History").setDesc("Save chat conversations to files.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.saveMessageHistory).onChange(async (value) => {
        this.plugin.settings.saveMessageHistory = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (this.plugin.settings.saveMessageHistory) {
      new import_obsidian4.Setting(containerEl).setName("Chat History Folder Path").setDesc('Folder to store chat history (.json files). Use "/" for vault root.').addText(
        (text) => text.setPlaceholder(DEFAULT_SETTINGS.chatHistoryFolderPath).setValue(this.plugin.settings.chatHistoryFolderPath).onChange(async (value) => {
          this.plugin.settings.chatHistoryFolderPath = value.trim() === "/" ? "/" : (0, import_obsidian4.normalizePath)(value.trim()) || DEFAULT_SETTINGS.chatHistoryFolderPath;
          await this.plugin.saveSettings();
          this.debouncedUpdateChatPath();
        })
      );
    }
    new import_obsidian4.Setting(containerEl).setName("Chat Export Folder Path").setDesc("Default folder for exported Markdown chats.").addText(
      (text) => text.setPlaceholder(DEFAULT_SETTINGS.chatExportFolderPath || "Vault Root").setValue(this.plugin.settings.chatExportFolderPath).onChange(async (value) => {
        this.plugin.settings.chatExportFolderPath = (0, import_obsidian4.normalizePath)(value.trim()) || DEFAULT_SETTINGS.chatExportFolderPath;
        await this.plugin.saveSettings();
        if (this.plugin.chatManager)
          await this.plugin.chatManager.ensureFoldersExist();
      })
    );
    this.createSectionHeader("Retrieval-Augmented Generation (RAG)");
    new import_obsidian4.Setting(containerEl).setName("Enable RAG").setDesc("Allow retrieving info from notes for context.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.ragEnabled).onChange(async (value) => {
        this.plugin.settings.ragEnabled = value;
        await this.plugin.saveSettings();
        this.display();
        if (value)
          this.debouncedUpdateRagPath();
      })
    );
    if (this.plugin.settings.ragEnabled) {
      new import_obsidian4.Setting(containerEl).setName("RAG Documents Folder Path").setDesc("Folder with notes for RAG.").addText(
        (text) => text.setPlaceholder(DEFAULT_SETTINGS.ragFolderPath).setValue(this.plugin.settings.ragFolderPath).onChange(async (value) => {
          var _a, _b, _c, _d;
          this.plugin.settings.ragFolderPath = (0, import_obsidian4.normalizePath)(value.trim()) || DEFAULT_SETTINGS.ragFolderPath;
          await this.plugin.saveSettings();
          this.debouncedUpdateRagPath();
          (_b = (_a = this.plugin).updateDailyTaskFilePath) == null ? void 0 : _b.call(_a);
          (_d = (_c = this.plugin).loadAndProcessInitialTasks) == null ? void 0 : _d.call(_c);
        })
      );
      new import_obsidian4.Setting(containerEl).setName("Enable Semantic Search").setDesc("Use embeddings (more accurate). If OFF, uses keyword search.").addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.ragEnableSemanticSearch).onChange(async (value) => {
          this.plugin.settings.ragEnableSemanticSearch = value;
          await this.plugin.saveSettings();
          this.display();
          this.debouncedUpdateRagPath();
        })
      );
      if (this.plugin.settings.ragEnableSemanticSearch) {
        let embeddingDropdown = null;
        const updateEmbeddingOptions = async (dropdown, button) => {
          if (!dropdown)
            return;
          const previousValue = this.plugin.settings.ragEmbeddingModel;
          dropdown.selectEl.innerHTML = "";
          dropdown.addOption("", "Loading models...");
          dropdown.setDisabled(true);
          button == null ? void 0 : button.setDisabled(true).setIcon("loader");
          try {
            const models = await this.plugin.ollamaService.getModels();
            dropdown.selectEl.innerHTML = "";
            dropdown.addOption("", "-- Select Embedding Model --");
            const commonEmbedModels = [
              "nomic-embed-text",
              "all-minilm",
              "mxbai-embed-large",
              "bge-base-en",
              "gte-base"
            ];
            commonEmbedModels.forEach((modelName) => dropdown.addOption(modelName, modelName));
            dropdown.addOption("---", "--- Other Installed Models ---").setDisabled(true);
            if (models && models.length > 0) {
              models.forEach((modelName) => {
                if (!commonEmbedModels.includes(modelName)) {
                  dropdown.addOption(modelName, modelName);
                }
              });
            }
            dropdown.setValue(
              models.includes(previousValue) ? previousValue : commonEmbedModels.length > 0 ? commonEmbedModels[0] : ""
            );
          } catch (error) {
            console.error("Error fetching models for embedding dropdown:", error);
            dropdown.selectEl.innerHTML = "";
            dropdown.addOption("", "Error loading models!");
            dropdown.setValue(previousValue);
          } finally {
            dropdown.setDisabled(false);
            button == null ? void 0 : button.setDisabled(false).setIcon("refresh-cw");
          }
        };
        new import_obsidian4.Setting(containerEl).setName("Embedding Model Name").setDesc("Ollama model for embeddings.").setClass("ollama-model-setting-container").addDropdown(async (dropdown) => {
          embeddingDropdown = dropdown;
          dropdown.onChange(async (value) => {
            this.plugin.settings.ragEmbeddingModel = value;
            await this.plugin.saveSettings();
            this.debouncedUpdateRagPath();
          });
          await updateEmbeddingOptions(dropdown);
        }).addExtraButton((button) => {
          button.setIcon("refresh-cw").setTooltip("Refresh model list").onClick(async () => {
            await updateEmbeddingOptions(embeddingDropdown, button);
            new import_obsidian4.Notice("Model list refreshed!");
          });
        });
        new import_obsidian4.Setting(containerEl).setName("Chunk Size (Characters)").setDesc("Size of text chunks for indexing.").addText(
          (text) => text.setPlaceholder(String(DEFAULT_SETTINGS.ragChunkSize)).setValue(String(this.plugin.settings.ragChunkSize)).onChange(async (value) => {
            const num = parseInt(value.trim(), 10);
            this.plugin.settings.ragChunkSize = !isNaN(num) && num > 50 ? num : DEFAULT_SETTINGS.ragChunkSize;
            await this.plugin.saveSettings();
            this.debouncedUpdateRagPath();
          })
        );
        new import_obsidian4.Setting(containerEl).setName("Similarity Threshold").setDesc("Min relevance score (0.0-1.0). Higher = stricter matching.").addSlider(
          (slider) => slider.setLimits(0, 1, 0.05).setValue(this.plugin.settings.ragSimilarityThreshold).setDynamicTooltip().onChange(async (value) => {
            this.plugin.settings.ragSimilarityThreshold = value;
            await this.plugin.saveSettings();
          })
        );
        new import_obsidian4.Setting(containerEl).setName("Top K Results").setDesc("Max number of relevant chunks to retrieve.").addText(
          (text) => text.setPlaceholder(String(DEFAULT_SETTINGS.ragTopK)).setValue(String(this.plugin.settings.ragTopK)).onChange(async (value) => {
            const num = parseInt(value.trim(), 10);
            this.plugin.settings.ragTopK = !isNaN(num) && num > 0 ? num : DEFAULT_SETTINGS.ragTopK;
            await this.plugin.saveSettings();
          })
        );
      }
      new import_obsidian4.Setting(containerEl).setName("Max Chars Per Document (During Context Build)").setDesc("Limits characters included per retrieved document in the final prompt (0=no limit).").addText(
        (text) => text.setPlaceholder(String(DEFAULT_SETTINGS.maxCharsPerDoc)).setValue(String(this.plugin.settings.maxCharsPerDoc)).onChange(async (value) => {
          const num = parseInt(value.trim(), 10);
          this.plugin.settings.maxCharsPerDoc = !isNaN(num) && num >= 0 ? num : DEFAULT_SETTINGS.maxCharsPerDoc;
          await this.plugin.saveSettings();
        })
      );
    }
    this.createSectionHeader("Advanced Context Management");
    new import_obsidian4.Setting(containerEl).setName("Use Advanced Context Strategy").setDesc("Enable automatic chat summarization and message chunking for long conversations.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.useAdvancedContextStrategy).onChange(async (value) => {
        this.plugin.settings.useAdvancedContextStrategy = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (this.plugin.settings.useAdvancedContextStrategy) {
      new import_obsidian4.Setting(containerEl).setName("Enable Context Summarization").setDesc("Automatically summarize older parts of the conversation.").addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.enableSummarization).onChange(async (value) => {
          this.plugin.settings.enableSummarization = value;
          await this.plugin.saveSettings();
          this.display();
        })
      );
      if (this.plugin.settings.enableSummarization) {
        new import_obsidian4.Setting(containerEl).setName("Summarization Prompt").setDesc("Prompt used for summarization. Use {text_to_summarize} placeholder.").addTextArea(
          (text) => text.setPlaceholder(DEFAULT_SETTINGS.summarizationPrompt).setValue(this.plugin.settings.summarizationPrompt).onChange(async (value) => {
            this.plugin.settings.summarizationPrompt = value || DEFAULT_SETTINGS.summarizationPrompt;
            await this.plugin.saveSettings();
          }).inputEl.setAttrs({ rows: 4 })
        );
      }
      let summarizationModelDropdown = null;
      const updateSummarizationOptions = async (dropdown, button) => {
        if (!dropdown)
          return;
        const currentVal = this.plugin.settings.summarizationModelName;
        dropdown.selectEl.innerHTML = "";
        dropdown.addOption("", "Loading models...");
        dropdown.setDisabled(true);
        button == null ? void 0 : button.setDisabled(true).setIcon("loader");
        try {
          const models = await this.plugin.ollamaService.getModels();
          dropdown.selectEl.innerHTML = "";
          dropdown.addOption("", "-- Select Summarization Model --");
          if (models && models.length > 0) {
            models.forEach((modelName) => {
              dropdown.addOption(modelName, modelName);
            });
            dropdown.setValue(models.includes(currentVal) ? currentVal : "");
          } else {
            dropdown.addOption("", "No models found");
            dropdown.setValue("");
          }
        } catch (error) {
          this.plugin.logger.error("Error fetching models for summarization settings:", error);
          dropdown.selectEl.innerHTML = "";
          dropdown.addOption("", "Error loading models!");
          dropdown.setValue("");
        } finally {
          dropdown.setDisabled(false);
          button == null ? void 0 : button.setDisabled(false).setIcon("refresh-cw");
        }
      };
      new import_obsidian4.Setting(containerEl).setName("Summarization Model").setDesc("Model used for summarizing chat history and individual messages.").addDropdown(async (dropdown) => {
        summarizationModelDropdown = dropdown;
        dropdown.onChange(async (value) => {
          this.plugin.settings.summarizationModelName = value;
          await this.plugin.saveSettings();
        });
        await updateSummarizationOptions(dropdown);
      }).addExtraButton((button) => {
        button.setIcon("refresh-cw").setTooltip("Refresh model list").onClick(async () => {
          await updateSummarizationOptions(summarizationModelDropdown, button);
          new import_obsidian4.Notice("Model list refreshed!");
        });
      });
      new import_obsidian4.Setting(containerEl).setName("Keep Last N Messages Before Summary").setDesc("Number of recent messages excluded from summarization.").addText(
        (text) => text.setPlaceholder(DEFAULT_SETTINGS.keepLastNMessagesBeforeSummary.toString()).setValue(this.plugin.settings.keepLastNMessagesBeforeSummary.toString()).onChange(async (value) => {
          const num = parseInt(value.trim(), 10);
          this.plugin.settings.keepLastNMessagesBeforeSummary = !isNaN(num) && num >= 0 ? num : DEFAULT_SETTINGS.keepLastNMessagesBeforeSummary;
          await this.plugin.saveSettings();
        })
      );
      new import_obsidian4.Setting(containerEl).setName("Fallback Summarization Model").setDesc(
        "Optional. Model to use if the primary summarization model is not set or not found. Uses the main Ollama server."
      ).addText(
        (text) => text.setPlaceholder("e.g., orca-mini or leave empty").setValue(this.plugin.settings.fallbackSummarizationModelName).onChange(async (value) => {
          this.plugin.settings.fallbackSummarizationModelName = value.trim();
          await this.plugin.saveSettings();
        })
      );
      new import_obsidian4.Setting(containerEl).setName("Summarization Chunk Size (Tokens)").setDesc("Approximate size of text chunks passed to the summarization model.").addText(
        (text) => text.setPlaceholder(DEFAULT_SETTINGS.summarizationChunkSize.toString()).setValue(this.plugin.settings.summarizationChunkSize.toString()).onChange(async (value) => {
          const num = parseInt(value.trim(), 10);
          this.plugin.settings.summarizationChunkSize = !isNaN(num) && num > 100 ? num : DEFAULT_SETTINGS.summarizationChunkSize;
          await this.plugin.saveSettings();
        })
      );
    }
    this.createSectionHeader("Productivity Assistant Features");
    new import_obsidian4.Setting(containerEl).setName("Enable Productivity Features").setDesc("Activate daily task integration.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableProductivityFeatures).onChange(async (value) => {
        var _a, _b, _c, _d;
        this.plugin.settings.enableProductivityFeatures = value;
        await this.plugin.saveSettings();
        this.display();
        (_b = (_a = this.plugin).updateDailyTaskFilePath) == null ? void 0 : _b.call(_a);
        (_d = (_c = this.plugin).loadAndProcessInitialTasks) == null ? void 0 : _d.call(_c);
      })
    );
    if (this.plugin.settings.enableProductivityFeatures) {
      new import_obsidian4.Setting(containerEl).setName("Daily Task File Name").setDesc("Filename within the RAG folder used for daily tasks.").addText(
        (text) => text.setPlaceholder(DEFAULT_SETTINGS.dailyTaskFileName).setValue(this.plugin.settings.dailyTaskFileName).onChange(async (value) => {
          var _a, _b, _c, _d;
          this.plugin.settings.dailyTaskFileName = value.trim() || DEFAULT_SETTINGS.dailyTaskFileName;
          await this.plugin.saveSettings();
          (_b = (_a = this.plugin).updateDailyTaskFilePath) == null ? void 0 : _b.call(_a);
          (_d = (_c = this.plugin).loadAndProcessInitialTasks) == null ? void 0 : _d.call(_c);
        })
      );
    }
    this.createSectionHeader("Speech & Translation");
    this.plugin.settings.enableTranslation = this.plugin.settings.translationProvider !== "none";
    new import_obsidian4.Setting(containerEl).setName("Translation Provider").setDesc("Select the service for message and input translation.").addDropdown(
      (dropdown) => dropdown.addOption("none", "Disabled").addOption("google", "Google Translate API").addOption("ollama", "Ollama (Local Model)").setValue(this.plugin.settings.translationProvider).onChange(async (value) => {
        this.plugin.settings.translationProvider = value;
        this.plugin.settings.enableTranslation = value !== "none";
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (this.plugin.settings.translationProvider === "google") {
      new import_obsidian4.Setting(containerEl).setName("Target Translation Language (Google)").setDesc("Translate messages/input into this language using Google.").addDropdown((dropdown) => {
        for (const code in LANGUAGES) {
          dropdown.addOption(code, LANGUAGES[code]);
        }
        dropdown.setValue(this.plugin.settings.translationTargetLanguage).onChange(async (value) => {
          this.plugin.settings.translationTargetLanguage = value;
          await this.plugin.saveSettings();
        });
      });
      new import_obsidian4.Setting(containerEl).setName("Google Cloud Translation API Key").setDesc("Required for Google translation feature. Keep confidential.").addText(
        (text) => text.setPlaceholder("Enter API Key").setValue(this.plugin.settings.googleTranslationApiKey).onChange(async (value) => {
          this.plugin.settings.googleTranslationApiKey = value.trim();
          await this.plugin.saveSettings();
        })
      );
    }
    if (this.plugin.settings.enableTranslation) {
      if (this.plugin.settings.translationProvider === "ollama") {
        let ollamaTranslationModelDropdown = null;
        const updateOllamaTranslationOptions = async (dropdown, button) => {
          if (!dropdown)
            return;
          const currentVal = this.plugin.settings.ollamaTranslationModel;
          dropdown.selectEl.innerHTML = "";
          dropdown.addOption("", "Loading models...");
          dropdown.setDisabled(true);
          button == null ? void 0 : button.setDisabled(true).setIcon("loader");
          try {
            const models = await this.plugin.ollamaService.getModels();
            dropdown.selectEl.innerHTML = "";
            dropdown.addOption("", "-- Select Ollama Translation Model --");
            if (models && models.length > 0) {
              models.forEach((m) => dropdown.addOption(m, m));
              dropdown.setValue(models.includes(currentVal) ? currentVal : "");
            } else {
              dropdown.addOption("", "No models found");
              dropdown.setValue("");
            }
          } catch (error) {
            this.plugin.logger.error("Error fetching models for Ollama translation settings:", error);
            dropdown.selectEl.innerHTML = "";
            dropdown.addOption("", "Error loading models!");
            dropdown.setValue("");
          } finally {
            dropdown.setDisabled(false);
            button == null ? void 0 : button.setDisabled(false).setIcon("refresh-cw");
          }
        };
        new import_obsidian4.Setting(containerEl).setName("Ollama Translation Model").setDesc("Ollama model to use for translation tasks.").addDropdown(async (dropdown) => {
          ollamaTranslationModelDropdown = dropdown;
          dropdown.onChange(async (value) => {
            this.plugin.settings.ollamaTranslationModel = value;
            await this.plugin.saveSettings();
          });
          await updateOllamaTranslationOptions(dropdown);
        }).addExtraButton((button) => {
          button.setIcon("refresh-cw").setTooltip("Refresh model list").onClick(async () => {
            await updateOllamaTranslationOptions(ollamaTranslationModelDropdown, button);
            new import_obsidian4.Notice("Model list refreshed!");
          });
        });
        new import_obsidian4.Setting(containerEl).setName("Target Translation Language (Ollama)").setDesc("Translate messages/input into this language using Ollama.").addDropdown((dropdown) => {
          for (const code in LANGUAGES) {
            dropdown.addOption(code, LANGUAGES[code]);
          }
          dropdown.setValue(this.plugin.settings.translationTargetLanguage).onChange(async (value) => {
            this.plugin.settings.translationTargetLanguage = value;
            await this.plugin.saveSettings();
          });
        });
      }
    }
    new import_obsidian4.Setting(containerEl).setName("Google API Key (Speech-to-Text)").setDesc("Required for voice input. Keep confidential.").addText(
      (text) => text.setPlaceholder("Enter API Key").setValue(this.plugin.settings.googleApiKey).onChange(async (value) => {
        this.plugin.settings.googleApiKey = value.trim();
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Speech Recognition Language").setDesc("Language for voice input (e.g., en-US, uk-UA).").addDropdown((dropdown) => {
      const speechLangs = {
        "uk-UA": "Ukrainian",
        "en-US": "English (US)"
      };
      for (const code in speechLangs) {
        dropdown.addOption(code, speechLangs[code]);
      }
      dropdown.setValue(this.plugin.settings.speechLanguage).onChange(async (value) => {
        this.plugin.settings.speechLanguage = value;
        await this.plugin.saveSettings();
      });
    });
    this.createSectionHeader("Logging");
    const logLevelOptions = {};
    Object.keys(LogLevel).forEach((key) => {
      if (isNaN(Number(key))) {
        logLevelOptions[key] = key;
      }
    });
    new import_obsidian4.Setting(containerEl).setName("Console Log Level").setDesc("Minimum level for developer console.").addDropdown(
      (dropdown) => dropdown.addOptions(logLevelOptions).setValue(this.plugin.settings.consoleLogLevel || "INFO").onChange(async (value) => {
        this.plugin.settings.consoleLogLevel = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Enable File Logging").setDesc(`Log to ${this.plugin.logger.getLogFilePath()} (for debugging).`).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.fileLoggingEnabled).onChange(async (value) => {
        this.plugin.settings.fileLoggingEnabled = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (this.plugin.settings.fileLoggingEnabled) {
      new import_obsidian4.Setting(containerEl).setName("File Log Level").setDesc("Minimum level for log file.").addDropdown(
        (dropdown) => dropdown.addOptions(logLevelOptions).setValue(this.plugin.settings.fileLogLevel || "WARN").onChange(async (value) => {
          this.plugin.settings.fileLogLevel = value;
          await this.plugin.saveSettings();
        })
      );
      new import_obsidian4.Setting(containerEl).setName("Log Caller Method Name").setDesc("Include [MethodName] in logs. May slightly impact performance.").addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.logCallerInfo).onChange(async (value) => {
          this.plugin.settings.logCallerInfo = value;
          await this.plugin.saveSettings();
        })
      );
      new import_obsidian4.Setting(containerEl).setName("Log File Path").setDesc("Current location of the log file.").addText(
        (text) => text.setValue(this.plugin.logger.getLogFilePath()).setDisabled(true)
      );
    }
  }
};

// src/SummaryModal.ts
var import_obsidian5 = require("obsidian");
var SummaryModal = class extends import_obsidian5.Modal {
  // Зберігаємо посилання для оновлення
  constructor(plugin, title, summary) {
    super(plugin.app);
    this.plugin = plugin;
    this.modalTitle = title;
    this.summaryText = summary;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h3", { text: this.modalTitle });
    this.summaryContainer = contentEl.createDiv({ cls: "summary-modal-content" });
    this.summaryContainer.setText(this.summaryText);
    this.summaryContainer.style.maxHeight = "60vh";
    this.summaryContainer.style.overflowY = "auto";
    this.summaryContainer.style.whiteSpace = "pre-wrap";
    this.summaryContainer.style.backgroundColor = "var(--background-secondary)";
    this.summaryContainer.style.padding = "10px";
    this.summaryContainer.style.borderRadius = "5px";
    this.summaryContainer.style.border = "1px solid var(--background-modifier-border)";
    this.summaryContainer.style.marginBottom = "15px";
    this.summaryContainer.style.userSelect = "text";
    const buttonContainer = new import_obsidian5.Setting(contentEl).addButton((btn) => btn.setButtonText("Copy").setTooltip("Copy summary to clipboard").setIcon("copy").onClick(() => {
      navigator.clipboard.writeText(this.summaryText).then(() => {
        new import_obsidian5.Notice("Summary copied!");
      }, (err) => {
        new import_obsidian5.Notice("Failed to copy summary.");
        this.plugin.logger.error("Copy summary error:", err);
      });
    }));
    if (this.plugin.settings.enableTranslation && this.plugin.settings.googleTranslationApiKey) {
      buttonContainer.addButton((translateBtn) => {
        translateBtn.setButtonText("Translate").setTooltip(`Translate to ${this.plugin.settings.translationTargetLanguage}`).setIcon("languages").onClick(async () => {
          const targetLang = this.plugin.settings.translationTargetLanguage;
          if (!targetLang) {
            new import_obsidian5.Notice("Target translation language not set in settings.");
            return;
          }
          translateBtn.setButtonText("Translating...");
          translateBtn.setDisabled(true);
          translateBtn.setIcon("loader");
          try {
            const translatedSummary = await this.plugin.translationService.translate(this.summaryText, targetLang);
            if (translatedSummary !== null) {
              this.summaryContainer.setText(translatedSummary);
              this.summaryText = translatedSummary;
              new import_obsidian5.Notice(`Summary translated to ${targetLang}`);
            } else {
            }
          } catch (error) {
            this.plugin.logger.error("Error translating summary in modal:", error);
            new import_obsidian5.Notice("Translation failed.");
          } finally {
            translateBtn.setButtonText("Translate");
            translateBtn.setDisabled(false);
            translateBtn.setIcon("languages");
          }
        });
      });
    }
    buttonContainer.addButton((btn) => btn.setButtonText("Close").onClick(() => {
      this.close();
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/constants.ts
var CSS_CLASSES = {
  MESSAGE_GROUP: "message-group",
  SYSTEM_GROUP: "system-message-group",
  MESSAGE: "message",
  SYSTEM_MESSAGE: "system-message",
  OLLAMA_MESSAGE: "ollama-message",
  // <-- Add/Uncomment
  CONTENT_CONTAINER: "message-content-container",
  CONTENT_COLLAPSIBLE: "message-content-collapsible",
  // <-- Add/Uncomment
  SYSTEM_ICON: "system-icon",
  SYSTEM_TEXT: "system-message-text",
  TIMESTAMP: "message-timestamp",
  DANGER_OPTION: "danger-option",
  CONTENT: "message-content",
  USER_GROUP: "user-message-group",
  // Likely needed if not already defined
  OLLAMA_GROUP: "ollama-message-group",
  // <-- Add/Uncomment
  THINKING_DOTS: "thinking-dots",
  // Needed by sendMessage placeholder
  THINKING_DOT: "thinking-dot",
  // Needed by sendMessage placeholder
  USER_MESSAGE: "user-message",
  // Likely needed if not already defined
  REGENERATE_BUTTON: "regenerate-button",
  // Likely needed
  COPY_BUTTON: "copy-button",
  // Likely needed
  DELETE_MESSAGE_BUTTON: "delete-message-button",
  // Likely needed
  MESSAGE_ARRIVING: "message-arriving",
  VISIBLE: "visible",
  DISABLED: "disabled",
  ERROR_TEXT: "error-message-text",
  // Додаємо відсутню константу
  SHOW_MORE_BUTTON: "show-more-button",
  SUBMENU_CONTENT_HIDDEN: "submenu-content-hidden",
  CODE_BLOCK_COPY_BUTTON: "code-block-copy-button",
  CODE_BLOCK_LANGUAGE: "code-block-language",
  AVATAR: "message-group-avatar",
  // Roles/Types
  USER_MESSAGE_GROUP: "user-message-group",
  ERROR_GROUP: "error-message-group",
  ERROR_MESSAGE: "error-message",
  // Content Specific
  CONTENT_COLLAPSED: "message-content-collapsed",
  ERROR_ICON: "error-icon",
  TRANSLATION_CONTAINER: "translation-container",
  TRANSLATION_CONTENT: "translation-content",
  AVATAR_USER: "user-avatar",
  AVATAR_AI: "ai-avatar",
  // Buttons & Actions
  TRANSLATE_BUTTON: "translate-button",
  SUMMARIZE_BUTTON: "summarize-button",
  STOP_BUTTON: "stop-generating-button",
  SCROLL_BOTTOM_BUTTON: "scroll-to-bottom-button",
  // States & Modifiers
  TRANSLATION_PENDING: "translation-pending",
  // For translate button maybe?
  RECORDING: "recording"
  // For voice button
};

// src/MessageRendererUtils.ts
var import_obsidian6 = require("obsidian");
var CSS_CLASS_AVATAR = "message-group-avatar";
var CSS_CLASS_AVATAR_AI = "ai-avatar";
var CSS_CLASS_AVATAR_USER = "user-avatar";
function decodeHtmlEntities(text) {
  if (typeof document === "undefined") {
    return text.replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&#39;/g, "'");
  }
  const ta = document.createElement("textarea");
  ta.innerHTML = text;
  return ta.value;
}
function detectThinkingTags(content) {
  const thinkTagRegex = /<think>[\s\S]*?<\/think>/gi;
  const hasThinkingTags = thinkTagRegex.test(content);
  let processedContent = content;
  if (hasThinkingTags) {
    processedContent = content.replace(thinkTagRegex, "").trim();
  }
  const format = /<[a-z][\s\S]*>/i.test(processedContent) ? "html" : "text";
  return {
    hasThinkingTags,
    contentWithoutTags: processedContent,
    // Повертаємо оброблений (або оригінальний) контент
    format
  };
}
function renderAvatar(app, plugin, groupEl, isUser) {
  const settings = plugin.settings;
  const avatarType = isUser ? settings.userAvatarType : settings.aiAvatarType;
  const avatarContent = isUser ? settings.userAvatarContent : settings.aiAvatarContent;
  const avatarClass = isUser ? CSS_CLASS_AVATAR_USER : CSS_CLASS_AVATAR_AI;
  const avatarEl = groupEl.createDiv({ cls: [CSS_CLASS_AVATAR, avatarClass] });
  avatarEl.empty();
  try {
    if (avatarType === "image" && avatarContent) {
      const imagePath = (0, import_obsidian6.normalizePath)(avatarContent);
      const imageFile = app.vault.getAbstractFileByPath(imagePath);
      if (imageFile instanceof import_obsidian6.TFile) {
        const imageUrl = app.vault.getResourcePath(imageFile);
        avatarEl.createEl("img", {
          attr: { src: imageUrl, alt: isUser ? "User Avatar" : "AI Avatar" },
          cls: "ollama-avatar-image"
        });
        avatarEl.title = `Avatar from: ${imagePath}`;
      } else {
        throw new Error("Invalid image path or not a file.");
      }
    } else if (avatarType === "icon" && avatarContent) {
      (0, import_obsidian6.setIcon)(avatarEl, avatarContent);
    } else {
      avatarEl.textContent = (avatarContent == null ? void 0 : avatarContent.substring(0, 2)) || (isUser ? "U" : "AI");
    }
  } catch (e) {
    plugin.logger.warn(`Failed to render avatar (type: ${avatarType}, content: ${avatarContent}):`, e);
    avatarEl.textContent = isUser ? "U" : "AI";
    avatarEl.title = "Failed to load avatar";
  }
}
function enhanceCodeBlocks(contentEl, view) {
  if (!view || !view.plugin) {
    console.error("enhanceCodeBlocks: Missing view or plugin context!");
    return;
  }
  view.plugin.logger.debug("[enhanceCodeBlocks] Enhancing code blocks...");
  try {
    const codeBlocks = contentEl.querySelectorAll("pre > code");
    codeBlocks.forEach((codeElement) => {
      const preElement = codeElement.parentElement;
      if (!preElement)
        return;
      if (preElement.querySelector(`.${CSS_CLASSES.CODE_BLOCK_COPY_BUTTON}`)) {
        return;
      }
      const copyButton = preElement.createEl("button", {
        cls: `${CSS_CLASSES.CODE_BLOCK_COPY_BUTTON} clickable-icon`,
        // Перевірте імена констант
        attr: { "aria-label": "Copy code", title: "Copy code" }
      });
      (0, import_obsidian6.setIcon)(copyButton, "copy");
      view.registerDomEvent(copyButton, "click", (event) => {
        event.stopPropagation();
        const codeToCopy = codeElement.textContent || "";
        navigator.clipboard.writeText(codeToCopy).then(() => {
          (0, import_obsidian6.setIcon)(copyButton, "check");
          setTimeout(() => (0, import_obsidian6.setIcon)(copyButton, "copy"), 2e3);
        }).catch((err) => {
          view.plugin.logger.error("Failed to copy code block:", err);
          new import_obsidian6.Notice("Failed to copy code to clipboard.");
        });
      });
      const language = codeElement.className.replace("language-", "");
      if (language && !preElement.querySelector(`.${CSS_CLASSES.CODE_BLOCK_LANGUAGE}`)) {
        preElement.createDiv({
          cls: CSS_CLASSES.CODE_BLOCK_LANGUAGE,
          // Перевірте ім'я константи
          text: language
        });
      }
      preElement.style.position = "relative";
    });
    view.plugin.logger.debug("[enhanceCodeBlocks] Finished enhancing code blocks.");
  } catch (error) {
    view.plugin.logger.error("[enhanceCodeBlocks] Error processing code blocks:", error);
  }
}
function fixBrokenTwemojiImages(contentEl) {
  console.debug("[fixBrokenTwemojiImages] Checking for broken Twemoji...");
  try {
    contentEl.querySelectorAll('img.emoji[alt][src*="twemoji.maxcdn.com"]').forEach((img) => {
      var _a;
      const alt = img.getAttribute("alt");
      if (alt && !img.getAttribute("data-fixed")) {
        const emojiHex = (_a = alt.codePointAt(0)) == null ? void 0 : _a.toString(16);
        if (emojiHex) {
          img.src = `https://cdn.jsdelivr.net/gh/jdecked/twemoji@latest/assets/svg/${emojiHex}.svg`;
          img.setAttribute("data-fixed", "true");
          img.onerror = () => {
            console.warn(`Failed to load emoji from jsdelivr: ${alt}`);
            if (img.parentNode) {
              img.replaceWith(document.createTextNode(alt));
            }
          };
        } else if (img.parentNode) {
          img.replaceWith(document.createTextNode(alt));
        }
      }
    });
    console.debug("[fixBrokenTwemojiImages] Finished checking Twemoji.");
  } catch (error) {
    console.error("[fixBrokenTwemojiImages] Error fixing Twemoji:", error);
  }
}

// src/renderers/BaseMessageRenderer.ts
var import_obsidian7 = require("obsidian");
var BaseMessageRenderer = class {
  constructor(app, plugin, message, view) {
    this.app = app;
    this.plugin = plugin;
    this.message = message;
    this.view = view;
  }
  createMessageGroupWrapper(groupClasses = []) {
    const messageGroup = document.createElement("div");
    messageGroup.classList.add(CSS_CLASSES.MESSAGE_GROUP, ...groupClasses);
    messageGroup.setAttribute("data-timestamp", this.message.timestamp.getTime().toString());
    return messageGroup;
  }
  // --- ЗРОБЛЕНО СТАТИЧНИМ ---
  /**
   * Створює та додає елемент мітки часу до вказаного батьківського елемента.
   * @param parentElement - Елемент, куди додати мітку часу.
   * @param timestamp - Об'єкт Date для форматування.
   * @param view - Екземпляр OllamaView для доступу до форматера.
   */
  static addTimestamp(parentElement, timestamp, view) {
    if (parentElement.querySelector(`.${CSS_CLASSES.TIMESTAMP}`)) {
      return;
    }
    parentElement.createDiv({
      cls: CSS_CLASSES.TIMESTAMP,
      text: view.formatTime(timestamp)
      // Використовуємо view для форматування
    });
  }
  // --- КІНЕЦЬ ЗМІНИ ---
  addAvatar(messageGroup, isUser) {
    renderAvatar(this.app, this.plugin, messageGroup, isUser);
  }
  // addBaseActionButtons залишається методом екземпляра, бо залежить від this.message та this.view
  addBaseActionButtons(messageWrapper, contentToCopy) {
    const buttonsWrapper = messageWrapper.createDiv({ cls: "message-actions-wrapper" });
    const copyBtn = buttonsWrapper.createEl("button", { cls: CSS_CLASSES.COPY_BUTTON, attr: { "aria-label": "Copy", title: "Copy" } });
    (0, import_obsidian7.setIcon)(copyBtn, "copy");
    this.view.registerDomEvent(copyBtn, "click", (e) => {
      e.stopPropagation();
      this.view.handleCopyClick(contentToCopy, copyBtn);
    });
    const deleteBtn = buttonsWrapper.createEl("button", { cls: [CSS_CLASSES.DELETE_MESSAGE_BUTTON, CSS_CLASSES.DANGER_OPTION], attr: { "aria-label": "Delete message", title: "Delete Message" } });
    (0, import_obsidian7.setIcon)(deleteBtn, "trash");
    this.view.registerDomEvent(deleteBtn, "click", (e) => {
      e.stopPropagation();
      this.view.handleDeleteMessageClick(this.message);
    });
  }
  createMessageBubble(messageWrapper, messageClasses = []) {
    const messageEl = messageWrapper.createDiv({ cls: [CSS_CLASSES.MESSAGE, ...messageClasses] });
    const contentContainer = messageEl.createDiv({ cls: CSS_CLASSES.CONTENT_CONTAINER });
    const contentEl = contentContainer.createDiv({ cls: CSS_CLASSES.CONTENT });
    return { messageEl, contentContainer, contentEl };
  }
};

// src/renderers/UserMessageRenderer.ts
var import_obsidian8 = require("obsidian");
var CSS_CLASS_USER_GROUP = "user-message-group";
var CSS_CLASS_USER_MESSAGE = "user-message";
var CSS_CLASS_REGENERATE_BUTTON = "regenerate-button";
var UserMessageRenderer = class extends BaseMessageRenderer {
  constructor(app, plugin, message, view) {
    super(app, plugin, message, view);
    if (message.role !== "user") {
      throw new Error("UserMessageRenderer can only render messages with role 'user'.");
    }
  }
  render() {
    const messageGroup = this.createMessageGroupWrapper([CSS_CLASS_USER_GROUP]);
    this.addAvatar(messageGroup, true);
    const messageWrapper = messageGroup.createDiv({ cls: "message-wrapper" });
    messageWrapper.style.order = "1";
    const { messageEl, contentEl } = this.createMessageBubble(messageWrapper, [CSS_CLASS_USER_MESSAGE]);
    this.message.content.split("\n").forEach((line, i, arr) => {
      contentEl.appendText(line);
      if (i < arr.length - 1)
        contentEl.createEl("br");
    });
    this.addUserActionButtons(messageWrapper);
    BaseMessageRenderer.addTimestamp(messageEl, this.message.timestamp, this.view);
    return messageGroup;
  }
  /**
   * Додає кнопки дій, специфічні для повідомлення користувача (Regenerate, Copy, Delete).
   * @param messageWrapper - Обгортка повідомлення (div.message-wrapper).
   */
  addUserActionButtons(messageWrapper) {
    const buttonsWrapper = messageWrapper.createDiv({ cls: "message-actions-wrapper" });
    const finalContent = this.message.content;
    const regenerateBtn = buttonsWrapper.createEl("button", {
      cls: CSS_CLASS_REGENERATE_BUTTON,
      attr: { title: "Regenerate response" }
    });
    (0, import_obsidian8.setIcon)(regenerateBtn, "refresh-cw");
    this.view.registerDomEvent(regenerateBtn, "click", (e) => {
      e.stopPropagation();
      this.view.handleRegenerateClick(this.message);
    });
    const copyBtn = buttonsWrapper.createEl("button", {
      cls: CSS_CLASSES.COPY_BUTTON,
      // Використовуємо константу
      attr: { "aria-label": "Copy", title: "Copy" }
    });
    (0, import_obsidian8.setIcon)(copyBtn, "copy");
    this.view.registerDomEvent(copyBtn, "click", (e) => {
      e.stopPropagation();
      this.view.handleCopyClick(finalContent, copyBtn);
    });
    const deleteBtn = buttonsWrapper.createEl("button", {
      cls: [CSS_CLASSES.DELETE_MESSAGE_BUTTON, CSS_CLASSES.DANGER_OPTION],
      // Використовуємо константи
      attr: { "aria-label": "Delete message", title: "Delete Message" }
    });
    (0, import_obsidian8.setIcon)(deleteBtn, "trash");
    this.view.registerDomEvent(deleteBtn, "click", (e) => {
      e.stopPropagation();
      this.view.handleDeleteMessageClick(this.message);
    });
  }
};

// src/renderers/AssistantMessageRenderer.ts
var import_obsidian9 = require("obsidian");
var AssistantMessageRenderer = class extends BaseMessageRenderer {
  constructor(app, plugin, message, view) {
    super(app, plugin, message, view);
    if (message.role !== "assistant") {
      throw new Error("AssistantMessageRenderer can only render messages with role 'assistant'.");
    }
  }
  // Метод render залишається методом екземпляра, бо викликає статичні та protected методи
  async render() {
    this.plugin.logger.debug(`[AssistantMessageRenderer] Starting render for ts: ${this.message.timestamp.getTime()}`);
    const messageGroup = this.createMessageGroupWrapper([CSS_CLASSES.OLLAMA_GROUP]);
    this.addAvatar(messageGroup, false);
    const messageWrapper = messageGroup.createDiv({ cls: "message-wrapper" });
    messageWrapper.style.order = "2";
    const { messageEl, contentEl } = this.createMessageBubble(messageWrapper, [CSS_CLASSES.OLLAMA_MESSAGE]);
    contentEl.addClass(CSS_CLASSES.CONTENT_COLLAPSIBLE);
    this.plugin.logger.debug(`[AssistantMessageRenderer] Created base structure. Calling static renderAssistantContent...`);
    try {
      await AssistantMessageRenderer.renderAssistantContent(
        contentEl,
        this.message.content,
        this.app,
        this.plugin,
        this.view
      );
      this.plugin.logger.debug(`[AssistantMessageRenderer] Static renderAssistantContent finished successfully.`);
    } catch (error) {
      this.plugin.logger.error(`[AssistantMessageRenderer] <<< CAUGHT ERROR in render >>> Calling static renderAssistantContent FAILED:`, error);
      contentEl.setText(`[Error rendering assistant content: ${error instanceof Error ? error.message : String(error)}]`);
      throw error;
    }
    this.plugin.logger.debug(`[AssistantMessageRenderer] Adding action buttons (static)...`);
    AssistantMessageRenderer.addAssistantActionButtons(messageWrapper, contentEl, this.message, this.plugin, this.view);
    this.plugin.logger.debug(`[AssistantMessageRenderer] Adding timestamp (static)...`);
    BaseMessageRenderer.addTimestamp(messageEl, this.message.timestamp, this.view);
    this.plugin.logger.debug(`[AssistantMessageRenderer] Scheduling checkMessageForCollapsing...`);
    setTimeout(() => {
      if (messageEl.isConnected)
        this.view.checkMessageForCollapsing(messageEl);
    }, 50);
    this.plugin.logger.debug(`[AssistantMessageRenderer] Finished render for ts: ${this.message.timestamp.getTime()}`);
    return messageGroup;
  }
  /**
   * Статичний метод для рендерингу контенту асистента (Markdown, код, емодзі).
   * Тепер обережніше видаляє індикатор завантаження.
      * @param contentEl - DOM-елемент для рендерингу.
      * @param markdownText - Текст у форматі Markdown для рендерингу.
      * @param app - Екземпляр App.
      * @param plugin - Екземпляр OllamaPlugin.
      * @param view - Екземпляр OllamaView.
   */
  static async renderAssistantContent(contentEl, markdownText, app, plugin, view) {
    var _a, _b;
    plugin.logger.debug("[renderAssistantContent STAT] Entering.");
    const dotsEl = contentEl.querySelector(`.${CSS_CLASSES.THINKING_DOTS}`);
    if (markdownText.trim().length > 0 && dotsEl) {
      plugin.logger.debug("[renderAssistantContent STAT] First chunk received, removing thinking dots.");
      dotsEl.remove();
    } else if (!dotsEl && contentEl.hasChildNodes()) {
      plugin.logger.debug("[renderAssistantContent STAT] Subsequent chunk, clearing contentEl.");
      contentEl.empty();
    } else if (!dotsEl && !contentEl.hasChildNodes()) {
      plugin.logger.debug("[renderAssistantContent STAT] No dots and no content, proceeding.");
    } else {
      plugin.logger.debug("[renderAssistantContent STAT] Empty markdown chunk received, dots untouched.");
    }
    let processedMarkdown = markdownText;
    try {
      const decoded = decodeHtmlEntities(markdownText);
      const thinkDetection = detectThinkingTags(decoded);
      processedMarkdown = thinkDetection.contentWithoutTags;
      if (thinkDetection.hasThinkingTags) {
        plugin.logger.debug("[renderAssistantContent STAT] Removed <think> tags.");
      }
    } catch (e) {
      plugin.logger.error("[renderAssistantContent STAT] Error decoding/removing tags:", e);
    }
    if (processedMarkdown.trim().length === 0) {
      plugin.logger.debug("[renderAssistantContent STAT] No content to render after processing.");
      return;
    }
    plugin.logger.debug("[renderAssistantContent STAT] Starting MarkdownRenderer.render...");
    try {
      await import_obsidian9.MarkdownRenderer.render(app, processedMarkdown, contentEl, (_b = (_a = plugin.app.vault.getRoot()) == null ? void 0 : _a.path) != null ? _b : "", view);
      plugin.logger.debug("[renderAssistantContent STAT] MarkdownRenderer.render finished successfully.");
    } catch (error) {
      plugin.logger.error("[renderAssistantContent STAT] <<< MARKDOWN RENDER FAILED >>>:", error);
      contentEl.setText(`[Error rendering Markdown: ${error instanceof Error ? error.message : String(error)}]`);
      throw error;
    }
    plugin.logger.debug("[renderAssistantContent STAT] Processing code blocks...");
    try {
      enhanceCodeBlocks(contentEl, view);
    } catch (error) {
      plugin.logger.error("[renderAssistantContent STAT] Error processing code blocks:", error);
    }
    if (plugin.settings.fixBrokenEmojis) {
      plugin.logger.debug("[renderAssistantContent STAT] Fixing Twemoji images...");
      try {
        fixBrokenTwemojiImages(contentEl);
      } catch (error) {
        plugin.logger.error("[renderAssistantContent STAT] Error fixing Twemoji:", error);
      }
    }
    plugin.logger.debug("[renderAssistantContent STAT] Exiting.");
  }
  /**
   * Статичний метод для додавання кнопок дій асистента.
      * @param messageWrapper - Обгортка повідомлення.
      * @param contentEl - Елемент контенту (для перекладу).
      * @param message - Об'єкт повідомлення (для видалення).
      * @param plugin - Екземпляр OllamaPlugin (для налаштувань).
      * @param view - Екземпляр OllamaView (для обробників подій).
   */
  static addAssistantActionButtons(messageWrapper, contentEl, message, plugin, view) {
    if (messageWrapper.querySelector(".message-actions-wrapper")) {
      plugin.logger.debug("[addAssistantActionButtons STAT] Buttons already exist, skipping.");
      return;
    }
    plugin.logger.debug("[addAssistantActionButtons STAT] Adding buttons...");
    const buttonsWrapper = messageWrapper.createDiv({ cls: "message-actions-wrapper" });
    const finalContent = message.content;
    const copyBtn = buttonsWrapper.createEl("button", { cls: CSS_CLASSES.COPY_BUTTON, attr: { "aria-label": "Copy", title: "Copy" } });
    (0, import_obsidian9.setIcon)(copyBtn, "copy");
    view.registerDomEvent(copyBtn, "click", (e) => {
      e.stopPropagation();
      view.handleCopyClick(finalContent, copyBtn);
    });
    if (plugin.settings.enableTranslation && plugin.settings.googleTranslationApiKey && finalContent.trim()) {
      const translateBtn = buttonsWrapper.createEl("button", { cls: CSS_CLASSES.TRANSLATE_BUTTON, attr: { "aria-label": "Translate", title: "Translate" } });
      (0, import_obsidian9.setIcon)(translateBtn, "languages");
      view.registerDomEvent(translateBtn, "click", (e) => {
        e.stopPropagation();
        if (contentEl.isConnected) {
          view.handleTranslateClick(finalContent, contentEl, translateBtn);
        } else {
          new import_obsidian9.Notice("Cannot translate: message content element not found.");
        }
      });
    }
    if (plugin.settings.summarizationModelName && finalContent.trim()) {
      const summarizeBtn = buttonsWrapper.createEl("button", { cls: CSS_CLASSES.SUMMARIZE_BUTTON, attr: { title: "Summarize message" } });
      (0, import_obsidian9.setIcon)(summarizeBtn, "scroll-text");
      view.registerDomEvent(summarizeBtn, "click", (e) => {
        e.stopPropagation();
        view.handleSummarizeClick(finalContent, summarizeBtn);
      });
    }
    const deleteBtn = buttonsWrapper.createEl("button", { cls: [CSS_CLASSES.DELETE_MESSAGE_BUTTON, CSS_CLASSES.DANGER_OPTION], attr: { "aria-label": "Delete message", title: "Delete Message" } });
    (0, import_obsidian9.setIcon)(deleteBtn, "trash");
    view.registerDomEvent(deleteBtn, "click", (e) => {
      e.stopPropagation();
      view.handleDeleteMessageClick(message);
    });
  }
  // --- КІНЕЦЬ СТАТИЧНОГО МЕТОДУ ---
};

// src/renderers/SystemMessageRenderer.ts
var import_obsidian10 = require("obsidian");
var SystemMessageRenderer = class extends BaseMessageRenderer {
  // Оновлений конструктор
  constructor(app, plugin, message, view) {
    super(app, plugin, message, view);
    if (message.role !== "system") {
      throw new Error("SystemMessageRenderer can only render messages with role 'system'.");
    }
  }
  /**
   * Визначає іконку на основі необов'язкової властивості 'type' у повідомленні.
   * За замовчуванням використовує 'info', якщо тип відсутній або не розпізнано.
   */
  getIconType() {
    const messageType = this.message.type;
    switch (messageType) {
      case "warning":
        return "alert-triangle";
      case "error":
        return "alert-circle";
      case "info":
      default:
        return "info";
    }
  }
  /**
   * Рендерить елемент групи системного повідомлення.
   */
  render() {
    const messageGroup = this.createMessageGroupWrapper([CSS_CLASSES.SYSTEM_GROUP]);
    const messageWrapper = messageGroup.createDiv({ cls: "message-wrapper" });
    const messageEl = messageWrapper.createDiv({ cls: `${CSS_CLASSES.MESSAGE} ${CSS_CLASSES.SYSTEM_MESSAGE}` });
    const contentContainer = messageEl.createDiv({ cls: CSS_CLASSES.CONTENT_CONTAINER });
    const iconSpan = contentContainer.createSpan({ cls: CSS_CLASSES.SYSTEM_ICON });
    (0, import_obsidian10.setIcon)(iconSpan, this.getIconType());
    contentContainer.createSpan({
      cls: CSS_CLASSES.SYSTEM_TEXT,
      text: this.message.content
      // Беремо контент з protected властивості базового класу
    });
    BaseMessageRenderer.addTimestamp(messageEl, this.message.timestamp, this.view);
    return messageGroup;
  }
};

// src/renderers/ErrorMessageRenderer.ts
var import_obsidian11 = require("obsidian");
var CSS_CLASS_ERROR_GROUP = "error-message-group";
var CSS_CLASS_ERROR_MESSAGE = "error-message";
var CSS_CLASS_ERROR_ICON = "error-icon";
var CSS_CLASS_ERROR_TEXT = "error-message-text";
var ErrorMessageRenderer = class extends BaseMessageRenderer {
  constructor(app, plugin, message, view) {
    super(app, plugin, message, view);
    if (message.role !== "error") {
      throw new Error("ErrorMessageRenderer can only render messages with role 'error'.");
    }
  }
  /**
   * Рендерить ОДНУ групу повідомлення про помилку.
   * Логіка групування та сумаризації керується ззовні (наприклад, OllamaView).
   */
  render() {
    const messageGroup = this.createMessageGroupWrapper([CSS_CLASS_ERROR_GROUP]);
    const messageWrapper = messageGroup.createDiv({ cls: "message-wrapper" });
    const { messageEl, contentContainer, contentEl } = this.createMessageBubble(messageWrapper, [CSS_CLASS_ERROR_MESSAGE]);
    contentEl.addClass(CSS_CLASS_ERROR_TEXT);
    (0, import_obsidian11.setIcon)(contentContainer.createSpan({ cls: CSS_CLASS_ERROR_ICON, prepend: true }), "alert-triangle");
    contentEl.setText(this.message.content);
    BaseMessageRenderer.addTimestamp(messageEl, this.message.timestamp, this.view);
    this.addErrorActionButtons(messageWrapper);
    return messageGroup;
  }
  /**
   * Додає кнопки дій, специфічні для повідомлення про помилку (наприклад, тільки Copy і Delete).
   * @param messageWrapper - Обгортка повідомлення (div.message-wrapper).
   */
  addErrorActionButtons(messageWrapper) {
    const buttonsWrapper = messageWrapper.createDiv({ cls: "message-actions-wrapper" });
    const finalContent = this.message.content;
    const copyBtn = buttonsWrapper.createEl("button", {
      cls: CSS_CLASSES.COPY_BUTTON,
      attr: { "aria-label": "Copy Error", title: "Copy Error" }
    });
    (0, import_obsidian11.setIcon)(copyBtn, "copy");
    this.view.registerDomEvent(copyBtn, "click", (e) => {
      e.stopPropagation();
      this.view.handleCopyClick(finalContent, copyBtn);
    });
    const deleteBtn = buttonsWrapper.createEl("button", {
      cls: [CSS_CLASSES.DELETE_MESSAGE_BUTTON, CSS_CLASSES.DANGER_OPTION],
      attr: { "aria-label": "Delete message", title: "Delete Message" }
    });
    (0, import_obsidian11.setIcon)(deleteBtn, "trash");
    this.view.registerDomEvent(deleteBtn, "click", (e) => {
      e.stopPropagation();
      this.view.handleDeleteMessageClick(this.message);
    });
  }
};

// src/SidebarManager.ts
var import_obsidian12 = require("obsidian");
var CSS_ROLE_PANEL_ITEM = "ollama-role-panel-item";
var CSS_ROLE_PANEL_ITEM_ICON = "ollama-role-panel-item-icon";
var CSS_ROLE_PANEL_ITEM_TEXT = "ollama-role-panel-item-text";
var CSS_ROLE_PANEL_ITEM_ACTIVE = "is-active";
var CSS_ROLE_PANEL_ITEM_CUSTOM = "is-custom";
var CSS_ROLE_PANEL_ITEM_NONE = "ollama-role-panel-item-none";
var CSS_CLASS_MENU_OPTION = "menu-option";
var CSS_SECTION_TOGGLE_CHEVRON = "ollama-section-toggle-chevron";
var CSS_SIDEBAR_HEADER_BUTTON = "ollama-sidebar-header-button";
var CSS_SIDEBAR_SECTION_CONTENT_HIDDEN = "ollama-sidebar-section-content-hidden";
var CSS_EXPANDED_CLASS = "is-expanded";
var CSS_HIERARCHY_ITEM = "ollama-hierarchy-item";
var CSS_FOLDER_ITEM = "ollama-folder-item";
var CSS_CHAT_ITEM = "ollama-chat-item";
var CSS_HIERARCHY_ITEM_CONTENT = "ollama-hierarchy-item-content";
var CSS_HIERARCHY_ITEM_CHILDREN = "ollama-hierarchy-item-children";
var CSS_HIERARCHY_ITEM_COLLAPSED = "is-collapsed";
var CSS_FOLDER_ICON = "ollama-folder-icon";
var CSS_HIERARCHY_ITEM_TEXT = "ollama-hierarchy-item-text";
var CSS_CHAT_ITEM_DETAILS = "ollama-chat-item-details";
var CSS_CHAT_ITEM_DATE = "ollama-chat-item-date";
var CSS_HIERARCHY_ITEM_OPTIONS = "ollama-hierarchy-item-options";
var CSS_HIERARCHY_INDENT_PREFIX = "ollama-indent-level-";
var CSS_FOLDER_ACTIVE_ANCESTOR = "is-active-ancestor";
var COLLAPSE_ICON_ACCORDION = "lucide-chevron-right";
var EXPAND_ICON_ACCORDION = "lucide-chevron-down";
var FOLDER_ICON_CLOSED = "lucide-folder";
var FOLDER_ICON_OPEN = "lucide-folder-open";
var CHAT_ICON = "lucide-message-square";
var CHAT_ICON_ACTIVE = "lucide-check";
var CSS_SIDEBAR_SECTION_ICON = "ollama-sidebar-section-icon";
var CHATS_SECTION_ICON = "lucide-messages-square";
var ROLES_SECTION_ICON = "lucide-users";
var SidebarManager = class {
  constructor(plugin, app, view) {
    this.folderExpansionState = /* @__PURE__ */ new Map();
    this.updateCounter = 0;
    this.updateChatList = async () => {
      this.updateCounter++;
      const currentUpdateId = this.updateCounter;
      const container = this.chatPanelListContainerEl;
      if (!container || !this.plugin.chatManager) {
        return;
      }
      this.plugin.logger.info(
        `[Update #${currentUpdateId}] >>>>> STARTING updateChatList (visible: ${this.isSectionVisible("chats")})`
      );
      container.classList.add("is-loading");
      const currentScrollTop = container.scrollTop;
      container.empty();
      try {
        const hierarchy = await this.plugin.chatManager.getChatHierarchy();
        const currentActiveChatId = this.plugin.chatManager.getActiveChatId();
        const activeAncestorPaths = /* @__PURE__ */ new Set();
        if (currentActiveChatId) {
          const activeChat = await this.plugin.chatManager.getActiveChat();
          if (activeChat == null ? void 0 : activeChat.filePath) {
            let currentPath = activeChat.filePath;
            while (currentPath.includes("/")) {
              const parentPath = currentPath.substring(0, currentPath.lastIndexOf("/"));
              if (parentPath === "") {
                break;
              } else {
                const normalizedParentPath = (0, import_obsidian12.normalizePath)(parentPath);
                activeAncestorPaths.add(normalizedParentPath);
                currentPath = parentPath;
              }
            }
          } else if (activeChat) {
          }
        }
        if (hierarchy.length === 0) {
          container.createDiv({ cls: "menu-info-text", text: "No saved chats or folders yet." });
        } else {
          hierarchy.forEach(
            (node) => this.renderHierarchyNode(node, container, 0, currentActiveChatId, activeAncestorPaths, currentUpdateId)
          );
        }
        this.plugin.logger.info(`[Update #${currentUpdateId}] <<<<< FINISHED updateChatList (rendering done)`);
      } catch (error) {
        this.plugin.logger.error(`[Update #${currentUpdateId}] Error rendering hierarchy:`, error);
        container.empty();
        container.createDiv({ text: "Error loading chat structure.", cls: "menu-error-text" });
      } finally {
        container.classList.remove("is-loading");
        requestAnimationFrame(() => {
          if (container == null ? void 0 : container.isConnected) {
            container.scrollTop = currentScrollTop;
          }
        });
      }
    };
    this.updateRoleList = async () => {
      var _a, _b;
      const container = this.rolePanelListEl;
      if (!container || !this.plugin.chatManager) {
        return;
      }
      this.plugin.logger.debug(
        `[SidebarManager.updateRoleList] Updating role list content (visible: ${this.isSectionVisible("roles")})...`
      );
      const currentScrollTop = container.scrollTop;
      container.empty();
      try {
        const roles = await this.plugin.listRoleFiles(true);
        const activeChat = await this.plugin.chatManager.getActiveChat();
        const currentRolePath = (_b = (_a = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _a.selectedRolePath) != null ? _b : this.plugin.settings.selectedRolePath;
        const noneOptionEl = container.createDiv({
          cls: [CSS_ROLE_PANEL_ITEM, CSS_ROLE_PANEL_ITEM_NONE, CSS_CLASS_MENU_OPTION]
        });
        const noneIconSpan = noneOptionEl.createSpan({ cls: [CSS_ROLE_PANEL_ITEM_ICON, "menu-option-icon"] });
        noneOptionEl.createSpan({ cls: [CSS_ROLE_PANEL_ITEM_TEXT, "menu-option-text"], text: "None" });
        (0, import_obsidian12.setIcon)(noneIconSpan, !currentRolePath ? "check" : "slash");
        if (!currentRolePath)
          noneOptionEl.addClass(CSS_ROLE_PANEL_ITEM_ACTIVE);
        this.view.registerDomEvent(noneOptionEl, "click", () => this.handleRolePanelItemClick(null, currentRolePath));
        roles.forEach((roleInfo) => {
          const roleOptionEl = container.createDiv({ cls: [CSS_ROLE_PANEL_ITEM, CSS_CLASS_MENU_OPTION] });
          const iconSpan = roleOptionEl.createSpan({ cls: [CSS_ROLE_PANEL_ITEM_ICON, "menu-option-icon"] });
          roleOptionEl.createSpan({ cls: [CSS_ROLE_PANEL_ITEM_TEXT, "menu-option-text"], text: roleInfo.name });
          if (roleInfo.isCustom)
            roleOptionEl.addClass(CSS_ROLE_PANEL_ITEM_CUSTOM);
          (0, import_obsidian12.setIcon)(iconSpan, roleInfo.path === currentRolePath ? "check" : roleInfo.isCustom ? "user" : "file-text");
          if (roleInfo.path === currentRolePath)
            roleOptionEl.addClass(CSS_ROLE_PANEL_ITEM_ACTIVE);
          this.view.registerDomEvent(
            roleOptionEl,
            "click",
            () => this.handleRolePanelItemClick(roleInfo, currentRolePath)
          );
        });
      } catch (error) {
        this.plugin.logger.error("[SidebarManager.updateRoleList] Error rendering:", error);
        container.empty();
        container.createDiv({ text: "Error loading roles.", cls: "menu-error-text" });
      } finally {
        requestAnimationFrame(() => {
          if (container == null ? void 0 : container.isConnected) {
            container.scrollTop = currentScrollTop;
          }
        });
      }
    };
    this.handleRolePanelItemClick = async (roleInfo, currentRolePath) => {
      var _a, _b, _c, _d, _e;
      const newRolePath = (_a = roleInfo == null ? void 0 : roleInfo.path) != null ? _a : "";
      const roleNameForEvent = (_b = roleInfo == null ? void 0 : roleInfo.name) != null ? _b : "None";
      const normalizedCurrentRolePath = currentRolePath != null ? currentRolePath : "";
      if (newRolePath !== normalizedCurrentRolePath) {
        const activeChat = await ((_c = this.plugin.chatManager) == null ? void 0 : _c.getActiveChat());
        try {
          if (activeChat) {
            await this.plugin.chatManager.updateActiveChatMetadata({ selectedRolePath: newRolePath || void 0 });
          } else {
            this.plugin.settings.selectedRolePath = newRolePath || void 0;
            await this.plugin.saveSettings();
            this.plugin.emit("role-changed", roleNameForEvent);
            (_e = (_d = this.plugin.promptService) == null ? void 0 : _d.clearRoleCache) == null ? void 0 : _e.call(_d);
          }
          this.updateRoleList();
        } catch (error) {
          this.plugin.logger.error(`[SidebarManager] Error setting role to ${newRolePath}:`, error);
          new import_obsidian12.Notice("Failed to set the role.");
        }
      } else {
      }
    };
    this.handleNewChatClick = async (targetFolderPath) => {
      var _a;
      const folderPath = (_a = targetFolderPath != null ? targetFolderPath : this.plugin.chatManager.chatsFolderPath) != null ? _a : "/";
      try {
        const newChat = await this.plugin.chatManager.createNewChat(void 0, folderPath);
        if (newChat) {
          new import_obsidian12.Notice(`Created new chat: ${newChat.metadata.name}`);
          this.plugin.emit("focus-input-request");
          const parentPath = folderPath.substring(0, folderPath.lastIndexOf("/"));
          if (parentPath && parentPath !== "/") {
            this.folderExpansionState.set(parentPath, true);
          }
          this.updateChatList();
        }
      } catch (error) {
        this.plugin.logger.error("[SidebarManager] Error creating new chat:", error);
        new import_obsidian12.Notice(`Error creating new chat: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    };
    this.handleNewFolderClick = async (parentFolderPath) => {
      var _a;
      const targetParentPath = (_a = parentFolderPath != null ? parentFolderPath : this.plugin.chatManager.chatsFolderPath) != null ? _a : "/";
      new PromptModal(this.app, "Create New Folder", "Enter folder name:", "", async (newName) => {
        const trimmedName = newName == null ? void 0 : newName.trim();
        if (!trimmedName) {
          new import_obsidian12.Notice("Folder name cannot be empty.");
          return;
        }
        if (/[\\/?:*"<>|]/.test(trimmedName)) {
          new import_obsidian12.Notice("Folder name contains invalid characters.");
          return;
        }
        const newFolderPath = (0, import_obsidian12.normalizePath)(
          targetParentPath === "/" ? trimmedName : `${targetParentPath}/${trimmedName}`
        );
        try {
          const success = await this.plugin.chatManager.createFolder(newFolderPath);
          if (success) {
            new import_obsidian12.Notice(`Folder "${trimmedName}" created.`);
            if (targetParentPath && targetParentPath !== "/") {
              this.folderExpansionState.set(targetParentPath, true);
            }
            this.updateChatList();
          }
        } catch (error) {
          this.plugin.logger.error(`[SidebarManager] Error creating folder ${newFolderPath}:`, error);
          new import_obsidian12.Notice(`Error creating folder: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }).open();
    };
    this.handleRenameFolder = async (folderNode) => {
      const currentName = folderNode.name;
      const parentPath = folderNode.path.substring(0, folderNode.path.lastIndexOf("/")) || "/";
      new PromptModal(this.app, "Rename Folder", `New name for "${currentName}":`, currentName, async (newName) => {
        const trimmedName = newName == null ? void 0 : newName.trim();
        if (!trimmedName || trimmedName === currentName) {
          new import_obsidian12.Notice(trimmedName === currentName ? "Name unchanged." : "Rename cancelled.");
          return;
        }
        if (/[\\/?:*"<>|]/.test(trimmedName)) {
          new import_obsidian12.Notice("Folder name contains invalid characters.");
          return;
        }
        const newFolderPath = (0, import_obsidian12.normalizePath)(parentPath === "/" ? trimmedName : `${parentPath}/${trimmedName}`);
        try {
          const exists = await this.app.vault.adapter.exists(newFolderPath);
          if (exists) {
            new import_obsidian12.Notice(`A folder or file named "${trimmedName}" already exists here.`);
            return;
          }
        } catch (e) {
        }
        try {
          const success = await this.plugin.chatManager.renameFolder(folderNode.path, newFolderPath);
          if (success) {
            new import_obsidian12.Notice(`Folder renamed to "${trimmedName}".`);
            if (this.folderExpansionState.has(folderNode.path)) {
              const wasExpanded = this.folderExpansionState.get(folderNode.path);
              this.folderExpansionState.delete(folderNode.path);
              this.folderExpansionState.set(newFolderPath, wasExpanded);
            }
            this.updateChatList();
          }
        } catch (error) {
          this.plugin.logger.error(
            `[SidebarManager] Error renaming folder ${folderNode.path} to ${newFolderPath}:`,
            error
          );
          new import_obsidian12.Notice(`Error renaming folder: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }).open();
    };
    this.handleDeleteFolder = async (folderNode) => {
      const folderName = folderNode.name;
      const folderPath = folderNode.path;
      if (folderPath === this.plugin.chatManager.chatsFolderPath) {
        new import_obsidian12.Notice("Cannot delete the main chat history folder.");
        return;
      }
      new ConfirmModal(
        this.app,
        "Delete Folder",
        `Delete folder "${folderName}" and ALL its contents (subfolders and chats)? This cannot be undone.`,
        async () => {
          const notice = new import_obsidian12.Notice(`Deleting folder "${folderName}"...`, 0);
          try {
            const success = await this.plugin.chatManager.deleteFolder(folderPath);
            if (success) {
              const keysToDelete = Array.from(this.folderExpansionState.keys()).filter((key) => key.startsWith(folderPath));
              keysToDelete.forEach((key) => this.folderExpansionState.delete(key));
              this.updateChatList();
            }
          } catch (error) {
            this.plugin.logger.error(`[SidebarManager] Error deleting folder ${folderPath}:`, error);
            new import_obsidian12.Notice(`Error deleting folder: ${error instanceof Error ? error.message : "Unknown error"}`);
          } finally {
            notice.hide();
          }
        }
      ).open();
    };
    this.plugin = plugin;
    this.app = app;
    this.view = view;
  }
  createSidebarUI(parentElement) {
    this.containerEl = parentElement.createDiv({ cls: "ollama-sidebar-container" });
    const chatPanel = this.containerEl.createDiv({ cls: "ollama-chat-panel" });
    this.chatPanelHeaderEl = chatPanel.createDiv({
      cls: ["ollama-sidebar-section-header", "menu-option"],
      attr: { "data-section-type": "chats", "data-collapsed": "false" }
    });
    const chatHeaderLeft = this.chatPanelHeaderEl.createDiv({ cls: "ollama-sidebar-header-left" });
    (0, import_obsidian12.setIcon)(chatHeaderLeft.createSpan({ cls: CSS_SIDEBAR_SECTION_ICON }), CHATS_SECTION_ICON);
    chatHeaderLeft.createSpan({ cls: "menu-option-text", text: "Chats" });
    const chatHeaderActions = this.chatPanelHeaderEl.createDiv({ cls: "ollama-sidebar-header-actions" });
    this.newFolderSidebarButton = chatHeaderActions.createDiv({
      cls: ["ollama-sidebar-header-button", "clickable-icon"],
      attr: { "aria-label": "New Folder", title: "New Folder" }
    });
    (0, import_obsidian12.setIcon)(this.newFolderSidebarButton, "lucide-folder-plus");
    this.newChatSidebarButton = chatHeaderActions.createDiv({
      cls: ["ollama-sidebar-header-button", "clickable-icon"],
      attr: { "aria-label": "New Chat", title: "New Chat" }
    });
    (0, import_obsidian12.setIcon)(this.newChatSidebarButton, "lucide-plus-circle");
    const chatChevron = chatHeaderActions.createSpan({ cls: [CSS_SECTION_TOGGLE_CHEVRON, "clickable-icon"] });
    (0, import_obsidian12.setIcon)(chatChevron, EXPAND_ICON_ACCORDION);
    this.chatPanelListContainerEl = chatPanel.createDiv({
      cls: ["ollama-chat-list-container", "ollama-sidebar-section-content", "is-expanded"]
    });
    const rolePanel = this.containerEl.createDiv({ cls: "ollama-role-panel" });
    this.rolePanelHeaderEl = rolePanel.createDiv({
      cls: ["ollama-sidebar-section-header", "menu-option"],
      attr: { "data-section-type": "roles", "data-collapsed": "true" }
    });
    const roleHeaderLeft = this.rolePanelHeaderEl.createDiv({ cls: "ollama-sidebar-header-left" });
    (0, import_obsidian12.setIcon)(roleHeaderLeft.createSpan({ cls: CSS_SIDEBAR_SECTION_ICON }), ROLES_SECTION_ICON);
    roleHeaderLeft.createSpan({ cls: "menu-option-text", text: "Roles" });
    const roleHeaderActions = this.rolePanelHeaderEl.createDiv({ cls: "ollama-sidebar-header-actions" });
    const roleChevron = roleHeaderActions.createSpan({ cls: [CSS_SECTION_TOGGLE_CHEVRON, "clickable-icon"] });
    (0, import_obsidian12.setIcon)(roleChevron, COLLAPSE_ICON_ACCORDION);
    this.rolePanelListEl = rolePanel.createDiv({ cls: ["ollama-role-panel-list", "ollama-sidebar-section-content"] });
    this.attachSidebarEventListeners();
    if (this.isSectionVisible("chats")) {
      this.updateChatList();
    }
    return this.containerEl;
  }
  attachSidebarEventListeners() {
    if (!this.chatPanelHeaderEl || !this.rolePanelHeaderEl || !this.newChatSidebarButton || !this.newFolderSidebarButton) {
      this.plugin.logger.error("[SidebarManager] Cannot attach listeners: UI elements missing.");
      return;
    }
    this.view.registerDomEvent(this.chatPanelHeaderEl, "click", () => this.toggleSection(this.chatPanelHeaderEl));
    this.view.registerDomEvent(this.rolePanelHeaderEl, "click", () => this.toggleSection(this.rolePanelHeaderEl));
    this.view.registerDomEvent(this.newChatSidebarButton, "click", (e) => {
      e.stopPropagation();
      this.handleNewChatClick(this.plugin.chatManager.chatsFolderPath);
    });
    this.view.registerDomEvent(this.newFolderSidebarButton, "click", (e) => {
      e.stopPropagation();
      this.handleNewFolderClick(this.plugin.chatManager.chatsFolderPath);
    });
  }
  isSectionVisible(type) {
    const headerEl = type === "chats" ? this.chatPanelHeaderEl : this.rolePanelHeaderEl;
    return (headerEl == null ? void 0 : headerEl.getAttribute("data-collapsed")) === "false";
  }
  renderHierarchyNode(node, parentElement, level, activeChatId, activeAncestorPaths, updateId) {
    var _a;
    const itemEl = parentElement.createDiv({ cls: [CSS_HIERARCHY_ITEM, `${CSS_HIERARCHY_INDENT_PREFIX}${level}`] });
    if (node.type === "folder") {
      itemEl.dataset.path = node.path;
    }
    const itemContentEl = itemEl.createDiv({ cls: CSS_HIERARCHY_ITEM_CONTENT });
    if (node.type === "folder") {
      itemEl.addClass(CSS_FOLDER_ITEM);
      const isExpanded = (_a = this.folderExpansionState.get(node.path)) != null ? _a : false;
      if (!isExpanded) {
        itemEl.addClass(CSS_HIERARCHY_ITEM_COLLAPSED);
      }
      if (activeAncestorPaths.has(node.path)) {
        itemEl.addClass(CSS_FOLDER_ACTIVE_ANCESTOR);
      }
      const folderIcon = itemContentEl.createSpan({ cls: CSS_FOLDER_ICON });
      (0, import_obsidian12.setIcon)(folderIcon, isExpanded ? FOLDER_ICON_OPEN : FOLDER_ICON_CLOSED);
      itemContentEl.createSpan({ cls: CSS_HIERARCHY_ITEM_TEXT, text: node.name });
      const optionsBtn = itemContentEl.createEl("button", {
        cls: [CSS_HIERARCHY_ITEM_OPTIONS, "clickable-icon"],
        attr: { "aria-label": "Folder options", title: "More options" }
      });
      (0, import_obsidian12.setIcon)(optionsBtn, "lucide-more-horizontal");
      this.view.registerDomEvent(optionsBtn, "click", (e) => {
        e.stopPropagation();
        this.showFolderContextMenu(e, node);
      });
      this.view.registerDomEvent(itemContentEl, "contextmenu", (e) => {
        e.preventDefault();
        this.showFolderContextMenu(e, node);
      });
      this.view.registerDomEvent(itemContentEl, "click", () => {
        this.handleToggleFolder(node.path);
      });
      const childrenContainer = itemEl.createDiv({ cls: CSS_HIERARCHY_ITEM_CHILDREN });
      if (node.children && node.children.length > 0) {
        node.children.forEach(
          (childNode) => this.renderHierarchyNode(childNode, childrenContainer, level + 1, activeChatId, activeAncestorPaths, updateId)
        );
      }
    } else if (node.type === "chat") {
      itemEl.addClass(CSS_CHAT_ITEM);
      const chatMeta = node.metadata;
      const isActive = chatMeta.id === activeChatId;
      if (isActive) {
        itemEl.addClass(CSS_ROLE_PANEL_ITEM_ACTIVE);
      }
      const chatIcon = itemContentEl.createSpan({ cls: CSS_FOLDER_ICON });
      (0, import_obsidian12.setIcon)(chatIcon, isActive ? CHAT_ICON_ACTIVE : CHAT_ICON);
      itemContentEl.createSpan({ cls: CSS_HIERARCHY_ITEM_TEXT, text: chatMeta.name });
      const detailsWrapper = itemContentEl.createDiv({ cls: CSS_CHAT_ITEM_DETAILS });
      try {
        const lastModifiedDate = new Date(chatMeta.lastModified);
        const dateText = !isNaN(lastModifiedDate.getTime()) ? this.formatRelativeDate(lastModifiedDate) : "Invalid date";
        if (dateText === "Invalid date") {
        }
        detailsWrapper.createDiv({ cls: CSS_CHAT_ITEM_DATE, text: dateText });
      } catch (e) {
        this.plugin.logger.error(`Error formatting date for chat ${chatMeta.id}: `, e);
        detailsWrapper.createDiv({ cls: CSS_CHAT_ITEM_DATE, text: "Date error" });
      }
      const optionsBtn = itemContentEl.createEl("button", {
        cls: [CSS_HIERARCHY_ITEM_OPTIONS, "clickable-icon"],
        attr: { "aria-label": "Chat options", title: "More options" }
      });
      (0, import_obsidian12.setIcon)(optionsBtn, "lucide-more-horizontal");
      this.view.registerDomEvent(optionsBtn, "click", (e) => {
        e.stopPropagation();
        this.showChatContextMenu(e, chatMeta);
      });
      this.view.registerDomEvent(itemContentEl, "click", async (e) => {
        if (e.target instanceof Element && e.target.closest(`.${CSS_HIERARCHY_ITEM_OPTIONS}`)) {
          return;
        }
        if (chatMeta.id !== activeChatId) {
          await this.plugin.chatManager.setActiveChat(chatMeta.id);
        }
      });
      this.view.registerDomEvent(itemContentEl, "contextmenu", (e) => {
        e.preventDefault();
        this.showChatContextMenu(e, chatMeta);
      });
    }
  }
  handleToggleFolder(folderPath) {
    var _a;
    const currentState = (_a = this.folderExpansionState.get(folderPath)) != null ? _a : false;
    const newState = !currentState;
    this.folderExpansionState.set(folderPath, newState);
    const folderItemEl = this.chatPanelListContainerEl.querySelector(
      `.ollama-folder-item[data-path="${folderPath}"]`
    );
    if (!folderItemEl) {
      this.updateChatList();
      return;
    }
    folderItemEl.classList.toggle(CSS_HIERARCHY_ITEM_COLLAPSED, !newState);
    const folderIconEl = folderItemEl.querySelector("." + CSS_FOLDER_ICON);
    if (folderIconEl) {
      (0, import_obsidian12.setIcon)(folderIconEl, newState ? FOLDER_ICON_OPEN : FOLDER_ICON_CLOSED);
    }
  }
  // Метод для розгортання/згортання секцій Chats/Roles (акордеон)
  async toggleSection(clickedHeaderEl) {
    const sectionType = clickedHeaderEl.getAttribute("data-section-type");
    const isCurrentlyCollapsed = clickedHeaderEl.getAttribute("data-collapsed") === "true";
    const iconEl = clickedHeaderEl.querySelector(`.${CSS_SECTION_TOGGLE_CHEVRON}`);
    let contentEl;
    let updateFunction;
    let otherHeaderEl;
    let otherContentEl;
    let otherSectionType = null;
    const chatHeader = this.chatPanelHeaderEl;
    const chatContent = this.chatPanelListContainerEl;
    const roleHeader = this.rolePanelHeaderEl;
    const roleContent = this.rolePanelListEl;
    if (sectionType === "chats") {
      contentEl = chatContent;
      updateFunction = this.updateChatList;
      otherHeaderEl = roleHeader;
      otherContentEl = roleContent;
      otherSectionType = "roles";
    } else {
      contentEl = roleContent;
      updateFunction = this.updateRoleList;
      otherHeaderEl = chatHeader;
      otherContentEl = chatContent;
      otherSectionType = "chats";
    }
    if (!contentEl || !iconEl || !updateFunction || !otherHeaderEl || !otherContentEl || !otherSectionType) {
      this.plugin.logger.error("Could not find all required elements for sidebar accordion toggle:", sectionType);
      return;
    }
    const boundUpdateFunction = updateFunction.bind(this);
    if (isCurrentlyCollapsed) {
      if (otherHeaderEl.getAttribute("data-collapsed") === "false") {
        const otherIconEl = otherHeaderEl.querySelector(`.${CSS_SECTION_TOGGLE_CHEVRON}`);
        otherHeaderEl.setAttribute("data-collapsed", "true");
        if (otherIconEl)
          (0, import_obsidian12.setIcon)(otherIconEl, COLLAPSE_ICON_ACCORDION);
        otherContentEl.classList.remove(CSS_EXPANDED_CLASS);
        otherContentEl.classList.add(CSS_SIDEBAR_SECTION_CONTENT_HIDDEN);
        const otherHeaderButtons = otherHeaderEl.querySelectorAll(`.${CSS_SIDEBAR_HEADER_BUTTON}`);
        otherHeaderButtons.forEach((btn) => btn.style.display = "none");
      }
      clickedHeaderEl.setAttribute("data-collapsed", "false");
      (0, import_obsidian12.setIcon)(iconEl, EXPAND_ICON_ACCORDION);
      contentEl.classList.remove(CSS_SIDEBAR_SECTION_CONTENT_HIDDEN);
      const headerButtons = clickedHeaderEl.querySelectorAll(`.${CSS_SIDEBAR_HEADER_BUTTON}`);
      headerButtons.forEach((btn) => btn.style.display = "");
      try {
        await boundUpdateFunction();
        requestAnimationFrame(() => {
          if ((contentEl == null ? void 0 : contentEl.isConnected) && clickedHeaderEl.getAttribute("data-collapsed") === "false") {
            contentEl.classList.add(CSS_EXPANDED_CLASS);
          }
        });
      } catch (error) {
        this.plugin.logger.error(`Error updating sidebar section ${sectionType}:`, error);
        contentEl.setText(`Error loading ${sectionType}.`);
        requestAnimationFrame(() => {
          if ((contentEl == null ? void 0 : contentEl.isConnected) && clickedHeaderEl.getAttribute("data-collapsed") === "false") {
            contentEl.classList.add(CSS_EXPANDED_CLASS);
          }
        });
      }
    } else {
      clickedHeaderEl.setAttribute("data-collapsed", "true");
      (0, import_obsidian12.setIcon)(iconEl, COLLAPSE_ICON_ACCORDION);
      contentEl.classList.remove(CSS_EXPANDED_CLASS);
      contentEl.classList.add(CSS_SIDEBAR_SECTION_CONTENT_HIDDEN);
      const headerButtons = clickedHeaderEl.querySelectorAll(`.${CSS_SIDEBAR_HEADER_BUTTON}`);
      headerButtons.forEach((btn) => btn.style.display = "none");
    }
  }
  // --- Кінець методу toggleSection ---
  // --- Решта методів без змін ---
  showFolderContextMenu(event, folderNode) {
    event.preventDefault();
    event.stopPropagation();
    const menu = new import_obsidian12.Menu();
    menu.addItem(
      (item) => item.setTitle("New Chat Here").setIcon("lucide-plus-circle").onClick(() => this.handleNewChatClick(folderNode.path))
    );
    menu.addItem(
      (item) => item.setTitle("New Folder Here").setIcon("lucide-folder-plus").onClick(() => this.handleNewFolderClick(folderNode.path))
    );
    menu.addSeparator();
    menu.addItem(
      (item) => item.setTitle("Rename Folder").setIcon("lucide-pencil").onClick(() => this.handleRenameFolder(folderNode))
    );
    menu.addItem((item) => {
      item.setTitle("Delete Folder").setIcon("lucide-trash-2").onClick(() => this.handleDeleteFolder(folderNode));
    });
    menu.showAtMouseEvent(event);
  }
  showChatContextMenu(event, chatMeta) {
    event.preventDefault();
    event.stopPropagation();
    const menu = new import_obsidian12.Menu();
    menu.addItem(
      (item) => item.setTitle("Clone Chat").setIcon("lucide-copy-plus").onClick(() => this.handleContextMenuClone(chatMeta.id))
    );
    menu.addItem(
      (item) => item.setTitle("Rename Chat").setIcon("lucide-pencil").onClick(() => this.handleContextMenuRename(chatMeta.id, chatMeta.name))
    );
    menu.addItem(
      (item) => item.setTitle("Export to Note").setIcon("lucide-download").onClick(() => this.exportSpecificChat(chatMeta.id))
    );
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle("Clear Messages").setIcon("lucide-trash").onClick(() => this.handleContextMenuClear(chatMeta.id, chatMeta.name));
    });
    menu.addItem((item) => {
      item.setTitle("Delete Chat").setIcon("lucide-trash-2").onClick(() => this.handleContextMenuDelete(chatMeta.id, chatMeta.name));
    });
    menu.showAtMouseEvent(event);
  }
  async handleContextMenuClone(chatId) {
    const notice = new import_obsidian12.Notice("Cloning chat...", 0);
    try {
      const c = await this.plugin.chatManager.cloneChat(chatId);
      if (c) {
        new import_obsidian12.Notice(`Chat cloned as "${c.metadata.name}"`);
        this.updateChatList();
        this.plugin.emit("focus-input-request");
      }
    } catch (e) {
      this.plugin.logger.error(`Clone error:`, e);
    } finally {
      notice.hide();
    }
  }
  async handleContextMenuRename(chatId, currentName) {
    new PromptModal(this.app, "Rename Chat", `New name for "${currentName}":`, currentName, async (newName) => {
      const trimmedName = newName == null ? void 0 : newName.trim();
      if (!trimmedName || trimmedName === currentName) {
        new import_obsidian12.Notice(trimmedName === currentName ? `Name unchanged.` : `Rename cancelled.`);
      } else if (/[\\/?:*"<>|]/.test(trimmedName)) {
        new import_obsidian12.Notice("Chat name contains invalid characters.");
      } else {
        const success = await this.plugin.chatManager.renameChat(chatId, trimmedName);
      }
      this.plugin.emit("focus-input-request");
    }).open();
  }
  // Видалено явний updateChatList
  async exportSpecificChat(chatId) {
    var _a;
    const notice = new import_obsidian12.Notice(`Exporting chat...`, 0);
    try {
      const chat = await this.plugin.chatManager.getChat(chatId);
      if (!chat || chat.messages.length === 0) {
        new import_obsidian12.Notice("Chat is empty or not found, nothing to export.");
        notice.hide();
        return;
      }
      const md = this.formatChatToMarkdown(chat.messages, chat.metadata);
      const ts = new Date().toISOString().replace(/[:.]/g, "-");
      const safeName = chat.metadata.name.replace(/[\\/?:*"<>|]/g, "-");
      const filename = `ollama-chat-${safeName}-${ts}.md`;
      let fPath = (_a = this.plugin.settings.chatExportFolderPath) == null ? void 0 : _a.trim();
      let fFolder = null;
      if (fPath) {
        fPath = (0, import_obsidian12.normalizePath)(fPath);
        const af = this.app.vault.getAbstractFileByPath(fPath);
        if (!af) {
          try {
            await this.app.vault.createFolder(fPath);
            const newAf = this.app.vault.getAbstractFileByPath(fPath);
            if (newAf instanceof import_obsidian12.TFolder) {
              fFolder = newAf;
              new import_obsidian12.Notice(`Created export folder: ${fPath}`);
            } else {
              throw new Error("Failed to get created folder.");
            }
          } catch (err) {
            this.plugin.logger.error("Folder creation error during export:", err);
            new import_obsidian12.Notice(`Export folder error. Saving to vault root.`);
            fFolder = this.app.vault.getRoot();
          }
        } else if (af instanceof import_obsidian12.TFolder) {
          fFolder = af;
        } else {
          new import_obsidian12.Notice(`Export path is not a folder. Saving to vault root.`);
          fFolder = this.app.vault.getRoot();
        }
      } else {
        fFolder = this.app.vault.getRoot();
      }
      if (!fFolder) {
        this.plugin.logger.error("Target folder for export could not be determined.");
        new import_obsidian12.Notice("Export folder error.");
        notice.hide();
        return;
      }
      const filePath = (0, import_obsidian12.normalizePath)(`${fFolder.path}/${filename}`);
      const file = await this.app.vault.create(filePath, md);
      new import_obsidian12.Notice(`Chat exported to ${file.path}`);
    } catch (e) {
      this.plugin.logger.error(`Chat export error:`, e);
      new import_obsidian12.Notice("Chat export failed.");
    } finally {
      notice.hide();
    }
  }
  async handleContextMenuClear(chatId, chatName) {
    new ConfirmModal(this.app, "Clear Messages", `Clear all messages in "${chatName}"?`, async () => {
      const notice = new import_obsidian12.Notice("Clearing messages...", 0);
      try {
        const success = await this.plugin.chatManager.clearChatMessagesById(chatId);
      } catch (e) {
        this.plugin.logger.error(`Clear messages error:`, e);
        new import_obsidian12.Notice("Failed to clear messages.");
      } finally {
        notice.hide();
      }
    }).open();
  }
  async handleContextMenuDelete(chatId, chatName) {
    new ConfirmModal(this.app, "Delete Chat", `Delete chat "${chatName}"? This cannot be undone.`, async () => {
      const notice = new import_obsidian12.Notice("Deleting chat...", 0);
      try {
        const success = await this.plugin.chatManager.deleteChat(chatId);
      } catch (e) {
        this.plugin.logger.error(`Delete chat error:`, e);
        new import_obsidian12.Notice("Failed to delete chat.");
      } finally {
        notice.hide();
      }
    }).open();
  }
  formatChatToMarkdown(messagesToFormat, metadata) {
    var _a;
    let localLastDate = null;
    const exportTimestamp = new Date();
    let markdown = `# AI Forge Chat: ${metadata.name}

`;
    markdown += `* **Chat ID:** ${metadata.id}
`;
    markdown += `* **Model:** ${metadata.modelName || "Default"}
`;
    markdown += `* **Role Path:** ${metadata.selectedRolePath || "None"}
`;
    markdown += `* **Temperature:** ${(_a = metadata.temperature) != null ? _a : this.plugin.settings.temperature}
`;
    markdown += `* **Created:** ${new Date(metadata.createdAt).toLocaleString()}
`;
    markdown += `* **Last Modified:** ${new Date(metadata.lastModified).toLocaleString()}
`;
    markdown += `* **Exported:** ${exportTimestamp.toLocaleString()}

`;
    markdown += `***

`;
    messagesToFormat.forEach((message) => {
      var _a2;
      if (!message || !((_a2 = message.content) == null ? void 0 : _a2.trim()) || !message.timestamp) {
        return;
      }
      let messageTimestamp;
      if (typeof message.timestamp === "string") {
        messageTimestamp = new Date(message.timestamp);
      } else if (message.timestamp instanceof Date) {
        messageTimestamp = message.timestamp;
      } else {
        return;
      }
      if (isNaN(messageTimestamp.getTime())) {
        return;
      }
      if (localLastDate === null || !this.isSameDay(localLastDate, messageTimestamp)) {
        if (localLastDate !== null)
          markdown += `***

`;
        markdown += `**${this.formatDateSeparator(messageTimestamp)}**
***

`;
        localLastDate = messageTimestamp;
      }
      const time = this.formatTime(messageTimestamp);
      let prefix = "";
      let contentPrefix = "";
      let content = message.content.trim();
      if (message.role === "assistant") {
        try {
          content = decodeHtmlEntities(content);
          if (detectThinkingTags(content).hasThinkingTags) {
            content = content.replace(/<thinking>[\s\S]*?<\/thinking>/g, "").trim();
            content = content.replace(/<think>[\s\S]*?<\/think>/g, "").trim();
          }
        } catch (e) {
        }
        if (!content)
          return;
      }
      switch (message.role) {
        case "user":
          prefix = `**User (${time}):**
`;
          break;
        case "assistant":
          prefix = `**Assistant (${time}):**
`;
          break;
        case "system":
          prefix = `> _[System (${time})]_ 
> `;
          contentPrefix = "> ";
          break;
        case "error":
          prefix = `> [!ERROR] Error (${time}):
> `;
          contentPrefix = "> ";
          break;
        default:
          prefix = `**${message.role} (${time}):**
`;
          break;
      }
      markdown += prefix;
      if (contentPrefix) {
        markdown += content.split("\n").map((line) => line.trim() ? `${contentPrefix}${line}` : contentPrefix.trim()).join(`
`) + "\n\n";
      } else if (content.includes("```")) {
        content = content.replace(/(\r?\n)*```/g, "\n\n```").replace(/```(\r?\n)*/g, "```\n\n").trim();
        markdown += content + "\n\n";
      } else {
        markdown += content.split("\n").map((line) => line.trim() ? line : "").join("\n") + "\n\n";
      }
    });
    return markdown.trim();
  }
  formatTime(date) {
    if (!(date instanceof Date) || isNaN(date.getTime()))
      return "??:??";
    return date.toLocaleTimeString(void 0, { hour: "numeric", minute: "2-digit", hour12: false });
  }
  formatDateSeparator(date) {
    if (!(date instanceof Date) || isNaN(date.getTime()))
      return "Unknown Date";
    const now = new Date();
    const yesterday = new Date(now);
    yesterday.setDate(now.getDate() - 1);
    if (this.isSameDay(date, now))
      return "Today";
    if (this.isSameDay(date, yesterday))
      return "Yesterday";
    const startOfToday = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const startOfGivenDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
    const diffDays = Math.floor((startOfToday.getTime() - startOfGivenDate.getTime()) / (1e3 * 60 * 60 * 24));
    if (diffDays > 1 && diffDays < 7) {
      return date.toLocaleDateString(void 0, { weekday: "long" });
    }
    return date.toLocaleDateString(void 0, { year: "numeric", month: "long", day: "numeric" });
  }
  formatRelativeDate(date) {
    if (!(date instanceof Date) || isNaN(date.getTime())) {
      return "Invalid date";
    }
    const now = new Date();
    const diffSeconds = Math.round((now.getTime() - date.getTime()) / 1e3);
    const diffMinutes = Math.floor(diffSeconds / 60);
    const diffHours = Math.floor(diffMinutes / 60);
    const diffDays = Math.floor(diffHours / 24);
    if (diffSeconds < 5)
      return "Just now";
    if (diffSeconds < 60)
      return `${diffSeconds}s ago`;
    if (diffMinutes < 60)
      return `${diffMinutes}m ago`;
    if (diffHours < 2)
      return `1h ago`;
    if (diffHours < 24)
      return `${diffHours}h ago`;
    if (diffDays === 1)
      return "Yesterday";
    if (diffDays < 7)
      return `${diffDays}d ago`;
    return date.toLocaleDateString(void 0, {
      month: "short",
      day: "numeric",
      year: date.getFullYear() !== now.getFullYear() ? "numeric" : void 0
    });
  }
  isSameDay(date1, date2) {
    if (!(date1 instanceof Date) || !(date2 instanceof Date) || isNaN(date1.getTime()) || isNaN(date2.getTime()))
      return false;
    return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate();
  }
  destroy() {
    var _a;
    (_a = this.containerEl) == null ? void 0 : _a.remove();
    this.folderExpansionState.clear();
  }
};

// src/DropdownMenuManager.ts
var import_obsidian13 = require("obsidian");
var CSS_CLASS_MENU_DROPDOWN = "menu-dropdown";
var CSS_CLASS_MENU_OPTION2 = "menu-option";
var CSS_CLASS_MENU_HEADER_ITEM = "menu-header-item";
var CSS_CLASS_SUBMENU_ICON = "submenu-icon";
var CSS_CLASS_SUBMENU_CONTENT = "submenu-content";
var CSS_CLASS_SETTINGS_OPTION = "settings-option";
var CSS_CLASS_MENU_SEPARATOR = "menu-separator";
var CSS_CLASS_CLEAR_CHAT_OPTION = "clear-chat-option";
var CSS_CLASS_EXPORT_CHAT_OPTION = "export-chat-option";
var CSS_CLASS_MODEL_OPTION = "model-option";
var CSS_CLASS_MODEL_LIST_CONTAINER = "model-list-container";
var CSS_CLASS_ROLE_OPTION = "role-option";
var CSS_CLASS_ROLE_LIST_CONTAINER = "role-list-container";
var CSS_CLASS_CHAT_OPTION = "chat-option";
var CSS_CLASS_CHAT_LIST_CONTAINER = "chat-list-container";
var CSS_CLASS_CHAT_LIST_SCROLLABLE = "chat-list-scrollable";
var CSS_CLASS_NEW_CHAT_OPTION = "new-chat-option";
var CSS_CLASS_RENAME_CHAT_OPTION = "rename-chat-option";
var CSS_CLASS_DELETE_CHAT_OPTION = "delete-chat-option";
var CSS_CLASS_CLONE_CHAT_OPTION = "clone-chat-option";
var CSS_CLASS_TOGGLE_VIEW_LOCATION = "toggle-view-location-option";
var CSS_CLASS_CHAT_LIST_ITEM = "ollama-chat-list-item";
var CSS_HR_AFTER_MODEL = "hr-after-model";
var CSS_HR_AFTER_ROLE = "hr-after-role";
var CSS_HR_AFTER_CHAT = "hr-after-chat";
var CSS_HR_AFTER_ACTIONS = "hr-after-actions";
var CSS_HR_AFTER_DANGER = "hr-after-danger";
var CSS_HR_AFTER_TOGGLE = "hr-after-toggle";
var CHAT_LIST_MAX_HEIGHT = "250px";
var DropdownMenuManager = class {
  constructor(plugin, app, view, parentElement, isSidebarLocation, isDesktop) {
    this.listeners = [];
    // --- Submenu Logic ---
    this.createSubmenuSection = (title, icon, listContainerClass, sectionClass) => {
      const section = this.menuDropdown.createDiv();
      if (sectionClass)
        section.addClass(sectionClass);
      const header = section.createDiv({
        cls: `${CSS_CLASS_MENU_OPTION2} ${CSS_CLASS_MENU_HEADER_ITEM}`
      });
      (0, import_obsidian13.setIcon)(header.createSpan({ cls: "menu-option-icon" }), icon);
      header.createSpan({ cls: "menu-option-text", text: title });
      (0, import_obsidian13.setIcon)(header.createSpan({ cls: CSS_CLASS_SUBMENU_ICON }), "chevron-right");
      const isChatList = listContainerClass === CSS_CLASS_CHAT_LIST_CONTAINER;
      const content = section.createDiv({
        cls: `${CSS_CLASS_SUBMENU_CONTENT} ${CSS_CLASSES.SUBMENU_CONTENT_HIDDEN} ${listContainerClass} ${isChatList ? CSS_CLASS_CHAT_LIST_SCROLLABLE : ""}`
      });
      content.style.maxHeight = "0";
      content.style.overflow = "hidden";
      content.style.transition = "max-height 0.3s ease-out, padding 0.3s ease-out";
      content.style.paddingTop = "0";
      content.style.paddingBottom = "0";
      return { header, content, section };
    };
    this.plugin = plugin;
    this.app = app;
    this.view = view;
    this.parentElement = parentElement;
    this.isSidebarLocation = isSidebarLocation;
    this.isDesktop = isDesktop;
    this.plugin.logger.info(`[DropdownMenuManager] Initialized. isSidebarLocation: ${isSidebarLocation}, isDesktop: ${isDesktop}`);
  }
  // --- ОСНОВНИЙ МЕТОД СТВОРЕННЯ МЕНЮ З КЛАСАМИ ДЛЯ РОЗДІЛЬНИКІВ ---
  createMenuUI() {
    this.plugin.logger.debug(`[DropdownMenuManager] Creating FULL menu structure for CSS control...`);
    this.menuDropdown = this.parentElement.createEl("div", { cls: [CSS_CLASS_MENU_DROPDOWN, "ollama-chat-menu"] });
    this.menuDropdown.style.display = "none";
    this.menuDropdown.classList.toggle("is-desktop", this.isDesktop);
    this.menuDropdown.classList.toggle("is-mobile-tablet", !this.isDesktop);
    this.menuDropdown.classList.toggle("is-sidebar-location", this.isSidebarLocation);
    this.menuDropdown.classList.toggle("is-tab-location", !this.isSidebarLocation);
    this.plugin.logger.debug(`[DropdownMenuManager] Added classes: ${this.menuDropdown.className}`);
    const modelSection = this.createSubmenuSection("Select Model", "list-collapse", CSS_CLASS_MODEL_LIST_CONTAINER, "model-submenu-section");
    this.modelSubmenuHeader = modelSection.header;
    this.modelSubmenuContent = modelSection.content;
    this.menuDropdown.createEl("hr", { cls: [CSS_CLASS_MENU_SEPARATOR, CSS_HR_AFTER_MODEL] });
    const roleDropdownSection = this.createSubmenuSection("Select Role", "users", CSS_CLASS_ROLE_LIST_CONTAINER, "role-submenu-section");
    this.roleSubmenuHeader = roleDropdownSection.header;
    this.roleSubmenuContent = roleDropdownSection.content;
    this.menuDropdown.createEl("hr", { cls: [CSS_CLASS_MENU_SEPARATOR, CSS_HR_AFTER_ROLE] });
    const chatDropdownSection = this.createSubmenuSection("Load Chat", "messages-square", CSS_CLASS_CHAT_LIST_CONTAINER, "chat-submenu-section");
    this.chatSubmenuHeader = chatDropdownSection.header;
    this.chatSubmenuContent = chatDropdownSection.content;
    this.menuDropdown.createEl("hr", { cls: [CSS_CLASS_MENU_SEPARATOR, CSS_HR_AFTER_CHAT] });
    this.newChatOption = this.createActionItem("plus-circle", "New Chat", CSS_CLASS_NEW_CHAT_OPTION);
    this.renameChatOption = this.createActionItem("pencil", "Rename Chat", CSS_CLASS_RENAME_CHAT_OPTION);
    this.cloneChatOption = this.createActionItem("copy-plus", "Clone Chat", CSS_CLASS_CLONE_CHAT_OPTION);
    this.exportChatOption = this.createActionItem("download", "Export Chat to Note", CSS_CLASS_EXPORT_CHAT_OPTION);
    this.menuDropdown.createEl("hr", { cls: [CSS_CLASS_MENU_SEPARATOR, CSS_HR_AFTER_ACTIONS] });
    this.clearChatOption = this.createActionItem("trash", "Clear Messages", [CSS_CLASS_CLEAR_CHAT_OPTION, CSS_CLASSES.DANGER_OPTION]);
    this.deleteChatOption = this.createActionItem("trash-2", "Delete Chat", [CSS_CLASS_DELETE_CHAT_OPTION, CSS_CLASSES.DANGER_OPTION]);
    this.menuDropdown.createEl("hr", { cls: [CSS_CLASS_MENU_SEPARATOR, CSS_HR_AFTER_DANGER] });
    this.toggleViewLocationOption = this.menuDropdown.createEl("div", { cls: `${CSS_CLASS_MENU_OPTION2} ${CSS_CLASS_TOGGLE_VIEW_LOCATION}` });
    this.updateToggleViewLocationOption();
    this.menuDropdown.createEl("hr", { cls: [CSS_CLASS_MENU_SEPARATOR, CSS_HR_AFTER_TOGGLE] });
    this.settingsOption = this.createActionItem("settings", "Settings", CSS_CLASS_SETTINGS_OPTION);
    this.plugin.logger.debug("[DropdownMenuManager] FULL Menu UI DOM created with HR classes.");
  }
  // attachEventListeners залишається таким, як у попередній відповіді (додає слухачі до всіх)
  attachEventListeners() {
    if (!this.modelSubmenuHeader)
      console.error("Model header missing");
    if (!this.roleSubmenuHeader)
      console.error("Role header missing");
    if (!this.chatSubmenuHeader)
      console.error("Chat header missing");
    if (!this.newChatOption)
      console.error("New Chat missing");
    if (!this.renameChatOption)
      console.error("Rename Chat missing");
    if (!this.cloneChatOption)
      console.error("Clone Chat missing");
    if (!this.exportChatOption)
      console.error("Export Chat missing");
    if (!this.clearChatOption)
      console.error("Clear Chat missing");
    if (!this.deleteChatOption)
      console.error("Delete Chat missing");
    if (!this.toggleViewLocationOption)
      console.error("Toggle View missing");
    if (!this.settingsOption)
      console.error("Settings missing");
    if (!this.menuDropdown)
      console.error("menuDropdown missing!");
    if (this.modelSubmenuHeader) {
      this.registerListener(this.modelSubmenuHeader, "click", () => {
        this.toggleSubmenu(this.modelSubmenuHeader, this.modelSubmenuContent, "models");
      });
    }
    if (this.roleSubmenuHeader) {
      this.registerListener(this.roleSubmenuHeader, "click", () => {
        this.toggleSubmenu(this.roleSubmenuHeader, this.roleSubmenuContent, "roles");
      });
    }
    if (this.chatSubmenuHeader) {
      this.registerListener(this.chatSubmenuHeader, "click", () => {
        if (this.chatSubmenuContent) {
          this.toggleSubmenu(this.chatSubmenuHeader, this.chatSubmenuContent, "chats");
        }
      });
    }
    if (this.newChatOption)
      this.registerListener(this.newChatOption, "click", this.view.handleNewChatClick);
    if (this.renameChatOption)
      this.registerListener(this.renameChatOption, "click", () => this.view.handleRenameChatClick());
    if (this.cloneChatOption)
      this.registerListener(this.cloneChatOption, "click", this.view.handleCloneChatClick);
    if (this.exportChatOption)
      this.registerListener(this.exportChatOption, "click", this.view.handleExportChatClick);
    if (this.clearChatOption)
      this.registerListener(this.clearChatOption, "click", this.view.handleClearChatClick);
    if (this.deleteChatOption)
      this.registerListener(this.deleteChatOption, "click", this.view.handleDeleteChatClick);
    if (this.toggleViewLocationOption)
      this.registerListener(this.toggleViewLocationOption, "click", this.view.handleToggleViewLocationClick);
    if (this.settingsOption)
      this.registerListener(this.settingsOption, "click", this.view.handleSettingsClick);
  }
  createActionItem(icon, text, cssClass) {
    const itemEl = this.menuDropdown.createEl("div", {
      cls: Array.isArray(cssClass) ? [CSS_CLASS_MENU_OPTION2, ...cssClass] : [CSS_CLASS_MENU_OPTION2, cssClass]
    });
    (0, import_obsidian13.setIcon)(itemEl.createSpan({ cls: "menu-option-icon" }), icon);
    itemEl.createSpan({ cls: "menu-option-text", text });
    return itemEl;
  }
  registerListener(element, type, handler) {
    const eventHandler = handler;
    element.addEventListener(type, eventHandler);
    this.listeners.push({ element, type, handler: eventHandler });
  }
  destroy() {
    this.plugin.logger.debug("[DropdownMenuManager] Destroying listeners...");
    this.listeners.forEach(({ element, type, handler }) => {
      element.removeEventListener(type, handler);
    });
    this.listeners = [];
    this.plugin.logger.debug("[DropdownMenuManager] Listeners destroyed.");
  }
  // --- Menu Visibility and State ---
  isMenuOpen() {
    return !!this.menuDropdown && this.menuDropdown.style.display === "block";
  }
  toggleMenu(event) {
    event.stopPropagation();
    if (!this.menuDropdown) {
      console.error("[DropdownMenuManager] menuDropdown missing!");
      return;
    }
    const isHidden = this.menuDropdown.style.display === "none";
    if (isHidden) {
      this.plugin.logger.debug("[DropdownMenuManager] Opening menu.");
      this.menuDropdown.style.display = "block";
      this.collapseAllSubmenus(null);
    } else {
      this.plugin.logger.debug("[DropdownMenuManager] Closing menu via toggle.");
      this.closeMenu();
    }
  }
  closeMenu() {
    if (this.menuDropdown) {
      this.plugin.logger.debug("[DropdownMenuManager] Closing menu.");
      this.menuDropdown.style.display = "none";
      this.collapseAllSubmenus(null);
    }
  }
  handleDocumentClick(event, menuButton) {
    var _a;
    if (this.isMenuOpen() && !(menuButton == null ? void 0 : menuButton.contains(event.target)) && !((_a = this.menuDropdown) == null ? void 0 : _a.contains(event.target))) {
      this.plugin.logger.debug("[DropdownMenuManager] Closing menu due to outside click.");
      this.closeMenu();
    }
  }
  async toggleSubmenu(headerEl, contentEl, type) {
    if (!headerEl || !contentEl)
      return;
    const iconEl = headerEl.querySelector(`.${CSS_CLASS_SUBMENU_ICON}`);
    const isHidden = contentEl.style.maxHeight === "0px" || contentEl.classList.contains(CSS_CLASSES.SUBMENU_CONTENT_HIDDEN);
    if (isHidden) {
      this.collapseAllSubmenus(contentEl);
    }
    if (isHidden) {
      if (iconEl instanceof HTMLElement)
        (0, import_obsidian13.setIcon)(iconEl, "chevron-down");
      contentEl.empty();
      contentEl.createDiv({
        cls: "menu-loading",
        text: `Loading ${type}...`
      });
      contentEl.classList.remove(CSS_CLASSES.SUBMENU_CONTENT_HIDDEN);
      contentEl.style.maxHeight = "40px";
      contentEl.style.paddingTop = "5px";
      contentEl.style.paddingBottom = "5px";
      contentEl.style.overflowY = "hidden";
      try {
        this.plugin.logger.debug(`[DropdownMenuManager] Toggling submenu open: ${type}`);
        switch (type) {
          case "models":
            await this.renderModelList();
            break;
          case "roles":
            await this.renderRoleList();
            break;
          case "chats":
            await this.renderChatListMenu();
            break;
        }
        requestAnimationFrame(() => {
          if (!contentEl.classList.contains(CSS_CLASSES.SUBMENU_CONTENT_HIDDEN)) {
            this.plugin.logger.trace(`[DropdownMenuManager] Setting submenu height for ${type}`);
            if (type === "chats") {
              contentEl.style.maxHeight = CHAT_LIST_MAX_HEIGHT;
              contentEl.style.overflowY = "auto";
            } else {
              contentEl.style.maxHeight = contentEl.scrollHeight + "px";
              contentEl.style.overflowY = "hidden";
            }
          }
        });
      } catch (error) {
        this.plugin.logger.error(`[DropdownMenuManager] Error rendering ${type} list:`, error);
        contentEl.empty();
        contentEl.createDiv({ cls: "menu-error-text", text: `Error loading ${type}.` });
        contentEl.style.maxHeight = "50px";
        contentEl.style.overflowY = "hidden";
      }
    } else {
      this.plugin.logger.debug(`[DropdownMenuManager] Toggling submenu closed: ${type}`);
      contentEl.classList.add(CSS_CLASSES.SUBMENU_CONTENT_HIDDEN);
      contentEl.style.maxHeight = "0";
      contentEl.style.paddingTop = "0";
      contentEl.style.paddingBottom = "0";
      contentEl.style.overflowY = "hidden";
      if (iconEl instanceof HTMLElement)
        (0, import_obsidian13.setIcon)(iconEl, "chevron-right");
    }
  }
  collapseAllSubmenus(exceptContent) {
    const submenus = [
      { header: this.modelSubmenuHeader, content: this.modelSubmenuContent },
      { header: this.roleSubmenuHeader, content: this.roleSubmenuContent },
      { header: this.chatSubmenuHeader, content: this.chatSubmenuContent }
    ];
    submenus.forEach((submenu) => {
      if (submenu.content && submenu.header && submenu.content !== exceptContent) {
        if (!submenu.content.classList.contains(CSS_CLASSES.SUBMENU_CONTENT_HIDDEN)) {
          this.plugin.logger.trace(`[DropdownMenuManager] Collapsing submenu.`);
          submenu.content.classList.add(CSS_CLASSES.SUBMENU_CONTENT_HIDDEN);
          submenu.content.style.maxHeight = "0";
          submenu.content.style.paddingTop = "0";
          submenu.content.style.paddingBottom = "0";
          submenu.content.style.overflowY = "hidden";
          const iconEl = submenu.header.querySelector(`.${CSS_CLASS_SUBMENU_ICON}`);
          if (iconEl instanceof HTMLElement) {
            (0, import_obsidian13.setIcon)(iconEl, "chevron-right");
          }
        }
      }
    });
  }
  // --- List Rendering / Update ---
  async renderModelList() {
    var _a, _b;
    const container = this.modelSubmenuContent;
    if (!container)
      return;
    this.plugin.logger.debug("[DropdownMenuManager] Rendering model list...");
    container.empty();
    const modelIconMap = { llama: "box-minimal", mistral: "wind" };
    const defaultIcon = "box";
    try {
      const models = await this.plugin.ollamaService.getModels();
      const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
      const currentModelName = ((_b = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _b.modelName) || this.plugin.settings.modelName;
      if (models.length === 0) {
        container.createEl("div", { cls: "menu-info-text", text: "No models available." });
        return;
      }
      models.forEach((modelName) => {
        const optionEl = container.createDiv({ cls: `${CSS_CLASS_MENU_OPTION2} ${CSS_CLASS_MODEL_OPTION}` });
        const iconSpan = optionEl.createEl("span", { cls: "menu-option-icon" });
        let iconToUse = defaultIcon;
        if (modelName === currentModelName) {
          iconToUse = "check";
          optionEl.addClass("is-selected");
        } else {
          const l = modelName.toLowerCase();
          let f = false;
          for (const k in modelIconMap) {
            if (l.includes(k)) {
              iconToUse = modelIconMap[k];
              f = true;
              break;
            }
          }
          if (!f)
            iconToUse = defaultIcon;
        }
        try {
          (0, import_obsidian13.setIcon)(iconSpan, iconToUse);
        } catch (e) {
          iconSpan.style.minWidth = "18px";
        }
        optionEl.createEl("span", { cls: "menu-option-text", text: modelName });
        this.registerListener(optionEl, "click", async () => {
          var _a2, _b2;
          this.plugin.logger.debug(`[DropdownMenuManager] Model selected: ${modelName}`);
          const latestChat = await ((_a2 = this.plugin.chatManager) == null ? void 0 : _a2.getActiveChat());
          const latestModel = ((_b2 = latestChat == null ? void 0 : latestChat.metadata) == null ? void 0 : _b2.modelName) || this.plugin.settings.modelName;
          if (modelName !== latestModel) {
            if (latestChat) {
              await this.plugin.chatManager.updateActiveChatMetadata({ modelName });
            } else {
              new import_obsidian13.Notice("Cannot set model: No active chat.");
            }
          }
          this.closeMenu();
        });
      });
    } catch (error) {
      this.plugin.logger.error("[DropdownMenuManager] Error rendering model list:", error);
      container.empty();
      container.createEl("div", { cls: "menu-error-text", text: "Error loading models." });
    }
  }
  async renderRoleList() {
    var _a, _b, _c;
    const container = this.roleSubmenuContent;
    if (!container)
      return;
    this.plugin.logger.debug("[DropdownMenuManager] Rendering role list...");
    container.empty();
    try {
      const roles = await this.plugin.listRoleFiles(true);
      const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
      const currentChatRolePath = (_c = (_b = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _b.selectedRolePath) != null ? _c : this.plugin.settings.selectedRolePath;
      const noRoleOptionEl = container.createDiv({ cls: `${CSS_CLASS_MENU_OPTION2} ${CSS_CLASS_ROLE_OPTION}` });
      const noRoleIconSpan = noRoleOptionEl.createEl("span", { cls: "menu-option-icon" });
      if (!currentChatRolePath) {
        (0, import_obsidian13.setIcon)(noRoleIconSpan, "check");
        noRoleOptionEl.addClass("is-selected");
      } else {
        (0, import_obsidian13.setIcon)(noRoleIconSpan, "slash");
        noRoleIconSpan.style.minWidth = "18px";
      }
      noRoleOptionEl.createEl("span", { cls: "menu-option-text", text: "None" });
      this.registerListener(noRoleOptionEl, "click", async () => {
        var _a2, _b2, _c2, _d, _e;
        this.plugin.logger.debug(`[DropdownMenuManager] Role selected: None`);
        const newRolePath = "";
        const latestChat = await ((_a2 = this.plugin.chatManager) == null ? void 0 : _a2.getActiveChat());
        const latestRolePath = (_c2 = (_b2 = latestChat == null ? void 0 : latestChat.metadata) == null ? void 0 : _b2.selectedRolePath) != null ? _c2 : this.plugin.settings.selectedRolePath;
        if (latestRolePath !== newRolePath) {
          this.plugin.logger.trace(`Current path '${latestRolePath}', new path '${newRolePath}'`);
          if (latestChat) {
            await this.plugin.chatManager.updateActiveChatMetadata({ selectedRolePath: newRolePath });
          } else {
            this.plugin.settings.selectedRolePath = newRolePath;
            await this.plugin.saveSettings();
            this.plugin.emit("role-changed", "None");
            (_e = (_d = this.plugin.promptService) == null ? void 0 : _d.clearRoleCache) == null ? void 0 : _e.call(_d);
          }
        }
        this.closeMenu();
      });
      if (roles.length > 0)
        container.createEl("hr", { cls: CSS_CLASS_MENU_SEPARATOR });
      roles.forEach((roleInfo) => {
        const roleOptionEl = container.createDiv({ cls: `${CSS_CLASS_MENU_OPTION2} ${CSS_CLASS_ROLE_OPTION}` });
        if (roleInfo.isCustom)
          roleOptionEl.addClass("is-custom");
        const iconSpan = roleOptionEl.createEl("span", { cls: "menu-option-icon" });
        if (roleInfo.path === currentChatRolePath) {
          (0, import_obsidian13.setIcon)(iconSpan, "check");
          roleOptionEl.addClass("is-selected");
        } else {
          (0, import_obsidian13.setIcon)(iconSpan, roleInfo.isCustom ? "user" : "box");
          iconSpan.style.minWidth = "18px";
        }
        roleOptionEl.createEl("span", { cls: "menu-option-text", text: roleInfo.name });
        this.registerListener(roleOptionEl, "click", async () => {
          var _a2, _b2, _c2, _d, _e;
          this.plugin.logger.debug(`[DropdownMenuManager] Role selected: ${roleInfo.name} (${roleInfo.path})`);
          const newRolePath = roleInfo.path;
          const latestChat = await ((_a2 = this.plugin.chatManager) == null ? void 0 : _a2.getActiveChat());
          const latestRolePath = (_c2 = (_b2 = latestChat == null ? void 0 : latestChat.metadata) == null ? void 0 : _b2.selectedRolePath) != null ? _c2 : this.plugin.settings.selectedRolePath;
          if (latestRolePath !== newRolePath) {
            this.plugin.logger.trace(`Current path '${latestRolePath}', new path '${newRolePath}'`);
            if (latestChat) {
              await this.plugin.chatManager.updateActiveChatMetadata({ selectedRolePath: newRolePath });
            } else {
              this.plugin.settings.selectedRolePath = newRolePath;
              await this.plugin.saveSettings();
              this.plugin.emit("role-changed", roleInfo.name);
              (_e = (_d = this.plugin.promptService) == null ? void 0 : _d.clearRoleCache) == null ? void 0 : _e.call(_d);
            }
          }
          this.closeMenu();
        });
      });
    } catch (error) {
      this.plugin.logger.error("[DropdownMenuManager] Error rendering role list:", error);
      container.empty();
      container.createEl("div", { cls: "menu-error-text", text: "Error loading roles." });
    }
  }
  async renderChatListMenu() {
    var _a, _b;
    const container = this.chatSubmenuContent;
    if (!container) {
      this.plugin.logger.warn("[DropdownMenuManager] Chat submenu container not found!");
      return;
    }
    this.plugin.logger.debug("[DropdownMenuManager] Rendering chat list...");
    container.empty();
    try {
      const chats = ((_a = this.plugin.chatManager) == null ? void 0 : _a.listAvailableChats()) || [];
      const currentActiveId = (_b = this.plugin.chatManager) == null ? void 0 : _b.getActiveChatId();
      if (chats.length === 0) {
        container.createEl("div", { cls: "menu-info-text", text: "No saved chats." });
        this.plugin.logger.debug("[DropdownMenuManager] Rendered 'No saved chats.' message.");
        return;
      }
      this.plugin.logger.debug(`[DropdownMenuManager] Rendering ${chats.length} chats. Active ID: ${currentActiveId}`);
      chats.forEach((chatMeta) => {
        const chatOptionEl = container.createDiv({
          cls: [CSS_CLASS_MENU_OPTION2, CSS_CLASS_CHAT_LIST_ITEM, CSS_CLASS_CHAT_OPTION]
        });
        const iconSpan = chatOptionEl.createEl("span", { cls: "menu-option-icon" });
        if (chatMeta.id === currentActiveId) {
          (0, import_obsidian13.setIcon)(iconSpan, "check");
          chatOptionEl.addClass("is-selected");
        } else {
          (0, import_obsidian13.setIcon)(iconSpan, "message-square");
        }
        const textSpan = chatOptionEl.createEl("span", { cls: "menu-option-text" });
        textSpan.createEl("div", { cls: "chat-option-name", text: chatMeta.name });
        const lastModifiedDate = new Date(chatMeta.lastModified);
        const dateText = !isNaN(lastModifiedDate.getTime()) ? this.view.formatRelativeDate(lastModifiedDate) : "Invalid date";
        if (dateText === "Invalid date") {
          this.plugin.logger.warn(`[DropdownMenuManager] Invalid date parsed for chat ${chatMeta.id}`);
        }
        textSpan.createEl("div", { cls: "chat-option-date", text: dateText });
        this.registerListener(chatOptionEl, "click", async () => {
          var _a2;
          this.plugin.logger.debug(`[DropdownMenuManager] Chat selected: ${chatMeta.name} (${chatMeta.id})`);
          const latestActiveId = (_a2 = this.plugin.chatManager) == null ? void 0 : _a2.getActiveChatId();
          if (chatMeta.id !== latestActiveId) {
            await this.plugin.chatManager.setActiveChat(chatMeta.id);
          }
          this.closeMenu();
        });
      });
      this.plugin.logger.debug("[DropdownMenuManager] Finished rendering chat list successfully.");
    } catch (error) {
      this.plugin.logger.error("[DropdownMenuManager] Error rendering chat list:", error);
      container.empty();
      container.createEl("div", { cls: "menu-error-text", text: "Error loading chats." });
    }
  }
  // --- UI Updates ---
  updateToggleViewLocationOption() {
    if (!this.toggleViewLocationOption)
      return;
    this.toggleViewLocationOption.empty();
    const iconSpan = this.toggleViewLocationOption.createSpan({ cls: "menu-option-icon" });
    const textSpan = this.toggleViewLocationOption.createSpan({ cls: "menu-option-text" });
    if (this.plugin.settings.openChatInTab) {
      (0, import_obsidian13.setIcon)(iconSpan, "sidebar-right");
      textSpan.setText("Show in Sidebar");
      this.toggleViewLocationOption.title = "Close tab and reopen in sidebar";
    } else {
      (0, import_obsidian13.setIcon)(iconSpan, "layout-list");
      textSpan.setText("Show in Tab");
      this.toggleViewLocationOption.title = "Close sidebar panel and reopen in tab";
    }
  }
  // --- Update Trigger Methods (Called by OllamaView) ---
  async updateModelListIfVisible() {
    if (this.isMenuOpen() && this.modelSubmenuContent && !this.modelSubmenuContent.classList.contains(CSS_CLASSES.SUBMENU_CONTENT_HIDDEN)) {
      this.plugin.logger.debug("[DropdownMenuManager] Model submenu open, refreshing model list.");
      await this.renderModelList();
      this.updateSubmenuHeight(this.modelSubmenuContent);
    }
  }
  async updateRoleListIfVisible() {
    if (this.isMenuOpen() && this.roleSubmenuContent && !this.roleSubmenuContent.classList.contains(CSS_CLASSES.SUBMENU_CONTENT_HIDDEN)) {
      this.plugin.logger.debug("[DropdownMenuManager] Role submenu open, refreshing role list.");
      await this.renderRoleList();
      this.updateSubmenuHeight(this.roleSubmenuContent);
    }
  }
  async updateChatListIfVisible() {
    if (this.isMenuOpen() && this.chatSubmenuContent && !this.chatSubmenuContent.classList.contains(CSS_CLASSES.SUBMENU_CONTENT_HIDDEN)) {
      this.plugin.logger.debug("[DropdownMenuManager] Chat submenu open, refreshing chat list.");
      await this.renderChatListMenu();
    }
  }
  updateSubmenuHeight(contentEl) {
    if (contentEl && !contentEl.classList.contains(CSS_CLASSES.SUBMENU_CONTENT_HIDDEN)) {
      requestAnimationFrame(() => {
        if (contentEl && !contentEl.classList.contains(CSS_CLASSES.SUBMENU_CONTENT_HIDDEN)) {
          this.plugin.logger.trace("[DropdownMenuManager] Updating submenu height.");
          if (!contentEl.classList.contains(CSS_CLASS_CHAT_LIST_CONTAINER)) {
            contentEl.style.maxHeight = contentEl.scrollHeight + "px";
          }
        }
      });
    }
  }
};

// src/OllamaView.ts
var VIEW_TYPE_OLLAMA_PERSONAS = "ollama-personas-chat-view";
var SCROLL_THRESHOLD = 150;
var CSS_CLASS_TRANSLATING_INPUT = "translating-input";
var CSS_CLASS_EMPTY_STATE = "ollama-empty-state";
var CSS_CLASS_MESSAGE = "message";
var CSS_CLASS_ERROR_TEXT2 = "error-message-text";
var CSS_CLASS_TRANSLATION_CONTAINER = "translation-container";
var CSS_CLASS_TRANSLATION_CONTENT = "translation-content";
var CSS_CLASS_TRANSLATION_PENDING = "translation-pending";
var CSS_CLASS_RECORDING = "recording";
var CSS_CLASS_DISABLED = "disabled";
var CSS_CLASS_DATE_SEPARATOR = "chat-date-separator";
var CSS_CLASS_VISIBLE = "visible";
var CSS_CLASS_CONTENT_COLLAPSED = "message-content-collapsed";
var CSS_CLASS_MENU_OPTION3 = "menu-option";
var CSS_ROLE_PANEL_ITEM2 = "ollama-role-panel-item";
var CSS_ROLE_PANEL_ITEM_ICON2 = "ollama-role-panel-item-icon";
var CSS_ROLE_PANEL_ITEM_TEXT2 = "ollama-role-panel-item-text";
var CSS_ROLE_PANEL_ITEM_ACTIVE2 = "is-active";
var CSS_ROLE_PANEL_ITEM_CUSTOM2 = "is-custom";
var CSS_ROLE_PANEL_ITEM_NONE2 = "ollama-role-panel-item-none";
var CSS_SIDEBAR_SECTION_ICON2 = "ollama-sidebar-section-icon";
var CSS_CHAT_ITEM_OPTIONS = "ollama-chat-item-options";
var CSS_CLASS_CHAT_LIST_ITEM2 = "ollama-chat-list-item";
var CSS_CLASS_RESIZER_HANDLE = "ollama-resizer-handle";
var CSS_CLASS_RESIZING = "is-resizing";
var OllamaView = class extends import_obsidian14.ItemView {
  // Debounced функція для збереження ширини
  // --- Кінець нових властивостей ---
  constructor(leaf, plugin) {
    super(leaf);
    this.isProcessing = false;
    this.scrollTimeout = null;
    this.speechWorker = null;
    this.mediaRecorder = null;
    this.audioStream = null;
    this.emptyStateEl = null;
    this.resizeTimeout = null;
    this.currentMessages = [];
    this.lastRenderedMessageDate = null;
    this.newMessagesIndicatorEl = null;
    this.userScrolledUp = false;
    this.lastProcessedChatId = null;
    this.currentAbortController = null;
    this.lastMessageElement = null;
    this.consecutiveErrorMessages = [];
    this.errorGroupElement = null;
    this.isSummarizingErrors = false;
    this.temporarilyDisableChatChangedReload = false;
    this.isRegenerating = false;
    // Новий прапорець
    this.activePlaceholder = null;
    this.currentMessageAddedResolver = null;
    // Посилання на div роздільника
    this.isResizing = false;
    this.initialMouseX = 0;
    this.initialSidebarWidth = 0;
    this.cancelGeneration = () => {
      this.plugin.logger.debug(`[OllamaView] cancelGeneration called. Current AbortController is ${this.currentAbortController ? "NOT null" : "null"}`);
      if (this.currentAbortController) {
        this.currentAbortController.abort();
        this.plugin.logger.debug(`[OllamaView] Abort signal sent.`);
      } else {
        this.plugin.logger.debug(`[OllamaView] No current AbortController to cancel.`);
      }
    };
    this.handleMessageDeleted = (data) => {
      var _a;
      const currentActiveChatId = (_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChatId();
      if (data.chatId !== currentActiveChatId || !this.chatContainer) {
        this.plugin.logger.debug(
          `handleMessageDeleted: Event ignored (Event chat ${data.chatId} !== active chat ${currentActiveChatId} or container missing).`
        );
        return;
      }
      const timestampMs = data.timestamp.getTime();
      const selector = `.${CSS_CLASSES.MESSAGE_GROUP}[data-timestamp="${timestampMs}"]`;
      try {
        const messageGroupEl = this.chatContainer.querySelector(selector);
        if (messageGroupEl instanceof HTMLElement) {
          this.plugin.logger.debug(
            `handleMessageDeleted: Found message group HTMLElement to remove with selector: ${selector}`
          );
          const currentScrollTop = this.chatContainer.scrollTop;
          const removedHeight = messageGroupEl.offsetHeight;
          const wasAboveViewport = messageGroupEl.offsetTop < currentScrollTop;
          messageGroupEl.remove();
          const initialLength = this.currentMessages.length;
          this.currentMessages = this.currentMessages.filter((msg) => msg.timestamp.getTime() !== timestampMs);
          this.plugin.logger.debug(
            `handleMessageDeleted: Updated local message cache from ${initialLength} to ${this.currentMessages.length} messages.`
          );
          if (wasAboveViewport) {
            const newScrollTop = currentScrollTop - removedHeight;
            this.chatContainer.scrollTop = newScrollTop >= 0 ? newScrollTop : 0;
            this.plugin.logger.debug(
              `handleMessageDeleted: Adjusted scroll top from ${currentScrollTop} to ${this.chatContainer.scrollTop} (removed height: ${removedHeight})`
            );
          } else {
            this.chatContainer.scrollTop = currentScrollTop;
            this.plugin.logger.debug(
              `handleMessageDeleted: Message was not above viewport, scroll top remains at ${currentScrollTop}`
            );
          }
          if (this.currentMessages.length === 0) {
            this.showEmptyState();
          }
        } else if (messageGroupEl) {
          this.plugin.logger.error(
            `handleMessageDeleted: Found element with selector ${selector}, but it is not an HTMLElement. Forcing reload.`,
            messageGroupEl
          );
          this.loadAndDisplayActiveChat();
        } else {
          this.plugin.logger.warn(
            `handleMessageDeleted: Could not find message group element with selector: ${selector}. Maybe already removed or timestamp attribute missing?`
          );
        }
      } catch (error) {
        this.plugin.logger.error(
          `handleMessageDeleted: Error removing message element for timestamp ${timestampMs}:`,
          error
        );
        this.loadAndDisplayActiveChat();
      }
    };
    this.updateRolePanelList = async () => {
      var _a, _b, _c;
      const container = this.rolePanelListEl;
      if (!container || !this.plugin.chatManager) {
        return;
      }
      if (((_a = this.rolePanelHeaderEl) == null ? void 0 : _a.getAttribute("data-collapsed")) === "true") {
        return;
      }
      const currentScrollTop = container.scrollTop;
      container.empty();
      try {
        const roles = await this.plugin.listRoleFiles(true);
        const activeChat = await this.plugin.chatManager.getActiveChat();
        const currentRolePath = (_c = (_b = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _b.selectedRolePath) != null ? _c : this.plugin.settings.selectedRolePath;
        const noneOptionEl = container.createDiv({ cls: [CSS_ROLE_PANEL_ITEM2, CSS_ROLE_PANEL_ITEM_NONE2, "menu-option"] });
        const noneIconSpan = noneOptionEl.createSpan({ cls: [CSS_ROLE_PANEL_ITEM_ICON2, "menu-option-icon"] });
        noneOptionEl.createSpan({ cls: [CSS_ROLE_PANEL_ITEM_TEXT2, "menu-option-text"], text: "None" });
        if (!currentRolePath) {
          noneOptionEl.addClass(CSS_ROLE_PANEL_ITEM_ACTIVE2);
          (0, import_obsidian14.setIcon)(noneIconSpan, "check");
        } else {
          (0, import_obsidian14.setIcon)(noneIconSpan, "slash");
        }
        this.registerDomEvent(noneOptionEl, "click", () => this.handleRolePanelItemClick(null, currentRolePath));
        roles.forEach((roleInfo) => {
          const roleOptionEl = container.createDiv({ cls: [CSS_ROLE_PANEL_ITEM2, "menu-option"] });
          const iconSpan = roleOptionEl.createSpan({ cls: [CSS_ROLE_PANEL_ITEM_ICON2, "menu-option-icon"] });
          roleOptionEl.createSpan({ cls: [CSS_ROLE_PANEL_ITEM_TEXT2, "menu-option-text"], text: roleInfo.name });
          if (roleInfo.isCustom) {
            roleOptionEl.addClass(CSS_ROLE_PANEL_ITEM_CUSTOM2);
          }
          if (roleInfo.path === currentRolePath) {
            roleOptionEl.addClass(CSS_ROLE_PANEL_ITEM_ACTIVE2);
            (0, import_obsidian14.setIcon)(iconSpan, "check");
          } else {
            (0, import_obsidian14.setIcon)(iconSpan, roleInfo.isCustom ? "user" : "file-text");
          }
          this.registerDomEvent(roleOptionEl, "click", () => this.handleRolePanelItemClick(roleInfo, currentRolePath));
        });
      } catch (error) {
        this.plugin.logger.error("[updateRolePanelList] Error rendering role panel list:", error);
        container.empty();
        container.createDiv({ text: "Error loading roles.", cls: "menu-error-text" });
      } finally {
        requestAnimationFrame(() => {
          container.scrollTop = currentScrollTop;
        });
      }
    };
    this.handleRolePanelItemClick = async (roleInfo, currentRolePath) => {
      var _a, _b, _c, _d, _e;
      const newRolePath = (_a = roleInfo == null ? void 0 : roleInfo.path) != null ? _a : "";
      const roleNameForEvent = (_b = roleInfo == null ? void 0 : roleInfo.name) != null ? _b : "None";
      this.plugin.logger.debug(
        `[handleRolePanelItemClick] Clicked role: ${roleNameForEvent} (Path: ${newRolePath || "None"})`
      );
      if (newRolePath !== currentRolePath) {
        const activeChat = await ((_c = this.plugin.chatManager) == null ? void 0 : _c.getActiveChat());
        try {
          if (activeChat) {
            this.plugin.logger.debug(
              `[handleRolePanelItemClick] Setting active role for chat ${activeChat.metadata.id} to: ${newRolePath || "None"}`
            );
            await this.plugin.chatManager.updateActiveChatMetadata({
              selectedRolePath: newRolePath
            });
          } else {
            this.plugin.logger.debug(
              `[handleRolePanelItemClick] No active chat. Setting global default role to: ${newRolePath || "None"}`
            );
            this.plugin.settings.selectedRolePath = newRolePath;
            await this.plugin.saveSettings();
            this.plugin.emit("role-changed", roleNameForEvent);
            (_e = (_d = this.plugin.promptService) == null ? void 0 : _d.clearRoleCache) == null ? void 0 : _e.call(_d);
          }
        } catch (error) {
          this.plugin.logger.error(`[handleRolePanelItemClick] Error setting role to ${newRolePath}:`, error);
          new import_obsidian14.Notice("Failed to set the role.");
        }
      } else {
      }
    };
    this.handleModelDisplayClick = async (event) => {
      var _a, _b;
      const menu = new import_obsidian14.Menu();
      let itemsAdded = false;
      const loadingNotice = new import_obsidian14.Notice("Loading models...", 0);
      try {
        const models = await this.plugin.ollamaService.getModels();
        const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
        const currentModelName = ((_b = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _b.modelName) || this.plugin.settings.modelName;
        loadingNotice.hide();
        if (models.length === 0) {
          menu.addItem((item) => item.setTitle("No models found").setDisabled(true));
          itemsAdded = true;
        } else {
          models.forEach((modelName) => {
            menu.addItem(
              (item) => item.setTitle(modelName).setIcon(modelName === currentModelName ? "check" : "radio-button").onClick(async () => {
                var _a2, _b2;
                const chatToUpdate = await ((_a2 = this.plugin.chatManager) == null ? void 0 : _a2.getActiveChat());
                const latestModelName = ((_b2 = chatToUpdate == null ? void 0 : chatToUpdate.metadata) == null ? void 0 : _b2.modelName) || this.plugin.settings.modelName;
                if (modelName !== latestModelName) {
                  if (chatToUpdate) {
                    await this.plugin.chatManager.updateActiveChatMetadata({
                      modelName
                    });
                  } else {
                    new import_obsidian14.Notice("Cannot set model: No active chat.");
                  }
                }
              })
            );
            itemsAdded = true;
          });
        }
      } catch (error) {
        loadingNotice.hide();
        console.error("Error loading models for model selection menu:", error);
        menu.addItem((item) => item.setTitle("Error loading models").setDisabled(true));
        itemsAdded = true;
        new import_obsidian14.Notice("Failed to load models. Check Ollama connection.");
      } finally {
        if (itemsAdded) {
          menu.showAtMouseEvent(event);
        } else {
          console.warn("Model menu was not shown because no items were added.");
        }
      }
    };
    this.handleKeyDown = (e) => {
      var _a;
      if (e.key === "Enter" && !e.shiftKey && !this.isProcessing && !((_a = this.sendButton) == null ? void 0 : _a.disabled)) {
        e.preventDefault();
        this.sendMessage();
      }
    };
    this.handleSendClick = () => {
      var _a;
      if (!this.isProcessing && !((_a = this.sendButton) == null ? void 0 : _a.disabled)) {
        this.sendMessage();
      } else {
      }
    };
    this.handleInputForResize = () => {
      if (this.resizeTimeout)
        clearTimeout(this.resizeTimeout);
      this.resizeTimeout = setTimeout(() => {
        this.adjustTextareaHeight();
        this.updateSendButtonState();
      }, 75);
    };
    this.handleVoiceClick = () => {
      this.toggleVoiceRecognition();
    };
    this.handleTranslateInputClick = async () => {
      const currentText = this.inputEl.value;
      const targetLang = this.plugin.settings.translationTargetLanguage;
      if (!currentText.trim()) {
        new import_obsidian14.Notice("Input is empty, nothing to translate.");
        return;
      }
      if (!this.plugin.settings.enableTranslation || this.plugin.settings.translationProvider === "none") {
        new import_obsidian14.Notice("Translation disabled or provider not selected in settings.");
        return;
      }
      if (!targetLang) {
        new import_obsidian14.Notice("Target language for translation is not set in settings.");
        return;
      }
      (0, import_obsidian14.setIcon)(this.translateInputButton, "loader");
      this.translateInputButton.disabled = true;
      this.translateInputButton.classList.add(CSS_CLASS_TRANSLATING_INPUT);
      this.translateInputButton.title = "Translating...";
      try {
        const translatedText = await this.plugin.translationService.translate(currentText, "English");
        if (translatedText !== null) {
          this.inputEl.value = translatedText;
          this.inputEl.dispatchEvent(new Event("input"));
          this.inputEl.focus();
          if (translatedText) {
            const end = translatedText.length;
            this.inputEl.setSelectionRange(end, end);
          }
        } else {
        }
      } catch (error) {
        this.plugin.logger.error("[OllamaView] Unexpected error during input translation call:", error);
        new import_obsidian14.Notice("Input translation encountered an unexpected error.");
      } finally {
        (0, import_obsidian14.setIcon)(this.translateInputButton, "languages");
        this.translateInputButton.disabled = this.isProcessing;
        this.translateInputButton.classList.remove(CSS_CLASS_TRANSLATING_INPUT);
        this.translateInputButton.title = `Translate input to ${LANGUAGES[targetLang] || targetLang}`;
      }
    };
    this.handleNewChatClick = async () => {
      var _a;
      this.plugin.logger.error("!!! OllamaView: handleNewChatClick ENTERED !!!");
      (_a = this.dropdownMenuManager) == null ? void 0 : _a.closeMenu();
      try {
        const newChat = await this.plugin.chatManager.createNewChat();
        if (newChat) {
          new import_obsidian14.Notice(`Created new chat: ${newChat.metadata.name}`);
          this.focusInput();
        } else {
          new import_obsidian14.Notice("Failed to create new chat.");
        }
      } catch (error) {
        new import_obsidian14.Notice("Error creating new chat.");
      }
    };
    this.handleRenameChatClick = async (chatIdToRename, currentChatName) => {
      var _a, _b;
      this.plugin.logger.error("!!! OllamaView: handleRenameChatClick ENTERED !!!");
      let chatId = chatIdToRename != null ? chatIdToRename : null;
      let currentName = currentChatName != null ? currentChatName : null;
      if (!chatId || !currentName) {
        const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
        if (!activeChat) {
          new import_obsidian14.Notice("No active chat to rename.");
          return;
        }
        chatId = activeChat.metadata.id;
        currentName = activeChat.metadata.name;
      }
      this.plugin.logger.debug(
        `[handleRenameChatClick] Initiating rename for chat ${chatId} (current name: "${currentName}")`
      );
      (_b = this.dropdownMenuManager) == null ? void 0 : _b.closeMenu();
      if (!chatId || currentName === null) {
        this.plugin.logger.error("[handleRenameChatClick] Failed to determine chat ID or current name.");
        new import_obsidian14.Notice("Could not initiate rename process.");
        return;
      }
      new PromptModal(this.app, "Rename Chat", `Enter new name for "${currentName}":`, currentName, async (newName) => {
        let noticeMessage = "Rename cancelled or name unchanged.";
        const trimmedName = newName == null ? void 0 : newName.trim();
        if (trimmedName && trimmedName !== "" && trimmedName !== currentName) {
          this.plugin.logger.debug(`Attempting rename for chat ${chatId} to "${trimmedName}" via ChatManager.renameChat`);
          const success = await this.plugin.chatManager.renameChat(chatId, trimmedName);
          if (success) {
            noticeMessage = `Chat renamed to "${trimmedName}"`;
          } else {
            noticeMessage = "Failed to rename chat.";
          }
        } else if (trimmedName && trimmedName === currentName) {
          noticeMessage = "Name unchanged.";
        } else if (newName === null || trimmedName === "") {
          noticeMessage = "Rename cancelled or invalid name entered.";
        }
        new import_obsidian14.Notice(noticeMessage);
        this.focusInput();
      }).open();
    };
    this.handleCloneChatClick = async () => {
      var _a, _b;
      (_a = this.dropdownMenuManager) == null ? void 0 : _a.closeMenu();
      const activeChat = await ((_b = this.plugin.chatManager) == null ? void 0 : _b.getActiveChat());
      if (!activeChat) {
        new import_obsidian14.Notice("No active chat to clone.");
        return;
      }
      const originalName = activeChat.metadata.name;
      const cloningNotice = new import_obsidian14.Notice("Cloning chat...", 0);
      try {
        const clonedChat = await this.plugin.chatManager.cloneChat(activeChat.metadata.id);
        if (clonedChat) {
          new import_obsidian14.Notice(`Chat cloned as "${clonedChat.metadata.name}" and activated.`);
        } else {
          new import_obsidian14.Notice("Failed to clone chat.");
        }
      } catch (error) {
        new import_obsidian14.Notice("An error occurred while cloning the chat.");
      } finally {
        cloningNotice.hide();
      }
    };
    this.handleClearChatClick = async () => {
      var _a, _b;
      (_a = this.dropdownMenuManager) == null ? void 0 : _a.closeMenu();
      const activeChat = await ((_b = this.plugin.chatManager) == null ? void 0 : _b.getActiveChat());
      if (activeChat) {
        const chatName = activeChat.metadata.name;
        new ConfirmModal(
          this.app,
          "Clear Chat Messages",
          `Are you sure you want to clear all messages in chat "${chatName}"?
This action cannot be undone.`,
          () => {
            this.plugin.chatManager.clearActiveChatMessages();
          }
        ).open();
      } else {
        new import_obsidian14.Notice("No active chat to clear.");
      }
    };
    this.handleDeleteChatClick = async () => {
      var _a, _b;
      (_a = this.dropdownMenuManager) == null ? void 0 : _a.closeMenu();
      const activeChat = await ((_b = this.plugin.chatManager) == null ? void 0 : _b.getActiveChat());
      if (activeChat) {
        const chatName = activeChat.metadata.name;
        new ConfirmModal(
          this.app,
          "Delete Chat",
          `Are you sure you want to delete chat "${chatName}"?
This action cannot be undone.`,
          async () => {
            const success = await this.plugin.chatManager.deleteChat(activeChat.metadata.id);
            if (success) {
              new import_obsidian14.Notice(`Chat "${chatName}" deleted.`);
            } else {
              new import_obsidian14.Notice(`Failed to delete chat "${chatName}".`);
            }
          }
        ).open();
      } else {
        new import_obsidian14.Notice("No active chat to delete.");
      }
    };
    this.handleExportChatClick = async () => {
      var _a, _b, _c;
      (_a = this.dropdownMenuManager) == null ? void 0 : _a.closeMenu();
      const activeChat = await ((_b = this.plugin.chatManager) == null ? void 0 : _b.getActiveChat());
      if (!activeChat || activeChat.messages.length === 0) {
        new import_obsidian14.Notice("Chat empty, nothing to export.");
        return;
      }
      try {
        const markdownContent = this.formatChatToMarkdown(activeChat.messages);
        const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
        const safeName = activeChat.metadata.name.replace(/[\\/?:*"<>|]/g, "-");
        const filename = `ollama-chat-${safeName}-${timestamp}.md`;
        let targetFolderPath = (_c = this.plugin.settings.chatExportFolderPath) == null ? void 0 : _c.trim();
        let targetFolder = null;
        if (targetFolderPath) {
          targetFolderPath = (0, import_obsidian14.normalizePath)(targetFolderPath);
          const abstractFile = this.app.vault.getAbstractFileByPath(targetFolderPath);
          if (!abstractFile) {
            try {
              await this.app.vault.createFolder(targetFolderPath);
              targetFolder = this.app.vault.getAbstractFileByPath(targetFolderPath);
              if (targetFolder) {
                new import_obsidian14.Notice(`Created export folder: ${targetFolderPath}`);
              } else {
                this.plugin.logger.error("Failed to get folder even after creation attempt:", targetFolderPath);
                new import_obsidian14.Notice(`Error creating export folder. Saving to vault root.`);
                targetFolder = this.app.vault.getRoot();
              }
            } catch (err) {
              this.plugin.logger.error("Error creating export folder:", err);
              new import_obsidian14.Notice(`Error creating export folder. Saving to vault root.`);
              targetFolder = this.app.vault.getRoot();
            }
          } else if (abstractFile instanceof import_obsidian14.TFolder) {
            targetFolder = abstractFile;
          } else {
            new import_obsidian14.Notice(`Error: Export path is not a folder. Saving to vault root.`);
            targetFolder = this.app.vault.getRoot();
          }
        } else {
          targetFolder = this.app.vault.getRoot();
        }
        if (!targetFolder) {
          this.plugin.logger.error("Failed to determine a valid target folder for export.");
          new import_obsidian14.Notice("Error determining export folder. Cannot save file.");
          return;
        }
        const filePath = (0, import_obsidian14.normalizePath)(`${targetFolder.path}/${filename}`);
        const existingFile = this.app.vault.getAbstractFileByPath(filePath);
        if (existingFile) {
        }
        const file = await this.app.vault.create(filePath, markdownContent);
        new import_obsidian14.Notice(`Chat exported to ${file.path}`);
      } catch (error) {
        this.plugin.logger.error("Error exporting chat:", error);
        if (error instanceof Error && error.message.includes("File already exists")) {
          new import_obsidian14.Notice("Error exporting chat: File already exists.");
        } else {
          new import_obsidian14.Notice("An unexpected error occurred during chat export.");
        }
      }
    };
    this.handleSettingsClick = async () => {
      var _a, _b, _c, _d, _e;
      (_a = this.dropdownMenuManager) == null ? void 0 : _a.closeMenu();
      (_c = (_b = this.app.setting) == null ? void 0 : _b.open) == null ? void 0 : _c.call(_b);
      (_e = (_d = this.app.setting) == null ? void 0 : _d.openTabById) == null ? void 0 : _e.call(_d, this.plugin.manifest.id);
    };
    this.handleDocumentClickForMenu = (e) => {
      var _a;
      (_a = this.dropdownMenuManager) == null ? void 0 : _a.handleDocumentClick(e, this.menuButton);
    };
    this.handleModelChange = async (modelName) => {
      var _a, _b, _c, _d;
      this.updateModelDisplay(modelName);
      try {
        const chat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
        const temp = (_c = (_b = chat == null ? void 0 : chat.metadata) == null ? void 0 : _b.temperature) != null ? _c : this.plugin.settings.temperature;
        this.updateTemperatureIndicator(temp);
        if (chat && this.currentMessages.length > 0) {
          await ((_d = this.plugin.chatManager) == null ? void 0 : _d.addMessageToActiveChat("system", `Model changed to: ${modelName}`, new Date()));
        }
      } catch (error) {
        this.plugin.logger.error("Error handling model change notification:", error);
      }
    };
    this.handleRoleChange = async (roleName) => {
      var _a, _b;
      const displayRole = roleName || "None";
      this.updateInputPlaceholder(displayRole);
      this.updateRoleDisplay(displayRole);
      try {
        const chat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
        if (chat && this.currentMessages.length > 0) {
          await ((_b = this.plugin.chatManager) == null ? void 0 : _b.addMessageToActiveChat("system", `Role changed to: ${displayRole}`, new Date()));
        } else {
          new import_obsidian14.Notice(`Role set to: ${displayRole}`);
        }
      } catch (error) {
        this.plugin.logger.error("Error handling role change notification:", error);
        new import_obsidian14.Notice(`Role set to: ${displayRole}`);
      }
    };
    this.handleRolesUpdated = () => {
      var _a, _b;
      (_a = this.plugin.promptService) == null ? void 0 : _a.clearRoleCache();
      if (this.dropdownMenuManager) {
        this.dropdownMenuManager.updateRoleListIfVisible().catch((e) => this.plugin.logger.error("Error updating role dropdown list:", e));
      }
      if ((_b = this.sidebarManager) == null ? void 0 : _b.isSectionVisible("roles")) {
        this.sidebarManager.updateRoleList().catch((e) => this.plugin.logger.error("Error updating role panel list:", e));
      } else {
      }
    };
    this.handleMessagesCleared = (chatId) => {
      var _a;
      if (chatId === ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChatId())) {
        console.log("[OllamaView] Messages cleared event received.");
        this.clearChatContainerInternal();
        this.currentMessages = [];
        this.showEmptyState();
      }
    };
    this.handleVisibilityChange = () => {
      if (document.visibilityState === "visible" && this.leaf.view === this) {
        requestAnimationFrame(() => {
          var _a;
          this.guaranteedScrollToBottom(50, true);
          this.adjustTextareaHeight();
          (_a = this.inputEl) == null ? void 0 : _a.focus();
        });
      }
    };
    this.handleActiveLeafChange = (leaf) => {
      var _a;
      if ((leaf == null ? void 0 : leaf.view) === this) {
        (_a = this.inputEl) == null ? void 0 : _a.focus();
        setTimeout(() => this.guaranteedScrollToBottom(150, true), 100);
      }
    };
    this.handleWindowResize = () => {
      if (this.resizeTimeout)
        clearTimeout(this.resizeTimeout);
      this.resizeTimeout = setTimeout(() => this.adjustTextareaHeight(), 100);
    };
    this.handleScroll = () => {
      if (!this.chatContainer || !this.newMessagesIndicatorEl || !this.scrollToBottomButton)
        return;
      const threshold = 150;
      const atBottom = this.chatContainer.scrollHeight - this.chatContainer.scrollTop - this.chatContainer.clientHeight < threshold;
      const previousScrolledUp = this.userScrolledUp;
      this.userScrolledUp = !atBottom;
      if (previousScrolledUp && atBottom) {
        this.newMessagesIndicatorEl.classList.remove(CSS_CLASS_VISIBLE);
      }
      this.scrollToBottomButton.classList.toggle(CSS_CLASS_VISIBLE, this.userScrolledUp);
    };
    this.handleNewMessageIndicatorClick = () => {
      var _a, _b;
      if (this.chatContainer) {
        this.chatContainer.scrollTo({ top: this.chatContainer.scrollHeight, behavior: "smooth" });
      }
      (_a = this.newMessagesIndicatorEl) == null ? void 0 : _a.classList.remove(CSS_CLASS_VISIBLE);
      (_b = this.scrollToBottomButton) == null ? void 0 : _b.classList.remove(CSS_CLASS_VISIBLE);
      this.userScrolledUp = false;
    };
    this.handleScrollToBottomClick = () => {
      var _a, _b;
      if (this.chatContainer) {
        this.chatContainer.scrollTo({ top: this.chatContainer.scrollHeight, behavior: "smooth" });
      }
      (_a = this.scrollToBottomButton) == null ? void 0 : _a.classList.remove(CSS_CLASS_VISIBLE);
      (_b = this.newMessagesIndicatorEl) == null ? void 0 : _b.classList.remove(CSS_CLASS_VISIBLE);
      this.userScrolledUp = false;
    };
    this.adjustTextareaHeight = () => {
      requestAnimationFrame(() => {
        if (!this.inputEl)
          return;
        const textarea = this.inputEl;
        const computedStyle = window.getComputedStyle(textarea);
        const baseMinHeight = parseFloat(computedStyle.minHeight) || 40;
        const maxHeight = parseFloat(computedStyle.maxHeight);
        const currentScrollTop = textarea.scrollTop;
        textarea.style.height = "auto";
        const scrollHeight = textarea.scrollHeight;
        let targetHeight = Math.max(baseMinHeight, scrollHeight);
        let applyOverflow = false;
        if (!isNaN(maxHeight) && targetHeight > maxHeight) {
          targetHeight = maxHeight;
          applyOverflow = true;
        }
        textarea.style.height = `${targetHeight}px`;
        textarea.style.overflowY = applyOverflow ? "auto" : "hidden";
        textarea.scrollTop = currentScrollTop;
      });
    };
    // Модифікуємо handleActiveChatChanged
    this.handleActiveChatChanged = async (data) => {
      var _a, _b, _c, _d, _e, _f, _g;
      this.plugin.logger.error(`[HANDLER] handleActiveChatChanged FIRED for chat ID: ${(_a = data.chatId) != null ? _a : "null"}. isRegenerating: ${this.isRegenerating}`);
      if (this.isRegenerating && data.chatId === this.plugin.chatManager.getActiveChatId()) {
        this.plugin.logger.warn(`[handleActiveChatChanged] Ignored active chat change for chat ID ${data.chatId} due to ongoing regeneration process for the same chat.`);
        this.lastProcessedChatId = data.chatId;
        return;
      }
      const chatSwitched = data.chatId !== this.lastProcessedChatId;
      this.plugin.logger.warn(`[handleActiveChatChanged] Calculated chatSwitched: ${chatSwitched}`);
      if (chatSwitched || data.chatId !== null && data.chat === null) {
        this.plugin.logger.error(`[handleActiveChatChanged] !!! FULL CHAT RELOAD Condition Met !!! (switched: ${chatSwitched}, data.chat === null: ${data.chat === null}). Preparing to call loadAndDisplayActiveChat...`);
        const currentStack = new Error().stack;
        this.plugin.logger.error(`[handleActiveChatChanged] Stack trace for reload condition: ${currentStack}`);
        this.lastProcessedChatId = data.chatId;
        this.plugin.logger.error("[handleActiveChatChanged] CALLING loadAndDisplayActiveChat NOW!");
        await this.loadAndDisplayActiveChat();
      } else if (data.chatId !== null && data.chat !== null) {
        this.plugin.logger.info(`[handleActiveChatChanged] Updating UI/Panels for existing chat ID: ${data.chatId}. NO FULL RELOAD.`);
        this.lastProcessedChatId = data.chatId;
        const chat = data.chat;
        const currentRolePath = (_c = (_b = chat.metadata) == null ? void 0 : _b.selectedRolePath) != null ? _c : this.plugin.settings.selectedRolePath;
        const currentRoleName = await this.findRoleNameByPath(currentRolePath);
        const currentModelName = ((_d = chat.metadata) == null ? void 0 : _d.modelName) || this.plugin.settings.modelName;
        const currentTemperature = (_f = (_e = chat.metadata) == null ? void 0 : _e.temperature) != null ? _f : this.plugin.settings.temperature;
        this.updateModelDisplay(currentModelName);
        this.updateRoleDisplay(currentRoleName);
        this.updateInputPlaceholder(currentRoleName);
        this.updateTemperatureIndicator(currentTemperature);
        this.plugin.logger.info("[handleActiveChatChanged] SKIPPED explicit sidebar panel update call here. Relying on 'chat-list-updated' event.");
      } else {
        this.plugin.logger.warn(`[handleActiveChatChanged] Entering UNHANDLED STATE: chatId=${data.chatId}, chatSwitched=${chatSwitched}.`);
        this.lastProcessedChatId = data.chatId;
      }
      if (this.dropdownMenuManager) {
        this.dropdownMenuManager.updateRoleListIfVisible().catch((e) => this.plugin.logger.error("Error updating role dropdown list in handleActiveChatChanged:", e));
      }
      this.plugin.logger.error(`[HANDLER] handleActiveChatChanged FINISHED for chat ID: ${(_g = data.chatId) != null ? _g : "null"}`);
    };
    this.handleChatListUpdated = () => {
      var _a;
      this.plugin.logger.error("[HANDLER] handleChatListUpdated FIRED");
      if (this.dropdownMenuManager) {
        this.dropdownMenuManager.updateChatListIfVisible().catch((e) => this.plugin.logger.error("Error updating chat dropdown list:", e));
      }
      if ((_a = this.sidebarManager) == null ? void 0 : _a.isSectionVisible("chats")) {
        this.sidebarManager.updateChatList().catch((error) => {
          this.plugin.logger.error("[OllamaView -> Sidebar] Error updating chat panel list:", error);
        });
      } else {
      }
    };
    this.handleSettingsUpdated = async () => {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      this.plugin.logger.error("[HANDLER] handleSettingsUpdated FIRED");
      const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
      const currentModelName = ((_b = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _b.modelName) || this.plugin.settings.modelName;
      const currentRolePath = (_d = (_c = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _c.selectedRolePath) != null ? _d : this.plugin.settings.selectedRolePath;
      const currentRoleName = await this.findRoleNameByPath(currentRolePath);
      const currentTemperature = (_f = (_e = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _e.temperature) != null ? _f : this.plugin.settings.temperature;
      this.updateModelDisplay(currentModelName);
      this.updateRoleDisplay(currentRoleName);
      this.updateInputPlaceholder(currentRoleName);
      this.updateTemperatureIndicator(currentTemperature);
      this.updateToggleViewLocationOption();
      this.updateToggleLocationButton();
      if (this.dropdownMenuManager) {
        this.dropdownMenuManager.updateRoleListIfVisible().catch((e) => this.plugin.logger.error("Error updating role dropdown list:", e));
        this.dropdownMenuManager.updateModelListIfVisible().catch((e) => this.plugin.logger.error("Error updating model dropdown list:", e));
        this.dropdownMenuManager.updateToggleViewLocationOption();
      }
      if ((_g = this.sidebarManager) == null ? void 0 : _g.isSectionVisible("roles")) {
        await this.sidebarManager.updateRoleList().catch((e) => this.plugin.logger.error("Error updating role panel list:", e));
      } else {
      }
      if ((_h = this.sidebarManager) == null ? void 0 : _h.isSectionVisible("chats")) {
        await this.sidebarManager.updateChatList().catch((e) => this.plugin.logger.error("Error updating chat panel list:", e));
      } else {
      }
    };
    this.handleRoleDisplayClick = async (event) => {
      var _a, _b, _c;
      const menu = new import_obsidian14.Menu();
      let itemsAdded = false;
      try {
        const roles = await this.plugin.listRoleFiles(true);
        const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
        const currentRolePath = (_c = (_b = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _b.selectedRolePath) != null ? _c : this.plugin.settings.selectedRolePath;
        menu.addItem((item) => {
          item.setTitle("None").setIcon(!currentRolePath ? "check" : "slash").onClick(async () => {
            var _a2, _b2;
            const newRolePath = "";
            if (currentRolePath !== newRolePath) {
              if (activeChat) {
                await this.plugin.chatManager.updateActiveChatMetadata({
                  selectedRolePath: newRolePath
                });
              } else {
                this.plugin.settings.selectedRolePath = newRolePath;
                await this.plugin.saveSettings();
                this.plugin.emit("role-changed", "None");
                (_b2 = (_a2 = this.plugin.promptService) == null ? void 0 : _a2.clearRoleCache) == null ? void 0 : _b2.call(_a2);
              }
            }
          });
          itemsAdded = true;
        });
        if (roles.length > 0) {
          menu.addSeparator();
          itemsAdded = true;
        }
        roles.forEach((roleInfo) => {
          menu.addItem((item) => {
            item.setTitle(roleInfo.name).setIcon(roleInfo.path === currentRolePath ? "check" : roleInfo.isCustom ? "user" : "file-text").onClick(async () => {
              var _a2, _b2;
              const newRolePath = roleInfo.path;
              if (currentRolePath !== newRolePath) {
                if (activeChat) {
                  await this.plugin.chatManager.updateActiveChatMetadata({
                    selectedRolePath: newRolePath
                  });
                } else {
                  this.plugin.settings.selectedRolePath = newRolePath;
                  await this.plugin.saveSettings();
                  this.plugin.emit("role-changed", roleInfo.name);
                  (_b2 = (_a2 = this.plugin.promptService) == null ? void 0 : _a2.clearRoleCache) == null ? void 0 : _b2.call(_a2);
                }
              }
            });
            itemsAdded = true;
          });
        });
      } catch (error) {
        console.error("Error loading roles for role selection menu:", error);
        if (!itemsAdded) {
          menu.addItem((item) => item.setTitle("Error loading roles").setDisabled(true));
          itemsAdded = true;
        }
        new import_obsidian14.Notice("Failed to load roles.");
      } finally {
        if (itemsAdded) {
          menu.showAtMouseEvent(event);
        } else {
        }
      }
    };
    this.handleTemperatureClick = async () => {
      var _a, _b;
      const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
      if (!activeChat) {
        new import_obsidian14.Notice("Select or create a chat to change temperature.");
        return;
      }
      const currentTemp = (_b = activeChat.metadata.temperature) != null ? _b : this.plugin.settings.temperature;
      const currentTempString = currentTemp !== null && currentTemp !== void 0 ? String(currentTemp) : "";
      new PromptModal(
        this.app,
        "Set Temperature",
        `Enter new temperature (e.g., 0.7). Higher values = more creative, lower = more focused.`,
        currentTempString,
        async (newValue) => {
          if (newValue === null || newValue.trim() === "") {
            new import_obsidian14.Notice("Temperature change cancelled.");
            return;
          }
          const newTemp = parseFloat(newValue.trim());
          if (isNaN(newTemp) || newTemp < 0 || newTemp > 2) {
            new import_obsidian14.Notice("Invalid temperature. Please enter a number between 0.0 and 2.0.", 4e3);
            return;
          }
          try {
            await this.plugin.chatManager.updateActiveChatMetadata({
              temperature: newTemp
            });
            this.updateTemperatureIndicator(newTemp);
            new import_obsidian14.Notice(`Temperature set to ${newTemp} for chat "${activeChat.metadata.name}".`);
          } catch (error) {
            this.plugin.logger.error("Failed to update chat temperature:", error);
            new import_obsidian14.Notice("Error setting temperature.");
          }
        }
      ).open();
    };
    this.handleToggleViewLocationClick = async () => {
      var _a;
      (_a = this.dropdownMenuManager) == null ? void 0 : _a.closeMenu();
      const currentSetting = this.plugin.settings.openChatInTab;
      const newSetting = !currentSetting;
      this.plugin.settings.openChatInTab = newSetting;
      await this.plugin.saveSettings();
      this.app.workspace.detachLeavesOfType(VIEW_TYPE_OLLAMA_PERSONAS);
      setTimeout(() => {
        this.plugin.activateView();
      }, 50);
    };
    this.updateChatPanelList = async () => {
      var _a;
      const container = this.chatPanelListEl;
      if (!container || !this.plugin.chatManager) {
        return;
      }
      if (((_a = this.chatPanelHeaderEl) == null ? void 0 : _a.getAttribute("data-collapsed")) === "true") {
        return;
      }
      const currentScrollTop = container.scrollTop;
      container.empty();
      try {
        const chats = this.plugin.chatManager.listAvailableChats() || [];
        const currentActiveId = this.plugin.chatManager.getActiveChatId();
        if (chats.length === 0) {
          container.createDiv({ cls: "menu-info-text", text: "No saved chats yet." });
        } else {
          chats.forEach((chatMeta) => {
            const chatOptionEl = container.createDiv({
              cls: [CSS_ROLE_PANEL_ITEM2, CSS_CLASS_MENU_OPTION3, CSS_CLASS_CHAT_LIST_ITEM2]
            });
            const iconSpan = chatOptionEl.createSpan({ cls: [CSS_ROLE_PANEL_ITEM_ICON2, "menu-option-icon"] });
            if (chatMeta.id === currentActiveId) {
              (0, import_obsidian14.setIcon)(iconSpan, "check");
              chatOptionEl.addClass(CSS_ROLE_PANEL_ITEM_ACTIVE2);
            } else {
              (0, import_obsidian14.setIcon)(iconSpan, "message-square");
            }
            const textWrapper = chatOptionEl.createDiv({ cls: "ollama-chat-item-text-wrapper" });
            textWrapper.createDiv({ cls: "chat-panel-item-name", text: chatMeta.name });
            const lastModifiedDate = new Date(chatMeta.lastModified);
            const dateText = !isNaN(lastModifiedDate.getTime()) ? this.formatRelativeDate(lastModifiedDate) : "Invalid date";
            if (dateText === "Invalid date") {
              this.plugin.logger.warn(
                `[updateChatPanelList] Invalid date parsed for chat ${chatMeta.id}, lastModified: ${chatMeta.lastModified}`
              );
            }
            textWrapper.createDiv({ cls: "chat-panel-item-date", text: dateText });
            const optionsBtn = chatOptionEl.createEl("button", {
              cls: [CSS_CHAT_ITEM_OPTIONS, "clickable-icon"],
              attr: { "aria-label": "Chat options", title: "More options" }
            });
            (0, import_obsidian14.setIcon)(optionsBtn, "lucide-more-horizontal");
            this.registerDomEvent(chatOptionEl, "click", async (e) => {
              var _a2;
              if (!(e.target instanceof Element && e.target.closest(`.${CSS_CHAT_ITEM_OPTIONS}`))) {
                if (chatMeta.id !== ((_a2 = this.plugin.chatManager) == null ? void 0 : _a2.getActiveChatId())) {
                  await this.plugin.chatManager.setActiveChat(chatMeta.id);
                }
              }
            });
            this.registerDomEvent(optionsBtn, "click", (e) => {
              e.stopPropagation();
              this.showChatContextMenu(e, chatMeta);
            });
            this.registerDomEvent(chatOptionEl, "contextmenu", (e) => {
              this.showChatContextMenu(e, chatMeta);
            });
          });
        }
      } catch (error) {
        this.plugin.logger.error("[updateChatPanelList] Error rendering chat panel list:", error);
        container.empty();
        container.createDiv({ text: "Error loading chats.", cls: "menu-error-text" });
      } finally {
        requestAnimationFrame(() => {
          if (container && container.isConnected) {
            container.scrollTop = currentScrollTop;
          }
        });
      }
    };
    this.handleMenuButtonClick = (e) => {
      var _a;
      (_a = this.dropdownMenuManager) == null ? void 0 : _a.toggleMenu(e);
    };
    // --- ДОДАНО: Методи для перетягування ---
    this.onDragStart = (event) => {
      var _a;
      if (event.button !== 0)
        return;
      this.isResizing = true;
      this.initialMouseX = event.clientX;
      this.initialSidebarWidth = ((_a = this.sidebarRootEl) == null ? void 0 : _a.offsetWidth) || 250;
      event.preventDefault();
      event.stopPropagation();
      document.addEventListener("mousemove", this.boundOnDragMove, { capture: true });
      document.addEventListener("mouseup", this.boundOnDragEnd, { capture: true });
      document.body.style.cursor = "ew-resize";
      document.body.classList.add(CSS_CLASS_RESIZING);
    };
    this.onDragMove = (event) => {
      if (!this.isResizing || !this.sidebarRootEl)
        return;
      requestAnimationFrame(() => {
        if (!this.isResizing || !this.sidebarRootEl)
          return;
        const currentMouseX = event.clientX;
        const deltaX = currentMouseX - this.initialMouseX;
        let newWidth = this.initialSidebarWidth + deltaX;
        const minWidth = 150;
        const containerWidth = this.contentEl.offsetWidth;
        const maxWidth = Math.max(minWidth + 50, containerWidth * 0.6);
        if (newWidth < minWidth)
          newWidth = minWidth;
        if (newWidth > maxWidth)
          newWidth = maxWidth;
        this.sidebarRootEl.style.width = `${newWidth}px`;
        this.sidebarRootEl.style.minWidth = `${newWidth}px`;
      });
    };
    this.onDragEnd = (event) => {
      if (!this.isResizing)
        return;
      this.isResizing = false;
      document.removeEventListener("mousemove", this.boundOnDragMove, { capture: true });
      document.removeEventListener("mouseup", this.boundOnDragEnd, { capture: true });
      document.body.style.cursor = "";
      document.body.classList.remove(CSS_CLASS_RESIZING);
      this.saveWidthDebounced();
    };
    this.plugin = plugin;
    this.app = plugin.app;
    this.initSpeechWorker();
    this.scrollListenerDebounced = (0, import_obsidian14.debounce)(this.handleScroll, 150, true);
    this.register(
      this.plugin.on("focus-input-request", () => {
        this.focusInput();
      })
    );
    this.boundOnDragMove = this.onDragMove.bind(this);
    this.boundOnDragEnd = this.onDragEnd.bind(this);
    this.saveWidthDebounced = (0, import_obsidian14.debounce)(() => {
      if (this.sidebarRootEl) {
        const newWidth = this.sidebarRootEl.offsetWidth;
        if (newWidth > 0 && newWidth !== this.plugin.settings.sidebarWidth) {
          this.plugin.logger.debug(`Saving sidebar width: ${newWidth}`);
          this.plugin.settings.sidebarWidth = newWidth;
          this.plugin.saveSettings();
        }
      }
    }, 800);
  }
  getViewType() {
    return VIEW_TYPE_OLLAMA_PERSONAS;
  }
  getDisplayText() {
    return "AI Forge";
  }
  getIcon() {
    return "brain-circuit";
  }
  async onOpen() {
    var _a, _b, _c, _d;
    this.plugin.logger.debug("[OllamaView] onOpen started.");
    this.createUIElements();
    const savedWidth = this.plugin.settings.sidebarWidth;
    if (this.sidebarRootEl && savedWidth && typeof savedWidth === "number" && savedWidth > 50) {
      this.plugin.logger.debug(`Applying saved sidebar width: ${savedWidth}px`);
      this.sidebarRootEl.style.width = `${savedWidth}px`;
      this.sidebarRootEl.style.minWidth = `${savedWidth}px`;
    } else if (this.sidebarRootEl) {
      let defaultWidth = 250;
      try {
        const cssVarWidth = getComputedStyle(this.sidebarRootEl).getPropertyValue("--ai-forge-sidebar-width").trim();
        if (cssVarWidth && cssVarWidth.endsWith("px")) {
          const parsedWidth = parseInt(cssVarWidth, 10);
          if (!isNaN(parsedWidth) && parsedWidth > 50) {
            defaultWidth = parsedWidth;
          }
        }
      } catch (e) {
        this.plugin.logger.warn("Could not read default width from CSS variable, using fallback.", e);
      }
      this.plugin.logger.debug(`Applying default sidebar width: ${defaultWidth}px`);
      this.sidebarRootEl.style.width = `${defaultWidth}px`;
      this.sidebarRootEl.style.minWidth = `${defaultWidth}px`;
    }
    try {
      const initialRolePath = this.plugin.settings.selectedRolePath;
      const initialRoleName = await this.findRoleNameByPath(initialRolePath);
      this.updateInputPlaceholder(initialRoleName);
      this.updateRoleDisplay(initialRoleName);
      this.updateModelDisplay(this.plugin.settings.modelName);
      this.updateTemperatureIndicator(this.plugin.settings.temperature);
      this.plugin.logger.debug("[OllamaView] Initial UI elements updated based on settings.");
    } catch (error) {
      this.plugin.logger.error("[OllamaView] Error during initial UI update in onOpen:", error);
    }
    this.attachEventListeners();
    this.autoResizeTextarea();
    this.updateSendButtonState();
    try {
      this.plugin.logger.debug("[OllamaView] Calling loadAndDisplayActiveChat from onOpen...");
      await this.loadAndDisplayActiveChat();
      this.plugin.logger.debug("[OllamaView] loadAndDisplayActiveChat completed successfully in onOpen.");
      (_a = this.sidebarManager) == null ? void 0 : _a.updateChatList().catch((e) => this.plugin.logger.error("Error updating chat list after initial load:", e));
      (_b = this.sidebarManager) == null ? void 0 : _b.updateRoleList().catch((e) => this.plugin.logger.error("Error updating role list after initial load:", e));
    } catch (error) {
      this.plugin.logger.error("[OllamaView] Error during initial chat load in onOpen:", error);
      this.showEmptyState();
      const updatePromises = [];
      if ((_c = this.sidebarManager) == null ? void 0 : _c.isSectionVisible("chats")) {
        updatePromises.push(this.sidebarManager.updateChatList().catch((e) => this.plugin.logger.error("Error updating chat panel list in catch:", e)));
      }
      if ((_d = this.sidebarManager) == null ? void 0 : _d.isSectionVisible("roles")) {
        updatePromises.push(this.sidebarManager.updateRoleList().catch((e) => this.plugin.logger.error("Error updating role panel list in catch:", e)));
      }
      if (updatePromises.length > 0) {
        await Promise.all(updatePromises);
      }
    }
    setTimeout(() => {
      var _a2;
      (_a2 = this.inputEl) == null ? void 0 : _a2.focus();
      this.plugin.logger.debug("[OllamaView] Input focused in onOpen.");
    }, 150);
    if (this.inputEl) {
      this.inputEl.dispatchEvent(new Event("input"));
    }
  }
  async onClose() {
    var _a, _b;
    document.removeEventListener("mousemove", this.boundOnDragMove, { capture: true });
    document.removeEventListener("mouseup", this.boundOnDragEnd, { capture: true });
    if (document.body.classList.contains(CSS_CLASS_RESIZING)) {
      document.body.style.cursor = "";
      document.body.classList.remove(CSS_CLASS_RESIZING);
    }
    this.isResizing = false;
    if (this.speechWorker) {
      this.speechWorker.terminate();
      this.speechWorker = null;
    }
    this.stopVoiceRecording(false);
    if (this.audioStream) {
      this.audioStream.getTracks().forEach((t) => t.stop());
      this.audioStream = null;
    }
    if (this.scrollTimeout)
      clearTimeout(this.scrollTimeout);
    if (this.resizeTimeout)
      clearTimeout(this.resizeTimeout);
    (_a = this.sidebarManager) == null ? void 0 : _a.destroy();
    (_b = this.dropdownMenuManager) == null ? void 0 : _b.destroy();
    this.plugin.logger.info("Ollama View closed and resources cleaned up.");
  }
  createUIElements() {
    this.plugin.logger.debug("createUIElements: Starting UI creation.");
    this.contentEl.empty();
    const flexContainer = this.contentEl.createDiv({ cls: "ollama-container" });
    const isSidebarLocation = !this.plugin.settings.openChatInTab;
    const isDesktop = import_obsidian14.Platform.isDesktop;
    this.plugin.logger.debug(`[OllamaView] createUIElements Context: isDesktop=${isDesktop}, isSidebarLocation=${isSidebarLocation}`);
    this.sidebarManager = new SidebarManager(this.plugin, this.app, this);
    this.sidebarRootEl = this.sidebarManager.createSidebarUI(flexContainer);
    const shouldShowInternalSidebar = isDesktop && !isSidebarLocation;
    if (this.sidebarRootEl) {
      this.sidebarRootEl.classList.toggle("internal-sidebar-hidden", !shouldShowInternalSidebar);
      this.plugin.logger.debug(`[OllamaView] Internal sidebar visibility set (hidden: ${!shouldShowInternalSidebar}). Classes: ${this.sidebarRootEl.className}`);
    } else {
      this.plugin.logger.error("[OllamaView] sidebarRootEl is missing after creation!");
    }
    this.resizerEl = flexContainer.createDiv({ cls: CSS_CLASS_RESIZER_HANDLE });
    this.resizerEl.title = "Drag to resize sidebar";
    this.resizerEl.classList.toggle("internal-sidebar-hidden", !shouldShowInternalSidebar);
    this.plugin.logger.debug(`[OllamaView] Resizer element created (hidden: ${!shouldShowInternalSidebar}).`);
    this.mainChatAreaEl = flexContainer.createDiv({ cls: "ollama-main-chat-area" });
    this.mainChatAreaEl.classList.toggle("full-width", !shouldShowInternalSidebar);
    this.plugin.logger.debug(`[OllamaView] Main chat area class 'full-width' set: ${!shouldShowInternalSidebar}`);
    this.chatContainerEl = this.mainChatAreaEl.createDiv({ cls: "ollama-chat-area-content" });
    this.chatContainer = this.chatContainerEl.createDiv({ cls: "ollama-chat-container" });
    this.newMessagesIndicatorEl = this.chatContainerEl.createDiv({ cls: "new-message-indicator" });
    (0, import_obsidian14.setIcon)(this.newMessagesIndicatorEl.createSpan({ cls: "indicator-icon" }), "arrow-down");
    this.newMessagesIndicatorEl.createSpan({ text: " New Messages" });
    this.scrollToBottomButton = this.chatContainerEl.createEl("button", { cls: ["scroll-to-bottom-button", "clickable-icon"], attr: { "aria-label": "Scroll to bottom", title: "Scroll to bottom" } });
    (0, import_obsidian14.setIcon)(this.scrollToBottomButton, "arrow-down");
    const inputContainer = this.mainChatAreaEl.createDiv({ cls: "chat-input-container" });
    this.inputEl = inputContainer.createEl("textarea", { attr: { placeholder: `Enter message text here...`, rows: 1 } });
    const controlsContainer = inputContainer.createDiv({ cls: "input-controls-container" });
    const leftControls = controlsContainer.createDiv({ cls: "input-controls-left" });
    this.translateInputButton = leftControls.createEl("button", { cls: "translate-input-button", attr: { "aria-label": "Translate input to English" } });
    (0, import_obsidian14.setIcon)(this.translateInputButton, "languages");
    this.translateInputButton.title = "Translate input to English";
    this.modelDisplayEl = leftControls.createDiv({ cls: "model-display" });
    this.modelDisplayEl.setText("...");
    this.modelDisplayEl.title = "Click to select model";
    this.roleDisplayEl = leftControls.createDiv({ cls: "role-display" });
    this.roleDisplayEl.setText("...");
    this.roleDisplayEl.title = "Click to select role";
    this.temperatureIndicatorEl = leftControls.createDiv({ cls: "temperature-indicator" });
    this.temperatureIndicatorEl.setText("?");
    this.temperatureIndicatorEl.title = "Click to set temperature";
    this.buttonsContainer = controlsContainer.createDiv({ cls: `buttons-container input-controls-right` });
    this.stopGeneratingButton = this.buttonsContainer.createEl("button", { cls: ["stop-generating-button", "danger-option"], attr: { "aria-label": "Stop Generation", title: "Stop Generation" } });
    (0, import_obsidian14.setIcon)(this.stopGeneratingButton, "square");
    this.stopGeneratingButton.hide();
    this.sendButton = this.buttonsContainer.createEl("button", { cls: "send-button", attr: { "aria-label": "Send" } });
    (0, import_obsidian14.setIcon)(this.sendButton, "send");
    this.voiceButton = this.buttonsContainer.createEl("button", { cls: "voice-button", attr: { "aria-label": "Voice Input" } });
    (0, import_obsidian14.setIcon)(this.voiceButton, "mic");
    this.toggleLocationButton = this.buttonsContainer.createEl("button", { cls: "toggle-location-button", attr: { "aria-label": "Toggle View Location" } });
    this.menuButton = this.buttonsContainer.createEl("button", { cls: "menu-button", attr: { "aria-label": "Menu" } });
    (0, import_obsidian14.setIcon)(this.menuButton, "more-vertical");
    this.updateToggleLocationButton();
    this.dropdownMenuManager = new DropdownMenuManager(this.plugin, this.app, this, inputContainer, isSidebarLocation, isDesktop);
    this.dropdownMenuManager.createMenuUI();
    this.plugin.logger.debug("createUIElements: Finished UI creation.");
  }
  attachEventListeners() {
    var _a;
    this.plugin.logger.debug("[OllamaView] Attaching event listeners...");
    if (this.resizerEl) {
      this.registerDomEvent(this.resizerEl, "mousedown", this.onDragStart);
      this.plugin.logger.debug("Added mousedown listener to resizer handle.");
    } else {
      this.plugin.logger.error("Resizer element (resizerEl) not found during listener attachment!");
    }
    if (this.inputEl) {
      this.registerDomEvent(this.inputEl, "keydown", this.handleKeyDown);
      this.registerDomEvent(this.inputEl, "input", this.handleInputForResize);
    }
    if (this.sendButton) {
      this.registerDomEvent(this.sendButton, "click", this.handleSendClick);
    }
    if (this.stopGeneratingButton) {
      this.registerDomEvent(this.stopGeneratingButton, "click", this.cancelGeneration);
    }
    if (this.voiceButton) {
      this.registerDomEvent(this.voiceButton, "click", this.handleVoiceClick);
    }
    if (this.translateInputButton) {
      this.registerDomEvent(this.translateInputButton, "click", this.handleTranslateInputClick);
    }
    if (this.menuButton) {
      this.registerDomEvent(this.menuButton, "click", this.handleMenuButtonClick);
    }
    if (this.toggleLocationButton) {
      this.registerDomEvent(this.toggleLocationButton, "click", this.handleToggleViewLocationClick);
    }
    if (this.modelDisplayEl) {
      this.registerDomEvent(this.modelDisplayEl, "click", this.handleModelDisplayClick);
    }
    if (this.roleDisplayEl) {
      this.registerDomEvent(this.roleDisplayEl, "click", this.handleRoleDisplayClick);
    }
    if (this.temperatureIndicatorEl) {
      this.registerDomEvent(this.temperatureIndicatorEl, "click", this.handleTemperatureClick);
    }
    if (this.chatContainer) {
      this.registerDomEvent(this.chatContainer, "scroll", this.scrollListenerDebounced);
    }
    if (this.newMessagesIndicatorEl) {
      this.registerDomEvent(this.newMessagesIndicatorEl, "click", this.handleNewMessageIndicatorClick);
    }
    if (this.scrollToBottomButton) {
      this.registerDomEvent(this.scrollToBottomButton, "click", this.handleScrollToBottomClick);
    }
    this.registerDomEvent(window, "resize", this.handleWindowResize);
    this.registerDomEvent(document, "click", this.handleDocumentClickForMenu);
    this.registerDomEvent(document, "visibilitychange", this.handleVisibilityChange);
    this.registerEvent(this.app.workspace.on("active-leaf-change", this.handleActiveLeafChange));
    (_a = this.dropdownMenuManager) == null ? void 0 : _a.attachEventListeners();
    this.register(this.plugin.on("model-changed", (modelName) => this.handleModelChange(modelName)));
    this.register(this.plugin.on("role-changed", (roleName) => this.handleRoleChange(roleName)));
    this.register(this.plugin.on("roles-updated", () => this.handleRolesUpdated()));
    this.register(this.plugin.on("message-added", (data) => this.handleMessageAdded(data)));
    this.register(this.plugin.on("active-chat-changed", (data) => this.handleActiveChatChanged(data)));
    this.register(this.plugin.on("messages-cleared", (chatId) => this.handleMessagesCleared(chatId)));
    this.register(this.plugin.on("chat-list-updated", () => this.handleChatListUpdated()));
    this.register(this.plugin.on("settings-updated", () => this.handleSettingsUpdated()));
    this.register(this.plugin.on("message-deleted", (data) => this.handleMessageDeleted(data)));
    this.register(this.plugin.on("ollama-connection-error", (message) => {
    }));
  }
  updateToggleLocationButton() {
    if (!this.toggleLocationButton)
      return;
    let iconName;
    let titleText;
    if (this.plugin.settings.openChatInTab) {
      iconName = "sidebar-right";
      titleText = "Move to Sidebar";
    } else {
      iconName = "layout-list";
      titleText = "Move to Tab";
    }
    (0, import_obsidian14.setIcon)(this.toggleLocationButton, iconName);
    this.toggleLocationButton.setAttribute("aria-label", titleText);
    this.toggleLocationButton.title = titleText;
  }
  updateModelDisplay(modelName) {
    if (this.modelDisplayEl) {
      if (modelName) {
        const displayName = modelName;
        const shortName = displayName.replace(/:latest$/, "");
        this.modelDisplayEl.setText(shortName);
        this.modelDisplayEl.title = `Current model: ${displayName}. Click to change.`;
        this.modelDisplayEl.removeClass("model-not-available");
      } else {
        this.modelDisplayEl.setText("Not available");
        this.modelDisplayEl.title = "No Ollama models detected. Check Ollama connection and ensure models are installed.";
        this.modelDisplayEl.addClass("model-not-available");
      }
    } else {
      console.error("[OllamaView] modelDisplayEl is missing!");
    }
  }
  handleContextMenuRename(chatId, currentName) {
    this.handleRenameChatClick(chatId, currentName);
  }
  async addMessageStandard(message) {
    var _a;
    const isNewDay = !this.lastRenderedMessageDate || !this.isSameDay(this.lastRenderedMessageDate, message.timestamp);
    if (isNewDay) {
      this.renderDateSeparator(message.timestamp);
      this.lastRenderedMessageDate = message.timestamp;
    } else if (!this.lastRenderedMessageDate && ((_a = this.chatContainer) == null ? void 0 : _a.children.length) === 0) {
      this.lastRenderedMessageDate = message.timestamp;
    }
    this.hideEmptyState();
    let messageGroupEl = null;
    try {
      let renderer = null;
      switch (message.role) {
        case "user":
          renderer = new UserMessageRenderer(this.app, this.plugin, message, this);
          break;
        case "system":
          renderer = new SystemMessageRenderer(this.app, this.plugin, message, this);
          break;
        case "error":
          this.handleErrorMessage(message);
          if (this.currentMessageAddedResolver) {
            this.currentMessageAddedResolver();
            this.currentMessageAddedResolver = null;
          }
          return;
        case "assistant":
          renderer = new AssistantMessageRenderer(this.app, this.plugin, message, this);
          break;
        default:
          return;
      }
      if (renderer) {
        const result = renderer.render();
        messageGroupEl = result instanceof Promise ? await result : result;
      }
      if (messageGroupEl && this.chatContainer) {
        this.chatContainer.appendChild(messageGroupEl);
        this.lastMessageElement = messageGroupEl;
        if (!messageGroupEl.isConnected) {
          this.plugin.logger.error(`[addMessageStandard] Node not connected! Role: ${message.role}`);
        }
        messageGroupEl.classList.add(CSS_CLASSES.MESSAGE_ARRIVING);
        setTimeout(() => messageGroupEl == null ? void 0 : messageGroupEl.classList.remove(CSS_CLASSES.MESSAGE_ARRIVING), 500);
        const isUserMessage = message.role === "user";
        if (!isUserMessage && this.userScrolledUp && this.newMessagesIndicatorEl) {
          this.newMessagesIndicatorEl.classList.add(CSS_CLASSES.VISIBLE);
        } else if (!this.userScrolledUp) {
          this.guaranteedScrollToBottom(isUserMessage ? 50 : 100, !isUserMessage);
        }
        setTimeout(() => this.updateScrollStateAndIndicators(), 100);
      } else if (renderer) {
      }
      if (this.currentMessageAddedResolver) {
        try {
          this.currentMessageAddedResolver();
        } catch (e) {
          this.plugin.logger.error("Error resolving promise in addMessageStandard:", e);
        }
        this.currentMessageAddedResolver = null;
      }
    } catch (error) {
      this.plugin.logger.error(
        `[addMessageStandard] Error rendering/appending standard message. Role: ${message.role}`,
        error
      );
      this.handleErrorMessage({
        role: "error",
        content: `Failed to display ${message.role} message. Render Error: ${error.message}`,
        timestamp: new Date()
      });
      if (this.currentMessageAddedResolver) {
        try {
          this.currentMessageAddedResolver();
        } catch (e) {
          this.plugin.logger.error("Error resolving promise after error:", e);
        }
        this.currentMessageAddedResolver = null;
      }
    }
  }
  updateInputPlaceholder(roleName) {
    if (this.inputEl) {
      this.inputEl.placeholder = `Enter message text here...`;
    }
  }
  autoResizeTextarea() {
    this.adjustTextareaHeight();
  }
  updateRoleDisplay(roleName) {
    if (this.roleDisplayEl) {
      const displayName = roleName || "None";
      this.roleDisplayEl.setText(displayName);
      this.roleDisplayEl.title = `Current role: ${displayName}. Click to change.`;
    }
  }
  // private updateSendButtonState(): void {
  //   if (!this.inputEl || !this.sendButton) return;
  //   const isDisabled = this.inputEl.value.trim() === "" || this.isProcessing || this.currentAbortController !== null;
  //   this.sendButton.disabled = isDisabled;
  //   this.sendButton.classList.toggle(CSS_CLASS_DISABLED, isDisabled);
  //   this.stopGeneratingButton?.toggle(this.currentAbortController !== null);
  // }
  updateSendButtonState() {
    if (!this.inputEl || !this.sendButton || !this.stopGeneratingButton) {
      this.plugin.logger.warn(`[OllamaView] updateSendButtonState: Aborted, some UI elements missing. inputEl: ${!!this.inputEl}, sendButton: ${!!this.sendButton}, stopGenButton: ${!!this.stopGeneratingButton}`);
      return;
    }
    const generationInProgress = this.currentAbortController !== null;
    const isInputEmpty = this.inputEl.value.trim() === "";
    this.plugin.logger.debug(`[OllamaView] updateSendButtonState: generationInProgress is ${generationInProgress}. isProcessing is ${this.isProcessing}. isInputEmpty is ${isInputEmpty}.`);
    if (generationInProgress) {
      this.plugin.logger.debug(`[OllamaView] updateSendButtonState: Generation IN PROGRESS. Showing STOP, Hiding SEND.`);
      this.stopGeneratingButton.show();
      this.sendButton.hide();
      this.sendButton.disabled = true;
    } else {
      this.plugin.logger.debug(`[OllamaView] updateSendButtonState: Generation NOT in progress. Hiding STOP, Showing SEND.`);
      this.stopGeneratingButton.hide();
      this.sendButton.show();
      const sendShouldBeDisabled = isInputEmpty || this.isProcessing;
      this.sendButton.disabled = sendShouldBeDisabled;
      this.sendButton.classList.toggle(CSS_CLASSES.DISABLED, sendShouldBeDisabled);
      this.plugin.logger.debug(`[OllamaView] updateSendButtonState: Send button disabled: ${sendShouldBeDisabled}.`);
    }
    this.plugin.logger.debug(`[OllamaView] updateSendButtonState finished.`);
  }
  showEmptyState() {
    var _a, _b;
    if (this.currentMessages.length === 0 && !this.emptyStateEl && this.chatContainer) {
      this.chatContainer.empty();
      this.emptyStateEl = this.chatContainer.createDiv({
        cls: CSS_CLASS_EMPTY_STATE
      });
      this.emptyStateEl.createDiv({
        cls: "empty-state-message",
        text: "No messages yet"
      });
      const modelName = ((_b = (_a = this.plugin) == null ? void 0 : _a.settings) == null ? void 0 : _b.modelName) || "the AI";
      this.emptyStateEl.createDiv({
        cls: "empty-state-tip",
        text: `Type a message or use the menu options to start interacting with ${modelName}.`
      });
    }
  }
  hideEmptyState() {
    if (this.emptyStateEl) {
      this.emptyStateEl.remove();
      this.emptyStateEl = null;
    }
  }
  setLoadingState(isLoading) {
    const oldIsProcessing = this.isProcessing;
    this.isProcessing = isLoading;
    this.plugin.logger.debug(`[OllamaView] setLoadingState: isProcessing set to ${this.isProcessing} (was ${oldIsProcessing}). isLoading param: ${isLoading}. currentAbortController is ${this.currentAbortController ? "NOT null" : "null"}`);
    if (this.inputEl)
      this.inputEl.disabled = isLoading;
    this.plugin.logger.debug(`[OllamaView] setLoadingState: Calling updateSendButtonState.`);
    this.updateSendButtonState();
    if (this.voiceButton) {
      this.voiceButton.disabled = isLoading;
      this.voiceButton.classList.toggle(CSS_CLASSES.DISABLED, isLoading);
    }
    if (this.translateInputButton) {
      this.translateInputButton.disabled = isLoading;
      this.translateInputButton.classList.toggle(CSS_CLASSES.DISABLED, isLoading);
    }
    if (this.menuButton) {
      this.menuButton.disabled = isLoading;
      this.menuButton.classList.toggle(CSS_CLASSES.DISABLED, isLoading);
    }
    if (this.chatContainer) {
      if (isLoading) {
        this.chatContainer.querySelectorAll(`.${CSS_CLASSES.SHOW_MORE_BUTTON}`).forEach((button) => {
          button.style.display = "none";
        });
      } else {
        this.checkAllMessagesForCollapsing();
      }
    }
    this.plugin.logger.debug(`[OllamaView] setLoadingState finished.`);
  }
  isSidebarSectionVisible(type) {
    const headerEl = type === "chats" ? this.chatPanelHeaderEl : this.rolePanelHeaderEl;
    return (headerEl == null ? void 0 : headerEl.getAttribute("data-collapsed")) === "false";
  }
  async loadAndDisplayActiveChat() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
    this.plugin.logger.error("[LOAD_DISPLAY] >>>>> ENTERING loadAndDisplayActiveChat");
    try {
      this.clearChatContainerInternal();
      this.currentMessages = [];
      this.lastRenderedMessageDate = null;
      this.lastMessageElement = null;
      this.consecutiveErrorMessages = [];
      this.errorGroupElement = null;
      let activeChat = null;
      let availableModels = [];
      let finalModelName = null;
      let finalRolePath = void 0;
      let finalRoleName = "None";
      let finalTemperature = void 0;
      let errorOccurred = false;
      try {
        activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat()) || null;
        this.plugin.logger.debug(
          `[loadAndDisplayActiveChat] Active chat fetched: ${(_c = (_b = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _b.id) != null ? _c : "null"}`
        );
        availableModels = await this.plugin.ollamaService.getModels();
        finalRolePath = (_e = (_d = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _d.selectedRolePath) != null ? _e : this.plugin.settings.selectedRolePath;
        finalRoleName = await this.findRoleNameByPath(finalRolePath);
        this.plugin.logger.debug(
          `[loadAndDisplayActiveChat] Determined role: Path='${finalRolePath || "None"}', Name='${finalRoleName}'`
        );
      } catch (error) {
        this.plugin.logger.error("[loadAndDisplayActiveChat] Error fetching initial data:", error);
        new import_obsidian14.Notice("Error connecting to Ollama or loading chat data.", 5e3);
        errorOccurred = true;
        finalModelName = availableModels.includes(this.plugin.settings.modelName) ? this.plugin.settings.modelName : (_f = availableModels[0]) != null ? _f : null;
        finalTemperature = this.plugin.settings.temperature;
        finalRolePath = this.plugin.settings.selectedRolePath;
        finalRoleName = await this.findRoleNameByPath(finalRolePath);
        activeChat = null;
      }
      if (!errorOccurred && activeChat) {
        let preferredModel = ((_g = activeChat.metadata) == null ? void 0 : _g.modelName) || this.plugin.settings.modelName;
        if (availableModels.length > 0) {
          if (preferredModel && availableModels.includes(preferredModel)) {
            finalModelName = preferredModel;
          } else {
            finalModelName = availableModels[0];
            this.plugin.logger.warn(
              `[loadAndDisplayActiveChat] Preferred model '${preferredModel}' not available. Using first available: '${finalModelName}'.`
            );
          }
        } else {
          finalModelName = null;
        }
        if (activeChat.metadata.modelName !== finalModelName && finalModelName !== null) {
          this.plugin.chatManager.updateActiveChatMetadata({ modelName: finalModelName }).catch((updateError) => {
            this.plugin.logger.error(
              "[loadAndDisplayActiveChat] Background error updating chat model metadata:",
              updateError
            );
          });
        }
        finalTemperature = (_i = (_h = activeChat.metadata) == null ? void 0 : _h.temperature) != null ? _i : this.plugin.settings.temperature;
      } else if (!errorOccurred && !activeChat) {
        finalModelName = availableModels.includes(this.plugin.settings.modelName) ? this.plugin.settings.modelName : (_j = availableModels[0]) != null ? _j : null;
        finalTemperature = this.plugin.settings.temperature;
      }
      if (activeChat !== null && !errorOccurred && ((_k = activeChat.messages) == null ? void 0 : _k.length) > 0) {
        this.hideEmptyState();
        this.currentMessages = [...activeChat.messages];
        this.lastRenderedMessageDate = null;
        for (const message of this.currentMessages) {
          let messageGroupEl = null;
          const isNewDay = !this.lastRenderedMessageDate || !this.isSameDay(this.lastRenderedMessageDate, message.timestamp);
          const isFirstMessageInContainer = this.chatContainer.children.length === 0;
          if (isNewDay || isFirstMessageInContainer) {
            if (isNewDay) {
              this.renderDateSeparator(message.timestamp);
            }
            this.lastRenderedMessageDate = message.timestamp;
          }
          try {
            let renderer = null;
            switch (message.role) {
              case "user":
                renderer = new UserMessageRenderer(this.app, this.plugin, message, this);
                break;
              case "assistant":
                renderer = new AssistantMessageRenderer(this.app, this.plugin, message, this);
                break;
              case "system":
                renderer = new SystemMessageRenderer(this.app, this.plugin, message, this);
                break;
              case "error":
                renderer = new ErrorMessageRenderer(this.app, this.plugin, message, this);
                this.lastMessageElement = null;
                this.errorGroupElement = null;
                this.consecutiveErrorMessages = [];
                break;
              default:
            }
            if (renderer) {
              const result = renderer.render();
              if (result instanceof Promise) {
                messageGroupEl = await result;
              } else {
                messageGroupEl = result;
              }
            }
          } catch (renderError) {
            this.plugin.logger.error("Error rendering message during load:", renderError, message);
            const errorDiv = this.chatContainer.createDiv({ cls: "render-error" });
            errorDiv.setText(`Error rendering message (role: ${message.role})`);
            messageGroupEl = errorDiv;
          }
          if (messageGroupEl) {
            this.chatContainer.appendChild(messageGroupEl);
            this.lastMessageElement = messageGroupEl;
          }
        }
        setTimeout(() => this.checkAllMessagesForCollapsing(), 100);
        setTimeout(() => {
          this.guaranteedScrollToBottom(100, false);
          setTimeout(() => {
            this.updateScrollStateAndIndicators();
          }, 150);
        }, 150);
      } else {
        this.showEmptyState();
        (_l = this.scrollToBottomButton) == null ? void 0 : _l.classList.remove(CSS_CLASSES.VISIBLE);
      }
      this.updateInputPlaceholder(finalRoleName);
      this.updateRoleDisplay(finalRoleName);
      this.updateModelDisplay(finalModelName);
      this.updateTemperatureIndicator(finalTemperature);
      this.plugin.logger.debug("[loadAndDisplayActiveChat] Updating visible sidebar panels via SidebarManager...");
      const panelUpdatePromises = [];
      if ((_m = this.sidebarManager) == null ? void 0 : _m.isSectionVisible("chats")) {
        panelUpdatePromises.push(
          this.sidebarManager.updateChatList().catch((e) => this.plugin.logger.error("Error updating chat panel list:", e))
        );
      } else {
        this.plugin.logger.debug("[loadAndDisplayActiveChat] Chat panel collapsed, skipping update.");
      }
      if ((_n = this.sidebarManager) == null ? void 0 : _n.isSectionVisible("roles")) {
        panelUpdatePromises.push(
          this.sidebarManager.updateRoleList().catch((e) => this.plugin.logger.error("Error updating role panel list:", e))
        );
      } else {
      }
      if (panelUpdatePromises.length > 0) {
        await Promise.all(panelUpdatePromises);
        this.plugin.logger.debug("[loadAndDisplayActiveChat] Sidebar panel updates finished.");
      }
      if (finalModelName === null) {
        if (this.inputEl) {
          this.inputEl.disabled = true;
          this.inputEl.placeholder = "No models available...";
        }
        if (this.sendButton) {
          this.sendButton.disabled = true;
          this.sendButton.classList.add(CSS_CLASSES.DISABLED);
        }
        this.setLoadingState(false);
      } else {
        if (this.inputEl) {
          this.inputEl.disabled = this.isProcessing;
        }
        this.updateSendButtonState();
      }
    } catch (error) {
      this.plugin.logger.error("[loadAndDisplayActiveChat] XXX \u041F\u041E\u041C\u0418\u041B\u041A\u0410 \u043F\u0456\u0434 \u0447\u0430\u0441 \u0432\u0438\u043A\u043E\u043D\u0430\u043D\u043D\u044F XXX", error);
    } finally {
    }
    this.plugin.logger.error("[LOAD_DISPLAY] <<<<< EXITING loadAndDisplayActiveChat");
  }
  async handleDeleteMessageClick(messageToDelete) {
    var _a;
    const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
    if (!activeChat) {
      new import_obsidian14.Notice("Cannot delete message: No active chat.");
      return;
    }
    new ConfirmModal(
      this.app,
      "Confirm Message Deletion",
      `Are you sure you want to delete this message?
"${messageToDelete.content.substring(0, 100)}${messageToDelete.content.length > 100 ? "..." : ""}"

This action cannot be undone.`,
      async () => {
        this.plugin.logger.info(
          `User confirmed deletion for message timestamp: ${messageToDelete.timestamp.toISOString()} in chat ${activeChat.metadata.id}`
        );
        try {
          const deleteSuccess = await this.plugin.chatManager.deleteMessageByTimestamp(
            activeChat.metadata.id,
            messageToDelete.timestamp
          );
          if (deleteSuccess) {
            new import_obsidian14.Notice("Message deleted.");
          } else {
            new import_obsidian14.Notice("Failed to delete message.");
            this.plugin.logger.warn(
              `deleteMessageByTimestamp returned false for chat ${activeChat.metadata.id}, timestamp ${messageToDelete.timestamp.toISOString()}`
            );
          }
        } catch (error) {
          this.plugin.logger.error(
            `Error deleting message (chat ${activeChat.metadata.id}, timestamp ${messageToDelete.timestamp.toISOString()}):`,
            error
          );
          new import_obsidian14.Notice("An error occurred while deleting the message.");
        }
      }
    ).open();
  }
  // Переконайтеся, що updateSendButtonState виглядає так:
  // private updateSendButtonState(): void {
  //   if (!this.inputEl || !this.sendButton || !this.stopGeneratingButton) return;
  //   const generationInProgress = this.currentAbortController !== null; 
  //   // isProcessing встановлюється/скидається через setLoadingState
  //   // Кнопка Send вимкнена, якщо поле порожнє, або йде обробка (isProcessing), або йде генерація (generationInProgress)
  //   const isSendDisabled = this.inputEl.value.trim() === "" || this.isProcessing || generationInProgress;
  //   this.sendButton.disabled = isSendDisabled;
  //   this.sendButton.classList.toggle(CSS_CLASSES.DISABLED, isSendDisabled);
  //   // Кнопка Stop активна (видима), тільки якщо є активний AbortController (тобто йде генерація)
  //   this.stopGeneratingButton.toggle(generationInProgress);
  //   // Кнопка Send ховається, якщо активна кнопка Stop
  //   this.sendButton.toggle(!generationInProgress); 
  // }
  // Переконайтеся, що handleMessageAdded очищує this.currentMessageAddedResolver НА ПОЧАТКУ
  // і викликає localResolver В КІНЦІ свого блоку try або в catch/finally.
  // Приклад структури handleMessageAdded (переконайтеся, що ваша версія схожа):
  // private async handleMessageAdded(data: { chatId: string; message: Message }): Promise<void> {
  //   const localResolver = this.currentMessageAddedResolver;
  //   this.currentMessageAddedResolver = null; 
  //   try {
  //     // ... ваша основна логіка обробки повідомлення ...
  //     // ... якщо це оновлення плейсхолдера, this.activePlaceholder = null; всередині ...
  //   } catch (outerError: any) {
  //     // ... обробка помилок ...
  //   } finally {
  //     if (localResolver) {
  //       localResolver(); // Викликаємо resolver тут, щоб сигналізувати про завершення
  //     }
  //     // ... логування виходу ...
  //   }
  // }
  handleCopyClick(content, buttonEl) {
    let textToCopy = content;
    if (detectThinkingTags(decodeHtmlEntities(content)).hasThinkingTags) {
      textToCopy = decodeHtmlEntities(content).replace(/<think>[\s\S]*?<\/think>/g, "").trim();
    }
    navigator.clipboard.writeText(textToCopy).then(() => {
      (0, import_obsidian14.setIcon)(buttonEl, "check");
      buttonEl.setAttribute("title", "Copied!");
      setTimeout(() => {
        (0, import_obsidian14.setIcon)(buttonEl, "copy");
        buttonEl.setAttribute("title", "Copy");
      }, 2e3);
    }).catch((err) => {
      console.error("Copy failed:", err);
      new import_obsidian14.Notice("Failed to copy text.");
    });
  }
  async handleTranslateClick(originalContent, contentEl, buttonEl) {
    var _a, _b, _c, _d;
    const targetLang = this.plugin.settings.translationTargetLanguage;
    if (!this.plugin.settings.enableTranslation || this.plugin.settings.translationProvider === "none") {
      new import_obsidian14.Notice("Translation disabled or provider not selected in settings.");
      return;
    }
    if (!targetLang) {
      new import_obsidian14.Notice("Target language for translation is not set in settings.");
      return;
    }
    let textToTranslate = "";
    try {
      const decodedContent = decodeHtmlEntities(originalContent);
      if (detectThinkingTags(decodedContent).hasThinkingTags) {
        textToTranslate = decodedContent.replace(/<think>[\s\S]*?<\/think>/g, "").trim();
      } else {
        textToTranslate = decodedContent.trim();
      }
      if (!textToTranslate) {
        new import_obsidian14.Notice("Nothing to translate (content might be empty after removing internal tags).");
        return;
      }
    } catch (error) {
      this.plugin.logger.error("[handleTranslateClick] Error during text preprocessing:", error);
      new import_obsidian14.Notice("Failed to prepare text for translation.");
      return;
    }
    (_a = contentEl.querySelector(`.${CSS_CLASS_TRANSLATION_CONTAINER}`)) == null ? void 0 : _a.remove();
    const originalIcon = ((_b = buttonEl.querySelector(".svg-icon")) == null ? void 0 : _b.getAttribute("icon-name")) || "languages";
    (0, import_obsidian14.setIcon)(buttonEl, "loader");
    buttonEl.disabled = true;
    buttonEl.classList.add(CSS_CLASS_TRANSLATION_PENDING);
    const originalTitle = buttonEl.title;
    buttonEl.setAttribute("title", "Translating...");
    buttonEl.addClass("button-loading");
    try {
      const translatedText = await this.plugin.translationService.translate(textToTranslate, targetLang);
      if (!contentEl || !contentEl.isConnected) {
        this.plugin.logger.error(
          "[handleTranslateClick] contentEl is null or not connected to DOM when translation arrived."
        );
        return;
      }
      if (translatedText !== null) {
        const translationContainer = contentEl.createDiv({ cls: CSS_CLASS_TRANSLATION_CONTAINER });
        const translationContentEl = translationContainer.createDiv({ cls: CSS_CLASS_TRANSLATION_CONTENT });
        await import_obsidian14.MarkdownRenderer.render(
          this.app,
          translatedText,
          translationContentEl,
          (_d = (_c = this.plugin.app.vault.getRoot()) == null ? void 0 : _c.path) != null ? _d : "",
          this
        );
        fixBrokenTwemojiImages(translationContentEl);
        const targetLangName = LANGUAGES[targetLang] || targetLang;
        translationContainer.createEl("div", {
          cls: "translation-indicator",
          text: `[Translated to ${targetLangName}]`
        });
        this.guaranteedScrollToBottom(50, false);
      }
    } catch (error) {
      this.plugin.logger.error("[OllamaView] Unexpected error during message translation call:", error);
    } finally {
      if (buttonEl == null ? void 0 : buttonEl.isConnected) {
        (0, import_obsidian14.setIcon)(buttonEl, originalIcon);
        buttonEl.disabled = false;
        buttonEl.classList.remove(CSS_CLASS_TRANSLATION_PENDING);
        buttonEl.setAttribute("title", originalTitle);
        buttonEl.removeClass("button-loading");
      }
    }
  }
  renderDateSeparator(date) {
    if (!this.chatContainer)
      return;
    this.chatContainer.createDiv({
      cls: CSS_CLASS_DATE_SEPARATOR,
      text: this.formatDateSeparator(date)
    });
  }
  initSpeechWorker() {
    try {
      const bufferToBase64 = (buffer) => {
        let binary = "";
        const bytes = new Uint8Array(buffer);
        const len = bytes.byteLength;
        for (let i = 0; i < len; i++) {
          binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
      };
      const workerCode = `
             
             self.onmessage = async (event) => {
                 const { apiKey, audioBlob, languageCode = 'uk-UA' } = event.data;

                 if (!apiKey || apiKey.trim() === '') {
                     self.postMessage({ error: true, message: 'Google API Key is not configured. Please add it in plugin settings.' });
                     return;
                 }

                 const url = "https:

                 try {
                     const arrayBuffer = await audioBlob.arrayBuffer();

                     
                     
                     let base64Audio;
                     if (typeof TextDecoder !== 'undefined') { 
                             
                             const base64String = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
                             base64Audio = base64String;

                     } else {
                             
                             base64Audio = btoa(
                                 new Uint8Array(arrayBuffer).reduce((data, byte) => data + String.fromCharCode(byte), '')
                             );
                     }


                     const response = await fetch(url, {
                         method: 'POST',
                         body: JSON.stringify({
                             config: {
                                 encoding: 'WEBM_OPUS', 
                                 sampleRateHertz: 48000, 
                                 languageCode: languageCode,
                                 model: 'latest_long', 
                                 enableAutomaticPunctuation: true,
                             },
                             audio: { content: base64Audio },
                         }),
                         headers: { 'Content-Type': 'application/json' },
                     });

                     const responseData = await response.json();

                     if (!response.ok) {
                         
                         self.postMessage({
                             error: true,
                             message: "Error from Google Speech API: " + (responseData.error?.message || response.statusText || 'Unknown error')
                         });
                         return;
                     }

                     if (responseData.results && responseData.results.length > 0) {
                         const transcript = responseData.results
                             .map(result => result.alternatives[0].transcript)
                             .join(' ')
                             .trim();
                         self.postMessage(transcript); 
                     } else {
                         
                         self.postMessage({ error: true, message: 'No speech detected or recognized.' });
                     }
                 } catch (error) {
                     
                     self.postMessage({
                         error: true,
                         message: 'Error processing speech recognition: ' + (error instanceof Error ? error.message : String(error))
                     });
                 }
             };
           `;
      const workerBlob = new Blob([workerCode], {
        type: "application/javascript"
      });
      const workerUrl = URL.createObjectURL(workerBlob);
      this.speechWorker = new Worker(workerUrl);
      URL.revokeObjectURL(workerUrl);
      this.setupSpeechWorkerHandlers();
    } catch (error) {
      new import_obsidian14.Notice("Speech recognition feature failed to initialize.");
      this.speechWorker = null;
    }
  }
  setupSpeechWorkerHandlers() {
    if (!this.speechWorker)
      return;
    this.speechWorker.onmessage = (event) => {
      const data = event.data;
      if (data && typeof data === "object" && data.error) {
        new import_obsidian14.Notice(`Speech Recognition Error: ${data.message}`);
        this.updateInputPlaceholder(this.plugin.settings.modelName);
        this.updateSendButtonState();
        return;
      }
      if (typeof data === "string" && data.trim()) {
        const transcript = data.trim();
        this.insertTranscript(transcript);
      } else if (typeof data !== "string") {
      }
      this.updateSendButtonState();
    };
    this.speechWorker.onerror = (error) => {
      new import_obsidian14.Notice("An unexpected error occurred in the speech recognition worker.");
      this.updateInputPlaceholder(this.plugin.settings.modelName);
      this.stopVoiceRecording(false);
    };
  }
  insertTranscript(transcript) {
    var _a, _b;
    if (!this.inputEl)
      return;
    const currentVal = this.inputEl.value;
    const start = (_a = this.inputEl.selectionStart) != null ? _a : currentVal.length;
    const end = (_b = this.inputEl.selectionEnd) != null ? _b : currentVal.length;
    let textToInsert = transcript;
    const precedingChar = start > 0 ? currentVal[start - 1] : null;
    const followingChar = end < currentVal.length ? currentVal[end] : null;
    if (precedingChar && precedingChar !== " " && precedingChar !== "\n") {
      textToInsert = " " + textToInsert;
    }
    if (followingChar && followingChar !== " " && followingChar !== "\n" && !textToInsert.endsWith(" ")) {
      textToInsert += " ";
    }
    const newValue = currentVal.substring(0, start) + textToInsert + currentVal.substring(end);
    this.inputEl.value = newValue;
    const newCursorPos = start + textToInsert.length;
    this.inputEl.setSelectionRange(newCursorPos, newCursorPos);
    this.inputEl.focus();
    this.inputEl.dispatchEvent(new Event("input"));
  }
  async toggleVoiceRecognition() {
    if (this.mediaRecorder && this.mediaRecorder.state === "recording") {
      this.stopVoiceRecording(true);
    } else {
      await this.startVoiceRecognition();
    }
  }
  async startVoiceRecognition() {
    var _a;
    if (!this.speechWorker) {
      new import_obsidian14.Notice("\u0424\u0443\u043D\u043A\u0446\u0456\u044F \u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u0432\u0430\u043D\u043D\u044F \u043C\u043E\u0432\u043B\u0435\u043D\u043D\u044F \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u0430 (worker \u043D\u0435 \u0456\u043D\u0456\u0446\u0456\u0430\u043B\u0456\u0437\u043E\u0432\u0430\u043D\u043E).");
      return;
    }
    const speechApiKey = this.plugin.settings.googleApiKey;
    if (!speechApiKey) {
      new import_obsidian14.Notice(
        "\u041A\u043B\u044E\u0447 Google API \u0434\u043B\u044F \u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u0432\u0430\u043D\u043D\u044F \u043C\u043E\u0432\u043B\u0435\u043D\u043D\u044F \u043D\u0435 \u043D\u0430\u043B\u0430\u0448\u0442\u043E\u0432\u0430\u043D\u043E. \u0411\u0443\u0434\u044C \u043B\u0430\u0441\u043A\u0430, \u0434\u043E\u0434\u0430\u0439\u0442\u0435 \u0439\u043E\u0433\u043E \u0432 \u043D\u0430\u043B\u0430\u0448\u0442\u0443\u0432\u0430\u043D\u043D\u044F\u0445 \u043F\u043B\u0430\u0433\u0456\u043D\u0430."
      );
      return;
    }
    try {
      this.audioStream = await navigator.mediaDevices.getUserMedia({
        audio: true
      });
      let recorderOptions;
      const preferredMimeType = "audio/webm;codecs=opus";
      if (MediaRecorder.isTypeSupported(preferredMimeType)) {
        recorderOptions = { mimeType: preferredMimeType };
      } else {
        recorderOptions = void 0;
      }
      this.mediaRecorder = new MediaRecorder(this.audioStream, recorderOptions);
      const audioChunks = [];
      (_a = this.voiceButton) == null ? void 0 : _a.classList.add(CSS_CLASS_RECORDING);
      (0, import_obsidian14.setIcon)(this.voiceButton, "stop-circle");
      this.inputEl.placeholder = "Recording... Speak now.";
      this.mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          audioChunks.push(event.data);
        }
      };
      this.mediaRecorder.onstop = () => {
        var _a2;
        if (this.speechWorker && audioChunks.length > 0) {
          const audioBlob = new Blob(audioChunks, {
            type: ((_a2 = this.mediaRecorder) == null ? void 0 : _a2.mimeType) || "audio/webm"
          });
          this.inputEl.placeholder = "Processing speech...";
          this.speechWorker.postMessage({
            apiKey: speechApiKey,
            audioBlob,
            languageCode: this.plugin.settings.speechLanguage || "uk-UA"
          });
        } else if (audioChunks.length === 0) {
          this.getCurrentRoleDisplayName().then((roleName) => this.updateInputPlaceholder(roleName));
          this.updateSendButtonState();
        }
      };
      this.mediaRecorder.onerror = (event) => {
        new import_obsidian14.Notice("An error occurred during recording.");
        this.stopVoiceRecording(false);
      };
      this.mediaRecorder.start();
    } catch (error) {
      if (error instanceof DOMException && error.name === "NotAllowedError") {
        new import_obsidian14.Notice("Microphone access denied. Please grant permission.");
      } else if (error instanceof DOMException && error.name === "NotFoundError") {
        new import_obsidian14.Notice("Microphone not found. Please ensure it's connected and enabled.");
      } else {
        new import_obsidian14.Notice("Could not start voice recording.");
      }
      this.stopVoiceRecording(false);
    }
  }
  stopVoiceRecording(processAudio) {
    var _a, _b;
    if (this.mediaRecorder && this.mediaRecorder.state === "recording") {
      this.mediaRecorder.stop();
    } else if (!processAudio && ((_a = this.mediaRecorder) == null ? void 0 : _a.state) === "inactive") {
    }
    (_b = this.voiceButton) == null ? void 0 : _b.classList.remove(CSS_CLASS_RECORDING);
    (0, import_obsidian14.setIcon)(this.voiceButton, "mic");
    this.getCurrentRoleDisplayName().then((roleName) => this.updateInputPlaceholder(roleName));
    this.updateSendButtonState();
    if (this.audioStream) {
      this.audioStream.getTracks().forEach((track) => track.stop());
      this.audioStream = null;
    }
    this.mediaRecorder = null;
  }
  checkAllMessagesForCollapsing() {
    var _a;
    (_a = this.chatContainer) == null ? void 0 : _a.querySelectorAll(`.${CSS_CLASS_MESSAGE}`).forEach((msgEl) => {
      this.checkMessageForCollapsing(msgEl);
    });
  }
  toggleMessageCollapse(contentEl, buttonEl) {
    const maxHeightLimit = this.plugin.settings.maxMessageHeight;
    const isInitialExpandedState = buttonEl.hasAttribute("data-initial-state");
    if (isInitialExpandedState) {
      buttonEl.removeAttribute("data-initial-state");
      contentEl.style.maxHeight = `${maxHeightLimit}px`;
      contentEl.classList.add(CSS_CLASS_CONTENT_COLLAPSED);
      buttonEl.setText("Show More \u25BC");
      setTimeout(() => {
        contentEl.scrollIntoView({ behavior: "smooth", block: "nearest" });
      }, 310);
    } else {
      const isCollapsed = contentEl.classList.contains(CSS_CLASS_CONTENT_COLLAPSED);
      if (isCollapsed) {
        contentEl.style.maxHeight = "";
        contentEl.classList.remove(CSS_CLASS_CONTENT_COLLAPSED);
        buttonEl.setText("Show Less \u25B2");
      } else {
        contentEl.style.maxHeight = `${maxHeightLimit}px`;
        contentEl.classList.add(CSS_CLASS_CONTENT_COLLAPSED);
        buttonEl.setText("Show More \u25BC");
        setTimeout(() => {
          contentEl.scrollIntoView({ behavior: "smooth", block: "nearest" });
        }, 310);
      }
    }
  }
  getChatContainer() {
    return this.chatContainer;
  }
  clearChatContainerInternal() {
    this.currentMessages = [];
    this.lastRenderedMessageDate = null;
    if (this.chatContainer)
      this.chatContainer.empty();
    this.hideEmptyState();
    this.lastMessageElement = null;
    this.consecutiveErrorMessages = [];
    this.errorGroupElement = null;
    this.isSummarizingErrors = false;
  }
  clearDisplayAndState() {
    this.clearChatContainerInternal();
    this.showEmptyState();
    this.updateSendButtonState();
    setTimeout(() => this.focusInput(), 50);
  }
  scrollToBottom() {
    this.guaranteedScrollToBottom(50, true);
  }
  clearInputField() {
    if (this.inputEl) {
      this.inputEl.value = "";
      this.inputEl.dispatchEvent(new Event("input"));
    }
  }
  focusInput() {
    setTimeout(() => {
      var _a;
      (_a = this.inputEl) == null ? void 0 : _a.focus();
    }, 0);
  }
  guaranteedScrollToBottom(delay = 50, forceScroll = false) {
    if (this.scrollTimeout) {
      clearTimeout(this.scrollTimeout);
      this.scrollTimeout = null;
    }
    this.scrollTimeout = setTimeout(() => {
      requestAnimationFrame(() => {
        var _a, _b;
        if (this.chatContainer) {
          const threshold = 100;
          const isScrolledUp = this.chatContainer.scrollHeight - this.chatContainer.scrollTop - this.chatContainer.clientHeight > threshold;
          if (isScrolledUp !== this.userScrolledUp) {
            this.userScrolledUp = isScrolledUp;
            if (!isScrolledUp)
              (_a = this.newMessagesIndicatorEl) == null ? void 0 : _a.classList.remove(CSS_CLASS_VISIBLE);
          }
          if (forceScroll || !this.userScrolledUp || this.isProcessing) {
            const behavior = this.isProcessing ? "auto" : "smooth";
            this.chatContainer.scrollTo({
              top: this.chatContainer.scrollHeight,
              behavior
            });
            if (forceScroll) {
              this.userScrolledUp = false;
              (_b = this.newMessagesIndicatorEl) == null ? void 0 : _b.classList.remove(CSS_CLASS_VISIBLE);
            }
          }
        } else {
        }
      });
      this.scrollTimeout = null;
    }, delay);
  }
  formatTime(date) {
    return date.toLocaleTimeString(void 0, {
      hour: "numeric",
      minute: "2-digit"
    });
  }
  formatDateSeparator(date) {
    const now = new Date();
    const yesterday = new Date(now);
    yesterday.setDate(now.getDate() - 1);
    if (this.isSameDay(date, now))
      return "Today";
    else if (this.isSameDay(date, yesterday))
      return "Yesterday";
    else
      return date.toLocaleDateString(void 0, {
        weekday: "long",
        year: "numeric",
        month: "long",
        day: "numeric"
      });
  }
  formatRelativeDate(date) {
    if (!(date instanceof Date) || isNaN(date.getTime())) {
      return "Invalid date";
    }
    const now = new Date();
    const diffSeconds = Math.round((now.getTime() - date.getTime()) / 1e3);
    const diffDays = Math.floor(diffSeconds / (60 * 60 * 24));
    if (diffDays === 0) {
      const diffHours = Math.floor(diffSeconds / (60 * 60));
      if (diffHours < 1)
        return "Just now";
      if (diffHours === 1)
        return "1 hour ago";
      if (diffHours < now.getHours())
        return `${diffHours} hours ago`;
      else
        return "Today";
    } else if (diffDays === 1) {
      return "Yesterday";
    } else if (diffDays < 7) {
      return `${diffDays} days ago`;
    } else {
      return date.toLocaleDateString(void 0, {
        month: "short",
        day: "numeric"
      });
    }
  }
  isSameDay(date1, date2) {
    return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate();
  }
  formatChatToMarkdown(messagesToFormat) {
    let localLastDate = null;
    const exportTimestamp = new Date();
    let markdown = `# AI Forge Chat Export
> Exported on: ${exportTimestamp.toLocaleString(void 0)}

`;
    messagesToFormat.forEach((message) => {
      var _a;
      if (!((_a = message.content) == null ? void 0 : _a.trim()))
        return;
      if (localLastDate === null || !this.isSameDay(localLastDate, message.timestamp)) {
        if (localLastDate !== null)
          markdown += `***
`;
        markdown += `**${this.formatDateSeparator(message.timestamp)}**
***

`;
      }
      localLastDate = message.timestamp;
      const time = this.formatTime(message.timestamp);
      let prefix = "";
      let contentPrefix = "";
      let content = message.content.trim();
      if (message.role === "assistant") {
        content = decodeHtmlEntities(content).replace(/<think>[\s\S]*?<\/think>/g, "").trim();
        if (!content)
          return;
      }
      switch (message.role) {
        case "user":
          prefix = `**User (${time}):**
`;
          break;
        case "assistant":
          prefix = `**Assistant (${time}):**
`;
          break;
        case "system":
          prefix = `> _[System (${time})]_ 
> `;
          contentPrefix = "> ";
          break;
        case "error":
          prefix = `> [!ERROR] Error (${time}):
> `;
          contentPrefix = "> ";
          break;
      }
      markdown += prefix;
      if (contentPrefix) {
        markdown += content.split("\n").map((line) => line.trim() ? `${contentPrefix}${line}` : contentPrefix.trim()).join(`
`) + "\n\n";
      } else if (content.includes("```")) {
        content = content.replace(/(\n*\s*)```/g, "\n\n```").replace(/```(\s*\n*)/g, "```\n\n");
        markdown += content.trim() + "\n\n";
      } else {
        markdown += content.split("\n").map((line) => line.trim() ? line : "").join("\n") + "\n\n";
      }
    });
    return markdown.trim();
  }
  async getCurrentRoleDisplayName() {
    var _a, _b, _c, _d;
    try {
      const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
      const rolePath = (_c = (_b = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _b.selectedRolePath) != null ? _c : this.plugin.settings.selectedRolePath;
      if (rolePath) {
        const allRoles = await this.plugin.listRoleFiles(true);
        const foundRole = allRoles.find((role) => role.path === rolePath);
        if (foundRole) {
          return foundRole.name;
        } else {
          console.warn(`Role with path "${rolePath}" not found in listRoleFiles results.`);
          return ((_d = rolePath.split("/").pop()) == null ? void 0 : _d.replace(".md", "")) || "Selected Role";
        }
      }
    } catch (error) {
      console.error("Error getting current role display name:", error);
    }
    return "None";
  }
  updateTemperatureIndicator(temperature) {
    if (!this.temperatureIndicatorEl)
      return;
    const tempValue = temperature != null ? temperature : this.plugin.settings.temperature;
    const emoji = this.getTemperatureEmoji(tempValue);
    this.temperatureIndicatorEl.setText(emoji);
    this.temperatureIndicatorEl.title = `Temperature: ${tempValue.toFixed(1)}. Click to change.`;
  }
  getTemperatureEmoji(temperature) {
    if (temperature <= 0.4) {
      return "\u{1F9CA}";
    } else if (temperature > 0.4 && temperature <= 0.6) {
      return "\u{1F642}";
    } else {
      return "\u{1F92A}";
    }
  }
  updateToggleViewLocationOption() {
    var _a;
    (_a = this.dropdownMenuManager) == null ? void 0 : _a.updateToggleViewLocationOption();
  }
  async findRoleNameByPath(rolePath) {
    var _a;
    if (!rolePath) {
      return "None";
    }
    try {
      const allRoles = await this.plugin.listRoleFiles(true);
      const foundRole = allRoles.find((role) => role.path === rolePath);
      if (foundRole) {
        return foundRole.name;
      } else {
        const fileName = (_a = rolePath.split("/").pop()) == null ? void 0 : _a.replace(".md", "");
        this.plugin.logger.warn(
          `[findRoleNameByPath] Role not found for path "${rolePath}". Using derived name: "${fileName || "Unknown"}"`
        );
        return fileName || "Unknown Role";
      }
    } catch (error) {
      this.plugin.logger.error(`[findRoleNameByPath] Error fetching roles for path "${rolePath}":`, error);
      return "Error";
    }
  }
  async toggleSidebarSection(clickedHeaderEl) {
    const sectionType = clickedHeaderEl.getAttribute("data-section-type");
    const isCurrentlyCollapsed = clickedHeaderEl.getAttribute("data-collapsed") === "true";
    const iconEl = clickedHeaderEl.querySelector(`.${CSS_SIDEBAR_SECTION_ICON2}`);
    let contentEl = null;
    let updateFunction = null;
    let otherHeaderEl = null;
    let otherContentEl = null;
    let otherSectionType = null;
    const collapseIcon = "lucide-folder";
    const expandIcon = "lucide-folder-open";
    const expandedClass = "is-expanded";
    if (sectionType === "chats") {
      contentEl = this.chatPanelListEl;
      updateFunction = this.updateChatPanelList;
      otherHeaderEl = this.rolePanelHeaderEl;
      otherContentEl = this.rolePanelListEl;
      otherSectionType = "roles";
    } else if (sectionType === "roles") {
      contentEl = this.rolePanelListEl;
      updateFunction = this.updateRolePanelList;
      otherHeaderEl = this.chatPanelHeaderEl;
      otherContentEl = this.chatPanelListEl;
      otherSectionType = "chats";
    }
    if (!contentEl || !iconEl || !updateFunction || !otherHeaderEl || !otherContentEl || !otherSectionType) {
      this.plugin.logger.error("Could not find all required elements for sidebar accordion toggle:", sectionType);
      return;
    }
    if (isCurrentlyCollapsed) {
      if (otherHeaderEl.getAttribute("data-collapsed") === "false") {
        const otherIconEl = otherHeaderEl.querySelector(`.${CSS_SIDEBAR_SECTION_ICON2}`);
        otherHeaderEl.setAttribute("data-collapsed", "true");
        if (otherIconEl)
          (0, import_obsidian14.setIcon)(otherIconEl, collapseIcon);
        otherContentEl.classList.remove(expandedClass);
        if (otherSectionType === "chats" && this.newChatSidebarButton)
          this.newChatSidebarButton.hide();
      }
      clickedHeaderEl.setAttribute("data-collapsed", "false");
      (0, import_obsidian14.setIcon)(iconEl, expandIcon);
      if (sectionType === "chats" && this.newChatSidebarButton)
        this.newChatSidebarButton.show();
      try {
        await updateFunction();
        contentEl.classList.add(expandedClass);
      } catch (error) {
        this.plugin.logger.error(`Error updating sidebar section ${sectionType}:`, error);
        contentEl.setText(`Error loading ${sectionType}.`);
        contentEl.classList.add(expandedClass);
      }
    } else {
      clickedHeaderEl.setAttribute("data-collapsed", "true");
      (0, import_obsidian14.setIcon)(iconEl, collapseIcon);
      contentEl.classList.remove(expandedClass);
      if (sectionType === "chats" && this.newChatSidebarButton) {
        this.newChatSidebarButton.hide();
      }
    }
  }
  showChatContextMenu(event, chatMeta) {
    event.preventDefault();
    const menu = new import_obsidian14.Menu();
    menu.addItem(
      (item) => item.setTitle("Clone Chat").setIcon("lucide-copy-plus").onClick(() => this.handleContextMenuClone(chatMeta.id))
    );
    menu.addItem(
      (item) => item.setTitle("Rename Chat").setIcon("lucide-pencil").onClick(() => this.handleContextMenuRename(chatMeta.id, chatMeta.name))
    );
    menu.addItem(
      (item) => item.setTitle("Export to Note").setIcon("lucide-download").onClick(() => this.exportSpecificChat(chatMeta.id))
    );
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle("Clear Messages").setIcon("lucide-trash").onClick(() => this.handleContextMenuClear(chatMeta.id, chatMeta.name));
      try {
        item.el.addClass("danger-option");
      } catch (e) {
        this.plugin.logger.error("Failed to add danger class using item.el/dom:", e, item);
      }
    });
    menu.addItem((item) => {
      item.setTitle("Delete Chat").setIcon("lucide-trash-2").onClick(() => this.handleContextMenuDelete(chatMeta.id, chatMeta.name));
      try {
        item.el.addClass("danger-option");
      } catch (e) {
        this.plugin.logger.error("Failed to add danger class using item.el/dom:", e, item);
      }
    });
    menu.showAtMouseEvent(event);
  }
  async handleContextMenuClone(chatId) {
    const cloningNotice = new import_obsidian14.Notice("Cloning chat...", 0);
    try {
      const clonedChat = await this.plugin.chatManager.cloneChat(chatId);
      if (clonedChat) {
        new import_obsidian14.Notice(`Chat cloned as "${clonedChat.metadata.name}" and activated.`);
      } else {
      }
    } catch (error) {
      this.plugin.logger.error(`Context menu: Error cloning chat ${chatId}:`, error);
      new import_obsidian14.Notice("Error cloning chat.");
    } finally {
      cloningNotice.hide();
    }
  }
  async exportSpecificChat(chatId) {
    var _a;
    const exportingNotice = new import_obsidian14.Notice(`Exporting chat...`, 0);
    try {
      const chat = await this.plugin.chatManager.getChat(chatId);
      if (!chat || chat.messages.length === 0) {
        new import_obsidian14.Notice("Chat is empty or not found, nothing to export.");
        exportingNotice.hide();
        return;
      }
      const markdownContent = this.formatChatToMarkdown(chat.messages);
      const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
      const safeName = chat.metadata.name.replace(/[\\/?:*"<>|]/g, "-");
      const filename = `ollama-chat-${safeName}-${timestamp}.md`;
      let targetFolderPath = (_a = this.plugin.settings.chatExportFolderPath) == null ? void 0 : _a.trim();
      let targetFolder = null;
      if (targetFolderPath) {
        targetFolderPath = (0, import_obsidian14.normalizePath)(targetFolderPath);
        const abstractFile = this.app.vault.getAbstractFileByPath(targetFolderPath);
        if (!abstractFile) {
          try {
            await this.app.vault.createFolder(targetFolderPath);
            targetFolder = this.app.vault.getAbstractFileByPath(targetFolderPath);
            if (targetFolder)
              new import_obsidian14.Notice(`Created export folder: ${targetFolderPath}`);
          } catch (err) {
            this.plugin.logger.error("Error creating export folder:", err);
            new import_obsidian14.Notice(`Error creating export folder. Saving to vault root.`);
            targetFolder = this.app.vault.getRoot();
          }
        } else if (abstractFile instanceof import_obsidian14.TFolder) {
          targetFolder = abstractFile;
        } else {
          new import_obsidian14.Notice(`Error: Export path is not a folder. Saving to vault root.`);
          targetFolder = this.app.vault.getRoot();
        }
      } else {
        targetFolder = this.app.vault.getRoot();
      }
      if (!targetFolder) {
        new import_obsidian14.Notice("Error determining export folder.");
        exportingNotice.hide();
        return;
      }
      const filePath = (0, import_obsidian14.normalizePath)(`${targetFolder.path}/${filename}`);
      const existingFile = this.app.vault.getAbstractFileByPath(filePath);
      if (existingFile) {
      }
      const file = await this.app.vault.create(filePath, markdownContent);
      new import_obsidian14.Notice(`Chat exported to ${file.path}`);
    } catch (error) {
      this.plugin.logger.error(`Context menu: Error exporting chat ${chatId}:`, error);
      new import_obsidian14.Notice("An error occurred during chat export.");
    } finally {
      exportingNotice.hide();
    }
  }
  async handleContextMenuClear(chatId, chatName) {
    new ConfirmModal(
      this.app,
      "Confirm Clear Messages",
      `Are you sure you want to clear all messages in chat "${chatName}"?
This action cannot be undone.`,
      async () => {
        const clearingNotice = new import_obsidian14.Notice("Clearing messages...", 0);
        try {
          const success = await this.plugin.chatManager.clearChatMessagesById(chatId);
          if (success) {
            new import_obsidian14.Notice(`Messages cleared for chat "${chatName}".`);
          } else {
            new import_obsidian14.Notice(`Failed to clear messages for chat "${chatName}".`);
          }
        } catch (error) {
          this.plugin.logger.error(`Context menu: Error clearing messages for chat ${chatId}:`, error);
          new import_obsidian14.Notice("Error clearing messages.");
        } finally {
          clearingNotice.hide();
        }
      }
    ).open();
  }
  async handleContextMenuDelete(chatId, chatName) {
    new ConfirmModal(
      this.app,
      "Confirm Delete Chat",
      `Are you sure you want to delete chat "${chatName}"?
This action cannot be undone.`,
      async () => {
        const deletingNotice = new import_obsidian14.Notice("Deleting chat...", 0);
        try {
          const success = await this.plugin.chatManager.deleteChat(chatId);
          if (success) {
            new import_obsidian14.Notice(`Chat "${chatName}" deleted.`);
          } else {
          }
        } catch (error) {
          this.plugin.logger.error(`Context menu: Error deleting chat ${chatId}:`, error);
          new import_obsidian14.Notice("Error deleting chat.");
        } finally {
          deletingNotice.hide();
        }
      }
    ).open();
  }
  isChatScrolledUp() {
    if (!this.chatContainer)
      return false;
    const scrollableDistance = this.chatContainer.scrollHeight - this.chatContainer.clientHeight;
    if (scrollableDistance <= 0)
      return false;
    const distanceFromBottom = scrollableDistance - this.chatContainer.scrollTop;
    return distanceFromBottom >= SCROLL_THRESHOLD;
  }
  updateScrollStateAndIndicators() {
    var _a, _b;
    if (!this.chatContainer)
      return;
    const wasScrolledUp = this.userScrolledUp;
    this.userScrolledUp = this.isChatScrolledUp();
    (_a = this.scrollToBottomButton) == null ? void 0 : _a.classList.toggle(CSS_CLASS_VISIBLE, this.userScrolledUp);
    if (wasScrolledUp && !this.userScrolledUp) {
      (_b = this.newMessagesIndicatorEl) == null ? void 0 : _b.classList.remove(CSS_CLASS_VISIBLE);
    }
  }
  checkMessageForCollapsing(messageEl) {
    const contentCollapsible = messageEl.querySelector(`.${CSS_CLASSES.CONTENT_COLLAPSIBLE}`);
    const maxH = this.plugin.settings.maxMessageHeight;
    const isAssistantMessage = messageEl.classList.contains(CSS_CLASSES.OLLAMA_MESSAGE);
    if (!contentCollapsible)
      return;
    if (this.isProcessing && isAssistantMessage) {
      const existingButton = messageEl.querySelector(`.${CSS_CLASSES.SHOW_MORE_BUTTON}`);
      existingButton == null ? void 0 : existingButton.remove();
      contentCollapsible.style.maxHeight = "";
      contentCollapsible.classList.remove(CSS_CLASS_CONTENT_COLLAPSED);
      return;
    }
    if (maxH <= 0) {
      const existingButton = messageEl.querySelector(`.${CSS_CLASSES.SHOW_MORE_BUTTON}`);
      existingButton == null ? void 0 : existingButton.remove();
      contentCollapsible.style.maxHeight = "";
      contentCollapsible.classList.remove(CSS_CLASS_CONTENT_COLLAPSED);
      return;
    }
    requestAnimationFrame(() => {
      if (!contentCollapsible || !contentCollapsible.isConnected)
        return;
      const existingButton = messageEl.querySelector(`.${CSS_CLASSES.SHOW_MORE_BUTTON}`);
      existingButton == null ? void 0 : existingButton.remove();
      const currentMaxHeight = contentCollapsible.style.maxHeight;
      contentCollapsible.style.maxHeight = "";
      const scrollHeight = contentCollapsible.scrollHeight;
      contentCollapsible.style.maxHeight = currentMaxHeight;
      if (scrollHeight > maxH) {
        const collapseButton = messageEl.createEl("button", {
          cls: CSS_CLASSES.SHOW_MORE_BUTTON,
          text: "Show Less \u25B2"
        });
        collapseButton.setAttribute("data-initial-state", "expanded");
        this.registerDomEvent(
          collapseButton,
          "click",
          () => this.toggleMessageCollapse(contentCollapsible, collapseButton)
        );
        contentCollapsible.classList.remove(CSS_CLASS_CONTENT_COLLAPSED);
        contentCollapsible.style.maxHeight = "";
      } else {
        contentCollapsible.style.maxHeight = "";
        contentCollapsible.classList.remove(CSS_CLASS_CONTENT_COLLAPSED);
      }
    });
  }
  async handleSummarizeClick(originalContent, buttonEl) {
    var _a;
    const summarizationModel = this.plugin.settings.summarizationModelName;
    if (!summarizationModel) {
      new import_obsidian14.Notice("Please select a summarization model in AI Forge settings (Productivity section).");
      return;
    }
    let textToSummarize = originalContent;
    if (detectThinkingTags(decodeHtmlEntities(originalContent)).hasThinkingTags) {
      textToSummarize = decodeHtmlEntities(originalContent).replace(/<think>[\s\S]*?<\/think>/g, "").trim();
    }
    if (!textToSummarize || textToSummarize.length < 50) {
      new import_obsidian14.Notice("Message is too short to summarize meaningfully.");
      return;
    }
    const originalIcon = ((_a = buttonEl.querySelector(".svg-icon")) == null ? void 0 : _a.getAttribute("icon-name")) || "scroll-text";
    (0, import_obsidian14.setIcon)(buttonEl, "loader");
    buttonEl.disabled = true;
    const originalTitle = buttonEl.title;
    buttonEl.title = "Summarizing...";
    buttonEl.addClass(CSS_CLASS_DISABLED);
    buttonEl.addClass("button-loading");
    try {
      const prompt = `Provide a concise summary of the following text:

"""
${textToSummarize}
"""

Summary:`;
      const requestBody = {
        model: summarizationModel,
        prompt,
        stream: false,
        temperature: 0.2,
        options: {
          num_ctx: this.plugin.settings.contextWindow > 2048 ? 2048 : this.plugin.settings.contextWindow
        }
      };
      const responseData = await this.plugin.ollamaService.generateRaw(requestBody);
      if (responseData && responseData.response) {
        new SummaryModal(this.plugin, "Message Summary", responseData.response.trim()).open();
      } else {
        throw new Error("Received empty response from summarization model.");
      }
    } catch (error) {
      this.plugin.logger.error("Error during summarization:", error);
      let userMessage = "Summarization failed: ";
      if (error instanceof Error) {
        if (error.message.includes("404") || error.message.toLocaleLowerCase().includes("model not found")) {
          userMessage += `Model '${summarizationModel}' not found.`;
        } else if (error.message.includes("connect") || error.message.includes("fetch")) {
          userMessage += "Could not connect to Ollama server.";
        } else {
          userMessage += error.message;
        }
      } else {
        userMessage += "Unknown error occurred.";
      }
      new import_obsidian14.Notice(userMessage, 6e3);
    } finally {
      (0, import_obsidian14.setIcon)(buttonEl, originalIcon);
      buttonEl.disabled = false;
      buttonEl.title = originalTitle;
      buttonEl.removeClass(CSS_CLASS_DISABLED);
      buttonEl.removeClass("button-loading");
    }
  }
  /**
   * Створює нову групу для відображення помилок або оновлює існуючу.
   * Тепер використовує ErrorMessageRenderer для створення візуального блоку.
   * @param isContinuing Чи це продовження попередньої послідовності помилок.
   */
  renderOrUpdateErrorGroup(isContinuing) {
    if (!this.chatContainer)
      return;
    const errorsToDisplay = [...this.consecutiveErrorMessages];
    if (errorsToDisplay.length === 0) {
      return;
    }
    const errorCount = errorsToDisplay.length;
    const lastError = errorsToDisplay[errorCount - 1];
    let groupEl;
    let contentContainer = null;
    if (isContinuing && this.errorGroupElement) {
      groupEl = this.errorGroupElement;
      contentContainer = groupEl.querySelector(`.${CSS_CLASS_ERROR_TEXT2}`);
      if (contentContainer) {
        contentContainer.empty();
      } else {
        this.plugin.logger.error("[renderOrUpdateErrorGroup] Could not find error text container in existing group!");
        return;
      }
      this.updateErrorGroupTimestamp(groupEl, lastError.timestamp);
    } else {
      this.hideEmptyState();
      this.isSummarizingErrors = false;
      const renderer = new ErrorMessageRenderer(this.app, this.plugin, lastError, this);
      groupEl = renderer.render();
      contentContainer = groupEl.querySelector(`.${CSS_CLASS_ERROR_TEXT2}`);
      this.chatContainer.appendChild(groupEl);
      this.errorGroupElement = groupEl;
      this.lastMessageElement = groupEl;
    }
    if (contentContainer) {
      if (errorCount === 1) {
        contentContainer.setText(lastError.content);
      } else {
        contentContainer.setText(`Multiple errors occurred (${errorCount}). Summarizing...`);
        if (!this.isSummarizingErrors) {
          this.triggerErrorSummarization(groupEl, errorsToDisplay);
        }
      }
    } else {
      this.plugin.logger.error("[renderOrUpdateErrorGroup] Failed to find/create content container for error group.");
    }
    this.guaranteedScrollToBottom(50, true);
  }
  updateErrorGroupTimestamp(groupEl, timestamp) {
    groupEl.setAttribute("data-timestamp", timestamp.getTime().toString());
    const timestampEl = groupEl.querySelector(`.${CSS_CLASSES.TIMESTAMP}`);
    if (timestampEl) {
      timestampEl.setText(this.formatTime(timestamp));
    }
  }
  async triggerErrorSummarization(targetGroupElement, errors) {
    const ENABLE_ERROR_SUMMARIZATION = false;
    if (!ENABLE_ERROR_SUMMARIZATION) {
      this.displayErrorListFallback(targetGroupElement, errors);
      return;
    }
    if (!this.plugin.settings.summarizationModelName || this.isSummarizingErrors) {
      if (!this.plugin.settings.summarizationModelName) {
        if (this.isSummarizingErrors)
          this.displayErrorListFallback(targetGroupElement, errors);
      }
      return;
    }
    this.isSummarizingErrors = true;
    try {
      const summary = await this.summarizeErrors(errors);
      const contentContainer = targetGroupElement.querySelector(`.${CSS_CLASSES.ERROR_TEXT}`);
      if (!contentContainer || !contentContainer.isConnected) {
        this.plugin.logger.warn(
          "[triggerErrorSummarization] Error content container disappeared before summarization finished."
        );
        return;
      }
      contentContainer.empty();
      if (summary) {
        contentContainer.setText(`Multiple errors occurred. Summary:
${summary}`);
      } else {
        this.plugin.logger.warn(
          "[triggerErrorSummarization] Summarization failed or returned empty. Displaying list fallback."
        );
        this.displayErrorListFallback(targetGroupElement, errors);
      }
    } catch (error) {
      this.plugin.logger.error("[triggerErrorSummarization] Unexpected error during summarization process:", error);
      this.displayErrorListFallback(targetGroupElement, errors);
    } finally {
      this.isSummarizingErrors = false;
    }
  }
  displayErrorListFallback(targetGroupElement, errors) {
    const contentContainer = targetGroupElement.querySelector(`.${CSS_CLASSES.ERROR_TEXT}`);
    if (!contentContainer || !contentContainer.isConnected) {
      if (!targetGroupElement.isConnected) {
      }
      return;
    }
    contentContainer.empty();
    const uniqueErrors = Array.from(new Set(errors.map((e) => e.content.trim())));
    contentContainer.createDiv({
      text: `Multiple errors occurred (${errors.length} total, ${uniqueErrors.length} unique):`,
      cls: "error-summary-header"
    });
    const listEl = contentContainer.createEl("ul");
    listEl.style.marginTop = "5px";
    listEl.style.paddingLeft = "20px";
    listEl.style.listStyle = "disc";
    uniqueErrors.forEach((errorMsg) => {
      const listItem = listEl.createEl("li");
      listItem.textContent = errorMsg;
    });
    this.guaranteedScrollToBottom(50, true);
  }
  /**
   * Виконує сумаризацію списку повідомлень про помилки за допомогою Ollama.
   * @param errors Масив повідомлень про помилки.
   * @returns Рядок з сумаризацією або null у разі помилки.
   */
  async summarizeErrors(errors) {
    var _a;
    const modelName = this.plugin.settings.summarizationModelName;
    if (!modelName)
      return null;
    if (errors.length < 2)
      return ((_a = errors[0]) == null ? void 0 : _a.content) || null;
    const uniqueErrorContents = Array.from(new Set(errors.map((e) => e.content.trim())));
    const errorsText = uniqueErrorContents.map((msg, index) => `Error ${index + 1}: ${msg}`).join("\n");
    const prompt = `Concisely summarize the following ${uniqueErrorContents.length} unique error messages reported by the system. Focus on the core issue(s):

${errorsText}

Summary:`;
    const requestBody = {
      model: modelName,
      prompt,
      stream: false,
      temperature: 0.2,
      options: {
        num_ctx: this.plugin.settings.contextWindow > 1024 ? 1024 : this.plugin.settings.contextWindow
      },
      system: "You are an assistant that summarizes lists of technical error messages accurately and concisely."
    };
    try {
      this.plugin.logger.debug(
        `[summarizeErrors] Sending request to model ${modelName}. Prompt length: ${prompt.length}`
      );
      const responseData = await this.plugin.ollamaService.generateRaw(requestBody);
      if (responseData && responseData.response) {
        return responseData.response.trim();
      } else {
        return null;
      }
    } catch (error) {
      this.plugin.logger.error("[summarizeErrors] Failed to summarize errors:", error);
      return null;
    }
  }
  handleErrorMessage(errorMessage) {
    if (errorMessage.role !== "error") {
      return;
    }
    this.consecutiveErrorMessages.push(errorMessage);
    const isContinuingError = this.lastMessageElement === this.errorGroupElement && this.errorGroupElement !== null;
    if (!isContinuingError) {
      this.errorGroupElement = null;
      this.consecutiveErrorMessages = [errorMessage];
    }
    try {
      this.renderOrUpdateErrorGroup(isContinuingError);
    } catch (error) {
      this.plugin.logger.error("[handleErrorMessage] Failed to render/update error group:", error);
      try {
      } catch (e) {
      }
    }
  }
  // OllamaView.ts
  async sendMessage() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
    const content = this.inputEl.value.trim();
    if (!content || this.isProcessing || this.sendButton.disabled || this.currentAbortController !== null) {
      this.plugin.logger.warn(
        `sendMessage: Aborted. Content: ${!!content}, Processing: ${this.isProcessing}, SendDisabled: ${this.sendButton.disabled}, AbortCtrl: ${!!this.currentAbortController}`
      );
      return;
    }
    const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
    if (!activeChat) {
      new import_obsidian14.Notice("Error: No active chat session found.");
      this.plugin.logger.error("sendMessage: No active chat found.");
      return;
    }
    const userMessageContent = this.inputEl.value;
    this.clearInputField();
    this.setLoadingState(true);
    this.hideEmptyState();
    this.currentAbortController = new AbortController();
    let accumulatedResponse = "";
    const responseStartTime = new Date();
    const responseStartTimeMs = responseStartTime.getTime();
    (_b = this.stopGeneratingButton) == null ? void 0 : _b.show();
    (_c = this.sendButton) == null ? void 0 : _c.hide();
    let streamErrorOccurred = null;
    let currentLocalPlaceholderRef = null;
    try {
      this.plugin.logger.debug(`[sendMessage] Adding user message to chat: "${userMessageContent.substring(0, 50)}..."`);
      const userMessageTimestamp = new Date();
      const userMessageAddedPromise = new Promise((resolve) => {
        this.currentMessageAddedResolver = resolve;
      });
      await this.plugin.chatManager.addMessageToActiveChat("user", userMessageContent, userMessageTimestamp);
      await userMessageAddedPromise;
      this.plugin.logger.debug("[sendMessage] User message processed by handleMessageAdded.");
      this.plugin.logger.debug(`[sendMessage] Creating placeholder for assistant response (timestamp: ${responseStartTimeMs}).`);
      const assistantPlaceholderGroupEl = this.chatContainer.createDiv({
        cls: `${CSS_CLASSES.MESSAGE_GROUP} ${CSS_CLASSES.OLLAMA_GROUP} placeholder`
      });
      assistantPlaceholderGroupEl.setAttribute("data-placeholder-timestamp", responseStartTimeMs.toString());
      renderAvatar(this.app, this.plugin, assistantPlaceholderGroupEl, false);
      const messageWrapperEl = assistantPlaceholderGroupEl.createDiv({ cls: "message-wrapper" });
      messageWrapperEl.style.order = "2";
      const assistantMessageElement = messageWrapperEl.createDiv({
        cls: `${CSS_CLASSES.MESSAGE} ${CSS_CLASSES.OLLAMA_MESSAGE}`
      });
      const contentContainer = assistantMessageElement.createDiv({ cls: CSS_CLASSES.CONTENT_CONTAINER });
      const assistantContentEl = contentContainer.createDiv({
        cls: `${CSS_CLASSES.CONTENT} ${CSS_CLASSES.CONTENT_COLLAPSIBLE} streaming-text`
      });
      assistantContentEl.empty();
      const dots = assistantContentEl.createDiv({ cls: CSS_CLASSES.THINKING_DOTS });
      for (let i = 0; i < 3; i++)
        dots.createDiv({ cls: CSS_CLASSES.THINKING_DOT });
      if (assistantPlaceholderGroupEl && assistantContentEl && messageWrapperEl) {
        this.activePlaceholder = {
          timestamp: responseStartTimeMs,
          groupEl: assistantPlaceholderGroupEl,
          contentEl: assistantContentEl,
          messageWrapper: messageWrapperEl
        };
        currentLocalPlaceholderRef = this.activePlaceholder;
        this.plugin.logger.debug(`[sendMessage] Placeholder created and activePlaceholder set for ts: ${responseStartTimeMs}.`);
      } else {
        this.plugin.logger.error("sendMessage: Failed to create all placeholder elements!");
        throw new Error("Failed to create placeholder elements for AI response.");
      }
      assistantPlaceholderGroupEl.classList.add(CSS_CLASSES.MESSAGE_ARRIVING);
      setTimeout(() => assistantPlaceholderGroupEl == null ? void 0 : assistantPlaceholderGroupEl.classList.remove(CSS_CLASSES.MESSAGE_ARRIVING), 500);
      this.guaranteedScrollToBottom(50, true);
      const stream = this.plugin.ollamaService.generateChatResponseStream(
        activeChat,
        // activeChat вже містить повідомлення користувача
        this.currentAbortController.signal
      );
      let firstChunk = true;
      for await (const chunk of stream) {
        if (this.currentAbortController.signal.aborted) {
          this.plugin.logger.debug("[sendMessage] Stream aborted by user during iteration.");
          throw new Error("aborted by user");
        }
        if ("error" in chunk && chunk.error) {
          if (!chunk.error.includes("aborted by user")) {
            this.plugin.logger.error(`[sendMessage] Stream error: ${chunk.error}`);
            throw new Error(chunk.error);
          } else {
            throw new Error("aborted by user");
          }
        }
        if ("response" in chunk && chunk.response) {
          if (((_d = this.activePlaceholder) == null ? void 0 : _d.timestamp) === responseStartTimeMs && this.activePlaceholder.contentEl) {
            if (firstChunk) {
              const thinkingDots = this.activePlaceholder.contentEl.querySelector(`.${CSS_CLASSES.THINKING_DOTS}`);
              if (thinkingDots)
                thinkingDots.remove();
              firstChunk = false;
            }
            accumulatedResponse += chunk.response;
            try {
              await AssistantMessageRenderer.renderAssistantContent(
                this.activePlaceholder.contentEl,
                accumulatedResponse,
                this.app,
                this.plugin,
                this
              );
            } catch (renderError) {
              this.plugin.logger.error("[sendMessage] Error during streaming render:", renderError);
              if ((_e = this.activePlaceholder) == null ? void 0 : _e.contentEl) {
                this.activePlaceholder.contentEl.setText(
                  `[Render Error: ${renderError.message}]`
                );
              }
            }
            this.guaranteedScrollToBottom(50, true);
          } else {
            this.plugin.logger.warn(`[sendMessage] activePlaceholder mismatch or contentEl missing during stream. Current ts: ${(_f = this.activePlaceholder) == null ? void 0 : _f.timestamp}, expected: ${responseStartTimeMs}. Accumulated chunk anyway.`);
            accumulatedResponse += chunk.response;
          }
        }
        if ("done" in chunk && chunk.done) {
          this.plugin.logger.debug("[sendMessage] Stream finished (done chunk received).");
          break;
        }
      }
    } catch (error) {
      streamErrorOccurred = error;
      this.plugin.logger.error("[sendMessage] Error caught during stream OR user message add:", streamErrorOccurred);
    }
    try {
      if (streamErrorOccurred) {
        this.plugin.logger.error(`[sendMessage] Handling stream error: ${streamErrorOccurred.message}`);
        if (((_g = currentLocalPlaceholderRef == null ? void 0 : currentLocalPlaceholderRef.groupEl) == null ? void 0 : _g.isConnected) && currentLocalPlaceholderRef.timestamp === responseStartTimeMs) {
          this.plugin.logger.debug(`[sendMessage] Removing local placeholder (ts: ${responseStartTimeMs}) due to stream error.`);
          currentLocalPlaceholderRef.groupEl.remove();
        }
        if (((_h = this.activePlaceholder) == null ? void 0 : _h.timestamp) === responseStartTimeMs) {
          this.activePlaceholder = null;
        }
        let errorMsgContent = `Error: ${streamErrorOccurred.message || "Unknown streaming error."}`;
        let errorMsgRole = "error";
        let savePartial = false;
        if (streamErrorOccurred.message === "aborted by user") {
          errorMsgContent = "Generation stopped.";
          errorMsgRole = "system";
          if (accumulatedResponse.trim())
            savePartial = true;
        } else {
          new import_obsidian14.Notice(errorMsgContent, 5e3);
        }
        const errorAddedPromise = new Promise((resolve) => {
          this.currentMessageAddedResolver = resolve;
        });
        await this.plugin.chatManager.addMessageToActiveChat(errorMsgRole, errorMsgContent, new Date());
        await errorAddedPromise;
        if (savePartial) {
          this.plugin.logger.debug("[sendMessage] Saving partial assistant response after user cancellation.");
          const partialAddedPromise = new Promise((resolve) => {
            this.currentMessageAddedResolver = resolve;
          });
          await this.plugin.chatManager.addMessageToActiveChat("assistant", accumulatedResponse, responseStartTime, false);
          await partialAddedPromise;
        }
      } else if (!accumulatedResponse.trim()) {
        this.plugin.logger.warn("[sendMessage] Assistant provided an empty response (no stream error).");
        if (((_i = currentLocalPlaceholderRef == null ? void 0 : currentLocalPlaceholderRef.groupEl) == null ? void 0 : _i.isConnected) && currentLocalPlaceholderRef.timestamp === responseStartTimeMs) {
          this.plugin.logger.debug(`[sendMessage] Removing local placeholder (ts: ${responseStartTimeMs}) due to empty response.`);
          currentLocalPlaceholderRef.groupEl.remove();
        }
        if (((_j = this.activePlaceholder) == null ? void 0 : _j.timestamp) === responseStartTimeMs) {
          this.activePlaceholder = null;
        }
        const emptyRespPromise = new Promise((resolve) => {
          this.currentMessageAddedResolver = resolve;
        });
        await this.plugin.chatManager.addMessageToActiveChat("system", "Assistant provided an empty response.", new Date());
        await emptyRespPromise;
      } else {
        this.plugin.logger.debug(
          `[sendMessage] Stream successful. Accumulated response length: ${accumulatedResponse.length}. Adding to ChatManager.`
        );
        this.plugin.chatManager.addMessageToActiveChat("assistant", accumulatedResponse, responseStartTime, false);
      }
    } catch (error) {
      this.plugin.logger.error("[sendMessage] Error caught in final processing/error handling block:", error);
      try {
        const finalErrorPromise = new Promise((resolve) => {
          this.currentMessageAddedResolver = resolve;
        });
        await this.plugin.chatManager.addMessageToActiveChat(
          "error",
          `Internal error after stream: ${error.message}`,
          new Date()
        );
        await finalErrorPromise;
      } catch (finalErrorErr) {
        this.plugin.logger.error("Failed to even add the FINAL error message during sendMessage:", finalErrorErr);
      }
    } finally {
      this.plugin.logger.debug(`[sendMessage] Entering finally block for request ${responseStartTimeMs}.`);
      if (this.currentMessageAddedResolver) {
        this.plugin.logger.warn(`[sendMessage] currentMessageAddedResolver was not nullified for ts ${responseStartTimeMs}. Nullifying now.`);
        this.currentMessageAddedResolver = null;
      }
      if (((_k = this.activePlaceholder) == null ? void 0 : _k.timestamp) === responseStartTimeMs) {
        this.plugin.logger.warn(`[sendMessage] Active placeholder for ts ${responseStartTimeMs} was not handled. Removing it in finally.`);
        if ((_l = this.activePlaceholder.groupEl) == null ? void 0 : _l.isConnected) {
          this.activePlaceholder.groupEl.remove();
        }
        this.activePlaceholder = null;
      }
      this.setLoadingState(false);
      (_m = this.stopGeneratingButton) == null ? void 0 : _m.hide();
      (_n = this.sendButton) == null ? void 0 : _n.show();
      this.currentAbortController = null;
      this.updateSendButtonState();
      this.focusInput();
      this.plugin.logger.debug(`[sendMessage] Finished for request ${responseStartTimeMs}.`);
    }
  }
  // OllamaView.ts
  async handleMessageAdded(data) {
    var _a, _b, _c, _d, _e;
    const localResolver = this.currentMessageAddedResolver;
    this.currentMessageAddedResolver = null;
    const messageForLog = data == null ? void 0 : data.message;
    try {
      if (!data || !data.message) {
        this.plugin.logger.error("[HMA] Invalid data received in handleMessageAdded.", data);
        if (localResolver) {
          this.plugin.logger.debug("[HMA] Calling localResolver due to invalid data before return.");
          localResolver();
        }
        return;
      }
      const { chatId: eventChatId, message } = data;
      const messageTimestampMs = message.timestamp.getTime();
      this.plugin.logger.info(
        `[HMA] <<< ENTERED >>> Chat: ${eventChatId}, Role: ${message.role}, Ts: ${messageTimestampMs}, Content: "${message.content.substring(0, 50)}..."`
      );
      if (!this.chatContainer || !this.plugin.chatManager) {
        this.plugin.logger.error("[HMA] CRITICAL: Context (chatContainer or chatManager) missing!");
        if (localResolver) {
          this.plugin.logger.debug("[HMA] Calling localResolver due to missing context before return.");
          localResolver();
        }
        return;
      }
      const activeChatId = this.plugin.chatManager.getActiveChatId();
      if (eventChatId !== activeChatId) {
        this.plugin.logger.debug(`[HMA] Event for non-active chat ${eventChatId} (current is ${activeChatId}). Ignoring UI update.`);
        if (localResolver) {
          this.plugin.logger.debug("[HMA] Calling localResolver due to non-active chat before return.");
          localResolver();
        }
        return;
      }
      const existingMessageElInDom = this.chatContainer.querySelector(`.${CSS_CLASSES.MESSAGE_GROUP}:not(.placeholder)[data-timestamp="${messageTimestampMs}"]`);
      if (existingMessageElInDom) {
        this.plugin.logger.warn(`[HMA] Message with ts ${messageTimestampMs} (Role: ${message.role}) already exists in DOM and is NOT a placeholder. Skipping add.`);
        if (localResolver) {
          this.plugin.logger.debug("[HMA] Calling localResolver due to existing DOM element (not placeholder) before return.");
          localResolver();
        }
        return;
      }
      const alreadyInCache = this.currentMessages.some(
        (m) => m.timestamp.getTime() === messageTimestampMs && m.role === message.role && m.content === message.content
      );
      if (alreadyInCache) {
        this.plugin.logger.warn(`[HMA] Message with ts ${messageTimestampMs} (Role: ${message.role}) is already in currentMessages. Likely duplicate event. Content: "${message.content.substring(0, 30)}"`);
        if (localResolver) {
          this.plugin.logger.debug("[HMA] Calling localResolver due to message already in cache before return.");
          localResolver();
        }
        return;
      }
      if (message.role === "assistant" && ((_a = this.activePlaceholder) == null ? void 0 : _a.timestamp) === messageTimestampMs) {
        this.plugin.logger.debug(
          `[HMA] Assistant message (ts: ${messageTimestampMs}) matches active placeholder. Updating placeholder in place.`
        );
        const placeholderToUpdate = this.activePlaceholder;
        if (placeholderToUpdate.groupEl && placeholderToUpdate.groupEl.isConnected && placeholderToUpdate.contentEl && placeholderToUpdate.messageWrapper) {
          placeholderToUpdate.groupEl.classList.remove("placeholder");
          placeholderToUpdate.groupEl.removeAttribute("data-placeholder-timestamp");
          placeholderToUpdate.groupEl.setAttribute("data-timestamp", messageTimestampMs.toString());
          const messageDomElement = placeholderToUpdate.groupEl.querySelector(`.${CSS_CLASSES.MESSAGE}`);
          if (!messageDomElement) {
            this.plugin.logger.error("[HMA] Critical: Could not find .message element within placeholder group. Removing placeholder and adding normally.");
            if (placeholderToUpdate.groupEl.isConnected)
              placeholderToUpdate.groupEl.remove();
            this.activePlaceholder = null;
            await this.addMessageStandard(message);
            return;
          }
          placeholderToUpdate.contentEl.classList.remove("streaming-text");
          const dotsEl = placeholderToUpdate.contentEl.querySelector(`.${CSS_CLASSES.THINKING_DOTS}`);
          if (dotsEl)
            dotsEl.remove();
          try {
            await AssistantMessageRenderer.renderAssistantContent(
              placeholderToUpdate.contentEl,
              message.content,
              this.app,
              this.plugin,
              this
            );
            AssistantMessageRenderer.addAssistantActionButtons(
              placeholderToUpdate.messageWrapper,
              placeholderToUpdate.contentEl,
              message,
              this.plugin,
              this
            );
            BaseMessageRenderer.addTimestamp(messageDomElement, message.timestamp, this);
            this.lastMessageElement = placeholderToUpdate.groupEl;
            this.currentMessages.push(message);
            this.hideEmptyState();
            this.activePlaceholder = null;
            this.plugin.logger.debug(`[HMA] Placeholder for ts ${messageTimestampMs} successfully updated and activePlaceholder cleared.`);
            setTimeout(() => {
              if (placeholderToUpdate.groupEl.isConnected) {
                this.checkMessageForCollapsing(placeholderToUpdate.groupEl);
              }
            }, 50);
            this.guaranteedScrollToBottom(100, false);
          } catch (renderError) {
            this.plugin.logger.error("[HMA] Error during final render/update of placeholder:", renderError);
            if (placeholderToUpdate.groupEl.isConnected) {
              placeholderToUpdate.groupEl.remove();
            }
            this.activePlaceholder = null;
            this.handleErrorMessage({
              role: "error",
              content: `Failed to finalize assistant message display: ${renderError.message}`,
              timestamp: new Date()
            });
          }
        } else {
          this.plugin.logger.error(
            `[HMA] Active placeholder for ts ${messageTimestampMs} was matched, but its groupEl is not connected or contentEl/messageWrapper missing. groupEl connected: ${(_b = placeholderToUpdate.groupEl) == null ? void 0 : _b.isConnected}. Adding message normally.`
          );
          this.activePlaceholder = null;
          await this.addMessageStandard(message);
        }
      } else if (message.role === "assistant" && this.activePlaceholder && this.activePlaceholder.timestamp !== messageTimestampMs) {
        this.plugin.logger.warn(`[HMA] Received assistant message (ts: ${messageTimestampMs}) but active placeholder is for a DIFFERENT request (ts: ${this.activePlaceholder.timestamp}). Adding current message normally.`);
        await this.addMessageStandard(message);
      } else {
        if (message.role === "assistant" && !this.activePlaceholder) {
          this.plugin.logger.debug(`[HMA] No active placeholder for assistant message (ts: ${messageTimestampMs}). Adding normally.`);
        } else if (message.role !== "assistant") {
          this.plugin.logger.debug(`[HMA] Message is not from assistant (Role: ${message.role}, Ts: ${messageTimestampMs}). Adding normally.`);
        }
        await this.addMessageStandard(message);
      }
      this.plugin.logger.info(
        `[HMA] <<< Nearing end of try block >>> Role: ${message.role}, Ts: ${messageTimestampMs}`
      );
    } catch (outerError) {
      this.plugin.logger.error("[HMA] <<< CAUGHT OUTER ERROR >>> in handleMessageAdded:", outerError, data);
      this.handleErrorMessage({
        role: "error",
        content: `Internal error processing new message in handleMessageAdded: ${outerError.message}`,
        timestamp: new Date()
      });
    } finally {
      if (localResolver) {
        this.plugin.logger.debug(`[HMA] FINALLY: Calling localResolver for message role ${messageForLog == null ? void 0 : messageForLog.role}, ts ${(_c = messageForLog == null ? void 0 : messageForLog.timestamp) == null ? void 0 : _c.getTime()}`);
        try {
          localResolver();
        } catch (resolverError) {
          this.plugin.logger.error("[HMA] Error calling localResolver in finally:", resolverError);
        }
      } else {
        this.plugin.logger.debug(`[HMA] FINALLY: localResolver was null for message role ${messageForLog == null ? void 0 : messageForLog.role}, ts ${(_d = messageForLog == null ? void 0 : messageForLog.timestamp) == null ? void 0 : _d.getTime()}`);
      }
      this.plugin.logger.info(
        `[HMA] <<< EXITED (finally block) >>> Role: ${messageForLog == null ? void 0 : messageForLog.role}, Ts: ${(_e = messageForLog == null ? void 0 : messageForLog.timestamp) == null ? void 0 : _e.getTime()}`
      );
    }
  }
  // OllamaView.ts
  async handleRegenerateClick(userMessage) {
    var _a;
    if (this.isRegenerating) {
      new import_obsidian14.Notice("Regeneration is already in progress. Please wait.", 3e3);
      this.plugin.logger.warn("[Regenerate] Attempted to start regeneration while another one is already in progress.");
      return;
    }
    if (this.currentAbortController) {
      this.plugin.logger.warn(
        "[Regenerate] Attempted to start regeneration while currentAbortController is not null. Previous operation might be active."
      );
      new import_obsidian14.Notice("Previous generation process is still active or finishing. Please wait.", 4e3);
      return;
    }
    const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
    if (!activeChat) {
      new import_obsidian14.Notice("Cannot regenerate: No active chat found.");
      return;
    }
    const chatId = activeChat.metadata.id;
    const messageIndex = activeChat.messages.findIndex(
      (msg) => msg.timestamp.getTime() === userMessage.timestamp.getTime() && msg.role === userMessage.role
    );
    if (messageIndex === -1) {
      this.plugin.logger.error(
        "[Regenerate] Could not find the user message in the active chat history for regeneration.",
        userMessage
      );
      new import_obsidian14.Notice("Error: Could not find the message to regenerate from.");
      return;
    }
    const hasMessagesAfter = activeChat.messages.length > messageIndex + 1;
    new ConfirmModal(
      this.app,
      "Confirm Regeneration",
      hasMessagesAfter ? "This will delete all messages after this prompt and generate a new response. Continue?" : "Generate a new response for this prompt?",
      async () => {
        var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
        this.isRegenerating = true;
        this.plugin.logger.error(`[HANDLER] handleRegenerateClick: isRegenerating set to true for ts ${userMessage.timestamp.toISOString()}.`);
        this.currentAbortController = new AbortController();
        let accumulatedResponse = "";
        const responseStartTime = new Date();
        const responseStartTimeMs = responseStartTime.getTime();
        let currentLocalPlaceholderRef = null;
        this.setLoadingState(true);
        let streamErrorOccurred = null;
        let mainAssistantMessageProcessedPromise = null;
        let emptySystemMessageProcessedPromise = null;
        let errorMessageProcessedPromise = null;
        let partialMessageProcessedPromise = null;
        try {
          this.plugin.logger.debug(`[Regenerate] Starting for message at index ${messageIndex} in chat ${chatId}. HasMessagesAfter: ${hasMessagesAfter}`);
          if (hasMessagesAfter) {
            const deleteSuccess = await this.plugin.chatManager.deleteMessagesAfter(chatId, messageIndex);
            if (!deleteSuccess) {
              throw new Error("Failed to delete subsequent messages for regeneration.");
            }
            this.plugin.logger.debug(`[Regenerate] Subsequent messages deleted.`);
          }
          await this.loadAndDisplayActiveChat();
          this.guaranteedScrollToBottom(50, true);
          this.plugin.logger.debug(`[Regenerate] Chat reloaded to reflect deletions.`);
          this.plugin.logger.debug(`[Regenerate] Creating placeholder for new assistant response (timestamp: ${responseStartTimeMs}).`);
          const assistantPlaceholderGroupEl = this.chatContainer.createDiv({
            cls: `${CSS_CLASSES.MESSAGE_GROUP} ${CSS_CLASSES.OLLAMA_GROUP} placeholder`
          });
          assistantPlaceholderGroupEl.setAttribute("data-placeholder-timestamp", responseStartTimeMs.toString());
          renderAvatar(this.app, this.plugin, assistantPlaceholderGroupEl, false);
          const messageWrapperEl = assistantPlaceholderGroupEl.createDiv({ cls: "message-wrapper" });
          messageWrapperEl.style.order = "2";
          const assistantMessageElement = messageWrapperEl.createDiv({
            cls: `${CSS_CLASSES.MESSAGE} ${CSS_CLASSES.OLLAMA_MESSAGE}`
          });
          const contentContainer = assistantMessageElement.createDiv({ cls: CSS_CLASSES.CONTENT_CONTAINER });
          const assistantContentEl = contentContainer.createDiv({
            cls: `${CSS_CLASSES.CONTENT} ${CSS_CLASSES.CONTENT_COLLAPSIBLE} streaming-text`
          });
          assistantContentEl.empty();
          const dots = assistantContentEl.createDiv({ cls: CSS_CLASSES.THINKING_DOTS });
          for (let i = 0; i < 3; i++)
            dots.createDiv({ cls: CSS_CLASSES.THINKING_DOT });
          if (assistantPlaceholderGroupEl && assistantContentEl && messageWrapperEl) {
            this.activePlaceholder = {
              timestamp: responseStartTimeMs,
              groupEl: assistantPlaceholderGroupEl,
              contentEl: assistantContentEl,
              messageWrapper: messageWrapperEl
            };
            currentLocalPlaceholderRef = this.activePlaceholder;
            this.plugin.logger.debug(`[Regenerate] Placeholder created and activePlaceholder set for ts: ${responseStartTimeMs}.`);
          } else {
            this.plugin.logger.error("[Regenerate] Failed to create all placeholder elements!");
            throw new Error("Failed to create placeholder elements for regeneration.");
          }
          assistantPlaceholderGroupEl.classList.add(CSS_CLASSES.MESSAGE_ARRIVING);
          setTimeout(() => assistantPlaceholderGroupEl == null ? void 0 : assistantPlaceholderGroupEl.classList.remove(CSS_CLASSES.MESSAGE_ARRIVING), 500);
          this.guaranteedScrollToBottom(50, true);
          const chatForStreaming = await this.plugin.chatManager.getChat(chatId);
          if (!chatForStreaming) {
            throw new Error("Failed to get updated chat context for streaming regeneration.");
          }
          this.plugin.logger.debug(`[Regenerate] Starting stream with ${chatForStreaming.messages.length} messages in context for chat ${chatId}.`);
          const stream = this.plugin.ollamaService.generateChatResponseStream(
            chatForStreaming,
            this.currentAbortController.signal
            // Використовуємо AbortController, встановлений на початку
          );
          let firstChunk = true;
          for await (const chunk of stream) {
            if (this.currentAbortController.signal.aborted) {
              this.plugin.logger.debug("[Regenerate] Stream aborted by user during iteration.");
              throw new Error("aborted by user");
            }
            if ("error" in chunk && chunk.error) {
              if (!chunk.error.includes("aborted by user")) {
                this.plugin.logger.error(`[Regenerate] Stream error: ${chunk.error}`);
                throw new Error(chunk.error);
              } else {
                this.plugin.logger.debug("[Regenerate] Stream reported 'aborted by user'.");
                throw new Error("aborted by user");
              }
            }
            if ("response" in chunk && chunk.response) {
              if (((_a2 = this.activePlaceholder) == null ? void 0 : _a2.timestamp) === responseStartTimeMs && this.activePlaceholder.contentEl) {
                if (firstChunk) {
                  const thinkingDots = this.activePlaceholder.contentEl.querySelector(`.${CSS_CLASSES.THINKING_DOTS}`);
                  if (thinkingDots)
                    thinkingDots.remove();
                  firstChunk = false;
                }
                accumulatedResponse += chunk.response;
                await AssistantMessageRenderer.renderAssistantContent(
                  this.activePlaceholder.contentEl,
                  accumulatedResponse,
                  this.app,
                  this.plugin,
                  this
                );
                this.guaranteedScrollToBottom(50, true);
                if (this.activePlaceholder.groupEl) {
                  this.checkMessageForCollapsing(this.activePlaceholder.groupEl);
                }
              } else {
                this.plugin.logger.warn(`[Regenerate] activePlaceholder mismatch or contentEl missing during stream. Current ts: ${(_b = this.activePlaceholder) == null ? void 0 : _b.timestamp}, expected: ${responseStartTimeMs}. Accumulated chunk anyway.`);
                accumulatedResponse += chunk.response;
              }
            }
            if ("done" in chunk && chunk.done) {
              this.plugin.logger.debug("[Regenerate] Stream finished (done chunk received).");
              break;
            }
          }
          this.plugin.logger.debug(
            `[Regenerate] Stream completed. Final response length: ${accumulatedResponse.length}. Placeholder still valid for this request: ${((_c = this.activePlaceholder) == null ? void 0 : _c.timestamp) === responseStartTimeMs}`
          );
          if (accumulatedResponse.trim()) {
            this.plugin.logger.debug(`[Regenerate] Adding assistant message to ChatManager for ts ${responseStartTimeMs}: "${accumulatedResponse.substring(0, 100)}..."`);
            let resolver;
            mainAssistantMessageProcessedPromise = new Promise((resolve) => {
              resolver = resolve;
            });
            this.currentMessageAddedResolver = resolver;
            this.plugin.chatManager.addMessageToActiveChat(
              "assistant",
              accumulatedResponse,
              responseStartTime,
              false
            );
          } else if (!this.currentAbortController.signal.aborted) {
            this.plugin.logger.warn("[Regenerate] Assistant provided an empty response, and not due to cancellation.");
            if (((_d = this.activePlaceholder) == null ? void 0 : _d.timestamp) === responseStartTimeMs && ((_e = this.activePlaceholder.groupEl) == null ? void 0 : _e.isConnected)) {
              this.plugin.logger.debug(`[Regenerate] Removing placeholder for ts ${responseStartTimeMs} due to empty response.`);
              this.activePlaceholder.groupEl.remove();
            }
            if (((_f = this.activePlaceholder) == null ? void 0 : _f.timestamp) === responseStartTimeMs) {
              this.activePlaceholder = null;
            }
            let resolverForEmptySystem;
            emptySystemMessageProcessedPromise = new Promise((resolve) => {
              resolverForEmptySystem = resolve;
            });
            this.currentMessageAddedResolver = resolverForEmptySystem;
            this.plugin.chatManager.addMessageToActiveChat(
              "system",
              "Assistant provided an empty response during regeneration.",
              new Date()
            );
          }
        } catch (error) {
          streamErrorOccurred = error;
          this.plugin.logger.error("[Regenerate] Error during regeneration process:", error);
          if (((_g = this.activePlaceholder) == null ? void 0 : _g.timestamp) === responseStartTimeMs) {
            currentLocalPlaceholderRef = this.activePlaceholder;
          }
          if ((_h = currentLocalPlaceholderRef == null ? void 0 : currentLocalPlaceholderRef.groupEl) == null ? void 0 : _h.isConnected) {
            this.plugin.logger.debug(`[Regenerate] Removing local placeholder (ts: ${responseStartTimeMs}) due to error: ${error.message}`);
            currentLocalPlaceholderRef.groupEl.remove();
          }
          if (((_i = this.activePlaceholder) == null ? void 0 : _i.timestamp) === responseStartTimeMs) {
            this.activePlaceholder = null;
          }
          let errorMsgForChat;
          let errorMsgRole = "error";
          let savePartialResponseOnError = false;
          if (error.name === "AbortError" || ((_j = error.message) == null ? void 0 : _j.includes("aborted by user"))) {
            this.plugin.logger.info("[Regenerate] Regeneration was stopped by user or aborted.");
            errorMsgForChat = "Regeneration stopped.";
            errorMsgRole = "system";
            if (accumulatedResponse.trim()) {
              savePartialResponseOnError = true;
            }
          } else {
            errorMsgForChat = `Regeneration failed: ${error.message || "Unknown error"}`;
            new import_obsidian14.Notice(errorMsgForChat, 5e3);
          }
          let errorResolver;
          errorMessageProcessedPromise = new Promise((resolve) => {
            errorResolver = resolve;
          });
          this.currentMessageAddedResolver = errorResolver;
          this.plugin.chatManager.addMessageToActiveChat(errorMsgRole, errorMsgForChat, new Date());
          if (savePartialResponseOnError) {
            this.plugin.logger.debug("[Regenerate] Saving partial response after cancellation.");
            let partialResolver;
            partialMessageProcessedPromise = new Promise((resolve) => {
              partialResolver = resolve;
            });
            this.currentMessageAddedResolver = partialResolver;
            this.plugin.chatManager.addMessageToActiveChat(
              "assistant",
              accumulatedResponse,
              responseStartTime,
              false
            );
          }
        } finally {
          this.plugin.logger.debug(`[Regenerate] FINALLY (START) for req ${responseStartTimeMs}. isRegenerating: ${this.isRegenerating}, AbortCtrl: ${this.currentAbortController ? "active" : "null"}, isProcessing: ${this.isProcessing}`);
          const promisesToAwait = [];
          if (mainAssistantMessageProcessedPromise)
            promisesToAwait.push(mainAssistantMessageProcessedPromise);
          if (emptySystemMessageProcessedPromise)
            promisesToAwait.push(emptySystemMessageProcessedPromise);
          if (errorMessageProcessedPromise)
            promisesToAwait.push(errorMessageProcessedPromise);
          if (partialMessageProcessedPromise)
            promisesToAwait.push(partialMessageProcessedPromise);
          if (promisesToAwait.length > 0) {
            this.plugin.logger.debug(`[Regenerate] FINALLY: Awaiting ${promisesToAwait.length} message processing promise(s) for ts ${responseStartTimeMs}.`);
            try {
              await Promise.all(promisesToAwait);
              this.plugin.logger.debug(`[Regenerate] FINALLY: All message processing promises for ts ${responseStartTimeMs} resolved.`);
            } catch (awaitError) {
              this.plugin.logger.error(`[Regenerate] FINALLY: Error awaiting message processing promises for ts ${responseStartTimeMs}:`, awaitError);
            }
          } else {
            this.plugin.logger.debug(`[Regenerate] FINALLY: No specific message promises to await for ts ${responseStartTimeMs}.`);
          }
          if (((_k = this.activePlaceholder) == null ? void 0 : _k.timestamp) === responseStartTimeMs) {
            this.plugin.logger.warn(`[Regenerate] FINALLY (after await): Active placeholder for ts ${responseStartTimeMs} was STILL NOT CLEARED. This indicates an issue in handleMessageAdded or promise logic. Removing now.`);
            if ((_l = this.activePlaceholder.groupEl) == null ? void 0 : _l.isConnected) {
              this.activePlaceholder.groupEl.remove();
            }
            this.activePlaceholder = null;
          }
          const prevAbortCtrl = this.currentAbortController;
          this.currentAbortController = null;
          this.plugin.logger.debug(`[Regenerate] FINALLY: currentAbortController set to null for req ${responseStartTimeMs}. Was: ${prevAbortCtrl ? "active" : "null"}. Now: ${this.currentAbortController ? "active" : "null"}`);
          const prevIsRegen = this.isRegenerating;
          this.isRegenerating = false;
          this.plugin.logger.debug(`[Regenerate] FINALLY: isRegenerating set to false for req ${responseStartTimeMs}. Was: ${prevIsRegen}. Now: ${this.isRegenerating}`);
          this.plugin.logger.debug(`[Regenerate] FINALLY: Calling setLoadingState(false) for req ${responseStartTimeMs}.`);
          this.setLoadingState(false);
          requestAnimationFrame(() => {
            this.plugin.logger.debug(`[Regenerate] FINALLY (requestAnimationFrame): Forcing updateSendButtonState for req ${responseStartTimeMs}. currentAbortController is ${this.currentAbortController ? "active" : "null"}, isProcessing: ${this.isProcessing}`);
            this.updateSendButtonState();
            this.plugin.logger.debug(`[Regenerate] FINALLY (requestAnimationFrame): UI update attempt finished for req ${responseStartTimeMs}.`);
          });
          this.plugin.logger.debug(`[Regenerate] FINALLY (END) for req ${responseStartTimeMs}. isRegenerating: ${this.isRegenerating}, AbortCtrl: ${this.currentAbortController ? "active" : "null"}, isProcessing: ${this.isProcessing}`);
          this.focusInput();
        }
      }
    ).open();
  }
};

// src/ragService.ts
var import_obsidian15 = require("obsidian");
var RagService = class {
  constructor(plugin) {
    this.chunkEmbeddings = [];
    this.isIndexing = false;
    this.embeddingModelName = "nomic-embed-text";
    this.plugin = plugin;
    this.adapter = plugin.app.vault.adapter;
    this.vault = plugin.app.vault;
    this.metadataCache = plugin.app.metadataCache;
    this.embeddingModelName = this.plugin.settings.ragEmbeddingModel || DEFAULT_SETTINGS.ragEmbeddingModel;
  }
  // src/ragService.ts -> splitIntoChunks (Версія 3 - Розділення за Заголовками)
  splitIntoChunks(text, chunkSize) {
    if (!text)
      return [];
    this.plugin.logger.debug(`[RagService Chunking v3] Input text length: ${text.length}`);
    const lines = text.split("\n");
    const chunks = [];
    let currentChunkLines = [];
    const minChunkLength = 15;
    for (const line of lines) {
      const trimmedLine = line.trim();
      const isHeading = trimmedLine.startsWith("# ");
      if (currentChunkLines.length > 0 && (isHeading || currentChunkLines.join("\n").length + trimmedLine.length + 1 > chunkSize)) {
        const chunkText = currentChunkLines.join("\n").trim();
        if (chunkText.length >= minChunkLength) {
          chunks.push(chunkText);
        } else {
          this.plugin.logger.debug(`[RagService Chunking v3] Skipping short chunk (length ${chunkText.length}): "${chunkText.substring(0, 70)}..."`);
        }
        currentChunkLines = [];
      }
      if (trimmedLine.length > 0) {
        if (trimmedLine.length <= chunkSize) {
          currentChunkLines.push(trimmedLine);
        } else {
          this.plugin.logger.debug(`[RagService Chunking v3] Line too long (${trimmedLine.length}), splitting...`);
          for (let i = 0; i < trimmedLine.length; i += chunkSize) {
            const subChunk = trimmedLine.substring(i, i + chunkSize);
            if (subChunk.length >= minChunkLength) {
              chunks.push(subChunk);
            }
          }
          currentChunkLines = [];
        }
      }
    }
    if (currentChunkLines.length > 0) {
      const chunkText = currentChunkLines.join("\n").trim();
      if (chunkText.length >= minChunkLength) {
        chunks.push(chunkText);
      } else {
        this.plugin.logger.debug(`[RagService Chunking v3] Skipping final short chunk (length ${chunkText.length}): "${chunkText.substring(0, 70)}..."`);
      }
    }
    this.plugin.logger.debug(`[RagService Chunking v3] Produced ${chunks.length} chunks after filtering (>=${minChunkLength} chars).`);
    return chunks;
  }
  /**
   * ОНОВЛЕНО: Індексує markdown файли, розпізнаючи тег 'personal-focus'.
   */
  async indexDocuments() {
    var _a, _b;
    if (!this.plugin.settings.ragEnabled || !this.plugin.settings.ragEnableSemanticSearch) {
      this.plugin.logger.debug("[RagService] RAG semantic indexing skipped (disabled in settings).");
      this.chunkEmbeddings = [];
      return;
    }
    if (this.isIndexing) {
      this.plugin.logger.warn("[RagService] Indexing already in progress.");
      return;
    }
    this.isIndexing = true;
    this.plugin.logger.info("[RagService] Starting semantic indexing...");
    const startTime = Date.now();
    this.embeddingModelName = this.plugin.settings.ragEmbeddingModel || DEFAULT_SETTINGS.ragEmbeddingModel;
    const chunkSize = this.plugin.settings.ragChunkSize || DEFAULT_SETTINGS.ragChunkSize;
    const personalFocusTag = "personal-focus";
    this.plugin.logger.debug(`[RagService] Using embedding model: ${this.embeddingModelName}, Chunk size: ${chunkSize}, Personal Focus Tag: '${personalFocusTag}'`);
    const newEmbeddings = [];
    try {
      const folderPath = this.plugin.settings.ragFolderPath;
      const files = await this.getMarkdownFiles(this.vault, folderPath);
      this.plugin.logger.debug(`[RagService] Found ${files.length} markdown files in "${folderPath}".`);
      let processedFiles = 0;
      let personalFocusFiles = 0;
      for (const file of files) {
        try {
          const content = await this.vault.read(file);
          const fileCache = this.metadataCache.getFileCache(file);
          const frontmatter = (fileCache == null ? void 0 : fileCache.frontmatter) || {};
          const isPersonal = frontmatter[personalFocusTag] === true;
          if (isPersonal) {
            personalFocusFiles++;
            this.plugin.logger.debug(`[RagService] File ${file.path} marked as personal focus.`);
          }
          let bodyContent = content;
          if (fileCache == null ? void 0 : fileCache.frontmatterPosition) {
            bodyContent = content.substring(fileCache.frontmatterPosition.end.offset).trim();
          }
          const chunks = this.splitIntoChunks(bodyContent, chunkSize);
          if (!chunks || chunks.length === 0) {
            continue;
          }
          const vectors = await this.plugin.ollamaService.generateEmbeddings(chunks, this.embeddingModelName);
          if (vectors && vectors.length === chunks.length) {
            const metadata = {
              ...frontmatter,
              // Копіюємо весь frontmatter
              path: file.path,
              filename: file.name,
              created: (_a = file.stat) == null ? void 0 : _a.ctime,
              modified: (_b = file.stat) == null ? void 0 : _b.mtime,
              isPersonalFocus: isPersonal
              // <-- Зберігаємо прапорець
            };
            for (let i = 0; i < chunks.length; i++) {
              newEmbeddings.push({
                text: chunks[i],
                vector: vectors[i],
                metadata
                // Всі чанки файлу мають однакові метадані
              });
            }
            processedFiles++;
          } else {
            this.plugin.logger.warn(`[RagService] Mismatch or error generating embeddings for ${file.path}. Expected ${chunks.length}, got ${vectors == null ? void 0 : vectors.length}`);
          }
        } catch (error) {
          this.plugin.logger.error(`[RagService] Error processing file ${file.path}:`, error);
        }
      }
      this.chunkEmbeddings = newEmbeddings;
      const duration = (Date.now() - startTime) / 1e3;
      this.plugin.logger.info(`[RagService] Semantic indexing complete in ${duration.toFixed(2)}s. Indexed ${this.chunkEmbeddings.length} chunks from ${processedFiles} files (${personalFocusFiles} personal focus files).`);
    } catch (error) {
      this.plugin.logger.error("[RagService] Error during indexing process:", error);
    } finally {
      this.isIndexing = false;
    }
  }
  async getMarkdownFiles(vault, folderPath) {
    const files = [];
    if (!folderPath) {
      this.plugin.logger.warn("[RagService] RAG folder path is not set.");
      return files;
    }
    const folder = vault.getAbstractFileByPath((0, import_obsidian15.normalizePath)(folderPath));
    if (!(folder instanceof import_obsidian15.TFolder)) {
      this.plugin.logger.warn(`[RagService] RAG folder path "${folderPath}" not found or is not a folder.`);
      return files;
    }
    const allFiles = vault.getMarkdownFiles();
    for (const file of allFiles) {
      if (file.path.startsWith(folder.path + "/")) {
        files.push(file);
      }
    }
    return files;
  }
  calculateCosineSimilarity(vecA, vecB) {
    if (!vecA || !vecB || vecA.length !== vecB.length || vecA.length === 0) {
      return 0;
    }
    let dotProduct = 0;
    let normA = 0;
    let normB = 0;
    for (let i = 0; i < vecA.length; i++) {
      dotProduct += vecA[i] * vecB[i];
      normA += vecA[i] * vecA[i];
      normB += vecB[i] * vecB[i];
    }
    if (normA === 0 || normB === 0)
      return 0;
    const magnitude = Math.sqrt(normA) * Math.sqrt(normB);
    if (magnitude === 0)
      return 0;
    return dotProduct / magnitude;
  }
  /**
   * Знаходить релевантні ЧАНКИ документів за допомогою семантичної подібності.
   * Повертає чанки з метаданими, включаючи прапорець isPersonalFocus.
   */
  async findRelevantDocuments(query, limit) {
    var _a;
    if (!this.plugin.settings.ragEnableSemanticSearch) {
      this.plugin.logger.debug("[RagService] Semantic search disabled, skipping retrieval.");
      return [];
    }
    if (!this.chunkEmbeddings || this.chunkEmbeddings.length === 0 || !query) {
      if (((_a = this.chunkEmbeddings) == null ? void 0 : _a.length) === 0)
        this.plugin.logger.warn("[RagService] No chunk embeddings available for search. Index might be empty or disabled.");
      return [];
    }
    this.plugin.logger.debug(`[RagService] Performing semantic search for query: "${query}"`);
    const startTime = Date.now();
    try {
      const queryEmbeddings = await this.plugin.ollamaService.generateEmbeddings([query], this.embeddingModelName);
      if (!queryEmbeddings || queryEmbeddings.length === 0 || !queryEmbeddings[0]) {
        this.plugin.logger.error("[RagService] Failed to generate embedding for the query.");
        return [];
      }
      const queryVector = queryEmbeddings[0];
      const scoredChunks = this.chunkEmbeddings.map((chunk) => {
        const similarity = this.calculateCosineSimilarity(queryVector, chunk.vector);
        return { ...chunk, score: similarity };
      });
      const similarityThreshold = this.plugin.settings.ragSimilarityThreshold || DEFAULT_SETTINGS.ragSimilarityThreshold;
      const relevantChunks = scoredChunks.filter((chunk) => chunk.score >= similarityThreshold);
      relevantChunks.sort((a, b) => b.score - a.score);
      const duration = Date.now() - startTime;
      this.plugin.logger.debug(`[RagService] Semantic search completed in ${duration}ms. Found ${relevantChunks.length} chunks above threshold ${similarityThreshold}.`);
      return relevantChunks.slice(0, limit);
    } catch (error) {
      this.plugin.logger.error("[RagService] Error during semantic search:", error);
      return [];
    }
  }
  /**
   * ОНОВЛЕНО: Готує контекст для LLM, розділяючи "особистий фокус" та "загальний" контекст.
   * @param query Запит користувача для пошуку релевантних чанків.
   * @returns Рядок з форматованим контекстом або порожній рядок.
   */
  async prepareContext(query) {
    if (!this.plugin.settings.ragEnabled || !this.plugin.settings.ragEnableSemanticSearch) {
      this.plugin.logger.debug("[RagService] Context preparation skipped (RAG or semantic search disabled).");
      return "";
    }
    const topK = this.plugin.settings.ragTopK || DEFAULT_SETTINGS.ragTopK;
    const relevantChunks = await this.findRelevantDocuments(query, topK);
    if (relevantChunks.length === 0) {
      this.plugin.logger.debug("[RagService] No relevant documents found for context.");
      return "";
    }
    this.plugin.logger.debug(`[RagService] Preparing context from ${relevantChunks.length} top chunks.`);
    const personalFocusChunks = [];
    const generalContextChunks = [];
    relevantChunks.forEach((chunk) => {
      if (chunk.metadata.isPersonalFocus) {
        personalFocusChunks.push(chunk);
      } else {
        generalContextChunks.push(chunk);
      }
    });
    let finalContext = "";
    if (personalFocusChunks.length > 0) {
      finalContext += "### Personal Focus Context (User's Life State & Goals):\n";
      finalContext += "IMPORTANT: This section contains key information about the user's current situation, priorities, and desired actions. Use it for strategic planning, progress tracking, and aligning suggestions with their core objectives.\n\n";
      personalFocusChunks.forEach((chunk, index) => {
        var _a, _b, _c;
        let header = `--- Chunk ${index + 1} from Personal Focus Note: ${((_a = chunk.metadata) == null ? void 0 : _a.filename) || chunk.metadata.path}`;
        header += ` (Score: ${(_c = (_b = chunk.score) == null ? void 0 : _b.toFixed(3)) != null ? _c : "N/A"}) ---
`;
        finalContext += header;
        finalContext += chunk.text.trim() + "\n\n";
      });
      this.plugin.logger.debug(`[RagService] Added ${personalFocusChunks.length} personal focus chunks to context.`);
    } else {
      this.plugin.logger.debug(`[RagService] No personal focus chunks found among relevant results.`);
    }
    if (generalContextChunks.length > 0) {
      if (finalContext) {
        finalContext += "---\n\n";
      }
      finalContext += "### General Context from User Notes:\n";
      finalContext += "This section contains potentially relevant background information from the user's general notes.\n\n";
      generalContextChunks.forEach((chunk, index) => {
        var _a, _b, _c, _d;
        let header = `--- Chunk ${index + 1} from: ${((_a = chunk.metadata) == null ? void 0 : _a.filename) || chunk.metadata.path}`;
        if (((_b = chunk.metadata) == null ? void 0 : _b["personal-logs"]) === true)
          header += ` [Type: Personal Log]`;
        header += ` (Score: ${(_d = (_c = chunk.score) == null ? void 0 : _c.toFixed(3)) != null ? _d : "N/A"}) ---
`;
        finalContext += header;
        finalContext += chunk.text.trim() + "\n\n";
      });
      this.plugin.logger.debug(`[RagService] Added ${generalContextChunks.length} general context chunks to context.`);
    } else {
      this.plugin.logger.debug(`[RagService] No general context chunks found among relevant results.`);
    }
    if (finalContext) {
      finalContext += "### End of Context\n";
    }
    return finalContext.trim();
  }
};

// src/OllamaService.ts
var OllamaService = class {
  constructor(plugin) {
    this.eventHandlers = {};
    this.plugin = plugin;
    if (!plugin.promptService) {
      const errorMsg = "[OllamaService] CRITICAL: PromptService not available on plugin instance during OllamaService construction!";
      plugin.logger.error(errorMsg);
      throw new Error(errorMsg);
    }
    this.promptService = plugin.promptService;
  }
  // --- Event Emitter (залишаємо без змін) ---
  on(event, callback) {
    if (!this.eventHandlers[event])
      this.eventHandlers[event] = [];
    this.eventHandlers[event].push(callback);
    return () => {
      var _a, _b;
      this.eventHandlers[event] = (_a = this.eventHandlers[event]) == null ? void 0 : _a.filter((h) => h !== callback);
      if (((_b = this.eventHandlers[event]) == null ? void 0 : _b.length) === 0)
        delete this.eventHandlers[event];
    };
  }
  emit(event, data) {
    const h = this.eventHandlers[event];
    if (h)
      h.slice().forEach((handler) => {
        try {
          handler(data);
        } catch (e) {
          console.error(`Error in OllamaService event handler for ${event}:`, e);
        }
      });
  }
  // ------------------------------------------
  setBaseUrl(url) {
  }
  /**
   * Відправляє запит на генерацію відповіді Ollama і повертає асинхронний ітератор для отримання частин відповіді.
   * @param chat Поточний об'єкт чату.
   * @param signal AbortSignal для можливості переривання запиту.
   * @returns Асинхронний ітератор, що видає OllamaStreamChunk.
   */
  async *generateChatResponseStream(chat, signal) {
    var _a;
    if (!chat) {
      this.plugin.logger.error("[OllamaService] generateChatResponseStream called with null chat.");
      yield { error: "Chat object is null." };
      return;
    }
    if (!this.promptService) {
      this.plugin.logger.error("[OllamaService] PromptService is not initialized!");
      yield { error: "Prompt service is unavailable." };
      return;
    }
    const currentSettings = this.plugin.settings;
    const modelName = chat.metadata.modelName || currentSettings.modelName;
    const temperature = (_a = chat.metadata.temperature) != null ? _a : currentSettings.temperature;
    if (!modelName) {
      this.plugin.logger.error("[OllamaService] No model specified in chat metadata or settings.");
      yield { error: "No Ollama model selected." };
      return;
    }
    const url = `${this.plugin.settings.ollamaServerUrl}/api/generate`;
    const headers = { "Content-Type": "application/json" };
    try {
      const history = chat.getMessages();
      this.plugin.logger.debug("[OllamaService] Getting system prompt from PromptService...");
      const systemPrompt = await this.promptService.getSystemPromptForAPI(chat.metadata);
      this.plugin.logger.debug("[OllamaService] Preparing prompt body from PromptService...");
      const promptBody = await this.promptService.preparePromptBody(history, chat.metadata);
      if (promptBody === null || promptBody === void 0) {
        this.plugin.logger.error("[OllamaService] Prompt body generation failed (returned null/undefined).");
        yield { error: "Could not generate prompt body." };
        return;
      }
      const requestBody = {
        model: modelName,
        prompt: promptBody,
        stream: true,
        // <--- ВАЖЛИВО: Вмикаємо стрімінг
        temperature,
        options: { num_ctx: currentSettings.contextWindow },
        ...systemPrompt && { system: systemPrompt }
      };
      this.plugin.logger.debug(`[OllamaService] Starting STREAMING request to ${url}: Model:"${modelName}", Temp:${temperature}, System Provided: ${!!systemPrompt}`);
      this.plugin.logger.debug("[OllamaService] Request body (prompt truncated):", { ...requestBody, prompt: promptBody.substring(0, 200) + "..." });
      const response = await fetch(url, {
        method: "POST",
        headers,
        body: JSON.stringify(requestBody),
        signal
        // <--- Передаємо AbortSignal
      });
      if (!response.ok) {
        let errorText = `Ollama API error! Status: ${response.status}`;
        try {
          const errorJson = await response.json();
          errorText += `: ${(errorJson == null ? void 0 : errorJson.error) || response.statusText || "No details"}`;
        } catch (e) {
          errorText += `: ${response.statusText || "Could not parse error details"}`;
        }
        this.plugin.logger.error(`[OllamaService] ${errorText}`);
        this.emit("connection-error", new Error(errorText));
        yield { error: errorText };
        return;
      }
      if (!response.body) {
        throw new Error("Response body is null");
      }
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = "";
      while (true) {
        const { done, value } = await reader.read();
        if (signal == null ? void 0 : signal.aborted) {
          this.plugin.logger.info("[OllamaService] Stream reading aborted by signal.");
          reader.cancel("Aborted by user");
          yield { error: "Generation aborted by user.", done: true };
          return;
        }
        if (done) {
          this.plugin.logger.debug("[OllamaService] Stream finished.");
          if (buffer.trim()) {
            try {
              const jsonChunk = JSON.parse(buffer.trim());
              yield jsonChunk;
            } catch (e) {
              this.plugin.logger.warn(`[OllamaService] Could not parse final buffer content: ${buffer.trim()}`, e);
            }
          }
          break;
        }
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split("\n");
        buffer = lines.pop() || "";
        for (const line of lines) {
          if (line.trim() === "")
            continue;
          try {
            const jsonChunk = JSON.parse(line.trim());
            yield jsonChunk;
            if (jsonChunk.done) {
              this.plugin.logger.debug("[OllamaService] Received 'done: true' chunk, finalizing stream.");
              reader.cancel("Stream finished by Ollama");
              return;
            }
          } catch (e) {
            this.plugin.logger.error(`[OllamaService] Failed to parse JSON chunk: ${line.trim()}`, e);
          }
        }
      }
    } catch (error) {
      if (error.name === "AbortError") {
        this.plugin.logger.info("[OllamaService] Fetch request aborted.");
        yield { error: "Generation aborted by user.", done: true };
      } else {
        this.plugin.logger.error("[OllamaService] Error during chat response stream generation:", error);
        let errorMessage = error instanceof Error ? error.message : "Unknown error generating stream.";
        if (errorMessage.includes("connect") || errorMessage.includes("fetch") || errorMessage.includes("NetworkError") || errorMessage.includes("Failed to fetch")) {
          errorMessage = `Connection Error: Failed to reach Ollama at ${this.plugin.settings.ollamaServerUrl}. Is it running?`;
          this.emit("connection-error", new Error(errorMessage));
        }
        yield { error: errorMessage };
      }
    }
  }
  // --- Інші методи (getModels, getModelDetails, generateEmbeddings, generateRaw, _ollamaFetch) ---
  // Важливо: _ollamaFetch ТЕПЕР НЕ ПОТРІБЕН для generateChatResponseStream,
  // але може бути корисним для інших запитів (embeddings, tags, show), якщо вони не потребують стрімінгу.
  // Якщо ви їх не використовуєте або можете адаптувати generateChatResponseStream для них, то _ollamaFetch можна видалити.
  // Залишимо його поки що, але переконайтесь, що generateRaw та інші використовують його коректно (як було в запиті).
  /**
   * Sends a non-streaming request body to the Ollama /api/generate endpoint.
   * (Залишаємо для можливої сумісності або інших потреб)
   */
  async generateRaw(requestBody) {
    var _a, _b;
    this.plugin.logger.debug("[OllamaService] Sending RAW (non-streaming) request to /api/generate:", { model: requestBody.model, temp: requestBody.temperature, system: !!requestBody.system, prompt_len: (_a = requestBody.prompt) == null ? void 0 : _a.length });
    if (!requestBody.model || !requestBody.prompt) {
      throw new Error("generateRaw requires 'model' and 'prompt' in requestBody");
    }
    requestBody.stream = false;
    if (!requestBody.system) {
      delete requestBody.system;
    }
    const url = `${this.plugin.settings.ollamaServerUrl}/api/generate`;
    const headers = { "Content-Type": "application/json" };
    try {
      const response = await fetch(url, {
        method: "POST",
        headers,
        body: JSON.stringify(requestBody)
        // Не передаємо signal тут, бо запит не потоковий і не має сенсу його переривати
      });
      if (!response.ok) {
        let errorText = `Ollama API error! Status: ${response.status}`;
        try {
          const errorJson = await response.json();
          errorText += `: ${(errorJson == null ? void 0 : errorJson.error) || response.statusText || "No details"}`;
        } catch (e) {
          errorText += `: ${response.statusText || "Could not parse error details"}`;
        }
        this.plugin.logger.error(`[OllamaService] ${errorText}`);
        this.emit("connection-error", new Error(errorText));
        throw new Error(errorText);
      }
      if (!response.body)
        throw new Error("Response body is null");
      return await response.json();
    } catch (error) {
      this.plugin.logger.error(`[OllamaService] Error in generateRaw (${url}):`, error);
      const connectionErrorMsg = `Failed to connect/communicate with Ollama server at ${this.plugin.settings.ollamaServerUrl}. Is it running? (Endpoint: /api/generate)`;
      if (!((_b = error.message) == null ? void 0 : _b.includes("Ollama API error"))) {
        this.emit("connection-error", new Error(connectionErrorMsg));
      }
      throw new Error(error.message || connectionErrorMsg);
    }
  }
  /**
   * Generates embeddings for a list of text prompts.
   * (Залишаємо без змін, використовує fetch)
   */
  async generateEmbeddings(prompts, model) {
    if (!prompts || prompts.length === 0)
      return [];
    const endpoint = "/api/embeddings";
    const url = `${this.plugin.settings.ollamaServerUrl}${endpoint}`;
    const headers = { "Content-Type": "application/json" };
    this.plugin.logger.debug(`[OllamaService] Generating ${prompts.length} embeddings using model ${model}...`);
    const embeddingsList = [];
    try {
      for (const prompt of prompts) {
        const trimmedPrompt = prompt.trim();
        if (!trimmedPrompt) {
          this.plugin.logger.warn("[OllamaService] Skipping empty prompt for embedding.");
          continue;
        }
        const requestBody = JSON.stringify({ model, prompt: trimmedPrompt });
        try {
          const response = await fetch(url, { method: "POST", headers, body: requestBody });
          if (!response.ok) {
            let errorText = `Ollama Embeddings API error! Status: ${response.status}`;
            try {
              const errJson = await response.json();
              errorText += `: ${(errJson == null ? void 0 : errJson.error) || "Details unavailable"}`;
            } catch (e) {
            }
            throw new Error(errorText);
          }
          const embeddingResponse = await response.json();
          if (embeddingResponse && embeddingResponse.embedding) {
            embeddingsList.push(embeddingResponse.embedding);
          } else {
            this.plugin.logger.warn(`[OllamaService] Invalid structure in embedding response for model ${model}. Prompt (start): "${trimmedPrompt.substring(0, 50)}..."`);
          }
        } catch (singleError) {
          this.plugin.logger.error(`[OllamaService] Failed to generate embedding for one prompt using model ${model}. Prompt (start): "${trimmedPrompt.substring(0, 50)}..."`, singleError);
          this.emit("connection-error", new Error(singleError.message || "Embedding generation failed"));
        }
      }
      this.plugin.logger.debug(`[OllamaService] Successfully generated ${embeddingsList.length} embeddings (out of ${prompts.length} prompts).`);
      return embeddingsList.length > 0 ? embeddingsList : null;
    } catch (error) {
      this.plugin.logger.error(`[OllamaService] General error during embedding generation for model ${model}:`, error);
      return null;
    }
  }
  /**
  * Gets list of available models.
  * (Залишаємо без змін, використовує fetch)
  */
  async getModels(forceRefresh = false) {
    var _a;
    const endpoint = "/api/tags";
    const url = `${this.plugin.settings.ollamaServerUrl}${endpoint}`;
    this.plugin.logger.debug(`[OllamaService] Fetching models from ${url}`);
    let modelListResult = [];
    try {
      const response = await fetch(url, { method: "GET" });
      if (!response.ok) {
        let errorText = `Ollama Tags API error! Status: ${response.status}`;
        try {
          const errJson = await response.json();
          errorText += `: ${(errJson == null ? void 0 : errJson.error) || "Details unavailable"}`;
        } catch (e) {
        }
        this.plugin.logger.error(`[OllamaService] ${errorText}`);
        this.emit("connection-error", new Error(errorText));
        throw new Error(errorText);
      }
      const data = await response.json();
      if (data && Array.isArray(data.models)) {
        const modelNames = data.models.map((m) => m == null ? void 0 : m.name).filter((name) => typeof name === "string" && name.length > 0).sort();
        this.plugin.logger.debug(`[OllamaService] Found ${modelNames.length} models.`);
        modelListResult = modelNames;
      } else {
        this.plugin.logger.warn("[OllamaService] Invalid response structure received from /api/tags:", data);
      }
    } catch (e) {
      this.plugin.logger.error(`[OllamaService] Failed to fetch models:`, e);
      if (!((_a = e.message) == null ? void 0 : _a.includes("API error"))) {
        this.emit("connection-error", new Error(e.message || "Failed to fetch models"));
      }
    }
    return modelListResult;
  }
  /**
   * Gets details for a specific model.
   * (Залишаємо без змін, використовує fetch)
   */
  async getModelDetails(modelName) {
    var _a;
    this.plugin.logger.debug(`[OllamaService] Fetching details for model: ${modelName}`);
    const endpoint = "/api/show";
    const url = `${this.plugin.settings.ollamaServerUrl}${endpoint}`;
    const headers = { "Content-Type": "application/json" };
    try {
      const response = await fetch(url, { method: "POST", headers, body: JSON.stringify({ name: modelName }) });
      if (!response.ok) {
        let errorText = `Ollama Show API error! Status: ${response.status}`;
        try {
          const errJson = await response.json();
          errorText += `: ${(errJson == null ? void 0 : errJson.error) || "Details unavailable"}`;
        } catch (e) {
        }
        this.plugin.logger.error(`[OllamaService] ${errorText}`);
        this.emit("connection-error", new Error(errorText));
        throw new Error(errorText);
      }
      const data = await response.json();
      return data;
    } catch (e) {
      this.plugin.logger.warn(`[OllamaService] Failed to get details for model ${modelName}:`, e);
      if (!((_a = e.message) == null ? void 0 : _a.includes("API error"))) {
        this.emit("connection-error", new Error(e.message || `Failed to get details for ${modelName}`));
      }
      return null;
    }
  }
  // _ollamaFetch більше не потрібен, оскільки всі запити тепер використовують fetch напряму.
  // Можна його видалити.
  // ВИДАЛЕНО МЕТОД generateChatResponse (старий, не потоковий)
  // Всі виклики мають тепер використовувати generateChatResponseStream
};

// src/PromptService.ts
var import_obsidian16 = require("obsidian");
var PromptService = class {
  constructor(plugin) {
    this.currentSystemPrompt = null;
    this.currentRolePath = null;
    this.roleCache = {};
    this.modelDetailsCache = {};
    this.plugin = plugin;
    this.app = plugin.app;
  }
  _countTokens(text) {
    if (!text)
      return 0;
    return Math.ceil(text.length / 4);
  }
  clearRoleCache() {
    this.plugin.logger.debug("[PromptService] Clearing role definition cache.");
    this.roleCache = {};
    this.currentRolePath = null;
    this.currentSystemPrompt = null;
  }
  clearModelDetailsCache() {
    this.plugin.logger.debug("[PromptService] Clearing model details cache.");
    this.modelDetailsCache = {};
  }
  async getRoleDefinition(rolePath) {
    var _a, _b, _c;
    const normalizedPath = rolePath ? (0, import_obsidian16.normalizePath)(rolePath) : null;
    if (normalizedPath === this.currentRolePath && normalizedPath && this.roleCache[normalizedPath]) {
      return this.roleCache[normalizedPath];
    }
    if (normalizedPath !== this.currentRolePath) {
      this.plugin.logger.info(`[PromptService] Role path changing from '${this.currentRolePath}' to '${normalizedPath}'. Clearing cache.`);
      if (this.currentRolePath && this.roleCache[this.currentRolePath]) {
        delete this.roleCache[this.currentRolePath];
      }
      this.currentRolePath = normalizedPath;
      this.currentSystemPrompt = null;
    }
    if (!normalizedPath || !this.plugin.settings.followRole) {
      this.plugin.logger.debug("[PromptService] No role path or followRole disabled. Role definition is null.");
      const definition = {
        systemPrompt: null,
        // Тут не можемо визначити isProductivityPersona без читання файлу,
        // але для випадку без ролі це не важливо. Якщо б логіка була іншою,
        // треба було б додати перевірку файлу тут.
        isProductivityPersona: false
      };
      return definition;
    }
    if (this.roleCache[normalizedPath]) {
      this.plugin.logger.debug(`[PromptService] Returning newly cached role definition for: ${normalizedPath}`);
      this.currentSystemPrompt = this.roleCache[normalizedPath].systemPrompt;
      return this.roleCache[normalizedPath];
    }
    this.plugin.logger.debug(`[PromptService] Loading role definition from file: ${normalizedPath}`);
    const file = this.app.vault.getAbstractFileByPath(normalizedPath);
    if (file instanceof import_obsidian16.TFile) {
      try {
        const fileCache = this.app.metadataCache.getFileCache(file);
        const frontmatter = fileCache == null ? void 0 : fileCache.frontmatter;
        const content = await this.app.vault.cachedRead(file);
        const systemPromptBody = ((_a = fileCache == null ? void 0 : fileCache.frontmatterPosition) == null ? void 0 : _a.end) ? content.substring(fileCache.frontmatterPosition.end.offset).trim() : content.trim();
        const isProductivity = ((_b = frontmatter == null ? void 0 : frontmatter.assistant_type) == null ? void 0 : _b.toLowerCase()) === "productivity" || (frontmatter == null ? void 0 : frontmatter.is_planner) === true;
        const definition = {
          systemPrompt: systemPromptBody || null,
          isProductivityPersona: isProductivity
        };
        this.plugin.logger.info(`[PromptService] Role loaded: ${normalizedPath}. Is Productivity: ${isProductivity}. Prompt length: ${((_c = definition.systemPrompt) == null ? void 0 : _c.length) || 0}`);
        this.roleCache[normalizedPath] = definition;
        this.currentSystemPrompt = definition.systemPrompt;
        return definition;
      } catch (error) {
        this.plugin.logger.error(`[PromptService] Error processing role file ${normalizedPath}:`, error);
        new import_obsidian16.Notice(`Error loading role: ${file.basename}. Check console.`);
        this.currentSystemPrompt = null;
        return { systemPrompt: null, isProductivityPersona: false };
      }
    } else {
      this.plugin.logger.warn(`[PromptService] Role file not found or not a file: ${normalizedPath}`);
      this.currentSystemPrompt = null;
      return { systemPrompt: null, isProductivityPersona: false };
    }
  }
  async _isProductivityPersonaActive(rolePath) {
    var _a;
    if (!this.plugin.settings.enableProductivityFeatures) {
      return false;
    }
    const roleDefinition = await this.getRoleDefinition(rolePath);
    return (_a = roleDefinition == null ? void 0 : roleDefinition.isProductivityPersona) != null ? _a : false;
  }
  /**
   * ОНОВЛЕНО: Повертає фінальний системний промпт для API, включаючи нові RAG інструкції.
   */
  async getSystemPromptForAPI(chatMetadata) {
    var _a, _b;
    const settings = this.plugin.settings;
    this.plugin.logger.debug(`[PromptService] Building system prompt for chat: ${chatMetadata.id}, Role path: ${(_a = chatMetadata.selectedRolePath) != null ? _a : settings.selectedRolePath}`);
    const selectedRolePath = chatMetadata.selectedRolePath !== void 0 && chatMetadata.selectedRolePath !== null ? chatMetadata.selectedRolePath : settings.selectedRolePath;
    let roleDefinition = null;
    if (selectedRolePath && settings.followRole) {
      roleDefinition = await this.getRoleDefinition(selectedRolePath);
    }
    const roleSystemPrompt = (roleDefinition == null ? void 0 : roleDefinition.systemPrompt) || null;
    const isProductivityActive = (_b = roleDefinition == null ? void 0 : roleDefinition.isProductivityPersona) != null ? _b : false;
    const ragInstructions = `
--- RAG Data Interpretation Rules ---
You will be provided context from the user's notes, potentially split into two sections:
1.  '### Personal Focus Context (User's Life State & Goals)':
    * This section contains HIGH-PRIORITY information reflecting the user's current situation, desired state, goals, priorities, and actions they believe they should take.
    * TREAT THIS SECTION AS THE PRIMARY SOURCE for understanding the user's core objectives and current life context.
    * Use this to align your suggestions, track progress on stated goals/priorities, and provide strategic guidance.
2.  '### General Context from User Notes':
    * This section contains potentially relevant background information from the user's general notes, identified based on semantic similarity to the current query.
    * Use this for supplementary details and broader context.

General Rules for BOTH Context Sections:
* Each context chunk originates from a specific file indicated in its header (e.g., "--- Chunk 1 from Personal Focus Note: My Goals.md ..."). You can refer to source files by name.
* Context from files/chunks marked with "[Type: Personal Log]" contains personal reflections, activities, or logs. Use this for analysis of personal state, mood, energy, and progress.
* Assume ANY bullet point item (lines starting with '-', '*', '+') OR any line containing one or more hash tags (#tag) represents a potential user goal, task, objective, idea, or key point. **Pay special attention to categorizing these:**
    * **Critical Goals/Tasks:** Identify these if the line contains tags like #critical, #critical\u{1F198} or keywords like "\u043A\u0440\u0438\u0442\u0438\u0447\u043D\u043E", "critical", "\u0442\u0435\u0440\u043C\u0456\u043D\u043E\u0432\u043E", "urgent". **Prioritize discussing these items, potential blockers, and progress.**
    * **Weekly Goals/Tasks:** Identify these if the line contains tags like #week, #weekly or keywords like "weekly", "\u0442\u0438\u0436\u043D\u0435\u0432\u0430", "\u0442\u0438\u0436\u043D\u0435\u0432\u0438\u0439". Consider their relevance for the current or upcoming week's planning.
    * Use the surrounding text and the source document name for context for all identified items.
* If the user asks about "available data", "all my notes", "summarize my RAG data", or similar general terms, base your answer on the ENTIRE provided context (both Personal Focus and General Context sections). Analyze themes across different chunks and documents.
--- End RAG Data Interpretation Rules ---
        `.trim();
    let finalSystemPrompt = "";
    if (settings.ragEnabled && this.plugin.ragService && settings.ragEnableSemanticSearch) {
      finalSystemPrompt += ragInstructions + "\n\n";
      this.plugin.logger.debug("[PromptService] RAG instructions added to system prompt.");
    } else {
      this.plugin.logger.debug("[PromptService] RAG instructions NOT added (RAG disabled or semantic search disabled).");
    }
    if (roleSystemPrompt) {
      finalSystemPrompt += roleSystemPrompt.trim();
      this.plugin.logger.debug(`[PromptService] Role system prompt added (Length: ${roleSystemPrompt.trim().length})`);
    } else {
      this.plugin.logger.debug("[PromptService] No role system prompt to add.");
    }
    if (isProductivityActive && finalSystemPrompt && settings.enableProductivityFeatures) {
      const now = new Date();
      const formattedDate = now.toLocaleDateString(void 0, { weekday: "long", year: "numeric", month: "long", day: "numeric" });
      const formattedTime = now.toLocaleTimeString(void 0, { hour: "numeric", minute: "2-digit" });
      finalSystemPrompt = finalSystemPrompt.replace(/\[Current Time\]/gi, formattedTime);
      finalSystemPrompt = finalSystemPrompt.replace(/\[Current Date\]/gi, formattedDate);
      this.plugin.logger.debug("[PromptService] Dynamic date/time injected.");
    }
    const trimmedFinalPrompt = finalSystemPrompt.trim();
    this.plugin.logger.debug(`[PromptService] Final System Prompt Length: ${trimmedFinalPrompt.length} chars. Has content: ${trimmedFinalPrompt.length > 0}`);
    return trimmedFinalPrompt.length > 0 ? trimmedFinalPrompt : null;
  }
  /**
   * Готує ТІЛО основного промпту (без системного), включаючи історію, контекст завдань та RAG.
   * Використовує оновлений `prepareContext` з `RagService`.
   */
  async preparePromptBody(history, chatMetadata) {
    var _a, _b;
    this.plugin.logger.debug("[PromptService] Preparing prompt body...");
    const settings = this.plugin.settings;
    const selectedRolePath = chatMetadata.selectedRolePath !== void 0 && chatMetadata.selectedRolePath !== null ? chatMetadata.selectedRolePath : settings.selectedRolePath;
    const isProductivityActive = await this._isProductivityPersonaActive(selectedRolePath);
    this.plugin.logger.debug(`[PromptService] Productivity features potentially active for body: ${isProductivityActive}`);
    let taskContext = "";
    if (isProductivityActive && settings.enableProductivityFeatures && this.plugin.chatManager) {
      await ((_b = (_a = this.plugin).checkAndProcessTaskUpdate) == null ? void 0 : _b.call(_a));
      const taskState = this.plugin.chatManager.getCurrentTaskState();
      if (taskState && taskState.hasContent) {
        taskContext = "\n--- Today's Tasks Context ---\n";
        taskContext += `Urgent: ${taskState.urgent.join(", ") || "None"}
`;
        taskContext += `Other: ${taskState.regular.join(", ") || "None"}
`;
        taskContext += "--- End Tasks Context ---";
        this.plugin.logger.debug(`[PromptService] Injecting task context (Urgent: ${taskState.urgent.length}, Regular: ${taskState.regular.length})`);
      } else {
        this.plugin.logger.debug("[PromptService] No relevant task state found or no tasks to inject.");
      }
    }
    const approxTaskTokens = this._countTokens(taskContext);
    const maxRagTokens = settings.ragEnabled ? settings.ragTopK * settings.ragChunkSize / 4 * 1.8 : 0;
    const maxHistoryTokens = settings.contextWindow - approxTaskTokens - maxRagTokens - 250;
    this.plugin.logger.debug(`[PromptService] Max tokens available for history processing: ${maxHistoryTokens}`);
    let processedHistoryString = "";
    if (isProductivityActive && settings.useAdvancedContextStrategy) {
      processedHistoryString = await this._buildAdvancedContext(history, chatMetadata, maxHistoryTokens);
    } else {
      processedHistoryString = this._buildSimpleContext(history, maxHistoryTokens);
    }
    let ragContext = "";
    if (settings.ragEnabled && this.plugin.ragService && settings.ragEnableSemanticSearch) {
      const lastUserMessage = history.findLast((m) => m.role === "user");
      if (lastUserMessage == null ? void 0 : lastUserMessage.content) {
        ragContext = await this.plugin.ragService.prepareContext(lastUserMessage.content);
        if (!ragContext)
          this.plugin.logger.info("[PromptService] RAG prepareContext returned empty.");
        else
          this.plugin.logger.debug(`[PromptService] RAG context length: ${ragContext.length} chars`);
      } else {
        this.plugin.logger.warn("[PromptService] RAG enabled, but no last user message found.");
      }
    } else {
      this.plugin.logger.debug("[PromptService] RAG context NOT prepared.");
    }
    let finalPromptBodyParts = [];
    if (ragContext) {
      finalPromptBodyParts.push(ragContext);
    }
    if (taskContext) {
      finalPromptBodyParts.push(taskContext);
    }
    if (processedHistoryString) {
      finalPromptBodyParts.push(`### Conversation History:
${processedHistoryString}`);
    }
    const finalPromptBody = finalPromptBodyParts.join("\n\n").trim();
    if (!finalPromptBody) {
      this.plugin.logger.warn("[PromptService] No RAG, no tasks, and no history processed. Returning null prompt body.");
      return null;
    }
    this.plugin.logger.debug(`[PromptService] Final prompt body length (approx tokens): ${this._countTokens(finalPromptBody)}`);
    return finalPromptBody;
  }
  // Методи _buildSimpleContext, _buildAdvancedContext, _summarizeMessages
  // залишаються без структурних змін (тільки логування)
  _buildSimpleContext(history, maxTokens) {
    let context = "";
    let currentTokens = 0;
    for (let i = history.length - 1; i >= 0; i--) {
      const message = history[i];
      if (message.role === "system" || message.role === "error")
        continue;
      const formattedMessage = `${message.role === "user" ? "User" : "Assistant"}: ${message.content.trim()}`;
      const messageTokens = this._countTokens(formattedMessage) + 5;
      if (currentTokens + messageTokens <= maxTokens) {
        context = formattedMessage + "\n\n" + context;
        currentTokens += messageTokens;
      } else {
        this.plugin.logger.debug(`[PromptService] Simple context limit reached (${currentTokens}/${maxTokens} tokens). Stopping history inclusion.`);
        break;
      }
    }
    return context.trim();
  }
  async _buildAdvancedContext(history, chatMetadata, maxTokens) {
    this.plugin.logger.debug("[PromptService] Building advanced context...");
    const settings = this.plugin.settings;
    const processedParts = [];
    let currentTokens = 0;
    const keepN = Math.max(0, settings.keepLastNMessagesBeforeSummary || 3);
    const actualKeepN = Math.min(history.length, keepN);
    const messagesToKeep = history.slice(-actualKeepN);
    const messagesToProcess = history.slice(0, -actualKeepN);
    this.plugin.logger.debug(`[PromptService] Advanced Context: Keeping last ${messagesToKeep.length}, processing ${messagesToProcess.length} older messages.`);
    if (messagesToProcess.length > 0) {
      let olderContextTokens = 0;
      let olderContextContent = "";
      if (settings.enableSummarization) {
        this.plugin.logger.info("[PromptService] Summarization enabled, attempting to summarize older messages...");
        const summary = await this._summarizeMessages(messagesToProcess, chatMetadata);
        if (summary) {
          olderContextContent = `[Summary of earlier conversation]:
${summary}`;
          olderContextTokens = this._countTokens(olderContextContent) + 10;
        } else {
          this.plugin.logger.warn("[PromptService] Summarization failed or returned empty. Will try to include older messages directly.");
        }
      }
      if (!olderContextContent) {
        this.plugin.logger.info("[PromptService] Including older messages directly if space allows.");
        let includedOlderCount = 0;
        for (let i = messagesToProcess.length - 1; i >= 0; i--) {
          const message = messagesToProcess[i];
          if (message.role === "system" || message.role === "error")
            continue;
          const formattedMessage = `${message.role === "user" ? "User" : "Assistant"}: ${message.content.trim()}`;
          const messageTokens = this._countTokens(formattedMessage) + 5;
          if (currentTokens + olderContextTokens + messageTokens <= maxTokens) {
            olderContextContent = formattedMessage + "\n\n" + olderContextContent;
            olderContextTokens += messageTokens;
            includedOlderCount++;
          } else {
            this.plugin.logger.debug(`[PromptService] Token limit reached while including older messages directly (${currentTokens + olderContextTokens}/${maxTokens}). Included ${includedOlderCount}.`);
            break;
          }
        }
        if (includedOlderCount > 0) {
          olderContextContent = `[Start of older messages directly included]:
${olderContextContent.trim()}
[End of older messages]`;
          olderContextTokens += 10;
        }
      }
      if (olderContextContent && currentTokens + olderContextTokens <= maxTokens) {
        processedParts.push(olderContextContent);
        currentTokens += olderContextTokens;
        this.plugin.logger.debug(`[PromptService] Added older context part (${olderContextTokens} tokens). Current total: ${currentTokens}`);
      } else if (olderContextContent) {
        this.plugin.logger.warn(`[PromptService] Older context part (${olderContextTokens} tokens) exceeds limit (${maxTokens - currentTokens} available). Skipping.`);
      }
    }
    let keptMessagesString = "";
    let keptMessagesTokens = 0;
    let includedKeptCount = 0;
    for (let i = messagesToKeep.length - 1; i >= 0; i--) {
      const message = messagesToKeep[i];
      if (message.role === "system" || message.role === "error")
        continue;
      const formattedMessage = `${message.role === "user" ? "User" : "Assistant"}: ${message.content.trim()}`;
      const messageTokens = this._countTokens(formattedMessage) + 5;
      if (currentTokens + keptMessagesTokens + messageTokens <= maxTokens) {
        keptMessagesString = formattedMessage + "\n\n" + keptMessagesString;
        keptMessagesTokens += messageTokens;
        includedKeptCount++;
      } else {
        this.plugin.logger.debug(`[PromptService] Token limit reached while including kept messages (${currentTokens + keptMessagesTokens}/${maxTokens}). Included ${includedKeptCount}.`);
        break;
      }
    }
    if (keptMessagesString) {
      processedParts.push(keptMessagesString.trim());
      currentTokens += keptMessagesTokens;
      this.plugin.logger.debug(`[PromptService] Added kept messages part (${keptMessagesTokens} tokens). Final total: ${currentTokens}`);
    } else {
      this.plugin.logger.debug("[PromptService] No kept messages to add or token limit prevented inclusion.");
    }
    this.plugin.logger.debug(`[PromptService] Advanced context built. Final approx tokens: ${currentTokens}`);
    return processedParts.join("\n\n").trim();
  }
  async _summarizeMessages(messagesToSummarize, chatMetadata) {
    if (!this.plugin.settings.enableSummarization || messagesToSummarize.length === 0) {
      return null;
    }
    this.plugin.logger.info(`[PromptService] Summarizing chunk of ${messagesToSummarize.length} messages...`);
    const textToSummarize = messagesToSummarize.filter((m) => m.role === "user" || m.role === "assistant").map((m) => `${m.role === "user" ? "User" : "Assistant"}: ${m.content.trim()}`).join("\n");
    if (!textToSummarize.trim()) {
      this.plugin.logger.warn("[PromptService] No actual user/assistant text content in messages to summarize.");
      return null;
    }
    const summarizationPromptTemplate = this.plugin.settings.summarizationPrompt || "Summarize the following conversation concisely:\n\n{text_to_summarize}";
    const summarizationFullPrompt = summarizationPromptTemplate.replace("{text_to_summarize}", textToSummarize);
    const summarizationModelName = this.plugin.settings.summarizationModelName || chatMetadata.modelName || this.plugin.settings.modelName;
    this.plugin.logger.debug(`[PromptService] Using model for summarization: ${summarizationModelName}`);
    const summarizationContextWindow = Math.min(this.plugin.settings.contextWindow || 4096, 4096);
    const requestBody = {
      model: summarizationModelName,
      // Використовуємо визначену модель
      prompt: summarizationFullPrompt,
      stream: false,
      temperature: 0.3,
      // Низька температура для консистентної сумаризації
      options: {
        num_ctx: summarizationContextWindow
        // Можна додати stop token, якщо потрібно, наприклад ["User:", "Assistant:"]
      },
      // Системний промпт для сумаризатора
      system: "You are a helpful assistant specializing in concisely summarizing conversation history. Focus on extracting key points, decisions, and unresolved questions."
    };
    try {
      if (!this.plugin.ollamaService) {
        this.plugin.logger.error("[PromptService] OllamaService is not available for summarization.");
        return null;
      }
      this.plugin.logger.debug(`[PromptService] Sending summarization request. Prompt length: ${summarizationFullPrompt.length}`);
      const responseData = await this.plugin.ollamaService.generateRaw(requestBody);
      if (responseData && typeof responseData.response === "string") {
        const summary = responseData.response.trim();
        this.plugin.logger.info(`[PromptService] Summarization successful (${this._countTokens(summary)} tokens).`);
        return summary;
      } else {
        this.plugin.logger.warn("[PromptService] Summarization request returned unexpected structure:", responseData);
        return null;
      }
    } catch (error) {
      this.plugin.logger.error("[PromptService] Error during summarization request:", error, "Request body (model/options):", { model: requestBody.model, options: requestBody.options });
      return null;
    }
  }
};

// src/ChatManager.ts
var import_obsidian18 = require("obsidian");

// src/Chat.ts
var import_obsidian17 = require("obsidian");
var Chat = class {
  // Додати властивість
  /**
   * Creates an instance of Chat. Should be called by ChatManager.
   * @param adapter - Obsidian's DataAdapter.
   * @param settings - Plugin settings relevant for chat operation.
   * @param data - The initial chat data (metadata and messages).
   * @param filePath - The full, normalized path where this chat should be saved/loaded from within the vault. **Required**.
   */
  constructor(adapter, settings, data, filePath, logger) {
    this.adapter = adapter;
    this.pluginSettings = settings;
    this.filePath = (0, import_obsidian17.normalizePath)(filePath);
    this.metadata = data.metadata;
    this.messages = data.messages.map((m) => ({ ...m, timestamp: new Date(m.timestamp) }));
    this.logger = logger;
    this.debouncedSave = (0, import_obsidian17.debounce)(this._saveToFile.bind(this), 1500, true);
  }
  // --- Message Management ---
  /**
   * Adds a new message to the chat history.
   * Updates the lastModified timestamp and triggers a debounced save.
   * @param role - The role of the message sender ('user', 'assistant', etc.).
   * @param content - The text content of the message.
   * @param timestamp - The timestamp for the message (defaults to now).
   * @returns The newly added message object.
   */
  addMessage(role, content, timestamp = new Date()) {
    const newMessage = { role, content, timestamp };
    this.messages.push(newMessage);
    this.metadata.lastModified = timestamp.toISOString();
    this.save();
    return newMessage;
  }
  /** Returns a copy of the chat messages array. */
  getMessages() {
    return [...this.messages];
  }
  /** Clears all messages from the chat history. Updates lastModified and saves. */
  clearMessages() {
    console.log(`[Chat ${this.metadata.id}] Clearing messages.`);
    this.messages = [];
    this.metadata.lastModified = new Date().toISOString();
    this.save();
  }
  // У файлі Chat.ts
  /**
   * Updates specified metadata fields for the chat.
   * Automatically updates the lastModified timestamp and triggers a save if changes occurred.
   * @param updates - An object containing metadata fields to update (cannot update 'id' or 'createdAt').
   * @returns {boolean} - True if any metadata field was actually changed, false otherwise.
   */
  updateMetadata(updates) {
    let changed = false;
    const currentMeta = this.metadata;
    if (updates.name !== void 0 && updates.name !== currentMeta.name) {
      currentMeta.name = updates.name;
      changed = true;
    }
    if (updates.modelName !== void 0 && updates.modelName !== currentMeta.modelName) {
      currentMeta.modelName = updates.modelName;
      changed = true;
    }
    if (updates.selectedRolePath !== void 0 && updates.selectedRolePath !== currentMeta.selectedRolePath) {
      currentMeta.selectedRolePath = updates.selectedRolePath;
      changed = true;
    }
    if (updates.temperature !== void 0 && updates.temperature !== currentMeta.temperature) {
      currentMeta.temperature = updates.temperature;
      changed = true;
    }
    if (updates.contextWindow !== void 0 && updates.contextWindow !== currentMeta.contextWindow) {
      currentMeta.contextWindow = updates.contextWindow;
      changed = true;
    }
    if (changed) {
      this.metadata.lastModified = new Date().toISOString();
      if (this.pluginSettings.logger) {
        this.pluginSettings.logger.debug(`[Chat ${this.metadata.id}] Metadata updated, scheduling save:`, updates);
      } else {
        console.log(`[Chat ${this.metadata.id}] Metadata updated, scheduling save:`, updates);
      }
      this.save();
    } else {
      if (this.pluginSettings.logger) {
        this.pluginSettings.logger.debug(`[Chat ${this.metadata.id}] updateMetadata called, but no changes detected.`);
      } else {
        console.log(`[Chat ${this.metadata.id}] updateMetadata called, but no changes detected.`);
      }
    }
    return changed;
  }
  // Також переконайтесь, що конструктор Chat приймає і зберігає logger (або plugin)
  // і що він передається при викликах new Chat та Chat.loadFromFile в ChatManager.ts
  // Приклад оновленого конструктора Chat:
  /*
      private logger: Logger; // Додати властивість
  
      constructor(
          adapter: DataAdapter,
          settings: ChatConstructorSettings,
          data: ChatData,
          filePath: string,
          logger: Logger // Додати параметр
      ) {
          this.adapter = adapter;
          this.pluginSettings = settings;
          this.filePath = normalizePath(filePath);
          this.metadata = data.metadata;
          this.messages = data.messages.map(m => ({ ...m, timestamp: new Date(m.timestamp) }));
          this.logger = logger; // Зберегти логер
  
          
          this.debouncedSave = debounce(this._saveToFile.bind(this), 1500, true);
      }
  
      // І оновіть статичний метод loadFromFile, щоб він теж приймав та передавав logger
       static async loadFromFile(filePath: string, adapter: DataAdapter, settings: ChatConstructorSettings, logger: Logger): Promise<Chat | null> {
          // ...
          return new Chat(adapter, settings, data, normPath, logger); // Передати logger
          // ...
       }
       */
  // --- Persistence ---
  /** Triggers a debounced save if message history saving is enabled. */
  save() {
    if (this.pluginSettings.saveMessageHistory) {
      this.debouncedSave();
    } else {
    }
  }
  /**
   * Saves the current chat state to its file immediately.
   * Bypasses the debounce timer. Returns true on success, false on failure.
   */
  async saveImmediately() {
    if (!this.pluginSettings.saveMessageHistory) {
      return true;
    }
    return await this._saveToFile();
  }
  /**
   * Internal method to perform the actual file writing operation.
   * Creates necessary directories if they don't exist.
   */
  async _saveToFile() {
    const chatData = {
      metadata: this.metadata,
      messages: this.messages.map((m) => ({
        ...m,
        timestamp: m.timestamp.toISOString()
        // Cast to any to satisfy type, it's a string
      }))
    };
    const jsonString = JSON.stringify(chatData, null, 2);
    try {
      const dirPath = this.filePath.substring(0, this.filePath.lastIndexOf("/"));
      if (dirPath && !await this.adapter.exists(dirPath)) {
        console.log(`[Chat ${this.metadata.id}] Directory ${dirPath} does not exist. Creating...`);
        await this.adapter.mkdir(dirPath);
        console.log(`[Chat ${this.metadata.id}] Directory ${dirPath} created.`);
      }
      await this.adapter.write(this.filePath, jsonString);
      return true;
    } catch (error) {
      console.error(`[Chat ${this.metadata.id}] Error saving chat to ${this.filePath}:`, error);
      new import_obsidian17.Notice(`Error saving chat: ${this.metadata.name}. Check console.`);
      return false;
    }
  }
  /**
   * Static method to load chat data from a specified file path within the vault.
   * Called by ChatManager.
   * @param filePath - The full, normalized path to the chat file.
   * @param adapter - Obsidian's DataAdapter.
   * @param settings - Plugin settings.
   * @returns A new Chat instance or null if loading fails.
   */
  static async loadFromFile(filePath, adapter, settings, logger) {
    var _a;
    const normPath = (0, import_obsidian17.normalizePath)(filePath);
    try {
      if (!await adapter.exists(normPath)) {
        logger.warn(`[Chat] File not found for loading: ${normPath}`);
        return null;
      }
      const json = await adapter.read(normPath);
      const data = JSON.parse(json);
      if (((_a = data == null ? void 0 : data.metadata) == null ? void 0 : _a.id) && Array.isArray(data.messages)) {
        logger.debug(`[Chat] Successfully parsed data, creating Chat instance for ID: ${data.metadata.id}`);
        return new Chat(adapter, settings, data, normPath, logger);
      } else {
        logger.error(`[Chat] Invalid data structure in file for static load: ${normPath}`, data);
        new import_obsidian17.Notice(`Error loading chat: Invalid data structure in ${filePath}`);
        return null;
      }
    } catch (e) {
      logger.error(`[Chat] Error loading or parsing file for static load: ${normPath}`, e);
      new import_obsidian17.Notice(`Error loading chat file: ${filePath}. ${e.message}`);
      return null;
    }
  }
  /**
   * Deletes the chat's associated `.json` file from the vault.
   * @returns true if the file was deleted or didn't exist, false on error.
   */
  async deleteFile() {
    console.log(`[Chat ${this.metadata.id}] Attempting to delete file: ${this.filePath}`);
    try {
      if (await this.adapter.exists(this.filePath)) {
        await this.adapter.remove(this.filePath);
        console.log(`[Chat ${this.metadata.id}] Successfully deleted file: ${this.filePath}`);
        return true;
      }
      console.log(`[Chat ${this.metadata.id}] File already deleted or never existed: ${this.filePath}`);
      return true;
    } catch (e) {
      console.error(`[Chat ${this.metadata.id}] Error deleting file ${this.filePath}:`, e);
      new import_obsidian17.Notice(`Error deleting chat file: ${this.metadata.name}. Check console.`);
      return false;
    }
  }
  toJSON() {
    return {
      metadata: this.metadata,
      messages: this.messages
    };
  }
};

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = { randomUUID };

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  var _a, _b, _c;
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = (_c = (_b = options.random) != null ? _b : (_a = options.rng) == null ? void 0 : _a.call(options)) != null ? _c : rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
    }
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// src/ChatManager.ts
var ChatManager = class {
  constructor(plugin) {
    this.chatsFolderPath = "/";
    // Зроблено public для доступу з SidebarManager
    this.chatIndex = {};
    this.activeChatId = null;
    this.activeChat = null;
    this.loadedChats = {};
    this.currentTaskState = null;
    this.plugin = plugin;
    this.app = plugin.app;
    this.adapter = plugin.app.vault.adapter;
    this.logger = plugin.logger;
  }
  async initialize() {
    this.updateChatsFolderPath();
    await this.ensureFoldersExist();
    await this.loadChatIndex(true);
    const savedActiveId = await this.plugin.loadDataKey(ACTIVE_CHAT_ID_KEY);
    if (savedActiveId && this.chatIndex[savedActiveId]) {
      await this.setActiveChat(savedActiveId);
    } else {
      await this.plugin.saveDataKey(ACTIVE_CHAT_ID_KEY, null);
      const hierarchy = await this.getChatHierarchy();
      const firstChat = this.findFirstChatInHierarchy(hierarchy);
      if (firstChat) {
        await this.setActiveChat(firstChat.metadata.id);
      } else {
        await this.setActiveChat(null);
      }
    }
  }
  findFirstChatInHierarchy(nodes) {
    for (const node of nodes) {
      if (node.type === "chat") {
        if (!isNaN(new Date(node.metadata.lastModified).getTime())) {
          return node;
        } else {
        }
      } else if (node.type === "folder") {
        const chatInFolder = this.findFirstChatInHierarchy(node.children);
        if (chatInFolder) {
          return chatInFolder;
        }
      }
    }
    return null;
  }
  updateChatsFolderPath() {
    var _a;
    const settingsPath = (_a = this.plugin.settings.chatHistoryFolderPath) == null ? void 0 : _a.trim();
    this.chatsFolderPath = settingsPath ? (0, import_obsidian18.normalizePath)(settingsPath) : "/";
    if (this.chatsFolderPath !== "/" && this.chatsFolderPath.endsWith("/")) {
      this.chatsFolderPath = this.chatsFolderPath.slice(0, -1);
    }
    if (!this.chatsFolderPath) {
      this.chatsFolderPath = "/";
    }
  }
  updateTaskState(tasks) {
    this.currentTaskState = tasks;
  }
  getCurrentTaskState() {
    return this.currentTaskState;
  }
  async ensureFoldersExist() {
    var _a, _b;
    const historyPath = (_a = this.plugin.settings.chatHistoryFolderPath) == null ? void 0 : _a.trim();
    const exportPath = (_b = this.plugin.settings.chatExportFolderPath) == null ? void 0 : _b.trim();
    const checkAndCreate = async (folderPath, folderDesc) => {
      if (!folderPath || folderPath === "/")
        return;
      const normalized = (0, import_obsidian18.normalizePath)(folderPath);
      if (normalized.startsWith("..") || normalized.includes("\0")) {
        new import_obsidian18.Notice(`Error: Invalid path for ${folderDesc}.`);
        return;
      }
      try {
        const exists = await this.adapter.exists(normalized);
        if (!exists) {
          await this.adapter.mkdir(normalized);
        } else {
          const stat = await this.adapter.stat(normalized);
          if ((stat == null ? void 0 : stat.type) !== "folder") {
            new import_obsidian18.Notice(`Error: Path for ${folderDesc} is not a folder.`);
          } else {
          }
        }
      } catch (error) {
        new import_obsidian18.Notice(`Error accessing folder for ${folderDesc}. Check permissions.`);
      }
    };
    await checkAndCreate(historyPath, "Chat History");
    await checkAndCreate(exportPath, "Chat Export");
  }
  async loadChatIndex(forceScan = false) {
    var _a;
    const storedIndex = await this.plugin.loadDataKey(CHAT_INDEX_KEY);
    const settingsPath = (_a = this.plugin.settings.chatHistoryFolderPath) == null ? void 0 : _a.trim();
    const currentPath = settingsPath && settingsPath !== "/" ? (0, import_obsidian18.normalizePath)(settingsPath) : "/";
    if (currentPath !== this.chatsFolderPath) {
      this.updateChatsFolderPath();
      forceScan = true;
    }
    if (!forceScan && storedIndex && typeof storedIndex === "object" && Object.keys(storedIndex).length > 0) {
      const firstKey = Object.keys(storedIndex)[0];
      if (storedIndex[firstKey] && typeof storedIndex[firstKey].name === "string" && typeof storedIndex[firstKey].lastModified === "string" && typeof storedIndex[firstKey].createdAt === "string") {
        this.chatIndex = storedIndex;
        return;
      } else {
        forceScan = true;
      }
    } else if (!forceScan && storedIndex && typeof storedIndex === "object" && Object.keys(storedIndex).length === 0) {
      this.chatIndex = {};
      return;
    } else if (!forceScan) {
      forceScan = true;
    }
    if (forceScan) {
      await this.rebuildIndexFromFiles();
    }
  }
  async rebuildIndexFromFiles() {
    const newIndex = {};
    let chatsLoaded = 0;
    let filesScanned = 0;
    try {
      if (this.chatsFolderPath !== "/") {
        const exists = await this.adapter.exists(this.chatsFolderPath);
        if (!exists) {
          try {
            await this.adapter.mkdir(this.chatsFolderPath);
          } catch (mkdirError) {
            this.chatIndex = {};
            await this.saveChatIndex();
            return;
          }
        } else {
          const stat = await this.adapter.stat(this.chatsFolderPath);
          if ((stat == null ? void 0 : stat.type) !== "folder") {
            new import_obsidian18.Notice(`Error: Chat history path '${this.chatsFolderPath}' is not a folder.`);
            this.chatIndex = {};
            await this.saveChatIndex();
            return;
          }
        }
      }
      const scanAndIndex = async (folderPath) => {
        var _a;
        let listResult;
        try {
          listResult = await this.adapter.list(folderPath);
        } catch (listError) {
          if (listError.message && listError.message.includes("Not a directory")) {
          } else {
          }
          return;
        }
        for (const fullPath of listResult.files) {
          const fileName = fullPath.substring(fullPath.lastIndexOf("/") + 1);
          if (!fileName.endsWith(".json") || fileName.startsWith("."))
            continue;
          const uuidPattern = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\.json$/i;
          const oldPattern = /^chat_\d+_[a-zA-Z0-9]+\.json$/;
          if (!uuidPattern.test(fileName) && !oldPattern.test(fileName))
            continue;
          filesScanned++;
          const chatId = fileName.slice(0, -5);
          try {
            const jsonContent = await this.adapter.read(fullPath);
            const data = JSON.parse(jsonContent);
            if (((_a = data == null ? void 0 : data.metadata) == null ? void 0 : _a.id) === chatId && typeof data.metadata.name === "string" && data.metadata.name.trim() !== "" && typeof data.metadata.lastModified === "string" && !isNaN(new Date(data.metadata.lastModified).getTime()) && typeof data.metadata.createdAt === "string" && !isNaN(new Date(data.metadata.createdAt).getTime())) {
              const meta = data.metadata;
              newIndex[chatId] = {
                name: meta.name,
                lastModified: new Date(meta.lastModified).toISOString(),
                createdAt: new Date(meta.createdAt).toISOString(),
                modelName: meta.modelName,
                selectedRolePath: meta.selectedRolePath,
                temperature: meta.temperature,
                contextWindow: meta.contextWindow
              };
              chatsLoaded++;
            } else {
            }
          } catch (e) {
            if (e instanceof SyntaxError) {
            } else {
            }
          }
        }
        for (const subFolderPath of listResult.folders) {
          await scanAndIndex(subFolderPath);
        }
      };
      await scanAndIndex(this.chatsFolderPath);
      this.chatIndex = newIndex;
      await this.saveChatIndex();
    } catch (error) {
      if (error.code === "ENOENT") {
        new import_obsidian18.Notice(`Error: Chat history folder '${this.chatsFolderPath}' not found.`);
      } else if (error.code === "EPERM" || error.code === "EACCES") {
        new import_obsidian18.Notice("Permission error accessing chat history folder.");
      } else {
        new import_obsidian18.Notice("Error rebuilding chat index. Check console.");
      }
      this.chatIndex = {};
      await this.saveChatIndex();
    }
  }
  async saveChatIndex() {
    try {
      await this.plugin.saveDataKey(CHAT_INDEX_KEY, this.chatIndex);
    } catch (error) {
      new import_obsidian18.Notice("Error saving chat index. Changes might be lost.");
    }
  }
  getChatFilePath(id, folderPath) {
    const fileName = `${id}.json`;
    const targetFolder = (0, import_obsidian18.normalizePath)(folderPath);
    if (targetFolder === "/" || targetFolder === "") {
      return (0, import_obsidian18.normalizePath)(fileName);
    } else {
      return (0, import_obsidian18.normalizePath)(`${targetFolder}/${fileName}`);
    }
  }
  async _scanFolderRecursive(folderPath) {
    const children = [];
    let listResult;
    try {
      const exists = await this.adapter.exists(folderPath);
      if (!exists) {
        return [];
      }
      const stat = await this.adapter.stat(folderPath);
      if ((stat == null ? void 0 : stat.type) !== "folder") {
        return [];
      }
      listResult = await this.adapter.list(folderPath);
    } catch (error) {
      if (error.code === "EPERM" || error.code === "EACCES") {
        new import_obsidian18.Notice(`Permission error reading folder: ${folderPath}`);
      } else {
      }
      return [];
    }
    for (const subFolderPath of listResult.folders) {
      try {
        const subStat = await this.adapter.stat(subFolderPath);
        if ((subStat == null ? void 0 : subStat.type) === "folder") {
          const folderName = subFolderPath.substring(subFolderPath.lastIndexOf("/") + 1);
          const subChildren = await this._scanFolderRecursive(subFolderPath);
          children.push({
            type: "folder",
            name: folderName,
            path: subFolderPath,
            children: subChildren
          });
        } else {
        }
      } catch (statError) {
      }
    }
    for (const fullPath of listResult.files) {
      const fileName = fullPath.substring(fullPath.lastIndexOf("/") + 1);
      if (!fileName.endsWith(".json") || fileName.startsWith("."))
        continue;
      const uuidPattern = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\.json$/i;
      const oldPattern = /^chat_\d+_[a-zA-Z0-9]+\.json$/;
      if (!uuidPattern.test(fileName) && !oldPattern.test(fileName))
        continue;
      const chatId = fileName.slice(0, -5);
      const storedMeta = this.chatIndex[chatId];
      if (storedMeta) {
        if (isNaN(new Date(storedMeta.lastModified).getTime()) || isNaN(new Date(storedMeta.createdAt).getTime())) {
          continue;
        }
        const chatMetadata = {
          id: chatId,
          name: storedMeta.name,
          lastModified: storedMeta.lastModified,
          createdAt: storedMeta.createdAt,
          modelName: storedMeta.modelName,
          selectedRolePath: storedMeta.selectedRolePath,
          temperature: storedMeta.temperature,
          contextWindow: storedMeta.contextWindow
        };
        children.push({
          type: "chat",
          metadata: chatMetadata,
          filePath: fullPath
        });
      } else {
      }
    }
    children.sort((a, b) => {
      if (a.type === "folder" && b.type === "chat")
        return -1;
      if (a.type === "chat" && b.type === "folder")
        return 1;
      if (a.type === "folder" && b.type === "folder") {
        return a.name.localeCompare(b.name);
      }
      if (a.type === "chat" && b.type === "chat") {
        const dateA = new Date(a.metadata.lastModified).getTime();
        const dateB = new Date(b.metadata.lastModified).getTime();
        const validA = !isNaN(dateA);
        const validB = !isNaN(dateB);
        if (validA && validB)
          return dateB - dateA;
        if (validB)
          return 1;
        if (validA)
          return -1;
        return a.metadata.name.localeCompare(b.metadata.name);
      }
      return 0;
    });
    return children;
  }
  async getChatHierarchy() {
    await this.ensureFoldersExist();
    return await this._scanFolderRecursive(this.chatsFolderPath);
  }
  async saveChatAndUpdateIndex(chat) {
    try {
      await chat.save();
      const meta = chat.metadata;
      const storedMeta = {
        name: meta.name,
        lastModified: meta.lastModified,
        createdAt: meta.createdAt,
        modelName: meta.modelName,
        selectedRolePath: meta.selectedRolePath,
        temperature: meta.temperature,
        contextWindow: meta.contextWindow
      };
      const existingIndexEntry = this.chatIndex[meta.id];
      const indexNeedsUpdate = !existingIndexEntry || existingIndexEntry.name !== storedMeta.name || existingIndexEntry.lastModified !== storedMeta.lastModified || existingIndexEntry.createdAt !== storedMeta.createdAt || existingIndexEntry.modelName !== storedMeta.modelName || existingIndexEntry.selectedRolePath !== storedMeta.selectedRolePath || existingIndexEntry.temperature !== storedMeta.temperature || existingIndexEntry.contextWindow !== storedMeta.contextWindow;
      if (indexNeedsUpdate) {
        this.chatIndex[meta.id] = storedMeta;
        await this.saveChatIndex();
        this.logger.error(`[ChatManager] >>> Emitting 'chat-list-updated' from saveChatAndUpdateIndex for ID: ${meta.id}`);
        this.plugin.emit("chat-list-updated");
        this.logger.debug(`Chat index updated for ${meta.id} after save trigger.`);
      } else {
        this.logger.trace(`Index for chat ${meta.id} unchanged after save trigger, skipping index save/event.`);
      }
      return true;
    } catch (error) {
      return false;
    }
  }
  async createNewChat(name, folderPath) {
    const targetFolder = folderPath ? (0, import_obsidian18.normalizePath)(folderPath) : this.chatsFolderPath;
    const finalFolderPath = targetFolder === "" || targetFolder === "." ? "/" : targetFolder;
    try {
      await this.ensureSpecificFolderExists(finalFolderPath);
    } catch (folderError) {
      new import_obsidian18.Notice(`Failed to ensure target folder exists: ${finalFolderPath}`);
      return null;
    }
    try {
      const now = new Date();
      const newId = v4_default();
      const filePath = this.getChatFilePath(newId, finalFolderPath);
      const initialMetadata = {
        id: newId,
        name: name || `Chat ${now.toLocaleDateString()} ${now.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })}`,
        modelName: this.plugin.settings.modelName,
        selectedRolePath: this.plugin.settings.selectedRolePath,
        temperature: this.plugin.settings.temperature,
        contextWindow: this.plugin.settings.contextWindow,
        createdAt: now.toISOString(),
        lastModified: now.toISOString()
      };
      const constructorSettings = { ...this.plugin.settings };
      const chatData = { metadata: initialMetadata, messages: [] };
      const newChat = new Chat(this.adapter, constructorSettings, chatData, filePath, this.logger);
      const storedMeta = {
        name: initialMetadata.name,
        lastModified: initialMetadata.lastModified,
        createdAt: initialMetadata.createdAt,
        modelName: initialMetadata.modelName,
        selectedRolePath: initialMetadata.selectedRolePath,
        temperature: initialMetadata.temperature,
        contextWindow: initialMetadata.contextWindow
      };
      this.chatIndex[newId] = storedMeta;
      await this.saveChatIndex();
      this.plugin.emit("chat-list-updated");
      const savedImmediately = await newChat.saveImmediately();
      if (!savedImmediately) {
        delete this.chatIndex[newId];
        await this.saveChatIndex();
        this.plugin.emit("chat-list-updated");
        new import_obsidian18.Notice("Error: Failed to save new chat file.");
        return null;
      }
      this.loadedChats[newId] = newChat;
      await this.setActiveChat(newId);
      return newChat;
    } catch (error) {
      this.logger.error("Error creating new chat:", error);
      new import_obsidian18.Notice("Error creating new chat session.");
      return null;
    }
  }
  async ensureSpecificFolderExists(folderPath) {
    if (!folderPath || folderPath === "/" || folderPath === ".")
      return;
    const normalized = (0, import_obsidian18.normalizePath)(folderPath);
    if (normalized.startsWith("..") || normalized.includes("\0")) {
      this.logger.error(`Attempted to ensure invalid folder path: ${normalized}`);
      throw new Error("Invalid folder path specified.");
    }
    try {
      const exists = await this.adapter.exists(normalized);
      if (!exists) {
        await this.adapter.mkdir(normalized);
      } else {
        const stat = await this.adapter.stat(normalized);
        if ((stat == null ? void 0 : stat.type) !== "folder") {
          this.logger.error(`Path exists but is not a folder: ${normalized}`);
          throw new Error(`Target path ${normalized} is not a folder.`);
        }
      }
    } catch (error) {
      this.logger.error(`Error creating/checking target folder '${normalized}':`, error);
      throw new Error(
        `Failed to ensure target folder ${normalized} exists: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }
  /** @deprecated Use getChatHierarchy instead. */
  listAvailableChats() {
    return Object.entries(this.chatIndex).map(([id, storedMeta]) => {
      if (!storedMeta || typeof storedMeta !== "object" || typeof storedMeta.name !== "string" || typeof storedMeta.lastModified !== "string" || typeof storedMeta.createdAt !== "string") {
        return null;
      }
      const lastModDate = new Date(storedMeta.lastModified);
      const createdDate = new Date(storedMeta.createdAt);
      if (isNaN(lastModDate.getTime()) || isNaN(createdDate.getTime())) {
        return null;
      }
      return {
        id,
        name: storedMeta.name,
        lastModified: storedMeta.lastModified,
        createdAt: storedMeta.createdAt,
        modelName: storedMeta.modelName,
        selectedRolePath: storedMeta.selectedRolePath,
        temperature: storedMeta.temperature,
        contextWindow: storedMeta.contextWindow
      };
    }).filter((chatMeta) => chatMeta !== null).sort((a, b) => {
      const dateA = new Date(a.lastModified).getTime();
      const dateB = new Date(b.lastModified).getTime();
      if (!isNaN(dateA) && !isNaN(dateB)) {
        if (dateB !== dateA)
          return dateB - dateA;
      } else if (!isNaN(dateB))
        return 1;
      else if (!isNaN(dateA))
        return -1;
      const createdA = new Date(a.createdAt).getTime();
      const createdB = new Date(b.createdAt).getTime();
      if (!isNaN(createdA) && !isNaN(createdB)) {
        return createdB - createdA;
      } else if (!isNaN(createdB))
        return 1;
      else if (!isNaN(createdA))
        return -1;
      return a.name.localeCompare(b.name);
    });
  }
  getActiveChatId() {
    return this.activeChatId;
  }
  async getChat(id, filePath) {
    var _a;
    if (this.loadedChats[id]) {
      return this.loadedChats[id];
    }
    let actualFilePath = filePath;
    if (!actualFilePath) {
      try {
        const hierarchy = await this.getChatHierarchy();
        actualFilePath = (_a = this.findChatPathInHierarchy(id, hierarchy)) != null ? _a : void 0;
        if (actualFilePath) {
        }
      } catch (hierarchyError) {
        this.logger.error(`Error getting hierarchy while searching path for chat ${id}:`, hierarchyError);
        actualFilePath = void 0;
      }
    }
    if (!actualFilePath) {
      this.logger.error(`Could not find or determine file path for chat ID ${id}.`);
      if (this.chatIndex[id]) {
      }
      return null;
    }
    if (!this.chatIndex[id]) {
      if (!filePath) {
        await this.rebuildIndexFromFiles();
        if (!this.chatIndex[id]) {
          this.logger.error(
            `Chat ID ${id} still not found in index after rescan, despite file existing at ${actualFilePath}.`
          );
          return null;
        }
      } else {
      }
    }
    try {
      if (typeof actualFilePath !== "string") {
        this.logger.error(`Internal error: actualFilePath is undefined before calling Chat.loadFromFile for ID ${id}`);
        return null;
      }
      const chat = await Chat.loadFromFile(actualFilePath, this.adapter, this.plugin.settings, this.logger);
      if (chat) {
        this.loadedChats[id] = chat;
        const storedMeta = this.chatIndex[id];
        const currentMeta = chat.metadata;
        const indexNeedsUpdate = !storedMeta || storedMeta.name !== currentMeta.name || storedMeta.lastModified !== currentMeta.lastModified || storedMeta.createdAt !== currentMeta.createdAt || // Додано createdAt
        storedMeta.modelName !== currentMeta.modelName || storedMeta.selectedRolePath !== currentMeta.selectedRolePath || storedMeta.temperature !== currentMeta.temperature || storedMeta.contextWindow !== currentMeta.contextWindow;
        if (indexNeedsUpdate) {
          await this.saveChatAndUpdateIndex(chat);
        }
        return chat;
      } else {
        this.logger.error(
          `Chat.loadFromFile returned null for ${id} at path ${actualFilePath}. Removing from index if present.`
        );
        await this.deleteChatFileAndIndexEntry(id, actualFilePath, false);
        if (this.activeChatId === id)
          await this.setActiveChat(null);
        return null;
      }
    } catch (error) {
      this.logger.error(`Unexpected error during getChat for ${id} from ${actualFilePath}:`, error);
      if (error.code === "ENOENT") {
        await this.deleteChatFileAndIndexEntry(id, actualFilePath, false);
        if (this.activeChatId === id)
          await this.setActiveChat(null);
      }
      return null;
    }
  }
  findChatPathInHierarchy(chatId, nodes) {
    for (const node of nodes) {
      if (node.type === "chat" && node.metadata.id === chatId) {
        return node.filePath;
      } else if (node.type === "folder") {
        const pathInFolder = this.findChatPathInHierarchy(chatId, node.children);
        if (pathInFolder) {
          return pathInFolder;
        }
      }
    }
    return null;
  }
  async deleteChatFileAndIndexEntry(id, filePath, deleteFile = true) {
    const safeFilePath = filePath != null ? filePath : "unknown_path";
    let indexChanged = false;
    if (this.loadedChats[id]) {
      delete this.loadedChats[id];
    }
    if (this.chatIndex[id]) {
      delete this.chatIndex[id];
      indexChanged = true;
    } else {
    }
    if (deleteFile && filePath && typeof filePath === "string" && filePath !== "/" && !filePath.endsWith("/")) {
      try {
        const fileExists = await this.adapter.exists(filePath);
        if (fileExists) {
          const stat = await this.adapter.stat(filePath);
          if ((stat == null ? void 0 : stat.type) === "file") {
            await this.adapter.remove(filePath);
          } else {
            this.logger.error(`Attempted to remove a non-file path during chat deletion: ${filePath}`);
          }
        } else {
        }
      } catch (e) {
        if (e.code === "EPERM" || e.code === "EACCES") {
          this.logger.error(`Permission error removing chat file ${filePath}:`, e);
          new import_obsidian18.Notice(`Permission error deleting file: ${filePath}`);
        } else {
          this.logger.error(`Error removing chat file ${filePath} during cleanup:`, e);
          new import_obsidian18.Notice(`Error deleting file: ${filePath}`);
        }
      }
    } else if (deleteFile) {
    }
    if (indexChanged) {
      await this.saveChatIndex();
      this.plugin.emit("chat-list-updated");
    }
  }
  async getActiveChat() {
    if (!this.activeChatId) {
      return null;
    }
    if (this.activeChat && this.activeChat.metadata.id === this.activeChatId) {
      return this.activeChat;
    }
    const chat = await this.getChat(this.activeChatId);
    if (chat) {
      this.activeChat = chat;
      return chat;
    } else {
      const hierarchy = await this.getChatHierarchy();
      const firstChat = this.findFirstChatInHierarchy(hierarchy);
      const nextActiveId = firstChat ? firstChat.metadata.id : null;
      await this.setActiveChat(nextActiveId);
      return this.activeChat;
    }
  }
  async setActiveChat(id) {
    const previousActiveId = this.activeChatId;
    if (id === previousActiveId) {
      if (id && !this.activeChat) {
        this.activeChat = await this.getChat(id);
      }
      return;
    }
    if (id && !this.chatIndex[id]) {
      this.logger.error(`Attempted to set active chat to non-existent ID in index: ${id}. Rebuilding index...`);
      await this.rebuildIndexFromFiles();
      if (!this.chatIndex[id]) {
        this.logger.error(
          `Chat ID ${id} still not found after index reload. Aborting setActiveChat. Keeping previous active chat: ${previousActiveId}`
        );
        new import_obsidian18.Notice(`Error: Chat with ID ${id} not found. Cannot activate.`);
        return;
      }
    }
    this.activeChatId = id;
    this.activeChat = null;
    await this.plugin.saveDataKey(ACTIVE_CHAT_ID_KEY, id);
    let loadedChat = null;
    if (id) {
      loadedChat = await this.getChat(id);
      if (!loadedChat) {
        this.logger.error(
          `CRITICAL: Failed to load chat ${id} via getChat even after index check. Resetting active chat to null.`
        );
        this.activeChatId = null;
        await this.plugin.saveDataKey(ACTIVE_CHAT_ID_KEY, null);
        id = null;
      } else {
        this.activeChat = loadedChat;
      }
    } else {
    }
    this.plugin.emit("active-chat-changed", { chatId: id, chat: this.activeChat });
  }
  async addMessageToActiveChat(role, content, timestamp, emitEvent = true) {
    const activeChat = await this.getActiveChat();
    if (!activeChat) {
      this.logger.error("Cannot add message: No active chat.");
      return null;
    }
    const messageTimestamp = timestamp || new Date();
    const newMessage = { role, content, timestamp: messageTimestamp };
    activeChat.messages.push(newMessage);
    const metadataChanged = activeChat.updateMetadata({});
    const indexUpdated = await this.saveChatAndUpdateIndex(activeChat);
    if (emitEvent && indexUpdated) {
      const eventData = { chatId: this.activeChatId, message: newMessage };
      this.plugin.emit("message-added", { chatId: activeChat.metadata.id, message: newMessage });
    } else if (emitEvent && !indexUpdated) {
    }
    return newMessage;
  }
  async clearActiveChatMessages() {
    const activeChat = await this.getActiveChat();
    if (!activeChat) {
      return;
    }
    if (activeChat.messages.length === 0) {
      return;
    }
    activeChat.clearMessages();
    await this.saveChatAndUpdateIndex(activeChat);
    this.plugin.emit("messages-cleared", activeChat.metadata.id);
  }
  async updateActiveChatMetadata(metadataUpdate) {
    var _a, _b, _c, _d, _e;
    const activeChat = await this.getActiveChat();
    if (!activeChat) {
      new import_obsidian18.Notice("No active chat to update metadata for.");
      return false;
    }
    this.logger.debug(`Attempting to update metadata for active chat ${activeChat.metadata.id}:`, metadataUpdate);
    if (Object.keys(metadataUpdate).length === 0) {
      return false;
    }
    this.logger.debug(`Attempting to update metadata for active chat ${activeChat.metadata.id}:`, metadataUpdate);
    const oldRolePath = activeChat.metadata.selectedRolePath;
    const oldModelName = activeChat.metadata.modelName;
    const changed = activeChat.updateMetadata(metadataUpdate);
    if (changed) {
      this.logger.debug(`Metadata updated in Chat object for ${activeChat.metadata.id}. Save scheduled by Chat.updateMetadata.`);
      await this.saveChatAndUpdateIndex(activeChat);
      const newMeta = activeChat.metadata;
      let roleChanged = false;
      let modelChanged = false;
      if (metadataUpdate.selectedRolePath !== void 0 && oldRolePath !== newMeta.selectedRolePath) {
        roleChanged = true;
      }
      if (metadataUpdate.modelName !== void 0 && oldModelName !== newMeta.modelName) {
        modelChanged = true;
      }
      if (roleChanged) {
        try {
          const rolePathArg = (_a = newMeta.selectedRolePath) != null ? _a : void 0;
          const newRoleName = await this.plugin.findRoleNameByPath(rolePathArg);
          this.plugin.emit("role-changed", newRoleName != null ? newRoleName : "None");
          (_c = (_b = this.plugin.promptService) == null ? void 0 : _b.clearRoleCache) == null ? void 0 : _c.call(_b);
        } catch (e) {
          this.logger.error("Error finding role name or emitting role-changed:", e);
        }
      }
      if (modelChanged) {
        this.plugin.emit("model-changed", newMeta.modelName || "");
        (_e = (_d = this.plugin.promptService) == null ? void 0 : _d.clearModelDetailsCache) == null ? void 0 : _e.call(_d);
      }
      this.logger.error(`[ChatManager] >>> Emitting 'active-chat-changed' from updateActiveChatMetadata for ID: ${this.activeChatId}`);
      this.plugin.emit("active-chat-changed", { chatId: this.activeChatId, chat: activeChat });
      return true;
    } else {
      return false;
    }
  }
  async deleteChat(id) {
    const chatExistedInIndex = !!this.chatIndex[id];
    const wasActive = id === this.activeChatId;
    let filePath = null;
    try {
      const hierarchy = await this.getChatHierarchy();
      filePath = this.findChatPathInHierarchy(id, hierarchy);
    } catch (hierarchyError) {
      this.logger.error(`Error getting hierarchy during delete operation for ${id}:`, hierarchyError);
    }
    if (!filePath && chatExistedInIndex) {
    } else if (!filePath && !chatExistedInIndex) {
      return false;
    }
    let success = true;
    try {
      await this.deleteChatFileAndIndexEntry(id, filePath, true);
    } catch (error) {
      this.logger.error(`Error during deletion process for chat ${id}:`, error);
      new import_obsidian18.Notice(`Error deleting chat ${id}. Check console.`);
      success = false;
      await this.rebuildIndexFromFiles();
    } finally {
      if (wasActive) {
        const newHierarchy = await this.getChatHierarchy();
        const firstChat = this.findFirstChatInHierarchy(newHierarchy);
        const nextActiveId = firstChat ? firstChat.metadata.id : null;
        await this.setActiveChat(nextActiveId);
      } else if (success && chatExistedInIndex) {
        new import_obsidian18.Notice(`Chat deleted.`);
      }
    }
    return success && chatExistedInIndex;
  }
  async cloneChat(chatIdToClone) {
    let originalFilePath = null;
    try {
      const hierarchy = await this.getChatHierarchy();
      originalFilePath = this.findChatPathInHierarchy(chatIdToClone, hierarchy);
    } catch (hierarchyError) {
      this.logger.error(`Error getting hierarchy during clone operation for ${chatIdToClone}:`, hierarchyError);
      new import_obsidian18.Notice("Error finding original chat for cloning.");
      return null;
    }
    if (!originalFilePath) {
      this.logger.error(`Cannot clone: File path for original chat ${chatIdToClone} not found.`);
      new import_obsidian18.Notice("Original chat file path not found.");
      return null;
    }
    const originalChat = await this.getChat(chatIdToClone, originalFilePath);
    if (!originalChat) {
      this.logger.error(`Cannot clone: Original chat ${chatIdToClone} could not be loaded from ${originalFilePath}.`);
      new import_obsidian18.Notice("Original chat could not be loaded.");
      return null;
    }
    const targetFolder = originalFilePath.substring(0, originalFilePath.lastIndexOf("/")) || "/";
    const finalFolderPath = targetFolder === "" || targetFolder === "." ? "/" : targetFolder;
    try {
      await this.ensureSpecificFolderExists(finalFolderPath);
    } catch (folderError) {
      new import_obsidian18.Notice(`Failed to ensure target folder for clone: ${finalFolderPath}`);
      return null;
    }
    try {
      const clonedData = originalChat.toJSON();
      const now = new Date();
      const newId = v4_default();
      const newFilePath = this.getChatFilePath(newId, finalFolderPath);
      clonedData.metadata.id = newId;
      clonedData.metadata.name = `Copy of ${originalChat.metadata.name}`;
      clonedData.metadata.createdAt = now.toISOString();
      clonedData.metadata.lastModified = now.toISOString();
      clonedData.metadata.modelName = originalChat.metadata.modelName;
      clonedData.metadata.selectedRolePath = originalChat.metadata.selectedRolePath;
      clonedData.metadata.temperature = originalChat.metadata.temperature;
      clonedData.metadata.contextWindow = originalChat.metadata.contextWindow;
      const constructorSettings = { ...this.plugin.settings };
      const clonedChat = new Chat(this.adapter, constructorSettings, clonedData, newFilePath, this.logger);
      const storedMeta = {
        name: clonedData.metadata.name,
        lastModified: clonedData.metadata.lastModified,
        createdAt: clonedData.metadata.createdAt,
        modelName: clonedData.metadata.modelName,
        selectedRolePath: clonedData.metadata.selectedRolePath,
        temperature: clonedData.metadata.temperature,
        contextWindow: clonedData.metadata.contextWindow
      };
      this.chatIndex[newId] = storedMeta;
      await this.saveChatIndex();
      this.plugin.emit("chat-list-updated");
      const savedImmediately = await clonedChat.saveImmediately();
      if (!savedImmediately) {
        delete this.chatIndex[newId];
        await this.saveChatIndex();
        this.plugin.emit("chat-list-updated");
        this.logger.error(`Failed to save the cloned chat file for ${newId} at ${newFilePath}. Removed from index.`);
        new import_obsidian18.Notice("Error: Failed to save the cloned chat file.");
        return null;
      }
      this.loadedChats[newId] = clonedChat;
      await this.setActiveChat(newId);
      return clonedChat;
    } catch (error) {
      this.logger.error("Error cloning chat:", error);
      new import_obsidian18.Notice("An error occurred while cloning the chat.");
      return null;
    }
  }
  async deleteMessagesAfter(chatId, messageIndexToDeleteAfter) {
    const chat = await this.getChat(chatId);
    if (!chat) {
      this.logger.error(`Cannot delete messages: Chat ${chatId} not found.`);
      return false;
    }
    if (messageIndexToDeleteAfter >= chat.messages.length - 1) {
      return true;
    }
    if (messageIndexToDeleteAfter < -1) {
      return false;
    }
    const originalLength = chat.messages.length;
    const targetLength = messageIndexToDeleteAfter + 1;
    chat.messages.length = targetLength;
    chat.updateMetadata({});
    await this.saveChatAndUpdateIndex(chat);
    if (this.activeChatId === chatId) {
      this.activeChat = chat;
      this.plugin.emit("active-chat-changed", { chatId, chat });
    }
    return true;
  }
  async deleteMessageByTimestamp(chatId, timestampToDelete) {
    const chat = await this.getChat(chatId);
    if (!chat) {
      this.logger.error(`Cannot delete message: Chat ${chatId} not found.`);
      new import_obsidian18.Notice(`Error: Chat ${chatId} not found.`);
      return false;
    }
    const timeTarget = timestampToDelete.getTime();
    const tolerance = 1e3;
    let messageIndex = -1;
    for (let i = 0; i < chat.messages.length; i++) {
      const messageTime = chat.messages[i].timestamp.getTime();
      if (!isNaN(messageTime) && Math.abs(messageTime - timeTarget) < tolerance) {
        messageIndex = i;
        break;
      } else if (isNaN(messageTime)) {
      }
    }
    if (messageIndex === -1) {
      new import_obsidian18.Notice("Message not found.");
      return false;
    }
    return await this._performDeleteMessageByIndex(chat, messageIndex);
  }
  async _performDeleteMessageByIndex(chat, messageIndex) {
    const chatId = chat.metadata.id;
    try {
      if (messageIndex < 0 || messageIndex >= chat.messages.length) {
        this.logger.error(
          `Invalid message index ${messageIndex} provided to _performDeleteMessageByIndex for chat ${chatId}.`
        );
        return false;
      }
      const deletedMessage = chat.messages.splice(messageIndex, 1)[0];
      chat.updateMetadata({});
      await this.saveChatAndUpdateIndex(chat);
      if (this.activeChatId === chatId) {
        this.activeChat = chat;
        this.plugin.emit("active-chat-changed", { chatId, chat });
      }
      if (deletedMessage) {
        this.plugin.emit("message-deleted", { chatId, timestamp: deletedMessage.timestamp });
      }
      return true;
    } catch (error) {
      this.logger.error(`Error during message deletion by index ${messageIndex} for chat ${chatId}:`, error);
      new import_obsidian18.Notice("Error deleting message.");
      return false;
    }
  }
  async clearChatMessagesById(chatId) {
    const chat = await this.getChat(chatId);
    if (!chat) {
      this.logger.error(`Cannot clear messages: Chat ${chatId} not found.`);
      new import_obsidian18.Notice(`Error: Chat ${chatId} not found.`);
      return false;
    }
    if (chat.messages.length === 0) {
      return true;
    }
    try {
      chat.clearMessages();
      await this.saveChatAndUpdateIndex(chat);
      const isActive = chatId === this.activeChatId;
      if (isActive) {
        this.activeChat = chat;
        this.plugin.emit("messages-cleared", chatId);
      }
      new import_obsidian18.Notice(`Messages cleared for chat "${chat.metadata.name}".`);
      return true;
    } catch (error) {
      this.logger.error(`Error during message clearing process for chat ${chatId}:`, error);
      new import_obsidian18.Notice("Error clearing messages.");
      return false;
    }
  }
  async renameChat(chatId, newName) {
    const trimmedName = newName.trim();
    if (!trimmedName) {
      new import_obsidian18.Notice("Chat name cannot be empty.");
      return false;
    }
    if (/[\\/?:*"<>|]/.test(trimmedName)) {
      new import_obsidian18.Notice("Chat name contains invalid characters.");
      return false;
    }
    const chat = await this.getChat(chatId);
    if (!chat) {
      this.logger.error(`Cannot rename: Chat ${chatId} not found.`);
      new import_obsidian18.Notice("Chat not found.");
      return false;
    }
    if (chat.metadata.name === trimmedName) {
      return true;
    }
    try {
      const changed = chat.updateMetadata({ name: trimmedName });
      if (changed) {
        await this.saveChatAndUpdateIndex(chat);
        if (this.activeChatId === chatId) {
          this.activeChat = chat;
          this.plugin.emit("active-chat-changed", { chatId, chat });
        }
        new import_obsidian18.Notice(`Chat renamed to "${trimmedName}".`);
        return true;
      } else {
        return false;
      }
    } catch (error) {
      this.logger.error(`Error renaming chat ${chatId}:`, error);
      new import_obsidian18.Notice("An error occurred while renaming the chat.");
      return false;
    }
  }
  // --- НОВІ МЕТОДИ ДЛЯ ПАПОК ---
  /**
   * Створює нову папку за вказаним шляхом.
   * @param folderPath Повний, нормалізований шлях до папки, яку потрібно створити.
   * @returns true, якщо папка успішно створена, false в іншому випадку.
   */
  async createFolder(folderPath) {
    const normalizedPath = (0, import_obsidian18.normalizePath)(folderPath);
    if (!normalizedPath || normalizedPath === "/" || normalizedPath === ".") {
      this.logger.error("Cannot create folder at root or with empty/dot path.");
      new import_obsidian18.Notice("Invalid folder path.");
      return false;
    }
    if (normalizedPath.startsWith("..") || normalizedPath.includes("\0")) {
      this.logger.error(`Attempted to create folder with invalid path: ${normalizedPath}`);
      new import_obsidian18.Notice("Invalid characters or path traversal detected.");
      return false;
    }
    try {
      const exists = await this.adapter.exists(normalizedPath);
      if (exists) {
        new import_obsidian18.Notice(`"${normalizedPath.split("/").pop()}" already exists.`);
        return false;
      }
      await this.adapter.mkdir(normalizedPath);
      this.plugin.emit("chat-list-updated");
      return true;
    } catch (error) {
      if (error.code === "EPERM" || error.code === "EACCES") {
        this.logger.error(`Permission error creating folder ${normalizedPath}:`, error);
        new import_obsidian18.Notice(`Permission error creating folder.`);
      } else {
        this.logger.error(`Error creating folder ${normalizedPath}:`, error);
        new import_obsidian18.Notice(`Failed to create folder: ${error.message || "Unknown error"}`);
      }
      return false;
    }
  }
  /**
   * Перейменовує або переміщує папку.
   * Важливо: Цей метод не оновлює індекс chatIndex автоматично для чатів всередині папки.
   * Найкраще викликати rebuildIndexFromFiles() після успішного перейменування або покладатися
   * на те, що getChatHierarchy() збиратиме актуальну структуру.
   * @param oldPath Повний, нормалізований старий шлях до папки.
   * @param newPath Повний, нормалізований новий шлях до папки.
   * @returns true, якщо перейменування/переміщення успішне, false в іншому випадку.
   */
  async renameFolder(oldPath, newPath) {
    const normOldPath = (0, import_obsidian18.normalizePath)(oldPath);
    const normNewPath = (0, import_obsidian18.normalizePath)(newPath);
    if (!normOldPath || normOldPath === "/" || !normNewPath || normNewPath === "/") {
      this.logger.error("Invalid paths provided for rename operation.");
      new import_obsidian18.Notice("Cannot rename root folder or use empty path.");
      return false;
    }
    if (normOldPath === normNewPath) {
      return true;
    }
    if (normNewPath.startsWith(normOldPath + "/")) {
      this.logger.error(`Cannot move folder "${normOldPath}" inside itself ("${normNewPath}").`);
      new import_obsidian18.Notice("Cannot move a folder inside itself.");
      return false;
    }
    try {
      const oldExists = await this.adapter.exists(normOldPath);
      if (!oldExists) {
        this.logger.error(`Source folder for rename does not exist: ${normOldPath}`);
        new import_obsidian18.Notice("Folder to rename not found.");
        return false;
      }
      const oldStat = await this.adapter.stat(normOldPath);
      if ((oldStat == null ? void 0 : oldStat.type) !== "folder") {
        this.logger.error(`Source path is not a folder: ${normOldPath}`);
        new import_obsidian18.Notice("Item to rename is not a folder.");
        return false;
      }
      const newExists = await this.adapter.exists(normNewPath);
      if (newExists) {
        this.logger.error(`Target path for rename already exists: ${normNewPath}`);
        new import_obsidian18.Notice(`"${normNewPath.split("/").pop()}" already exists.`);
        return false;
      }
      await this.adapter.rename(normOldPath, normNewPath);
      Object.values(this.loadedChats).forEach((chat) => {
        if (chat.filePath.startsWith(normOldPath + "/")) {
          const relativePath = chat.filePath.substring(normOldPath.length);
          const updatedPath = (0, import_obsidian18.normalizePath)(normNewPath + relativePath);
          chat.filePath = updatedPath;
        }
      });
      this.plugin.emit("chat-list-updated");
      return true;
    } catch (error) {
      if (error.code === "EPERM" || error.code === "EACCES") {
        this.logger.error(`Permission error renaming folder ${normOldPath} to ${normNewPath}:`, error);
        new import_obsidian18.Notice(`Permission error renaming folder.`);
      } else {
        this.logger.error(`Error renaming folder ${normOldPath} to ${normNewPath}:`, error);
        new import_obsidian18.Notice(`Failed to rename folder: ${error.message || "Unknown error"}`);
      }
      return false;
    }
  }
  /**
   * Рекурсивно видаляє папку та весь її вміст (підпапки та чати).
   * @param folderPath Повний, нормалізований шлях до папки, яку потрібно видалити.
   * @returns true, якщо папка та її вміст успішно видалені, false в іншому випадку.
   */
  async deleteFolder(folderPath) {
    const normalizedPath = (0, import_obsidian18.normalizePath)(folderPath);
    if (!normalizedPath || normalizedPath === "/" || normalizedPath === ".") {
      this.logger.error(`Attempted to delete root or invalid folder path: ${normalizedPath}`);
      new import_obsidian18.Notice("Cannot delete this folder.");
      return false;
    }
    if (normalizedPath === this.chatsFolderPath) {
      this.logger.error(`Attempted to delete the main chat history folder: ${normalizedPath}`);
      new import_obsidian18.Notice("Cannot delete the main chat history folder set in settings.");
      return false;
    }
    try {
      const exists = await this.adapter.exists(normalizedPath);
      if (!exists) {
        return true;
      }
      const stat = await this.adapter.stat(normalizedPath);
      if ((stat == null ? void 0 : stat.type) !== "folder") {
        this.logger.error(`Path to delete is not a folder: ${normalizedPath}`);
        new import_obsidian18.Notice("Item to delete is not a folder.");
        return false;
      }
      const chatIdsToDelete = [];
      const collectChatIds = async (currentPath) => {
        try {
          const list = await this.adapter.list(currentPath);
          for (const file of list.files) {
            const fileName = file.substring(file.lastIndexOf("/") + 1);
            if (fileName.endsWith(".json")) {
              const chatId = fileName.slice(0, -5);
              if (this.chatIndex[chatId]) {
                chatIdsToDelete.push(chatId);
              }
            }
          }
          for (const folder of list.folders) {
            await collectChatIds(folder);
          }
        } catch (listError) {
          this.logger.error(`Error listing folder ${currentPath} during pre-delete cleanup:`, listError);
        }
      };
      await collectChatIds(normalizedPath);
      let activeChatWasDeleted = false;
      chatIdsToDelete.forEach((id) => {
        if (this.chatIndex[id]) {
          delete this.chatIndex[id];
        }
        if (this.loadedChats[id]) {
          delete this.loadedChats[id];
        }
        if (this.activeChatId === id) {
          activeChatWasDeleted = true;
          this.activeChatId = null;
          this.activeChat = null;
        }
      });
      await this.saveChatIndex();
      if (activeChatWasDeleted) {
        await this.plugin.saveDataKey(ACTIVE_CHAT_ID_KEY, null);
      }
      await this.adapter.rmdir(normalizedPath, true);
      this.plugin.emit("chat-list-updated");
      if (activeChatWasDeleted) {
        this.plugin.emit("active-chat-changed", { chatId: null, chat: null });
      }
      return true;
    } catch (error) {
      if (error.code === "EPERM" || error.code === "EACCES") {
        this.logger.error(`Permission error deleting folder ${normalizedPath}:`, error);
        new import_obsidian18.Notice(`Permission error deleting folder.`);
      } else {
        this.logger.error(`Error deleting folder ${normalizedPath}:`, error);
        new import_obsidian18.Notice(`Failed to delete folder: ${error.message || "Unknown error"}`);
      }
      await this.rebuildIndexFromFiles();
      return false;
    }
  }
  // --- ВИПРАВЛЕНИЙ МЕТОД: Переміщення чату ---
  async moveChat(chatId, oldFilePath, newFolderPath) {
    const normOldPath = (0, import_obsidian18.normalizePath)(oldFilePath);
    const normNewFolderPath = (0, import_obsidian18.normalizePath)(newFolderPath);
    this.logger.info(`Attempting to move chat ${chatId} from "${normOldPath}" to folder "${normNewFolderPath}"`);
    let newFilePath = null;
    if (!chatId || !oldFilePath || !newFolderPath) {
      this.logger.error("Move chat failed: Invalid arguments provided.");
      new import_obsidian18.Notice("Move chat failed: Invalid data.");
      return false;
    }
    try {
      if (!await this.adapter.exists(normOldPath)) {
        this.logger.error(`Move chat failed: Source file does not exist: ${normOldPath}`);
        new import_obsidian18.Notice("Move chat failed: Source file not found.");
        await this.rebuildIndexFromFiles();
        this.plugin.emit("chat-list-updated");
        return false;
      }
      const oldStat = await this.adapter.stat(normOldPath);
      if ((oldStat == null ? void 0 : oldStat.type) !== "file") {
        this.logger.error(`Move chat failed: Source path is not a file: ${normOldPath}`);
        new import_obsidian18.Notice("Move chat failed: Source is not a file.");
        return false;
      }
      if (!await this.adapter.exists(normNewFolderPath)) {
        this.logger.error(`Move chat failed: Target folder does not exist: ${normNewFolderPath}`);
        new import_obsidian18.Notice("Move chat failed: Target folder not found.");
        return false;
      }
      const newStat = await this.adapter.stat(normNewFolderPath);
      if ((newStat == null ? void 0 : newStat.type) !== "folder") {
        this.logger.error(`Move chat failed: Target path is not a folder: ${normNewFolderPath}`);
        new import_obsidian18.Notice("Move chat failed: Target is not a folder.");
        return false;
      }
      const fileName = oldFilePath.substring(oldFilePath.lastIndexOf("/") + 1);
      newFilePath = (0, import_obsidian18.normalizePath)(`${normNewFolderPath}/${fileName}`);
      if (normOldPath === newFilePath) {
        this.logger.warn(`Move chat skipped: Source and target paths are the same: ${normOldPath}`);
        return true;
      }
      if (await this.adapter.exists(newFilePath)) {
        this.logger.error(`Move chat failed: File already exists at target path: ${newFilePath}`);
        new import_obsidian18.Notice(`Move chat failed: A file named "${fileName}" already exists in the target folder.`);
        return false;
      }
      this.logger.debug(`Executing adapter.rename from "${normOldPath}" to "${newFilePath}"`);
      await this.adapter.rename(normOldPath, newFilePath);
      this.logger.info(`Chat file moved successfully to ${newFilePath}`);
      if (this.loadedChats[chatId] && newFilePath) {
        this.logger.debug(`Updating file path in loadedChats cache for ${chatId} to ${newFilePath}`);
        this.loadedChats[chatId].filePath = newFilePath;
      }
      this.plugin.emit("chat-list-updated");
      return true;
    } catch (error) {
      const targetPathDesc = newFilePath != null ? newFilePath : normNewFolderPath;
      if (error.code === "EPERM" || error.code === "EACCES") {
        this.logger.error(`Permission error moving chat file from "${normOldPath}" towards "${targetPathDesc}":`, error);
        new import_obsidian18.Notice(`Permission error moving chat file.`);
      } else {
        this.logger.error(`Error moving chat file from "${normOldPath}" towards "${targetPathDesc}":`, error);
        new import_obsidian18.Notice(`Failed to move chat: ${error.message || "Unknown error"}`);
      }
      await this.rebuildIndexFromFiles();
      this.plugin.emit("chat-list-updated");
      return false;
    }
  }
  // --- КІНЕЦЬ ВИПРАВЛЕНОГО МЕТОДУ ---
  // --- КІНЕЦЬ НОВИХ МЕТОДІВ ---
};

// src/main.ts
var import_child_process = require("child_process");

// src/TranslationService.ts
var import_obsidian19 = require("obsidian");
var GOOGLE_TRANSLATE_API_URL = "https://translation.googleapis.com/language/translate/v2";
var TranslationService = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  /**
   * Головний метод для перекладу тексту. Вибирає провайдера на основі налаштувань.
   * @param text Текст для перекладу.
   * @param targetLang Код цільової мови (e.g., 'uk', 'en'). Якщо не вказано, використовується з налаштувань.
   * @returns Перекладений текст або null у разі помилки/вимкнення.
   */
  async translate(text, targetLang) {
    const provider = this.plugin.settings.translationProvider;
    const finalTargetLang = targetLang || this.plugin.settings.translationTargetLanguage;
    if (provider === "none" || !this.plugin.settings.enableTranslation) {
      this.plugin.logger.debug("[TranslationService] Translation disabled or provider is 'none'.");
      return null;
    }
    if (!text || !text.trim()) {
      this.plugin.logger.debug("[TranslationService] Input text is empty.");
      return "";
    }
    if (!finalTargetLang) {
      this.plugin.logger.error("[TranslationService] Target language is not defined.");
      new import_obsidian19.Notice("Translation Error: Target language not configured.");
      return null;
    }
    this.plugin.logger.info(`[TranslationService] Requesting translation via '${provider}' to '${finalTargetLang}'.`);
    try {
      switch (provider) {
        case "google":
          const apiKey = this.plugin.settings.googleTranslationApiKey;
          if (!apiKey) {
            new import_obsidian19.Notice("Google Translation API Key is not configured.");
            this.plugin.logger.error("[TranslationService] Google API Key missing.");
            return null;
          }
          return await this._translateWithGoogle(text, finalTargetLang, apiKey);
        case "ollama":
          const model = this.plugin.settings.ollamaTranslationModel;
          if (!model) {
            new import_obsidian19.Notice("Ollama translation model is not selected in settings.");
            this.plugin.logger.error("[TranslationService] Ollama translation model missing.");
            return null;
          }
          return await this._translateWithOllama(text, finalTargetLang, model);
        default:
          this.plugin.logger.warn(`[TranslationService] Unknown translation provider: ${provider}`);
          return null;
      }
    } catch (error) {
      this.plugin.logger.error(`[TranslationService] General translation error for provider ${provider}:`, error);
      new import_obsidian19.Notice(`Translation failed: ${error instanceof Error ? error.message : "Unknown error"}`);
      return null;
    }
  }
  /**
   * Переклад за допомогою Google Translate API.
   */
  async _translateWithGoogle(text, targetLang, apiKey) {
    var _a, _b, _c, _d;
    this.plugin.logger.debug(`[_translateWithGoogle] Translating to ${targetLang}...`);
    try {
      const response = await fetch(`${GOOGLE_TRANSLATE_API_URL}?key=${apiKey}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ q: text, target: targetLang, format: "text" })
      });
      const data = await response.json();
      if (!response.ok) {
        const errorMsg = ((_a = data.error) == null ? void 0 : _a.message) || `HTTP error ${response.status}`;
        throw new Error(`Google API Error: ${errorMsg}`);
      }
      if ((_d = (_c = (_b = data.data) == null ? void 0 : _b.translations) == null ? void 0 : _c[0]) == null ? void 0 : _d.translatedText) {
        const translatedText = this.decodeHtmlEntities(data.data.translations[0].translatedText);
        this.plugin.logger.debug("[_translateWithGoogle] Translation successful.");
        return translatedText;
      } else {
        this.plugin.logger.error("[_translateWithGoogle] Unexpected response structure:", data);
        throw new Error("Unexpected response structure from Google API.");
      }
    } catch (error) {
      this.plugin.logger.error("[_translateWithGoogle] API call failed:", error);
      throw error;
    }
  }
  /**
   * Переклад за допомогою моделі Ollama.
   */
  async _translateWithOllama(text, targetLang, model) {
    this.plugin.logger.debug(`[_translateWithOllama] Translating to ${targetLang} using model ${model}...`);
    const targetLangName = LANGUAGES[targetLang] || targetLang;
    const prompt = `Translate the following text to ${targetLangName}. Output ONLY the translated text, without any introduction or explanation.

Text:
"""
${text}
"""

Translated Text:`;
    try {
      const requestBody = {
        model,
        prompt,
        stream: false,
        // Для перекладу зазвичай не потрібен стрімінг
        options: {
          temperature: 0.2,
          // Низька температура для більш точного перекладу
          num_predict: 1024
          // Обмеження довжини відповіді (можна налаштувати)
          // Можна додати stop tokens, якщо модель додає зайве
        }
      };
      this.plugin.logger.debug("Sending translation request to Ollama:", requestBody);
      const responseData = await this.plugin.ollamaService.generateRaw(requestBody);
      if (responseData && responseData.response) {
        const translatedText = responseData.response.trim();
        this.plugin.logger.debug(`[_translateWithOllama] Translation successful. Result length: ${translatedText.length}`);
        return translatedText;
      } else {
        this.plugin.logger.warn("[_translateWithOllama] Received empty response from Ollama model.");
        return null;
      }
    } catch (error) {
      this.plugin.logger.error(`[_translateWithOllama] Ollama request failed for model ${model}:`, error);
      throw error;
    }
  }
  // Допоміжна функція декодування HTML (без змін)
  decodeHtmlEntities(text) {
    if (typeof document !== "undefined") {
      const textArea = document.createElement("textarea");
      textArea.innerHTML = text;
      return textArea.value;
    } else {
      return text.replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&#39;/g, "'");
    }
  }
};

// src/main.ts
var SESSIONS_INDEX_KEY = "chatIndex_v2";
var ACTIVE_CHAT_ID_KEY = "activeChatId_v2";
var CHAT_INDEX_KEY = "chatIndex_v2";
var OllamaPlugin2 = class extends import_obsidian20.Plugin {
  constructor() {
    super(...arguments);
    this.view = null;
    this.eventHandlers = {};
    this.roleListCache = null;
    this.roleCacheClearTimeout = null;
    this.indexUpdateTimeout = null;
    this.dailyTaskFilePath = null;
    this.taskFileContentCache = null;
    this.taskFileNeedsUpdate = false;
    this.taskCheckInterval = null;
    // Debounced функція оновлення для Vault Events
    this.debouncedIndexAndUIRebuild = (0, import_obsidian20.debounce)(
      async () => {
        if (this.chatManager) {
          await this.chatManager.rebuildIndexFromFiles();
          this.emit("chat-list-updated");
        }
      },
      1500,
      true
    );
  }
  // --- Event Emitter Methods ---
  on(event, callback) {
    if (!this.eventHandlers[event])
      this.eventHandlers[event] = [];
    this.eventHandlers[event].push(callback);
    return () => {
      var _a, _b;
      this.eventHandlers[event] = (_a = this.eventHandlers[event]) == null ? void 0 : _a.filter((h) => h !== callback);
      if (((_b = this.eventHandlers[event]) == null ? void 0 : _b.length) === 0) {
        delete this.eventHandlers[event];
      }
    };
  }
  emit(event, data) {
    const handlers = this.eventHandlers[event];
    if (handlers) {
      handlers.slice().forEach((handler) => {
        try {
          handler(data);
        } catch (e) {
        }
      });
    }
  }
  // --------------------------
  isTaskFileUpdated() {
    return this.taskFileNeedsUpdate;
  }
  async onload() {
    const initialSettingsData = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    const loggerSettings = {
      consoleLogLevel: true ? initialSettingsData.consoleLogLevel || "INFO" : "DEBUG",
      fileLoggingEnabled: initialSettingsData.fileLoggingEnabled,
      fileLogLevel: initialSettingsData.fileLogLevel,
      logCallerInfo: initialSettingsData.logCallerInfo,
      logFilePath: initialSettingsData.logFilePath,
      logFileMaxSizeMB: initialSettingsData.logFileMaxSizeMB
    };
    this.logger = new Logger(this, loggerSettings);
    await this.loadSettingsAndMigrate();
    this.promptService = new PromptService(this);
    this.ollamaService = new OllamaService(this);
    this.translationService = new TranslationService(this);
    this.ragService = new RagService(this);
    this.chatManager = new ChatManager(this);
    await this.chatManager.initialize();
    this.logger.updateSettings({
      consoleLogLevel: this.settings.consoleLogLevel,
      fileLoggingEnabled: this.settings.fileLoggingEnabled,
      fileLogLevel: this.settings.fileLogLevel,
      logCallerInfo: this.settings.logCallerInfo,
      logFilePath: this.settings.logFilePath,
      logFileMaxSizeMB: this.settings.logFileMaxSizeMB
    });
    this.registerView(VIEW_TYPE_OLLAMA_PERSONAS, (leaf) => {
      this.view = new OllamaView(leaf, this);
      return this.view;
    });
    this.ollamaService.on("connection-error", (error) => {
      this.emit("ollama-connection-error", error.message || "Unknown connection error");
    });
    this.register(
      this.on("ollama-connection-error", async (message) => {
        if (this.chatManager) {
          await this.chatManager.addMessageToActiveChat("error", message, new Date());
        } else {
          new import_obsidian20.Notice(`Ollama Connection Error: ${message}`);
        }
      })
    );
    this.register(this.on("active-chat-changed", this.handleActiveChatChangedLocally.bind(this)));
    this.register(
      this.on("settings-updated", () => {
        var _a, _b, _c, _d;
        this.logger.updateSettings({
          consoleLogLevel: this.settings.consoleLogLevel,
          fileLoggingEnabled: this.settings.fileLoggingEnabled,
          fileLogLevel: this.settings.fileLogLevel,
          logCallerInfo: this.settings.logCallerInfo,
          logFilePath: this.settings.logFilePath,
          logFileMaxSizeMB: this.settings.logFileMaxSizeMB
        });
        this.updateDailyTaskFilePath();
        this.loadAndProcessInitialTasks();
        this.updateOllamaServiceConfig();
        this.roleListCache = null;
        (_b = (_a = this.promptService) == null ? void 0 : _a.clearRoleCache) == null ? void 0 : _b.call(_a);
        this.emit("roles-updated");
        (_d = (_c = this.view) == null ? void 0 : _c.handleSettingsUpdated) == null ? void 0 : _d.call(_c);
      })
    );
    this.addRibbonIcon("brain-circuit", "Open AI Forge Chat", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-chat-view",
      name: "Open AI Forge Chat",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "index-rag-documents",
      name: "AI Forge: Index documents for RAG",
      callback: async () => {
        if (this.settings.ragEnabled)
          await this.ragService.indexDocuments();
        else
          new import_obsidian20.Notice("RAG is disabled in settings.");
      }
    });
    this.addCommand({
      id: "clear-active-chat-history",
      name: "AI Forge: Clear Active Chat History",
      callback: async () => {
        await this.clearMessageHistoryWithConfirmation();
      }
    });
    this.addCommand({
      id: "refresh-roles",
      name: "AI Forge: Refresh Roles List",
      callback: async () => {
        await this.listRoleFiles(true);
        this.emit("roles-updated");
        new import_obsidian20.Notice("Role list refreshed.");
      }
    });
    this.addCommand({
      id: "new-chat",
      name: "AI Forge: New Chat",
      callback: async () => {
        const newChat = await this.chatManager.createNewChat();
        if (newChat) {
          new import_obsidian20.Notice(`Created new chat: ${newChat.metadata.name}`);
        }
      }
    });
    this.addCommand({
      id: "switch-chat",
      name: "AI Forge: Switch Chat",
      callback: async () => {
        await this.showChatSwitcher();
      }
    });
    this.addCommand({
      id: "rename-active-chat",
      name: "AI Forge: Rename Active Chat",
      callback: async () => {
        await this.renameActiveChat();
      }
    });
    this.addCommand({
      id: "delete-active-chat",
      name: "AI Forge: Delete Active Chat",
      callback: async () => {
        await this.deleteActiveChatWithConfirmation();
      }
    });
    this.settingTab = new OllamaSettingTab(this.app, this);
    this.addSettingTab(this.settingTab);
    this.app.workspace.onLayoutReady(async () => {
      if (this.settings.ragEnabled) {
        setTimeout(() => {
          var _a;
          (_a = this.ragService) == null ? void 0 : _a.indexDocuments();
        }, 5e3);
      }
      const savedActiveId = await this.loadDataKey(ACTIVE_CHAT_ID_KEY);
      if (savedActiveId && this.settings.saveMessageHistory) {
        await this.chatManager.setActiveChat(savedActiveId);
      }
    });
    this.registerVaultListeners();
    const debouncedRoleClear = (0, import_obsidian20.debounce)(
      () => {
        var _a, _b;
        this.roleListCache = null;
        (_b = (_a = this.promptService) == null ? void 0 : _a.clearRoleCache) == null ? void 0 : _b.call(_a);
        this.emit("roles-updated");
      },
      1500,
      true
    );
    const handleModifyEvent = (file) => {
      if (file instanceof import_obsidian20.TFile) {
        this.handleRoleOrRagFileChange(file.path, debouncedRoleClear, false);
        this.handleTaskFileModify(file);
      }
    };
    const handleDeleteEvent = (file) => {
      var _a;
      this.handleRoleOrRagFileChange(file.path, debouncedRoleClear, true);
      if (this.settings.enableProductivityFeatures && file.path === this.dailyTaskFilePath) {
        this.dailyTaskFilePath = null;
        this.taskFileContentCache = null;
        this.taskFileNeedsUpdate = false;
        (_a = this.chatManager) == null ? void 0 : _a.updateTaskState(null);
      }
    };
    const handleRenameEvent = (file, oldPath) => {
      this.handleRoleOrRagFileChange(file.path, debouncedRoleClear, false);
      this.handleRoleOrRagFileChange(oldPath, debouncedRoleClear, true);
      if (this.settings.enableProductivityFeatures) {
        if (oldPath === this.dailyTaskFilePath) {
          this.updateDailyTaskFilePath();
          this.loadAndProcessInitialTasks();
        } else if (file.path === this.dailyTaskFilePath) {
          this.taskFileNeedsUpdate = true;
          this.checkAndProcessTaskUpdate();
        }
      }
    };
    const handleCreateEvent = (file) => {
      this.handleRoleOrRagFileChange(file.path, debouncedRoleClear, false);
      if (this.settings.enableProductivityFeatures && file.path === this.dailyTaskFilePath) {
        this.taskFileNeedsUpdate = true;
        this.checkAndProcessTaskUpdate();
      }
    };
    this.registerEvent(this.app.vault.on("modify", handleModifyEvent));
    this.registerEvent(this.app.vault.on("delete", handleDeleteEvent));
    this.registerEvent(this.app.vault.on("rename", handleRenameEvent));
    this.registerEvent(this.app.vault.on("create", handleCreateEvent));
    this.updateDailyTaskFilePath();
    await this.loadAndProcessInitialTasks();
    if (this.settings.enableProductivityFeatures) {
      this.taskCheckInterval = setInterval(() => this.checkAndProcessTaskUpdate(), 5e3);
      this.registerInterval(this.taskCheckInterval);
    }
  }
  registerVaultListeners() {
    const handleFileCreateDelete = (file) => {
      if (!file || !this.chatManager || !this.settings.chatHistoryFolderPath)
        return;
      const historyPath = (0, import_obsidian20.normalizePath)(this.settings.chatHistoryFolderPath);
      if (file.path.startsWith(historyPath + "/") && (file.path.toLowerCase().endsWith(".json") || file instanceof import_obsidian20.TFolder)) {
        this.debouncedIndexAndUIRebuild();
      }
    };
    const handleFileRename = (file, oldPath) => {
      if (!file || !this.chatManager || !this.settings.chatHistoryFolderPath)
        return;
      const historyPath = (0, import_obsidian20.normalizePath)(this.settings.chatHistoryFolderPath);
      const isInHistoryNew = file.path.startsWith(historyPath + "/");
      const isInHistoryOld = oldPath.startsWith(historyPath + "/");
      if ((isInHistoryNew || isInHistoryOld) && file.path !== historyPath && oldPath !== historyPath) {
        this.debouncedIndexAndUIRebuild();
      }
    };
    this.registerEvent(this.app.vault.on("create", handleFileCreateDelete));
    this.registerEvent(this.app.vault.on("delete", handleFileCreateDelete));
    this.registerEvent(this.app.vault.on("rename", handleFileRename));
  }
  // --- Логіка файлу завдань ---
  updateDailyTaskFilePath() {
    var _a, _b, _c;
    const folderPath = (_a = this.settings.ragFolderPath) == null ? void 0 : _a.trim();
    const fileName = (_b = this.settings.dailyTaskFileName) == null ? void 0 : _b.trim();
    const newPath = folderPath && fileName ? (0, import_obsidian20.normalizePath)(`${folderPath}/${fileName}`) : null;
    if (newPath !== this.dailyTaskFilePath) {
      this.dailyTaskFilePath = newPath;
      this.taskFileContentCache = null;
      this.taskFileNeedsUpdate = true;
    } else if (!newPath && this.dailyTaskFilePath !== null) {
      this.dailyTaskFilePath = null;
      this.taskFileContentCache = null;
      (_c = this.chatManager) == null ? void 0 : _c.updateTaskState(null);
      this.taskFileNeedsUpdate = false;
    }
  }
  handleTaskFileModify(file) {
    if (this.settings.enableProductivityFeatures && file.path === this.dailyTaskFilePath) {
      if (!this.taskFileNeedsUpdate) {
        this.taskFileNeedsUpdate = true;
      }
    }
  }
  async loadAndProcessInitialTasks() {
    var _a, _b, _c, _d;
    if (!this.settings.enableProductivityFeatures || !this.dailyTaskFilePath) {
      if (this.taskFileContentCache !== null) {
        this.taskFileContentCache = null;
        (_a = this.chatManager) == null ? void 0 : _a.updateTaskState(null);
      }
      this.taskFileNeedsUpdate = false;
      return;
    }
    try {
      const fileExists = await this.app.vault.adapter.exists(this.dailyTaskFilePath);
      if (fileExists) {
        const content = await this.app.vault.adapter.read(this.dailyTaskFilePath);
        if (content !== this.taskFileContentCache || this.taskFileContentCache === null) {
          this.taskFileContentCache = content;
          const tasks = this.parseTasks(content);
          (_b = this.chatManager) == null ? void 0 : _b.updateTaskState(tasks);
          this.taskFileNeedsUpdate = false;
        } else {
          this.taskFileNeedsUpdate = false;
        }
      } else {
        if (this.taskFileContentCache !== null) {
          this.taskFileContentCache = null;
          (_c = this.chatManager) == null ? void 0 : _c.updateTaskState(null);
        }
        this.taskFileNeedsUpdate = false;
      }
    } catch (error) {
      if (this.taskFileContentCache !== null) {
        this.taskFileContentCache = null;
        (_d = this.chatManager) == null ? void 0 : _d.updateTaskState(null);
      }
      this.taskFileNeedsUpdate = false;
    }
  }
  parseTasks(content) {
    const lines = content.split("\n");
    const urgent = [];
    const regular = [];
    let hasContent = false;
    for (const line of lines) {
      const trimmedLine = line.trim();
      if (!trimmedLine)
        continue;
      hasContent = true;
      if (trimmedLine.startsWith("- [x]") || trimmedLine.startsWith("- [X]"))
        continue;
      let taskText = trimmedLine;
      let isUrgent = false;
      if (taskText.startsWith("!") || taskText.toLowerCase().includes("[urgent]")) {
        isUrgent = true;
        taskText = taskText.replace(/^!/, "").replace(/\[urgent\]/i, "").trim();
      }
      if (taskText.startsWith("- [ ]")) {
        taskText = taskText.substring(taskText.indexOf("]") + 1).trim();
      } else if (taskText.startsWith("- ")) {
        taskText = taskText.substring(1).trim();
      }
      if (taskText.length > 0) {
        if (isUrgent) {
          urgent.push(taskText);
        } else {
          regular.push(taskText);
        }
      }
    }
    const hasActualTasks = urgent.length > 0 || regular.length > 0;
    return { urgent, regular, hasContent: hasActualTasks };
  }
  async checkAndProcessTaskUpdate() {
    if (this.taskFileNeedsUpdate && this.settings.enableProductivityFeatures) {
      await this.loadAndProcessInitialTasks();
    } else {
    }
  }
  // --- Кінець логіки файлу завдань ---
  // Обробник змін для ролей та RAG
  handleRoleOrRagFileChange(changedPath, debouncedRoleClear, isDeletion = false) {
    const normPath = (0, import_obsidian20.normalizePath)(changedPath);
    const userRolesPath = this.settings.userRolesFolderPath ? (0, import_obsidian20.normalizePath)(this.settings.userRolesFolderPath) : null;
    const builtInRolesPath = this.manifest.dir ? (0, import_obsidian20.normalizePath)(`${this.manifest.dir}/roles`) : null;
    let isRoleFile = false;
    if (normPath.toLowerCase().endsWith(".md")) {
      if (userRolesPath && normPath.startsWith(userRolesPath + "/")) {
        if (normPath.substring(userRolesPath.length + 1).indexOf("/") === -1) {
          isRoleFile = true;
        }
      } else if (builtInRolesPath && normPath.startsWith(builtInRolesPath + "/")) {
        if (normPath.substring(builtInRolesPath.length + 1).indexOf("/") === -1) {
          isRoleFile = true;
        }
      }
    }
    if (userRolesPath && normPath === userRolesPath) {
      isRoleFile = true;
    }
    if (isRoleFile) {
      debouncedRoleClear();
    }
    const ragFolderPath = this.settings.ragFolderPath ? (0, import_obsidian20.normalizePath)(this.settings.ragFolderPath) : null;
    if (this.settings.ragEnabled && ragFolderPath && (normPath.startsWith(ragFolderPath + "/") || normPath === ragFolderPath)) {
      if (normPath !== this.dailyTaskFilePath) {
        this.debounceIndexUpdate();
      } else {
      }
    }
  }
  async onunload() {
    this.app.workspace.getLeavesOfType(VIEW_TYPE_OLLAMA_PERSONAS).forEach((l) => l.detach());
    this.view = null;
    if (this.indexUpdateTimeout)
      clearTimeout(this.indexUpdateTimeout);
    if (this.roleCacheClearTimeout)
      clearTimeout(this.roleCacheClearTimeout);
    if (this.taskCheckInterval)
      clearInterval(this.taskCheckInterval);
    this.eventHandlers = {};
    try {
      if (this.chatManager && this.settings.saveMessageHistory) {
        const lastActiveId = this.chatManager.getActiveChatId();
        if (lastActiveId !== void 0 && lastActiveId !== null) {
          await this.saveDataKey(ACTIVE_CHAT_ID_KEY, lastActiveId);
        } else {
          await this.saveDataKey(ACTIVE_CHAT_ID_KEY, null);
        }
      } else {
        await this.saveDataKey(ACTIVE_CHAT_ID_KEY, null);
      }
    } catch (error) {
    }
  }
  updateOllamaServiceConfig() {
    var _a;
    if (this.ollamaService) {
      (_a = this.promptService) == null ? void 0 : _a.clearModelDetailsCache();
    }
  }
  debounceIndexUpdate() {
    if (this.indexUpdateTimeout)
      clearTimeout(this.indexUpdateTimeout);
    this.indexUpdateTimeout = setTimeout(async () => {
      if (this.settings.ragEnabled && this.ragService) {
        await this.ragService.indexDocuments();
      } else {
      }
      this.indexUpdateTimeout = null;
    }, 3e4);
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const viewType = VIEW_TYPE_OLLAMA_PERSONAS;
    const existingLeaves = workspace.getLeavesOfType(viewType);
    if (existingLeaves.length > 0) {
      leaf = existingLeaves[0];
    } else {
      if (this.settings.openChatInTab) {
        leaf = workspace.getLeaf("tab");
      } else {
        leaf = workspace.getRightLeaf(false);
        if (!leaf) {
          leaf = workspace.getLeaf("tab");
        } else {
        }
      }
      if (leaf) {
        try {
          await leaf.setViewState({ type: viewType, active: true });
        } catch (e) {
          new import_obsidian20.Notice("Error opening AI Forge view.");
          return;
        }
      } else {
        new import_obsidian20.Notice("Could not open AI Forge view.");
        return;
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
      setTimeout(() => {
        if (leaf && leaf.view instanceof OllamaView) {
          this.view = leaf.view;
          this.emit("focus-input-request");
        } else {
          this.view = null;
        }
      }, 50);
    }
  }
  async loadSettingsAndMigrate() {
    const loadedData = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS, loadedData);
    this.updateOllamaServiceConfig();
    this.updateDailyTaskFilePath();
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.emit("settings-updated");
  }
  async saveDataKey(key, value) {
    try {
      const data = await this.loadData() || {};
      data[key] = value;
      await this.saveData(data);
    } catch (error) {
    }
  }
  async loadDataKey(key) {
    try {
      const data = await this.loadData() || {};
      const value = data[key];
      return value;
    } catch (error) {
      return void 0;
    }
  }
  async clearMessageHistoryWithConfirmation() {
    if (!this.chatManager) {
      new import_obsidian20.Notice("Error: Chat Manager not ready.");
      return;
    }
    const activeChat = await this.chatManager.getActiveChat();
    if (activeChat && activeChat.messages.length > 0) {
      new ConfirmModal(this.app, "Clear History", `Clear messages in "${activeChat.metadata.name}"?`, async () => {
        await this.chatManager.clearActiveChatMessages();
        new import_obsidian20.Notice(`History cleared for "${activeChat.metadata.name}".`);
      }).open();
    } else if (activeChat) {
      new import_obsidian20.Notice("Chat history is already empty.");
    } else {
      new import_obsidian20.Notice("No active chat to clear.");
    }
  }
  async listRoleFiles(forceRefresh = false) {
    if (this.roleListCache && !forceRefresh) {
      return this.roleListCache;
    }
    const roles = [];
    const addedNamesLowerCase = /* @__PURE__ */ new Set();
    const adapter = this.app.vault.adapter;
    const pluginDir = this.manifest.dir;
    const builtInRoleName = "Productivity Assistant";
    const builtInRoleFileName = "Productivity_Assistant.md";
    let builtInRolePath = null;
    if (pluginDir) {
      builtInRolePath = (0, import_obsidian20.normalizePath)(`${pluginDir}/roles/${builtInRoleFileName}`);
      try {
        if (await adapter.exists(builtInRolePath)) {
          const stat = await adapter.stat(builtInRolePath);
          if ((stat == null ? void 0 : stat.type) === "file") {
            roles.push({ name: builtInRoleName, path: builtInRolePath, isCustom: false });
            addedNamesLowerCase.add(builtInRoleName.toLowerCase());
          }
        }
      } catch (error) {
      }
    }
    const userRolesFolderPath = this.settings.userRolesFolderPath ? (0, import_obsidian20.normalizePath)(this.settings.userRolesFolderPath) : null;
    if (userRolesFolderPath && userRolesFolderPath !== "/") {
      try {
        const folderExists = await adapter.exists(userRolesFolderPath);
        const folderStat = folderExists ? await adapter.stat(userRolesFolderPath) : null;
        if ((folderStat == null ? void 0 : folderStat.type) === "folder") {
          const listResult = await adapter.list(userRolesFolderPath);
          for (const filePath of listResult.files) {
            if (filePath.toLowerCase().endsWith(".md") && filePath.substring(userRolesFolderPath.length + 1).indexOf("/") === -1 && filePath !== builtInRolePath) {
              const fileName = filePath.substring(filePath.lastIndexOf("/") + 1);
              const roleName = fileName.slice(0, -3);
              if (!addedNamesLowerCase.has(roleName.toLowerCase())) {
                roles.push({ name: roleName, path: filePath, isCustom: true });
                addedNamesLowerCase.add(roleName.toLowerCase());
              } else {
              }
            }
          }
        }
      } catch (e) {
      }
    }
    roles.sort((a, b) => a.name.localeCompare(b.name));
    this.roleListCache = roles;
    return roles;
  }
  async executeSystemCommand(command) {
    var _a;
    if (!(command == null ? void 0 : command.trim())) {
      return { stdout: "", stderr: "Empty command.", error: new Error("Empty command.") };
    }
    if (typeof process === "undefined" || !((_a = process == null ? void 0 : process.versions) == null ? void 0 : _a.node)) {
      new import_obsidian20.Notice("Cannot execute system command: Node.js environment is required.");
      return { stdout: "", stderr: "Node.js required.", error: new Error("Node.js required.") };
    }
    return new Promise((resolve) => {
      (0, import_child_process.exec)(command, (error, stdout, stderr) => {
        if (error) {
          if (stderr && stderr.trim())
            resolve({ stdout: stdout.toString(), stderr: stderr.toString(), error });
        }
      });
    });
  }
  async showChatSwitcher() {
    new import_obsidian20.Notice("Switch Chat UI not implemented yet.");
  }
  async renameActiveChat() {
    if (!this.chatManager) {
      new import_obsidian20.Notice("Error: Chat manager is not ready.");
      return;
    }
    const activeChat = await this.chatManager.getActiveChat();
    if (!activeChat) {
      new import_obsidian20.Notice("No active chat to rename.");
      return;
    }
    const currentName = activeChat.metadata.name;
    const chatId = activeChat.metadata.id;
    new PromptModal(this.app, "Rename Chat", `Enter new name for "${currentName}":`, currentName, async (newName) => {
      const trimmedName = newName == null ? void 0 : newName.trim();
      if (trimmedName && trimmedName !== "" && trimmedName !== currentName) {
        const success = await this.chatManager.renameChat(chatId, trimmedName);
        if (!success) {
        }
      } else if (newName === null || trimmedName === "") {
        new import_obsidian20.Notice("Rename cancelled or invalid name entered.");
      } else {
        new import_obsidian20.Notice("Name unchanged.");
      }
    }).open();
  }
  async deleteActiveChatWithConfirmation() {
    if (!this.chatManager) {
      new import_obsidian20.Notice("Error: Chat manager is not ready.");
      return;
    }
    const activeChat = await this.chatManager.getActiveChat();
    if (!activeChat) {
      new import_obsidian20.Notice("No active chat to delete.");
      return;
    }
    const chatName = activeChat.metadata.name;
    const chatId = activeChat.metadata.id;
    new ConfirmModal(
      this.app,
      "Delete Chat",
      `Are you sure you want to delete chat "${chatName}"?
This action cannot be undone.`,
      async () => {
        const success = await this.chatManager.deleteChat(chatId);
        if (!success) {
        }
      }
    ).open();
  }
  async handleActiveChatChangedLocally(data) {
    if (this.settings.saveMessageHistory) {
      await this.saveDataKey(ACTIVE_CHAT_ID_KEY, data.chatId);
    } else {
      await this.saveDataKey(ACTIVE_CHAT_ID_KEY, null);
    }
  }
  findRoleNameByPath(rolePath) {
    var _a;
    if (!rolePath)
      return "None";
    const cachedRole = (_a = this.roleListCache) == null ? void 0 : _a.find((rl) => rl.path === rolePath);
    if (cachedRole) {
      return cachedRole.name;
    }
    try {
      const fileName = rolePath.substring(rolePath.lastIndexOf("/") + 1);
      const roleName = fileName.endsWith(".md") ? fileName.slice(0, -3) : fileName;
      return roleName || "Unknown Role";
    } catch (e) {
      return "Unknown Role";
    }
  }
};
