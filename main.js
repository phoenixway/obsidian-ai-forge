/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => OllamaPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian12 = require("obsidian");

// src/OllamaView.ts
var import_obsidian3 = require("obsidian");

// src/ConfirmModal.ts
var import_obsidian = require("obsidian");
var ConfirmModal = class extends import_obsidian.Modal {
  constructor(app, title, message, onConfirm) {
    super(app);
    this.title = title;
    this.message = message;
    this.onConfirm = onConfirm;
    this.title = title;
    this.message = message;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl, titleEl } = this;
    titleEl.setText(this.title);
    contentEl.createEl("p", { text: this.message });
    new import_obsidian.Setting(contentEl).addButton((button) => button.setButtonText("Confirm").setCta().onClick(() => {
      this.onConfirm();
      this.close();
    })).addButton((button) => button.setButtonText("Cancel").onClick(() => {
      this.close();
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/PromptModal.ts
var import_obsidian2 = require("obsidian");
var PromptModal = class extends import_obsidian2.Modal {
  constructor(app, title, promptText, initialValue = "", onSubmit) {
    super(app);
    this.title = title;
    this.promptText = promptText;
    this.initialValue = initialValue;
    this.onSubmit = onSubmit;
    // Приватний метод для обробки відправки (щоб уникнути дублювання коду для кнопки та Enter)
    this.submitInput = () => {
      this.onSubmit(this.inputValue);
      this.close();
    };
    this.title = title;
    this.promptText = promptText;
    this.inputValue = initialValue;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl, titleEl } = this;
    let textInput;
    titleEl.setText(this.title);
    if (this.promptText) {
      contentEl.createEl("p", { text: this.promptText });
    }
    new import_obsidian2.Setting(contentEl).setName("New value:").addText((text) => {
      textInput = text;
      text.setValue(this.inputValue).onChange((value) => {
        this.inputValue = value;
      });
      text.inputEl.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          this.submitInput();
        }
      });
    });
    new import_obsidian2.Setting(contentEl).addButton((button) => button.setButtonText("Submit").setCta().onClick(this.submitInput)).addButton((button) => button.setButtonText("Cancel").onClick(() => {
      this.close();
    }));
    setTimeout(() => {
      var _a, _b;
      (_a = textInput == null ? void 0 : textInput.inputEl) == null ? void 0 : _a.focus();
      (_b = textInput == null ? void 0 : textInput.inputEl) == null ? void 0 : _b.select();
    }, 50);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/OllamaView.ts
var VIEW_TYPE_OLLAMA_PERSONAS = "ollama-personas-chat-view";
var CSS_CLASS_CONTAINER = "ollama-container";
var CSS_CLASS_CHAT_CONTAINER = "ollama-chat-container";
var CSS_CLASS_INPUT_CONTAINER = "chat-input-container";
var CSS_CLASS_BUTTONS_CONTAINER = "buttons-container";
var CSS_CLASS_SEND_BUTTON = "send-button";
var CSS_CLASS_VOICE_BUTTON = "voice-button";
var CSS_CLASS_TRANSLATE_INPUT_BUTTON = "translate-input-button";
var CSS_CLASS_TRANSLATING_INPUT = "translating-input";
var CSS_CLASS_MENU_BUTTON = "menu-button";
var CSS_CLASS_MENU_DROPDOWN = "menu-dropdown";
var CSS_CLASS_MENU_OPTION = "menu-option";
var CSS_CLASS_MENU_HEADER_ITEM = "menu-header-item";
var CSS_CLASS_SUBMENU_ICON = "submenu-icon";
var CSS_CLASS_SUBMENU_CONTENT = "submenu-content";
var CSS_CLASS_SUBMENU_CONTENT_HIDDEN = "submenu-content-hidden";
var CSS_CLASS_SETTINGS_OPTION = "settings-option";
var CSS_CLASS_EMPTY_STATE = "ollama-empty-state";
var CSS_CLASS_MESSAGE_GROUP = "message-group";
var CSS_CLASS_USER_GROUP = "user-message-group";
var CSS_CLASS_OLLAMA_GROUP = "ollama-message-group";
var CSS_CLASS_SYSTEM_GROUP = "system-message-group";
var CSS_CLASS_ERROR_GROUP = "error-message-group";
var CSS_CLASS_MESSAGE = "message";
var CSS_CLASS_USER_MESSAGE = "user-message";
var CSS_CLASS_OLLAMA_MESSAGE = "ollama-message";
var CSS_CLASS_SYSTEM_MESSAGE = "system-message";
var CSS_CLASS_ERROR_MESSAGE = "error-message";
var CSS_CLASS_SYSTEM_ICON = "system-icon";
var CSS_CLASS_ERROR_ICON = "error-icon";
var CSS_CLASS_SYSTEM_TEXT = "system-message-text";
var CSS_CLASS_ERROR_TEXT = "error-message-text";
var CSS_CLASS_CONTENT_CONTAINER = "message-content-container";
var CSS_CLASS_CONTENT = "message-content";
var CSS_CLASS_THINKING_DOTS = "thinking-dots";
var CSS_CLASS_THINKING_DOT = "thinking-dot";
var CSS_CLASS_THINKING_BLOCK = "thinking-block";
var CSS_CLASS_THINKING_HEADER = "thinking-header";
var CSS_CLASS_THINKING_TOGGLE = "thinking-toggle";
var CSS_CLASS_THINKING_TITLE = "thinking-title";
var CSS_CLASS_THINKING_CONTENT = "thinking-content";
var CSS_CLASS_TIMESTAMP = "message-timestamp";
var CSS_CLASS_COPY_BUTTON = "copy-button";
var CSS_CLASS_TRANSLATE_BUTTON = "translate-button";
var CSS_CLASS_TRANSLATION_CONTAINER = "translation-container";
var CSS_CLASS_TRANSLATION_CONTENT = "translation-content";
var CSS_CLASS_TRANSLATION_PENDING = "translation-pending";
var CSS_CLASS_RECORDING = "recording";
var CSS_CLASS_DISABLED = "disabled";
var CSS_CLASS_MESSAGE_ARRIVING = "message-arriving";
var CSS_CLASS_DATE_SEPARATOR = "chat-date-separator";
var CSS_CLASS_AVATAR = "message-group-avatar";
var CSS_CLASS_AVATAR_USER = "user-avatar";
var CSS_CLASS_AVATAR_AI = "ai-avatar";
var CSS_CLASS_CODE_BLOCK_COPY_BUTTON = "code-block-copy-button";
var CSS_CLASS_CODE_BLOCK_LANGUAGE = "code-block-language";
var CSS_CLASS_NEW_MESSAGE_INDICATOR = "new-message-indicator";
var CSS_CLASS_VISIBLE = "visible";
var CSS_CLASS_MENU_SEPARATOR = "menu-separator";
var CSS_CLASS_CLEAR_CHAT_OPTION = "clear-chat-option";
var CSS_CLASS_EXPORT_CHAT_OPTION = "export-chat-option";
var CSS_CLASS_CONTENT_COLLAPSIBLE = "message-content-collapsible";
var CSS_CLASS_CONTENT_COLLAPSED = "message-content-collapsed";
var CSS_CLASS_SHOW_MORE_BUTTON = "show-more-button";
var CSS_CLASS_MODEL_OPTION = "model-option";
var CSS_CLASS_MODEL_LIST_CONTAINER = "model-list-container";
var CSS_CLASS_ROLE_OPTION = "role-option";
var CSS_CLASS_ROLE_LIST_CONTAINER = "role-list-container";
var CSS_CLASS_CHAT_OPTION = "chat-option";
var CSS_CLASS_CHAT_LIST_CONTAINER = "chat-list-container";
var CSS_CLASS_MENU_HEADER = "menu-header";
var CSS_CLASS_NEW_CHAT_OPTION = "new-chat-option";
var CSS_CLASS_RENAME_CHAT_OPTION = "rename-chat-option";
var CSS_CLASS_DELETE_CHAT_OPTION = "delete-chat-option";
var CSS_CLASS_CLONE_CHAT_OPTION = "clone-chat-option";
var CSS_CLASS_DANGER_OPTION = "danger-option";
var CSS_CLASS_MODEL_DISPLAY = "model-display";
var CSS_CLASS_ROLE_DISPLAY = "role-display";
var CSS_CLASS_INPUT_CONTROLS_CONTAINER = "input-controls-container";
var CSS_CLASS_INPUT_CONTROLS_LEFT = "input-controls-left";
var CSS_CLASS_INPUT_CONTROLS_RIGHT = "input-controls-right";
var LANGUAGES = {
  "af": "Afrikaans",
  "sq": "Albanian",
  "am": "Amharic",
  "ar": "Arabic",
  "hy": "Armenian",
  "az": "Azerbaijani",
  "eu": "Basque",
  "be": "Belarusian",
  "bn": "Bengali",
  "bs": "Bosnian",
  "bg": "Bulgarian",
  "ca": "Catalan",
  "ceb": "Cebuano",
  "ny": "Chichewa",
  "zh-CN": "Chinese (Simplified)",
  "zh-TW": "Chinese (Traditional)",
  "co": "Corsican",
  "hr": "Croatian",
  "cs": "Czech",
  "da": "Danish",
  "nl": "Dutch",
  "en": "English",
  "eo": "Esperanto",
  "et": "Estonian",
  "tl": "Filipino",
  "fi": "Finnish",
  "fr": "French",
  "fy": "Frisian",
  "gl": "Galician",
  "ka": "Georgian",
  "de": "German",
  "el": "Greek",
  "gu": "Gujarati",
  "ht": "Haitian Creole",
  "ha": "Hausa",
  "haw": "Hawaiian",
  "iw": "Hebrew",
  "he": "Hebrew",
  "hi": "Hindi",
  "hmn": "Hmong",
  "hu": "Hungarian",
  "is": "Icelandic",
  "ig": "Igbo",
  "id": "Indonesian",
  "ga": "Irish",
  "it": "Italian",
  "ja": "Japanese",
  "jw": "Javanese",
  "kn": "Kannada",
  "kk": "Kazakh",
  "km": "Khmer",
  "rw": "Kinyarwanda",
  "ko": "Korean",
  "ku": "Kurdish (Kurmanji)",
  "ky": "Kyrgyz",
  "lo": "Lao",
  "la": "Latin",
  "lv": "Latvian",
  "lt": "Lithuanian",
  "lb": "Luxembourgish",
  "mk": "Macedonian",
  "mg": "Malagasy",
  "ms": "Malay",
  "ml": "Malayalam",
  "mt": "Maltese",
  "mi": "Maori",
  "mr": "Marathi",
  "mn": "Mongolian",
  "my": "Myanmar (Burmese)",
  "ne": "Nepali",
  "no": "Norwegian",
  "or": "Odia (Oriya)",
  "ps": "Pashto",
  "fa": "Persian",
  "pl": "Polish",
  "pt": "Portuguese",
  "pa": "Punjabi",
  "ro": "Romanian",
  "ru": "Russian",
  "sm": "Samoan",
  "gd": "Scots Gaelic",
  "sr": "Serbian",
  "st": "Sesotho",
  "sn": "Shona",
  "sd": "Sindhi",
  "si": "Sinhala",
  "sk": "Slovak",
  "sl": "Slovenian",
  "so": "Somali",
  "es": "Spanish",
  "su": "Sundanese",
  "sw": "Swahili",
  "sv": "Swedish",
  "tg": "Tajik",
  "ta": "Tamil",
  "tt": "Tatar",
  "te": "Telugu",
  "th": "Thai",
  "tr": "Turkish",
  "tk": "Turkmen",
  "uk": "Ukrainian",
  "ur": "Urdu",
  "ug": "Uyghur",
  "uz": "Uzbek",
  "vi": "Vietnamese",
  "cy": "Welsh",
  "xh": "Xhosa",
  "yi": "Yiddish",
  "yo": "Yoruba",
  "zu": "Zulu"
};
var OllamaView = class extends import_obsidian3.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    // --- State ---
    this.isProcessing = false;
    this.scrollTimeout = null;
    this.speechWorker = null;
    this.mediaRecorder = null;
    this.audioStream = null;
    this.emptyStateEl = null;
    this.resizeTimeout = null;
    this.currentMessages = [];
    this.lastRenderedMessageDate = null;
    this.newMessagesIndicatorEl = null;
    this.userScrolledUp = false;
    this.handleSettingsUpdated = async () => {
      var _a, _b;
      const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
      const currentModelName = ((_b = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _b.modelName) || this.plugin.settings.modelName;
      const currentRoleName = await this.getCurrentRoleDisplayName();
      this.updateModelDisplay(currentModelName);
      this.updateRoleDisplay(currentRoleName);
      this.updateInputPlaceholder(currentRoleName);
    };
    this.handleModelDisplayClick = async (event) => {
      var _a, _b;
      const menu = new import_obsidian3.Menu();
      let itemsAdded = false;
      const loadingNotice = new import_obsidian3.Notice("Loading models...", 0);
      try {
        const models = await this.plugin.ollamaService.getModels();
        const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
        const currentModelName = ((_b = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _b.modelName) || this.plugin.settings.modelName;
        loadingNotice.hide();
        if (models.length === 0) {
          menu.addItem((item) => item.setTitle("No models found").setDisabled(true));
          itemsAdded = true;
        } else {
          models.forEach((modelName) => {
            menu.addItem(
              (item) => item.setTitle(modelName).setIcon(modelName === currentModelName ? "check" : "radio-button").onClick(async () => {
                var _a2, _b2;
                const chatToUpdate = await ((_a2 = this.plugin.chatManager) == null ? void 0 : _a2.getActiveChat());
                const latestModelName = ((_b2 = chatToUpdate == null ? void 0 : chatToUpdate.metadata) == null ? void 0 : _b2.modelName) || this.plugin.settings.modelName;
                if (modelName !== latestModelName) {
                  if (chatToUpdate) {
                    await this.plugin.chatManager.updateActiveChatMetadata({ modelName });
                  } else {
                    new import_obsidian3.Notice("Cannot set model: No active chat.");
                  }
                }
              })
            );
            itemsAdded = true;
          });
        }
      } catch (error) {
        loadingNotice.hide();
        console.error("Error loading models for model selection menu:", error);
        menu.addItem((item) => item.setTitle("Error loading models").setDisabled(true));
        itemsAdded = true;
        new import_obsidian3.Notice("Failed to load models. Check Ollama connection.");
      } finally {
        if (itemsAdded) {
          menu.showAtMouseEvent(event);
        } else {
          console.warn("Model menu was not shown because no items were added.");
        }
      }
    };
    // --- Event Handlers ---
    // Input & Sending
    this.handleKeyDown = (e) => {
      var _a;
      if (e.key === "Enter" && !e.shiftKey && !this.isProcessing && !((_a = this.sendButton) == null ? void 0 : _a.disabled)) {
        e.preventDefault();
        this.sendMessage();
      }
    };
    this.handleSendClick = () => {
      var _a;
      if (!this.isProcessing && !((_a = this.sendButton) == null ? void 0 : _a.disabled)) {
        this.sendMessage();
      } else {
      }
    };
    this.handleInputForResize = () => {
      if (this.resizeTimeout)
        clearTimeout(this.resizeTimeout);
      this.resizeTimeout = setTimeout(() => {
        this.adjustTextareaHeight();
        this.updateSendButtonState();
      }, 50);
    };
    // Input Area Buttons
    this.handleVoiceClick = () => {
      this.toggleVoiceRecognition();
    };
    this.handleTranslateInputClick = async () => {
      const currentText = this.inputEl.value;
      const targetLang = "en";
      if (!currentText.trim()) {
        new import_obsidian3.Notice("Input empty...");
        return;
      }
      if (!this.plugin.settings.enableTranslation) {
        new import_obsidian3.Notice("Translation disabled...");
        return;
      }
      const apiKey = this.plugin.settings.googleTranslationApiKey;
      if (!apiKey) {
        new import_obsidian3.Notice("Translation API Key not set...");
        return;
      }
      (0, import_obsidian3.setIcon)(this.translateInputButton, "loader");
      this.translateInputButton.disabled = true;
      this.translateInputButton.classList.add(CSS_CLASS_TRANSLATING_INPUT);
      this.translateInputButton.title = "Translating...";
      try {
        const translatedText = await this.plugin.translationService.translate(currentText, targetLang);
        if (translatedText !== null) {
          this.inputEl.value = translatedText;
          this.inputEl.dispatchEvent(new Event("input"));
          this.inputEl.focus();
          const end = translatedText.length;
          this.inputEl.setSelectionRange(end, end);
        } else {
          console.warn("Input translation failed.");
        }
      } catch (error) {
        console.error("Input translation error:", error);
        new import_obsidian3.Notice("Input translation error.");
      } finally {
        (0, import_obsidian3.setIcon)(this.translateInputButton, "languages");
        this.translateInputButton.disabled = this.isProcessing;
        this.translateInputButton.classList.remove(CSS_CLASS_TRANSLATING_INPUT);
        this.translateInputButton.title = "Translate input to English";
      }
    };
    // Menu Button Click (Toggles Custom Div)
    this.handleMenuClick = (e) => {
      e.stopPropagation();
      if (!this.menuDropdown) {
        console.error("menuDropdown missing!");
        return;
      }
      const isHidden = this.menuDropdown.style.display === "none";
      if (isHidden) {
        this.menuDropdown.style.display = "block";
        this.collapseAllSubmenus(null);
      } else {
        this.closeMenu();
      }
    };
    // --- Action Handlers (Must call closeMenu) ---
    this.handleNewChatClick = async () => {
      this.closeMenu();
      try {
        const newChat = await this.plugin.chatManager.createNewChat();
        if (newChat) {
          new import_obsidian3.Notice(`Created new chat: ${newChat.metadata.name}`);
          this.focusInput();
        } else {
          new import_obsidian3.Notice("Failed to create new chat.");
        }
      } catch (error) {
        new import_obsidian3.Notice("Error creating new chat.");
      }
    };
    this.handleRenameChatClick = async () => {
      var _a;
      this.closeMenu();
      const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
      if (!activeChat) {
        new import_obsidian3.Notice("No active chat to rename.");
        return;
      }
      const currentName = activeChat.metadata.name;
      new PromptModal(this.app, "Rename Chat", `Enter new name for "${currentName}":`, currentName, async (newName) => {
        let noticeMessage = "Rename cancelled or name unchanged.";
        if (newName && newName.trim() !== "" && newName.trim() !== currentName) {
          const success = await this.plugin.chatManager.renameChat(activeChat.metadata.id, newName.trim());
          if (success) {
            noticeMessage = `Chat renamed to "${newName.trim()}"`;
          } else {
            noticeMessage = "Failed to rename chat.";
          }
        } else if ((newName == null ? void 0 : newName.trim()) === currentName) {
          noticeMessage = "Name unchanged.";
        } else {
          noticeMessage = "Rename cancelled or invalid name entered.";
        }
        new import_obsidian3.Notice(noticeMessage);
        this.focusInput();
      }).open();
    };
    this.handleCloneChatClick = async () => {
      var _a;
      this.closeMenu();
      const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
      if (!activeChat) {
        new import_obsidian3.Notice("No active chat to clone.");
        return;
      }
      const originalName = activeChat.metadata.name;
      const cloningNotice = new import_obsidian3.Notice("Cloning chat...", 0);
      try {
        const clonedChat = await this.plugin.chatManager.cloneChat(activeChat.metadata.id);
        if (clonedChat) {
          new import_obsidian3.Notice(`Chat cloned as "${clonedChat.metadata.name}" and activated.`);
        } else {
          new import_obsidian3.Notice("Failed to clone chat.");
        }
      } catch (error) {
        new import_obsidian3.Notice("An error occurred while cloning the chat.");
      } finally {
        cloningNotice.hide();
      }
    };
    this.handleClearChatClick = async () => {
      var _a;
      this.closeMenu();
      const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
      if (activeChat) {
        const chatName = activeChat.metadata.name;
        new ConfirmModal(this.app, "Clear Chat Messages", `Are you sure you want to clear all messages in chat "${chatName}"?
This action cannot be undone.`, () => {
          this.plugin.chatManager.clearActiveChatMessages();
        }).open();
      } else {
        new import_obsidian3.Notice("No active chat to clear.");
      }
    };
    this.handleDeleteChatClick = async () => {
      var _a;
      this.closeMenu();
      const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
      if (activeChat) {
        const chatName = activeChat.metadata.name;
        new ConfirmModal(this.app, "Delete Chat", `Are you sure you want to delete chat "${chatName}"?
This action cannot be undone.`, async () => {
          const success = await this.plugin.chatManager.deleteChat(activeChat.metadata.id);
          if (success) {
            new import_obsidian3.Notice(`Chat "${chatName}" deleted.`);
          } else {
            new import_obsidian3.Notice(`Failed to delete chat "${chatName}".`);
          }
        }).open();
      } else {
        new import_obsidian3.Notice("No active chat to delete.");
      }
    };
    // Цей обробник події викликається при натисканні на "Export to Note"
    this.handleExportChatClick = async () => {
      var _a, _b;
      this.closeMenu();
      const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
      if (!activeChat || activeChat.messages.length === 0) {
        new import_obsidian3.Notice("Chat empty, nothing to export.");
        return;
      }
      try {
        const markdownContent = this.formatChatToMarkdown(activeChat.messages);
        const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
        const safeName = activeChat.metadata.name.replace(/[\\/?:*"<>|]/g, "-");
        const filename = `ollama-chat-${safeName}-${timestamp}.md`;
        let targetFolderPath = (_b = this.plugin.settings.chatExportFolderPath) == null ? void 0 : _b.trim();
        let targetFolder = null;
        if (targetFolderPath) {
          targetFolderPath = (0, import_obsidian3.normalizePath)(targetFolderPath);
          const abstractFile = this.app.vault.getAbstractFileByPath(targetFolderPath);
          if (!abstractFile) {
            try {
              await this.app.vault.createFolder(targetFolderPath);
              targetFolder = this.app.vault.getAbstractFileByPath(targetFolderPath);
              if (targetFolder) {
                new import_obsidian3.Notice(`Created export folder: ${targetFolderPath}`);
              } else {
                this.plugin.logger.error("Failed to get folder even after creation attempt:", targetFolderPath);
                new import_obsidian3.Notice(`Error creating export folder. Saving to vault root.`);
                targetFolder = this.app.vault.getRoot();
              }
            } catch (err) {
              this.plugin.logger.error("Error creating export folder:", err);
              new import_obsidian3.Notice(`Error creating export folder. Saving to vault root.`);
              targetFolder = this.app.vault.getRoot();
            }
          } else if (abstractFile instanceof import_obsidian3.TFolder) {
            targetFolder = abstractFile;
          } else {
            this.plugin.logger.warn(`Export path exists but is not a folder: ${targetFolderPath}`);
            new import_obsidian3.Notice(`Error: Export path is not a folder. Saving to vault root.`);
            targetFolder = this.app.vault.getRoot();
          }
        } else {
          targetFolder = this.app.vault.getRoot();
        }
        if (!targetFolder) {
          this.plugin.logger.error("Failed to determine a valid target folder for export.");
          new import_obsidian3.Notice("Error determining export folder. Cannot save file.");
          return;
        }
        const filePath = (0, import_obsidian3.normalizePath)(`${targetFolder.path}/${filename}`);
        const existingFile = this.app.vault.getAbstractFileByPath(filePath);
        if (existingFile) {
          this.plugin.logger.warn(`Export file already exists, overwriting: ${filePath}`);
        }
        const file = await this.app.vault.create(filePath, markdownContent);
        new import_obsidian3.Notice(`Chat exported to ${file.path}`);
      } catch (error) {
        this.plugin.logger.error("Error exporting chat:", error);
        if (error instanceof Error && error.message.includes("File already exists")) {
          new import_obsidian3.Notice("Error exporting chat: File already exists.");
        } else {
          new import_obsidian3.Notice("An unexpected error occurred during chat export.");
        }
      }
    };
    this.handleSettingsClick = async () => {
      var _a, _b, _c, _d;
      this.closeMenu();
      (_b = (_a = this.app.setting) == null ? void 0 : _a.open) == null ? void 0 : _b.call(_a);
      (_d = (_c = this.app.setting) == null ? void 0 : _c.openTabById) == null ? void 0 : _d.call(_c, this.plugin.manifest.id);
    };
    this.handleDocumentClickForMenu = (e) => {
      var _a, _b;
      if (this.isMenuOpen() && !((_a = this.menuButton) == null ? void 0 : _a.contains(e.target)) && !((_b = this.menuDropdown) == null ? void 0 : _b.contains(e.target))) {
        this.closeMenu();
      }
    };
    // --- Plugin Event Handlers ---
    this.handleModelChange = (modelName) => {
      this.updateModelDisplay(modelName);
      if (this.currentMessages.length > 0) {
        this.addMessageToDisplay("system", `Model changed to: ${modelName}`, new Date());
      }
    };
    this.handleRoleChange = (roleName) => {
      this.plugin.logger.debug(`[AI Forge View Debug] handleRoleChange received roleName: '${roleName}'`);
      const displayRole = roleName || "None";
      this.updateInputPlaceholder(displayRole);
      this.updateRoleDisplay(displayRole);
      if (this.currentMessages.length > 0) {
        this.addMessageToDisplay("system", `Role changed to: ${displayRole}`, new Date());
      } else {
        new import_obsidian3.Notice(`Role set to: ${displayRole}`);
      }
    };
    this.handleRolesUpdated = () => {
      var _a;
      (_a = this.plugin.promptService) == null ? void 0 : _a.clearRoleCache();
      if (this.isMenuOpen()) {
        this.renderRoleList();
      }
    };
    this.handleChatListUpdated = () => {
      console.log("[OllamaView] Chat list updated event received.");
      if (this.isMenuOpen()) {
        this.renderChatListMenu();
      }
    };
    // Refresh list if open
    this.handleActiveChatChanged = (data) => {
      console.log(`[OllamaView] Active chat changed event received. New ID: ${data.chatId}`);
      this.loadAndDisplayActiveChat();
    };
    this.handleMessageAdded = (data) => {
      var _a;
      if (data.chatId === ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChatId())) {
        this.addMessageToDisplay(data.message.role, data.message.content, data.message.timestamp);
        if (this.isMenuOpen()) {
          this.renderChatListMenu();
        }
      }
    };
    // Refresh list date if open
    this.handleMessagesCleared = (chatId) => {
      var _a;
      if (chatId === ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChatId())) {
        console.log("[OllamaView] Messages cleared event received.");
        this.clearChatContainerInternal();
        this.currentMessages = [];
        this.showEmptyState();
      }
    };
    // --- Window/Workspace State Handlers ---
    this.handleVisibilityChange = () => {
      if (document.visibilityState === "visible" && this.leaf.view === this) {
        requestAnimationFrame(() => {
          var _a;
          this.guaranteedScrollToBottom(50, true);
          this.adjustTextareaHeight();
          (_a = this.inputEl) == null ? void 0 : _a.focus();
        });
      }
    };
    this.handleActiveLeafChange = (leaf) => {
      var _a;
      if ((leaf == null ? void 0 : leaf.view) === this) {
        (_a = this.inputEl) == null ? void 0 : _a.focus();
        setTimeout(() => this.guaranteedScrollToBottom(150, true), 100);
      }
    };
    this.handleWindowResize = () => {
      if (this.resizeTimeout)
        clearTimeout(this.resizeTimeout);
      this.resizeTimeout = setTimeout(() => this.adjustTextareaHeight(), 100);
    };
    // --- Scroll Handling ---
    this.handleScroll = () => {
      if (!this.chatContainer || !this.newMessagesIndicatorEl)
        return;
      const threshold = 150;
      const atBottom = this.chatContainer.scrollHeight - this.chatContainer.scrollTop - this.chatContainer.clientHeight < threshold;
      const previousScrolledUp = this.userScrolledUp;
      this.userScrolledUp = !atBottom;
      if (previousScrolledUp && atBottom) {
        this.newMessagesIndicatorEl.classList.remove(CSS_CLASS_VISIBLE);
      }
    };
    this.handleNewMessageIndicatorClick = () => {
      var _a;
      if (this.chatContainer) {
        this.chatContainer.scrollTo({ top: this.chatContainer.scrollHeight, behavior: "smooth" });
      }
      (_a = this.newMessagesIndicatorEl) == null ? void 0 : _a.classList.remove(CSS_CLASS_VISIBLE);
      this.userScrolledUp = false;
    };
    this.adjustTextareaHeight = () => {
      requestAnimationFrame(() => {
        if (!this.inputEl)
          return;
        const textarea = this.inputEl;
        const originalMinHeightStyle = textarea.style.minHeight;
        textarea.style.height = "auto";
        textarea.style.minHeight = "0";
        requestAnimationFrame(() => {
          if (!this.inputEl)
            return;
          const computedStyle = window.getComputedStyle(textarea);
          const baseMinHeight = parseFloat(computedStyle.minHeight) || 40;
          const maxHeight = parseFloat(computedStyle.maxHeight);
          const scrollHeight = textarea.scrollHeight;
          let targetMinHeight = Math.max(baseMinHeight, scrollHeight);
          if (!isNaN(maxHeight) && targetMinHeight > maxHeight) {
            targetMinHeight = maxHeight;
            if (textarea.style.overflowY !== "auto" && textarea.style.overflowY !== "scroll") {
              textarea.style.overflowY = "auto";
            }
          } else {
            if (textarea.style.overflowY === "auto" || textarea.style.overflowY === "scroll") {
              textarea.style.overflowY = "hidden";
            }
          }
          textarea.style.minHeight = `${targetMinHeight}px`;
          textarea.style.height = "auto";
        });
      });
    };
    this.handleRoleDisplayClick = async (event) => {
      var _a, _b, _c;
      this.plugin.logger.debug("[OllamaView Debug] Role display clicked, creating native menu.");
      const menu = new import_obsidian3.Menu();
      let itemsAdded = false;
      try {
        const roles = await this.plugin.listRoleFiles(true);
        this.plugin.logger.debug("[OllamaView Debug] Roles loaded:", roles);
        const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
        const currentRolePath = (_c = (_b = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _b.selectedRolePath) != null ? _c : this.plugin.settings.selectedRolePath;
        this.plugin.logger.debug("[OllamaView Debug] Current role path:", currentRolePath);
        menu.addItem((item) => {
          item.setTitle("None").setIcon(!currentRolePath ? "check" : "slash").onClick(async () => {
            var _a2, _b2;
            const newRolePath = "";
            if (currentRolePath !== newRolePath) {
              if (activeChat) {
                await this.plugin.chatManager.updateActiveChatMetadata({ selectedRolePath: newRolePath });
              } else {
                this.plugin.settings.selectedRolePath = newRolePath;
                await this.plugin.saveSettings();
                this.plugin.emit("role-changed", "None");
                (_b2 = (_a2 = this.plugin.promptService) == null ? void 0 : _a2.clearRoleCache) == null ? void 0 : _b2.call(_a2);
              }
            }
          });
          itemsAdded = true;
        });
        if (roles.length > 0) {
          menu.addSeparator();
          itemsAdded = true;
        }
        roles.forEach((roleInfo) => {
          menu.addItem((item) => {
            item.setTitle(roleInfo.name).setIcon(roleInfo.path === currentRolePath ? "check" : roleInfo.isCustom ? "user" : "file-text").onClick(async () => {
              var _a2, _b2;
              const newRolePath = roleInfo.path;
              if (currentRolePath !== newRolePath) {
                if (activeChat) {
                  await this.plugin.chatManager.updateActiveChatMetadata({ selectedRolePath: newRolePath });
                } else {
                  this.plugin.settings.selectedRolePath = newRolePath;
                  await this.plugin.saveSettings();
                  this.plugin.emit("role-changed", roleInfo.name);
                  (_b2 = (_a2 = this.plugin.promptService) == null ? void 0 : _a2.clearRoleCache) == null ? void 0 : _b2.call(_a2);
                }
              }
            });
            itemsAdded = true;
          });
        });
      } catch (error) {
        console.error("Error loading roles for role selection menu:", error);
        if (!itemsAdded) {
          menu.addItem((item) => item.setTitle("Error loading roles").setDisabled(true));
          itemsAdded = true;
        }
        new import_obsidian3.Notice("Failed to load roles.");
      } finally {
        if (itemsAdded) {
          menu.showAtMouseEvent(event);
        } else {
          console.warn("Role menu was not shown because no items were added.");
        }
      }
    };
    this.plugin = plugin;
    this.initSpeechWorker();
    this.scrollListenerDebounced = (0, import_obsidian3.debounce)(this.handleScroll, 150, true);
  }
  // --- Getters ---
  /** Checks if the custom menu dropdown is currently visible */
  isMenuOpen() {
    return !!this.menuDropdown && this.menuDropdown.style.display === "block";
  }
  // --- Obsidian View Methods ---
  getViewType() {
    return VIEW_TYPE_OLLAMA_PERSONAS;
  }
  getDisplayText() {
    return "AI Forge";
  }
  getIcon() {
    return "brain-circuit";
  }
  async onOpen() {
    this.createUIElements();
    this.getCurrentRoleDisplayName().then((roleName) => {
      this.updateInputPlaceholder(roleName);
    });
    this.updateModelDisplay(this.plugin.settings.modelName);
    this.attachEventListeners();
    this.autoResizeTextarea();
    this.updateSendButtonState();
    try {
      await this.loadAndDisplayActiveChat();
    } catch (error) {
      this.plugin.logger.error("[OllamaView] Error during initial chat load:", error);
      this.showEmptyState();
      this.getCurrentRoleDisplayName().then((roleName) => {
        this.updateInputPlaceholder(roleName);
        this.updateRoleDisplay(roleName);
      });
      this.updateModelDisplay(this.plugin.settings.modelName);
    }
    setTimeout(() => {
      var _a;
      return (_a = this.inputEl) == null ? void 0 : _a.focus();
    }, 150);
    if (this.inputEl) {
      this.inputEl.dispatchEvent(new Event("input"));
    }
  }
  async onClose() {
    if (this.speechWorker) {
      this.speechWorker.terminate();
      this.speechWorker = null;
    }
    this.stopVoiceRecording(false);
    if (this.audioStream) {
      this.audioStream.getTracks().forEach((t) => t.stop());
      this.audioStream = null;
    }
    if (this.scrollTimeout)
      clearTimeout(this.scrollTimeout);
    if (this.resizeTimeout)
      clearTimeout(this.resizeTimeout);
  }
  // --- UI Creation (with Custom Div Menu & Accordion) ---
  createUIElements() {
    this.contentEl.empty();
    this.chatContainerEl = this.contentEl.createDiv({ cls: CSS_CLASS_CONTAINER });
    this.chatContainer = this.chatContainerEl.createDiv({ cls: CSS_CLASS_CHAT_CONTAINER });
    this.newMessagesIndicatorEl = this.chatContainerEl.createDiv({ cls: CSS_CLASS_NEW_MESSAGE_INDICATOR });
    (0, import_obsidian3.setIcon)(this.newMessagesIndicatorEl.createSpan({ cls: "indicator-icon" }), "arrow-down");
    this.newMessagesIndicatorEl.createSpan({ text: " New Messages" });
    const inputContainer = this.chatContainerEl.createDiv({ cls: CSS_CLASS_INPUT_CONTAINER });
    this.inputEl = inputContainer.createEl("textarea", { attr: { placeholder: `Text...`, rows: 1 } });
    const controlsContainer = inputContainer.createDiv({ cls: CSS_CLASS_INPUT_CONTROLS_CONTAINER });
    const leftControls = controlsContainer.createDiv({ cls: CSS_CLASS_INPUT_CONTROLS_LEFT });
    this.translateInputButton = leftControls.createEl("button", { cls: CSS_CLASS_TRANSLATE_INPUT_BUTTON, attr: { "aria-label": "Translate input to English" } });
    (0, import_obsidian3.setIcon)(this.translateInputButton, "languages");
    this.translateInputButton.title = "Translate input to English";
    this.modelDisplayEl = leftControls.createDiv({ cls: CSS_CLASS_MODEL_DISPLAY });
    this.modelDisplayEl.setText("...");
    this.modelDisplayEl.title = "Click to select model";
    this.roleDisplayEl = leftControls.createDiv({ cls: CSS_CLASS_ROLE_DISPLAY });
    this.roleDisplayEl.setText("...");
    this.roleDisplayEl.title = "Click to select role";
    this.buttonsContainer = controlsContainer.createDiv({ cls: `${CSS_CLASS_BUTTONS_CONTAINER} ${CSS_CLASS_INPUT_CONTROLS_RIGHT}` });
    this.sendButton = this.buttonsContainer.createEl("button", { cls: CSS_CLASS_SEND_BUTTON, attr: { "aria-label": "Send" } });
    (0, import_obsidian3.setIcon)(this.sendButton, "send");
    this.voiceButton = this.buttonsContainer.createEl("button", { cls: CSS_CLASS_VOICE_BUTTON, attr: { "aria-label": "Voice Input" } });
    (0, import_obsidian3.setIcon)(this.voiceButton, "mic");
    this.menuButton = this.buttonsContainer.createEl("button", { cls: CSS_CLASS_MENU_BUTTON, attr: { "aria-label": "Menu" } });
    (0, import_obsidian3.setIcon)(this.menuButton, "more-vertical");
    this.menuDropdown = inputContainer.createEl("div", { cls: [CSS_CLASS_MENU_DROPDOWN, "ollama-chat-menu"] });
    this.menuDropdown.style.display = "none";
    const createSubmenuSection = (title, icon, listContainerClass, sectionClass) => {
      const section = this.menuDropdown.createDiv();
      if (sectionClass)
        section.addClass(sectionClass);
      const header = section.createDiv({ cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_MENU_HEADER_ITEM}` });
      (0, import_obsidian3.setIcon)(header.createSpan({ cls: "menu-option-icon" }), icon);
      header.createSpan({ cls: "menu-option-text", text: title });
      (0, import_obsidian3.setIcon)(header.createSpan({ cls: CSS_CLASS_SUBMENU_ICON }), "chevron-right");
      const content = section.createDiv({ cls: `${CSS_CLASS_SUBMENU_CONTENT} ${CSS_CLASS_SUBMENU_CONTENT_HIDDEN} ${listContainerClass}` });
      content.style.maxHeight = "0";
      content.style.overflow = "hidden";
      content.style.transition = "max-height 0.3s ease-out, padding 0.3s ease-out";
      content.style.paddingTop = "0";
      content.style.paddingBottom = "0";
      return { header, content, section };
    };
    const modelSection = createSubmenuSection("Select Model", "list-collapse", CSS_CLASS_MODEL_LIST_CONTAINER, "model-submenu-section");
    this.modelSubmenuHeader = modelSection.header;
    this.modelSubmenuContent = modelSection.content;
    const roleSection = createSubmenuSection("Select Role", "users", CSS_CLASS_ROLE_LIST_CONTAINER, "role-submenu-section");
    this.roleSubmenuHeader = roleSection.header;
    this.roleSubmenuContent = roleSection.content;
    const chatSection = createSubmenuSection("Load Chat", "messages-square", CSS_CLASS_CHAT_LIST_CONTAINER);
    this.chatSubmenuHeader = chatSection.header;
    this.chatSubmenuContent = chatSection.content;
    this.menuDropdown.createEl("hr", { cls: CSS_CLASS_MENU_SEPARATOR });
    this.menuDropdown.createEl("div", { text: "Actions", cls: CSS_CLASS_MENU_HEADER });
    this.newChatOption = this.menuDropdown.createEl("div", { cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_NEW_CHAT_OPTION}` });
    (0, import_obsidian3.setIcon)(this.newChatOption.createSpan({ cls: "menu-option-icon" }), "plus-circle");
    this.newChatOption.createSpan({ cls: "menu-option-text", text: "New Chat" });
    this.renameChatOption = this.menuDropdown.createEl("div", { cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_RENAME_CHAT_OPTION}` });
    (0, import_obsidian3.setIcon)(this.renameChatOption.createSpan({ cls: "menu-option-icon" }), "pencil");
    this.renameChatOption.createSpan({ cls: "menu-option-text", text: "Rename Chat" });
    this.cloneChatOption = this.menuDropdown.createEl("div", { cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_CLONE_CHAT_OPTION}` });
    (0, import_obsidian3.setIcon)(this.cloneChatOption.createSpan({ cls: "menu-option-icon" }), "copy-plus");
    this.cloneChatOption.createSpan({ cls: "menu-option-text", text: "Clone Chat" });
    this.exportChatOption = this.menuDropdown.createEl("div", { cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_EXPORT_CHAT_OPTION}` });
    (0, import_obsidian3.setIcon)(this.exportChatOption.createSpan({ cls: "menu-option-icon" }), "download");
    this.exportChatOption.createSpan({ cls: "menu-option-text", text: "Export Chat to Note" });
    this.menuDropdown.createEl("hr", { cls: CSS_CLASS_MENU_SEPARATOR });
    this.clearChatOption = this.menuDropdown.createEl("div", { cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_CLEAR_CHAT_OPTION} ${CSS_CLASS_DANGER_OPTION}` });
    (0, import_obsidian3.setIcon)(this.clearChatOption.createSpan({ cls: "menu-option-icon" }), "trash");
    this.clearChatOption.createSpan({ cls: "menu-option-text", text: "Clear Messages" });
    this.deleteChatOption = this.menuDropdown.createEl("div", { cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_DELETE_CHAT_OPTION} ${CSS_CLASS_DANGER_OPTION}` });
    (0, import_obsidian3.setIcon)(this.deleteChatOption.createSpan({ cls: "menu-option-icon" }), "trash-2");
    this.deleteChatOption.createSpan({ cls: "menu-option-text", text: "Delete Chat" });
    this.menuDropdown.createEl("hr", { cls: CSS_CLASS_MENU_SEPARATOR });
    this.settingsOption = this.menuDropdown.createEl("div", { cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_SETTINGS_OPTION}` });
    (0, import_obsidian3.setIcon)(this.settingsOption.createSpan({ cls: "menu-option-icon" }), "settings");
    this.settingsOption.createSpan({ cls: "menu-option-text", text: "Settings" });
  }
  // --- Event Listeners (with Custom Div Menu) ---
  attachEventListeners() {
    if (!this.inputEl)
      console.error("inputEl missing!");
    if (!this.sendButton)
      console.error("sendButton missing!");
    if (!this.menuButton)
      console.error("menuButton missing!");
    if (!this.modelDisplayEl)
      console.error("modelDisplayEl missing!");
    if (!this.translateInputButton)
      console.error("translateInputButton missing!");
    if (this.inputEl) {
      this.inputEl.addEventListener("keydown", this.handleKeyDown);
      this.inputEl.addEventListener("input", this.handleInputForResize);
    }
    if (this.sendButton)
      this.sendButton.addEventListener("click", this.handleSendClick);
    if (this.voiceButton)
      this.voiceButton.addEventListener("click", this.handleVoiceClick);
    if (this.translateInputButton)
      this.translateInputButton.addEventListener("click", this.handleTranslateInputClick);
    if (this.menuButton)
      this.menuButton.addEventListener("click", this.handleMenuClick);
    if (this.modelDisplayEl)
      this.registerDomEvent(this.modelDisplayEl, "click", this.handleModelDisplayClick);
    if (this.roleDisplayEl) {
      this.registerDomEvent(this.roleDisplayEl, "click", this.handleRoleDisplayClick);
    } else {
      this.plugin.logger.error("roleDisplayEl missing!");
    }
    if (this.modelSubmenuHeader)
      this.registerDomEvent(this.modelSubmenuHeader, "click", () => this.toggleSubmenu(this.modelSubmenuHeader, this.modelSubmenuContent, "models"));
    else
      console.error("modelSubmenuHeader missing!");
    if (this.roleSubmenuHeader)
      this.registerDomEvent(this.roleSubmenuHeader, "click", () => this.toggleSubmenu(this.roleSubmenuHeader, this.roleSubmenuContent, "roles"));
    else
      console.error("roleSubmenuHeader missing!");
    if (this.chatSubmenuHeader)
      this.registerDomEvent(this.chatSubmenuHeader, "click", () => this.toggleSubmenu(this.chatSubmenuHeader, this.chatSubmenuContent, "chats"));
    else
      console.error("chatSubmenuHeader missing!");
    if (this.settingsOption)
      this.settingsOption.addEventListener("click", this.handleSettingsClick);
    else
      console.error("settingsOption missing!");
    if (this.clearChatOption)
      this.clearChatOption.addEventListener("click", this.handleClearChatClick);
    else
      console.error("clearChatOption missing!");
    if (this.exportChatOption)
      this.exportChatOption.addEventListener("click", this.handleExportChatClick);
    else
      console.error("exportChatOption missing!");
    if (this.newChatOption)
      this.newChatOption.addEventListener("click", this.handleNewChatClick);
    else
      console.error("newChatOption missing!");
    if (this.renameChatOption)
      this.renameChatOption.addEventListener("click", this.handleRenameChatClick);
    else
      console.error("renameChatOption missing!");
    if (this.cloneChatOption)
      this.cloneChatOption.addEventListener("click", this.handleCloneChatClick);
    else
      console.error("cloneChatOption missing!");
    if (this.deleteChatOption)
      this.deleteChatOption.addEventListener("click", this.handleDeleteChatClick);
    else
      console.error("deleteChatOption missing!");
    if (this.settingsOption)
      this.settingsOption.addEventListener("click", this.handleSettingsClick);
    else
      console.error("settingsOption missing!");
    if (this.clearChatOption)
      this.clearChatOption.addEventListener("click", this.handleClearChatClick);
    else
      console.error("clearChatOption missing!");
    if (this.exportChatOption)
      this.exportChatOption.addEventListener("click", this.handleExportChatClick);
    else
      console.error("exportChatOption missing!");
    if (this.newChatOption)
      this.newChatOption.addEventListener("click", this.handleNewChatClick);
    else
      console.error("newChatOption missing!");
    if (this.renameChatOption)
      this.renameChatOption.addEventListener("click", this.handleRenameChatClick);
    else
      console.error("renameChatOption missing!");
    if (this.cloneChatOption)
      this.cloneChatOption.addEventListener("click", this.handleCloneChatClick);
    else
      console.error("cloneChatOption missing!");
    if (this.deleteChatOption)
      this.deleteChatOption.addEventListener("click", this.handleDeleteChatClick);
    else
      console.error("deleteChatOption missing!");
    this.registerDomEvent(window, "resize", this.handleWindowResize);
    this.registerEvent(this.app.workspace.on("resize", this.handleWindowResize));
    this.registerDomEvent(document, "click", this.handleDocumentClickForMenu);
    this.registerDomEvent(document, "visibilitychange", this.handleVisibilityChange);
    this.registerEvent(this.app.workspace.on("active-leaf-change", this.handleActiveLeafChange));
    if (this.chatContainer) {
      this.registerDomEvent(this.chatContainer, "scroll", this.scrollListenerDebounced);
    } else {
      this.plugin.logger.error("chatContainer missing!");
    }
    if (this.newMessagesIndicatorEl) {
      this.registerDomEvent(this.newMessagesIndicatorEl, "click", this.handleNewMessageIndicatorClick);
    }
    this.register(this.plugin.on("model-changed", this.handleModelChange));
    this.register(this.plugin.on("role-changed", this.handleRoleChange));
    this.register(this.plugin.on("roles-updated", this.handleRolesUpdated));
    this.register(this.plugin.on("active-chat-changed", this.handleActiveChatChanged));
    this.register(this.plugin.on("message-added", this.handleMessageAdded));
    this.register(this.plugin.on("messages-cleared", this.handleMessagesCleared));
    this.register(this.plugin.on("chat-list-updated", this.handleChatListUpdated));
    this.register(this.plugin.on("settings-updated", this.handleSettingsUpdated));
  }
  updateModelDisplay(modelName) {
    if (this.modelDisplayEl) {
      this.plugin.logger.debug(`[OllamaView] updateModelDisplay called with: ${modelName}`);
      if (modelName) {
        const displayName = modelName;
        const shortName = displayName.replace(/:latest$/, "");
        this.modelDisplayEl.setText(shortName);
        this.modelDisplayEl.title = `Current model: ${displayName}. Click to change.`;
        this.modelDisplayEl.removeClass("model-not-available");
      } else {
        this.modelDisplayEl.setText("Not available");
        this.modelDisplayEl.title = "No Ollama models detected. Check Ollama connection and ensure models are installed.";
        this.modelDisplayEl.addClass("model-not-available");
      }
    } else {
      console.error("[OllamaView] modelDisplayEl is missing!");
    }
  }
  // Handles clicks on submenu headers (Model, Role, Chat)
  async toggleSubmenu(headerEl, contentEl, type) {
    if (!headerEl || !contentEl)
      return;
    const iconEl = headerEl.querySelector(`.${CSS_CLASS_SUBMENU_ICON}`);
    const isHidden = contentEl.style.maxHeight === "0px" || contentEl.classList.contains(CSS_CLASS_SUBMENU_CONTENT_HIDDEN);
    if (isHidden) {
      this.collapseAllSubmenus(contentEl);
    }
    if (isHidden) {
      if (iconEl instanceof HTMLElement)
        (0, import_obsidian3.setIcon)(iconEl, "chevron-down");
      contentEl.empty();
      contentEl.createDiv({ cls: "menu-loading", text: `Loading ${type}...` });
      contentEl.classList.remove(CSS_CLASS_SUBMENU_CONTENT_HIDDEN);
      contentEl.style.paddingTop = "5px";
      contentEl.style.paddingBottom = "5px";
      contentEl.style.maxHeight = "40px";
      try {
        switch (type) {
          case "models":
            await this.renderModelList();
            break;
          case "roles":
            await this.renderRoleList();
            break;
          case "chats":
            await this.renderChatListMenu();
            break;
        }
        requestAnimationFrame(() => {
          if (!contentEl.classList.contains(CSS_CLASS_SUBMENU_CONTENT_HIDDEN)) {
            contentEl.style.maxHeight = contentEl.scrollHeight + "px";
          }
        });
      } catch (error) {
        this.plugin.logger.error(`Error rendering ${type} list:`, error);
        contentEl.empty();
        contentEl.createDiv({ cls: "menu-error-text", text: `Error loading ${type}.` });
        contentEl.style.maxHeight = "50px";
      }
    } else {
      contentEl.classList.add(CSS_CLASS_SUBMENU_CONTENT_HIDDEN);
      contentEl.style.maxHeight = "0";
      contentEl.style.paddingTop = "0";
      contentEl.style.paddingBottom = "0";
      if (iconEl instanceof HTMLElement)
        (0, import_obsidian3.setIcon)(iconEl, "chevron-right");
    }
  }
  // Helper to collapse all submenus except the one potentially being opened
  collapseAllSubmenus(exceptContent) {
    const submenus = [
      { header: this.modelSubmenuHeader, content: this.modelSubmenuContent },
      { header: this.roleSubmenuHeader, content: this.roleSubmenuContent },
      { header: this.chatSubmenuHeader, content: this.chatSubmenuContent }
    ];
    submenus.forEach((submenu) => {
      if (submenu.content && submenu.header && submenu.content !== exceptContent) {
        if (!submenu.content.classList.contains(CSS_CLASS_SUBMENU_CONTENT_HIDDEN)) {
          submenu.content.classList.add(CSS_CLASS_SUBMENU_CONTENT_HIDDEN);
          submenu.content.style.maxHeight = "0";
          submenu.content.style.paddingTop = "0";
          submenu.content.style.paddingBottom = "0";
          const iconEl = submenu.header.querySelector(`.${CSS_CLASS_SUBMENU_ICON}`);
          if (iconEl instanceof HTMLElement) {
            (0, import_obsidian3.setIcon)(iconEl, "chevron-right");
          }
        }
      }
    });
  }
  // --- UI Update Methods ---
  updateInputPlaceholder(roleName) {
    if (this.inputEl) {
      const displayRole = roleName || "Assistant";
      this.inputEl.placeholder = `Message ${displayRole}...`;
    }
  }
  closeMenu() {
    if (this.menuDropdown) {
      this.menuDropdown.style.display = "none";
      this.collapseAllSubmenus(null);
    }
  }
  autoResizeTextarea() {
    this.adjustTextareaHeight();
  }
  updateRoleDisplay(roleName) {
    if (this.roleDisplayEl) {
      const displayName = roleName || "None";
      this.roleDisplayEl.setText(displayName);
      this.roleDisplayEl.title = `Current role: ${displayName}. Click to change.`;
    }
  }
  updateSendButtonState() {
    if (!this.inputEl || !this.sendButton)
      return;
    const isDisabled = this.inputEl.value.trim() === "" || this.isProcessing;
    this.sendButton.disabled = isDisabled;
    this.sendButton.classList.toggle(CSS_CLASS_DISABLED, isDisabled);
  }
  showEmptyState() {
    var _a, _b;
    if (this.currentMessages.length === 0 && !this.emptyStateEl && this.chatContainer) {
      this.chatContainer.empty();
      this.emptyStateEl = this.chatContainer.createDiv({ cls: CSS_CLASS_EMPTY_STATE });
      this.emptyStateEl.createDiv({ cls: "empty-state-message", text: "No messages yet" });
      const modelName = ((_b = (_a = this.plugin) == null ? void 0 : _a.settings) == null ? void 0 : _b.modelName) || "the AI";
      this.emptyStateEl.createDiv({ cls: "empty-state-tip", text: `Type a message or use the menu options to start interacting with ${modelName}.` });
    }
  }
  hideEmptyState() {
    if (this.emptyStateEl) {
      this.emptyStateEl.remove();
      this.emptyStateEl = null;
    }
  }
  setLoadingState(isLoading) {
    this.isProcessing = isLoading;
    if (this.inputEl)
      this.inputEl.disabled = isLoading;
    this.updateSendButtonState();
    if (this.voiceButton) {
      this.voiceButton.disabled = isLoading;
      this.voiceButton.classList.toggle(CSS_CLASS_DISABLED, isLoading);
    }
    if (this.translateInputButton) {
      this.translateInputButton.disabled = isLoading;
      this.translateInputButton.classList.toggle(CSS_CLASS_DISABLED, isLoading);
    }
    if (this.menuButton) {
      this.menuButton.disabled = isLoading;
      this.menuButton.classList.toggle(CSS_CLASS_DISABLED, isLoading);
    }
  }
  async loadAndDisplayActiveChat() {
    var _a, _b, _c;
    this.plugin.logger.debug("[OllamaView] loadAndDisplayActiveChat called");
    this.clearChatContainerInternal();
    this.currentMessages = [];
    this.lastRenderedMessageDate = null;
    let activeChat = null;
    let availableModels = [];
    let finalModelName = null;
    let errorOccurred = false;
    try {
      activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat()) || null;
      this.plugin.logger.debug(`[OllamaView] Active chat loaded: ${((_b = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _b.name) || "None"}`);
      availableModels = await this.plugin.ollamaService.getModels();
      this.plugin.logger.debug(`[OllamaView] Available models fetched: ${availableModels.join(", ")}`);
    } catch (error) {
      console.error("[OllamaView] Error fetching active chat or available models:", error);
      new import_obsidian3.Notice("Error connecting to Ollama or loading chat data. Please check connection and settings.", 5e3);
      this.showEmptyState();
      errorOccurred = true;
      finalModelName = null;
    }
    if (!errorOccurred) {
      let preferredModel = (_c = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _c.modelName;
      this.plugin.logger.debug(`[OllamaView] Model from active chat metadata: ${preferredModel}`);
      if (!preferredModel) {
        preferredModel = this.plugin.settings.modelName;
        this.plugin.logger.debug(`[OllamaView] No model in chat metadata, using settings model: ${preferredModel}`);
      } else {
        this.plugin.logger.debug(`[OllamaView] Using model from chat metadata: ${preferredModel}`);
      }
      if (availableModels.length > 0) {
        if (preferredModel && availableModels.includes(preferredModel)) {
          finalModelName = preferredModel;
          this.plugin.logger.debug(`[OllamaView] Preferred model "${finalModelName}" is available.`);
        } else {
          finalModelName = availableModels[0];
          if (preferredModel) {
            this.plugin.logger.warn(`[OllamaView] Preferred model "${preferredModel}" is not available. Falling back to first available: "${finalModelName}".`);
            new import_obsidian3.Notice(`Model "${preferredModel}" not found, using "${finalModelName}".`, 3e3);
          } else {
            this.plugin.logger.info(`[OllamaView] No preferred model specified or found. Using first available model: "${finalModelName}".`);
          }
        }
      } else {
        this.plugin.logger.warn("[OllamaView] No models available from Ollama service.");
        finalModelName = null;
      }
      if (activeChat && activeChat.metadata.modelName !== finalModelName) {
        this.plugin.logger.info(`[OllamaView] Model for active chat "${activeChat.metadata.name}" resolved to "${finalModelName}" (was "${activeChat.metadata.modelName}"). Updating metadata.`);
        try {
          if (finalModelName !== null) {
            await this.plugin.chatManager.updateActiveChatMetadata({ modelName: finalModelName });
            if (activeChat.metadata)
              activeChat.metadata.modelName = finalModelName;
          } else {
            this.plugin.logger.warn(`[OllamaView] No available models, not updating active chat metadata.`);
          }
        } catch (updateError) {
          console.error(`[OllamaView] Failed to update active chat model metadata:`, updateError);
        }
      }
    }
    const currentRoleName = await this.getCurrentRoleDisplayName();
    if (!errorOccurred && activeChat && activeChat.messages.length > 0) {
      this.hideEmptyState();
      this.renderMessages(activeChat.messages);
      this.checkAllMessagesForCollapsing();
      setTimeout(() => {
        this.guaranteedScrollToBottom(100, true);
      }, 150);
    } else if (!errorOccurred) {
      this.showEmptyState();
    }
    this.updateInputPlaceholder(currentRoleName);
    this.updateRoleDisplay(currentRoleName);
    this.updateModelDisplay(finalModelName);
    if (finalModelName === null) {
      if (this.inputEl) {
        this.inputEl.disabled = true;
        this.inputEl.placeholder = "No models available...";
      }
      if (this.sendButton)
        this.sendButton.disabled = true;
      this.setLoadingState(false);
    } else {
      if (this.inputEl) {
        this.inputEl.disabled = this.isProcessing;
      }
      this.updateSendButtonState();
    }
  }
  /** Renders a list of messages to the chat container */
  renderMessages(messagesToRender) {
    this.clearChatContainerInternal();
    this.currentMessages = [...messagesToRender];
    this.lastRenderedMessageDate = null;
    messagesToRender.forEach((message) => {
      this.renderMessageInternal(message, messagesToRender);
    });
  }
  /** Appends a single message to the display */
  addMessageToDisplay(role, content, timestamp) {
    if (!this.chatContainer)
      return;
    const newMessage = { role, content, timestamp };
    const currentContext = [...this.currentMessages];
    const messageEl = this.renderMessageInternal(newMessage, [...currentContext, newMessage]);
    this.currentMessages.push(newMessage);
    if (messageEl) {
      this.checkMessageForCollapsing(messageEl);
    }
    const isUserOrError = role === "user" || role === "error";
    if (!isUserOrError && this.userScrolledUp && this.newMessagesIndicatorEl) {
      this.newMessagesIndicatorEl.classList.add(CSS_CLASS_VISIBLE);
    } else if (!this.userScrolledUp) {
      const forceScroll = !isUserOrError;
      this.guaranteedScrollToBottom(forceScroll ? 100 : 50, forceScroll);
    }
    this.hideEmptyState();
  }
  /** Sends the user's input as a message and gets a response */
  async sendMessage() {
    var _a;
    const content = this.inputEl.value.trim();
    if (!content || this.isProcessing || this.sendButton.disabled)
      return;
    const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
    if (!activeChat) {
      new import_obsidian3.Notice("Error: No active chat session found.");
      return;
    }
    const userMessageContent = this.inputEl.value;
    this.clearInputField();
    this.setLoadingState(true);
    this.hideEmptyState();
    let loadingEl = null;
    try {
      const userMessage = await this.plugin.chatManager.addMessageToActiveChat("user", userMessageContent);
      if (!userMessage)
        throw new Error("Failed to add user message to history.");
      loadingEl = this.addLoadingIndicator();
      this.guaranteedScrollToBottom(50, true);
      const assistantMessage = await this.plugin.ollamaService.generateChatResponse(activeChat);
      if (loadingEl) {
        this.removeLoadingIndicator(loadingEl);
        loadingEl = null;
      }
      if (assistantMessage) {
        await this.plugin.chatManager.addMessageToActiveChat(assistantMessage.role, assistantMessage.content);
      } else {
        this.addMessageToDisplay("error", "Assistant did not provide a response.", new Date());
      }
    } catch (error) {
      if (loadingEl) {
        this.removeLoadingIndicator(loadingEl);
        loadingEl = null;
      }
      this.addMessageToDisplay("error", `Error: ${error.message || "Unknown error."}`, new Date());
    } finally {
      if (loadingEl) {
        this.removeLoadingIndicator(loadingEl);
      }
      this.setLoadingState(false);
      this.focusInput();
    }
  }
  // --- Core Rendering Logic ---
  /** Renders a single message bubble based on the message object and context */
  renderMessageInternal(message, messageContext) {
    const messageIndex = messageContext.findIndex((m) => m === message);
    if (messageIndex === -1)
      return null;
    const prevMessage = messageIndex > 0 ? messageContext[messageIndex - 1] : null;
    const isNewDay = !this.lastRenderedMessageDate || !this.isSameDay(this.lastRenderedMessageDate, message.timestamp);
    if (isNewDay) {
      this.renderDateSeparator(message.timestamp);
      this.lastRenderedMessageDate = message.timestamp;
    } else if (messageIndex === 0 && !this.lastRenderedMessageDate) {
      this.lastRenderedMessageDate = message.timestamp;
    }
    let messageGroup = null;
    let groupClass = CSS_CLASS_MESSAGE_GROUP;
    let messageClass = `${CSS_CLASS_MESSAGE} ${CSS_CLASS_MESSAGE_ARRIVING}`;
    let showAvatar = true;
    let isUser = false;
    const isFirstInGroup = !prevMessage || prevMessage.role !== message.role || isNewDay;
    switch (message.role) {
      case "user":
        groupClass += ` ${CSS_CLASS_USER_GROUP}`;
        messageClass += ` ${CSS_CLASS_USER_MESSAGE}`;
        isUser = true;
        break;
      case "assistant":
        groupClass += ` ${CSS_CLASS_OLLAMA_GROUP}`;
        messageClass += ` ${CSS_CLASS_OLLAMA_MESSAGE}`;
        break;
      case "system":
        groupClass += ` ${CSS_CLASS_SYSTEM_GROUP}`;
        messageClass += ` ${CSS_CLASS_SYSTEM_MESSAGE}`;
        showAvatar = false;
        break;
      case "error":
        groupClass += ` ${CSS_CLASS_ERROR_GROUP}`;
        messageClass += ` ${CSS_CLASS_ERROR_MESSAGE}`;
        showAvatar = false;
        break;
    }
    const lastElement = this.chatContainer.lastElementChild;
    if (isFirstInGroup || !lastElement || !lastElement.matches(`.${groupClass.split(" ")[1]}`)) {
      messageGroup = this.chatContainer.createDiv({ cls: groupClass });
      if (showAvatar)
        this.renderAvatar(messageGroup, isUser);
    } else {
      messageGroup = lastElement;
    }
    let messageWrapper = messageGroup.querySelector(".message-wrapper");
    if (!messageWrapper) {
      messageWrapper = messageGroup.createDiv({ cls: "message-wrapper" });
      if (messageGroup.classList.contains(CSS_CLASS_USER_GROUP)) {
        messageWrapper.style.order = "1";
      } else {
        messageWrapper.style.order = "2";
      }
    }
    const messageEl = messageWrapper.createDiv({ cls: messageClass });
    const contentContainer = messageEl.createDiv({ cls: CSS_CLASS_CONTENT_CONTAINER });
    const contentEl = contentContainer.createDiv({ cls: CSS_CLASS_CONTENT });
    switch (message.role) {
      case "assistant":
      case "user":
        contentEl.addClass(CSS_CLASS_CONTENT_COLLAPSIBLE);
        if (message.role === "assistant") {
          this.renderAssistantContent(contentEl, message.content);
        } else {
          message.content.split("\n").forEach((line, i, arr) => {
            contentEl.appendText(line);
            if (i < arr.length - 1)
              contentEl.createEl("br");
          });
        }
        break;
      case "system":
        (0, import_obsidian3.setIcon)(contentEl.createSpan({ cls: CSS_CLASS_SYSTEM_ICON }), "info");
        contentEl.createSpan({ cls: CSS_CLASS_SYSTEM_TEXT, text: message.content });
        break;
      case "error":
        (0, import_obsidian3.setIcon)(contentEl.createSpan({ cls: CSS_CLASS_ERROR_ICON }), "alert-triangle");
        contentEl.createSpan({ cls: CSS_CLASS_ERROR_TEXT, text: message.content });
        break;
    }
    const buttonsWrapper = contentContainer.createDiv({ cls: "message-actions-wrapper" });
    if (message.role !== "system" && message.role !== "error") {
      const copyBtn = buttonsWrapper.createEl("button", { cls: CSS_CLASS_COPY_BUTTON, attr: { title: "Copy", "aria-label": "Copy message content" } });
      (0, import_obsidian3.setIcon)(copyBtn, "copy");
      this.registerDomEvent(copyBtn, "click", (e) => {
        e.stopPropagation();
        this.handleCopyClick(message.content, copyBtn);
      });
    }
    if (this.plugin.settings.enableTranslation && this.plugin.settings.translationTargetLanguage && (message.role === "user" || message.role === "assistant")) {
      const targetLangName = LANGUAGES[this.plugin.settings.translationTargetLanguage] || this.plugin.settings.translationTargetLanguage;
      const translateBtn = buttonsWrapper.createEl("button", { cls: CSS_CLASS_TRANSLATE_BUTTON, attr: { title: `Translate to ${targetLangName}`, "aria-label": "Translate message" } });
      (0, import_obsidian3.setIcon)(translateBtn, "languages");
      this.registerDomEvent(translateBtn, "click", (e) => {
        e.stopPropagation();
        this.handleTranslateClick(message.content, contentEl, translateBtn);
      });
    }
    messageEl.createDiv({ cls: CSS_CLASS_TIMESTAMP, text: this.formatTime(message.timestamp) });
    setTimeout(() => messageEl.classList.remove(CSS_CLASS_MESSAGE_ARRIVING), 500);
    return messageEl;
  }
  // --- Action Button Handlers ---
  handleCopyClick(content, buttonEl) {
    let textToCopy = content;
    if (this.detectThinkingTags(this.decodeHtmlEntities(content)).hasThinkingTags) {
      textToCopy = this.decodeHtmlEntities(content).replace(/<think>[\s\S]*?<\/think>/g, "").trim();
    }
    navigator.clipboard.writeText(textToCopy).then(() => {
      (0, import_obsidian3.setIcon)(buttonEl, "check");
      buttonEl.setAttribute("title", "Copied!");
      setTimeout(() => {
        (0, import_obsidian3.setIcon)(buttonEl, "copy");
        buttonEl.setAttribute("title", "Copy");
      }, 2e3);
    }).catch((err) => {
    });
  }
  async handleTranslateClick(originalContent, contentEl, buttonEl) {
    var _a, _b, _c;
    const targetLang = this.plugin.settings.translationTargetLanguage;
    const apiKey = this.plugin.settings.googleTranslationApiKey;
    if (!targetLang || !apiKey) {
      new import_obsidian3.Notice("Translation not configured. Please check language and API key in settings.");
      return;
    }
    let textToTranslate = originalContent;
    if (this.detectThinkingTags(this.decodeHtmlEntities(originalContent)).hasThinkingTags) {
      textToTranslate = this.decodeHtmlEntities(originalContent).replace(/<think>[\s\S]*?<\/think>/g, "").trim();
    }
    if (!textToTranslate)
      return;
    (_a = contentEl.querySelector(`.${CSS_CLASS_TRANSLATION_CONTAINER}`)) == null ? void 0 : _a.remove();
    (0, import_obsidian3.setIcon)(buttonEl, "loader");
    buttonEl.disabled = true;
    buttonEl.classList.add(CSS_CLASS_TRANSLATION_PENDING);
    buttonEl.setAttribute("title", "Translating...");
    try {
      const translatedText = await this.plugin.translationService.translate(textToTranslate, targetLang);
      if (translatedText !== null) {
        const translationContainer = contentEl.createDiv({ cls: CSS_CLASS_TRANSLATION_CONTAINER });
        const translationContentEl = translationContainer.createDiv({ cls: CSS_CLASS_TRANSLATION_CONTENT });
        await import_obsidian3.MarkdownRenderer.renderMarkdown(
          translatedText,
          translationContentEl,
          (_c = (_b = this.plugin.app.vault.getRoot()) == null ? void 0 : _b.path) != null ? _c : "",
          // Шлях контексту (корінь сховища)
          this
          // Компонент (View)
        );
        const targetLangName = LANGUAGES[targetLang] || targetLang;
        translationContainer.createEl("div", { cls: "translation-indicator", text: `[Translated to ${targetLangName}]` });
        this.guaranteedScrollToBottom(50, false);
      }
    } catch (error) {
      new import_obsidian3.Notice("An unexpected error occurred during translation.");
    } finally {
      (0, import_obsidian3.setIcon)(buttonEl, "languages");
      buttonEl.disabled = false;
      buttonEl.classList.remove(CSS_CLASS_TRANSLATION_PENDING);
      const targetLangName = LANGUAGES[targetLang] || targetLang;
      buttonEl.setAttribute("title", `Translate to ${targetLangName}`);
    }
  }
  // --- Rendering Helpers ---
  renderAvatar(groupEl, isUser) {
    const settings = this.plugin.settings;
    const avatarType = isUser ? settings.userAvatarType : settings.aiAvatarType;
    const avatarContent = isUser ? settings.userAvatarContent : settings.aiAvatarContent;
    const avatarClass = isUser ? CSS_CLASS_AVATAR_USER : CSS_CLASS_AVATAR_AI;
    const avatarEl = groupEl.createDiv({ cls: `${CSS_CLASS_AVATAR} ${avatarClass}` });
    if (avatarType === "initials") {
      avatarEl.textContent = avatarContent || (isUser ? "U" : "A");
    } else if (avatarType === "icon") {
      try {
        (0, import_obsidian3.setIcon)(avatarEl, avatarContent || (isUser ? "user" : "bot"));
      } catch (e) {
        avatarEl.textContent = isUser ? "U" : "A";
      }
    } else {
      avatarEl.textContent = isUser ? "U" : "A";
    }
  }
  renderDateSeparator(date) {
    if (!this.chatContainer)
      return;
    this.chatContainer.createDiv({ cls: CSS_CLASS_DATE_SEPARATOR, text: this.formatDateSeparator(date) });
  }
  renderAssistantContent(containerEl, content) {
    var _a, _b;
    const decodedContent = this.decodeHtmlEntities(content);
    const thinkingInfo = this.detectThinkingTags(decodedContent);
    containerEl.empty();
    if (thinkingInfo.hasThinkingTags) {
      const processedHtml = this.processThinkingTags(decodedContent);
      containerEl.innerHTML = processedHtml;
      this.addThinkingToggleListeners(containerEl);
      this.addCodeBlockEnhancements(containerEl);
    } else {
      import_obsidian3.MarkdownRenderer.renderMarkdown(
        decodedContent,
        // Use decoded content for rendering
        containerEl,
        (_b = (_a = this.app.vault.getRoot()) == null ? void 0 : _a.path) != null ? _b : "",
        // Source path context
        this
        // Component context for links etc.
      );
      this.addCodeBlockEnhancements(containerEl);
    }
  }
  addCodeBlockEnhancements(contentEl) {
    contentEl.querySelectorAll("pre").forEach((pre) => {
      if (pre.querySelector(`.${CSS_CLASS_CODE_BLOCK_COPY_BUTTON}`))
        return;
      const code = pre.querySelector("code");
      if (!code)
        return;
      const codeText = code.textContent || "";
      const langClass = Array.from(code.classList).find((cls) => cls.startsWith("language-"));
      if (langClass) {
        const lang = langClass.replace("language-", "");
        if (lang) {
          if (!pre.querySelector(`.${CSS_CLASS_CODE_BLOCK_LANGUAGE}`)) {
            pre.createEl("span", { cls: CSS_CLASS_CODE_BLOCK_LANGUAGE, text: lang });
          }
        }
      }
      const copyBtn = pre.createEl("button", { cls: CSS_CLASS_CODE_BLOCK_COPY_BUTTON });
      (0, import_obsidian3.setIcon)(copyBtn, "copy");
      copyBtn.setAttribute("title", "Copy Code");
      copyBtn.setAttribute("aria-label", "Copy code block");
      this.registerDomEvent(copyBtn, "click", (e) => {
        e.stopPropagation();
        navigator.clipboard.writeText(codeText).then(() => {
          (0, import_obsidian3.setIcon)(copyBtn, "check");
          copyBtn.setAttribute("title", "Copied!");
          setTimeout(() => {
            (0, import_obsidian3.setIcon)(copyBtn, "copy");
            copyBtn.setAttribute("title", "Copy Code");
          }, 1500);
        }).catch((err) => {
          new import_obsidian3.Notice("Failed to copy code.");
        });
      });
    });
  }
  // --- Menu List Rendering (Accordion Style) ---
  async renderModelList() {
    var _a, _b;
    const container = this.modelSubmenuContent;
    if (!container)
      return;
    container.empty();
    const modelIconMap = {
      "llama": "box-minimal",
      "mistral": "wind"
      /*...*/
    };
    const defaultIcon = "box";
    try {
      const models = await this.plugin.ollamaService.getModels();
      const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
      const currentModelName = ((_b = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _b.modelName) || this.plugin.settings.modelName;
      if (models.length === 0) {
        container.createEl("div", { cls: "menu-info-text", text: "No models." });
        return;
      }
      models.forEach((modelName) => {
        const optionEl = container.createDiv({ cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_MODEL_OPTION}` });
        const iconSpan = optionEl.createEl("span", { cls: "menu-option-icon" });
        let iconToUse = defaultIcon;
        if (modelName === currentModelName) {
          iconToUse = "check";
          optionEl.addClass("is-selected");
        } else {
          const l = modelName.toLowerCase();
          let f = false;
          for (const k in modelIconMap) {
            if (l.includes(k)) {
              iconToUse = modelIconMap[k];
              f = true;
              break;
            }
          }
          if (!f)
            iconToUse = defaultIcon;
        }
        try {
          (0, import_obsidian3.setIcon)(iconSpan, iconToUse);
        } catch (e) {
          iconSpan.style.minWidth = "18px";
        }
        optionEl.createEl("span", { cls: "menu-option-text", text: modelName });
        this.registerDomEvent(optionEl, "click", async () => {
          var _a2;
          if (modelName !== currentModelName) {
            const chat = await ((_a2 = this.plugin.chatManager) == null ? void 0 : _a2.getActiveChat());
            if (chat)
              await this.plugin.chatManager.updateActiveChatMetadata({ modelName });
            else
              new import_obsidian3.Notice("No active chat.");
          }
          this.closeMenu();
        });
      });
      this.updateSubmenuHeight(container);
    } catch (error) {
      container.empty();
      container.createEl("div", { cls: "menu-error-text", text: "Error models." });
      this.updateSubmenuHeight(container);
    }
  }
  async renderRoleList() {
    var _a, _b, _c;
    const container = this.roleSubmenuContent;
    if (!container)
      return;
    container.empty();
    try {
      const roles = await this.plugin.listRoleFiles(true);
      const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
      const currentChatRolePath = (_c = (_b = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _b.selectedRolePath) != null ? _c : this.plugin.settings.selectedRolePath;
      const noRoleOptionEl = container.createDiv({ cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_ROLE_OPTION}` });
      const noRoleIconSpan = noRoleOptionEl.createEl("span", { cls: "menu-option-icon" });
      if (!currentChatRolePath) {
        (0, import_obsidian3.setIcon)(noRoleIconSpan, "check");
        noRoleOptionEl.addClass("is-selected");
      } else {
        (0, import_obsidian3.setIcon)(noRoleIconSpan, "slash");
        noRoleIconSpan.style.minWidth = "18px";
      }
      noRoleOptionEl.createEl("span", {
        cls: "menu-option-text",
        text: "None"
      });
      this.registerDomEvent(noRoleOptionEl, "click", async () => {
        var _a2, _b2, _c2;
        const nrp = "";
        if (this.plugin.settings.selectedRolePath !== nrp || currentChatRolePath !== nrp) {
          this.plugin.settings.selectedRolePath = nrp;
          await this.plugin.saveSettings();
          const chat = await ((_a2 = this.plugin.chatManager) == null ? void 0 : _a2.getActiveChat());
          if (chat && chat.metadata.selectedRolePath !== nrp) {
            await this.plugin.chatManager.updateActiveChatMetadata({ selectedRolePath: nrp });
            (_c2 = (_b2 = this.plugin.promptService) == null ? void 0 : _b2.clearRoleCache) == null ? void 0 : _c2.call(_b2);
          }
          this.plugin.emit("role-changed", "None");
        }
        this.closeMenu();
      });
      if (roles.length > 0)
        container.createEl("hr", { cls: CSS_CLASS_MENU_SEPARATOR });
      roles.forEach((roleInfo) => {
        const roleOptionEl = container.createDiv({ cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_ROLE_OPTION}` });
        if (roleInfo.isCustom)
          roleOptionEl.addClass("is-custom");
        const iconSpan = roleOptionEl.createEl("span", { cls: "menu-option-icon" });
        if (roleInfo.path === currentChatRolePath) {
          (0, import_obsidian3.setIcon)(iconSpan, "check");
          roleOptionEl.addClass("is-selected");
        } else {
          (0, import_obsidian3.setIcon)(iconSpan, roleInfo.isCustom ? "user" : "box");
          iconSpan.style.minWidth = "18px";
        }
        roleOptionEl.createEl("span", { cls: "menu-option-text", text: roleInfo.name });
        this.registerDomEvent(roleOptionEl, "click", async () => {
          var _a2, _b2, _c2;
          const nrp = roleInfo.path;
          if (this.plugin.settings.selectedRolePath !== nrp || currentChatRolePath !== nrp) {
            this.plugin.settings.selectedRolePath = nrp;
            await this.plugin.saveSettings();
            const chat = await ((_a2 = this.plugin.chatManager) == null ? void 0 : _a2.getActiveChat());
            if (chat && chat.metadata.selectedRolePath !== nrp) {
              await this.plugin.chatManager.updateActiveChatMetadata({ selectedRolePath: nrp });
              (_c2 = (_b2 = this.plugin.promptService) == null ? void 0 : _b2.clearRoleCache) == null ? void 0 : _c2.call(_b2);
            }
            this.plugin.emit("role-changed", roleInfo.name);
          }
          this.closeMenu();
        });
      });
      this.updateSubmenuHeight(container);
    } catch (error) {
      container.empty();
      container.createEl("div", { cls: "menu-error-text", text: "Error roles." });
      this.updateSubmenuHeight(container);
    }
  }
  async renderChatListMenu() {
    var _a, _b;
    const container = this.chatSubmenuContent;
    if (!container)
      return;
    container.empty();
    try {
      const chats = ((_a = this.plugin.chatManager) == null ? void 0 : _a.listAvailableChats()) || [];
      const currentActiveId = (_b = this.plugin.chatManager) == null ? void 0 : _b.getActiveChatId();
      if (chats.length === 0) {
        container.createEl("div", { cls: "menu-info-text", text: "No saved chats." });
        return;
      }
      chats.forEach((chatMeta) => {
        const chatOptionEl = container.createDiv({ cls: `${CSS_CLASS_MENU_OPTION} ${CSS_CLASS_CHAT_OPTION}` });
        const iconSpan = chatOptionEl.createEl("span", { cls: "menu-option-icon" });
        if (chatMeta.id === currentActiveId) {
          (0, import_obsidian3.setIcon)(iconSpan, "check");
          chatOptionEl.addClass("is-selected");
        } else {
          (0, import_obsidian3.setIcon)(iconSpan, "message-square");
        }
        const textSpan = chatOptionEl.createEl("span", { cls: "menu-option-text" });
        textSpan.createEl("div", { cls: "chat-option-name", text: chatMeta.name });
        const dateText = this.formatRelativeDate(new Date(chatMeta.lastModified));
        textSpan.createEl("div", { cls: "chat-option-date", text: dateText });
        this.registerDomEvent(chatOptionEl, "click", async () => {
          var _a2;
          if (chatMeta.id !== ((_a2 = this.plugin.chatManager) == null ? void 0 : _a2.getActiveChatId())) {
            await this.plugin.chatManager.setActiveChat(chatMeta.id);
          }
          this.closeMenu();
        });
      });
      this.updateSubmenuHeight(container);
    } catch (error) {
      container.empty();
      container.createEl("div", { cls: "menu-error-text", text: "Error chats." });
      this.updateSubmenuHeight(container);
    }
  }
  updateSubmenuHeight(contentEl) {
    if (contentEl && !contentEl.classList.contains(CSS_CLASS_SUBMENU_CONTENT_HIDDEN)) {
      requestAnimationFrame(() => {
        contentEl.style.maxHeight = contentEl.scrollHeight + "px";
      });
    }
  }
  // --- Speech Recognition Methods ---
  // --- Speech Recognition Placeholders ---
  initSpeechWorker() {
    try {
      const bufferToBase64 = (buffer) => {
        let binary = "";
        const bytes = new Uint8Array(buffer);
        const len = bytes.byteLength;
        for (let i = 0; i < len; i++) {
          binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
      };
      const workerCode = `
             // Worker Scope
             self.onmessage = async (event) => {
                 const { apiKey, audioBlob, languageCode = 'uk-UA' } = event.data;

                 if (!apiKey || apiKey.trim() === '') {
                     self.postMessage({ error: true, message: 'Google API Key is not configured. Please add it in plugin settings.' });
                     return;
                 }

                 const url = "https://speech.googleapis.com/v1/speech:recognize?key=" + apiKey;

                 try {
                     const arrayBuffer = await audioBlob.arrayBuffer();

                     // Optimized Base64 Conversion (using helper if needed, or direct if worker supports TextDecoder efficiently)
                     // Simpler approach: pass buffer directly if API allows, or use efficient base64:
                     let base64Audio;
                     if (typeof TextDecoder !== 'undefined') { // Browser environment check
                             // Modern approach (often faster if native)
                             const base64String = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
                             base64Audio = base64String;

                     } else {
                             // Fallback (similar to original, ensure correctness)
                             base64Audio = btoa(
                                 new Uint8Array(arrayBuffer).reduce((data, byte) => data + String.fromCharCode(byte), '')
                             );
                     }


                     const response = await fetch(url, {
                         method: 'POST',
                         body: JSON.stringify({
                             config: {
                                 encoding: 'WEBM_OPUS', // Ensure this matches MediaRecorder output
                                 sampleRateHertz: 48000, // Match sample rate if possible
                                 languageCode: languageCode,
                                 model: 'latest_long', // Consider other models if needed
                                 enableAutomaticPunctuation: true,
                             },
                             audio: { content: base64Audio },
                         }),
                         headers: { 'Content-Type': 'application/json' },
                     });

                     const responseData = await response.json();

                     if (!response.ok) {
                         //console.error("Google Speech API Error:", responseData);
                         self.postMessage({
                             error: true,
                             message: "Error from Google Speech API: " + (responseData.error?.message || response.statusText || 'Unknown error')
                         });
                         return;
                     }

                     if (responseData.results && responseData.results.length > 0) {
                         const transcript = responseData.results
                             .map(result => result.alternatives[0].transcript)
                             .join(' ')
                             .trim();
                         self.postMessage(transcript); // Send back only the transcript string
                     } else {
                         // Handle cases where API returns ok but no results (e.g., silence)
                         self.postMessage({ error: true, message: 'No speech detected or recognized.' });
                     }
                 } catch (error) {
                     //console.error("Error in speech worker processing:", error);
                     self.postMessage({
                         error: true,
                         message: 'Error processing speech recognition: ' + (error instanceof Error ? error.message : String(error))
                     });
                 }
             };
           `;
      const workerBlob = new Blob([workerCode], { type: "application/javascript" });
      const workerUrl = URL.createObjectURL(workerBlob);
      this.speechWorker = new Worker(workerUrl);
      URL.revokeObjectURL(workerUrl);
      this.setupSpeechWorkerHandlers();
    } catch (error) {
      new import_obsidian3.Notice("Speech recognition feature failed to initialize.");
      this.speechWorker = null;
    }
  }
  setupSpeechWorkerHandlers() {
    if (!this.speechWorker)
      return;
    this.speechWorker.onmessage = (event) => {
      const data = event.data;
      if (data && typeof data === "object" && data.error) {
        new import_obsidian3.Notice(`Speech Recognition Error: ${data.message}`);
        this.updateInputPlaceholder(this.plugin.settings.modelName);
        this.updateSendButtonState();
        return;
      }
      if (typeof data === "string" && data.trim()) {
        const transcript = data.trim();
        this.insertTranscript(transcript);
      } else if (typeof data !== "string") {
      }
      this.updateSendButtonState();
    };
    this.speechWorker.onerror = (error) => {
      new import_obsidian3.Notice("An unexpected error occurred in the speech recognition worker.");
      this.updateInputPlaceholder(this.plugin.settings.modelName);
      this.stopVoiceRecording(false);
    };
  }
  insertTranscript(transcript) {
    var _a, _b;
    if (!this.inputEl)
      return;
    const currentVal = this.inputEl.value;
    const start = (_a = this.inputEl.selectionStart) != null ? _a : currentVal.length;
    const end = (_b = this.inputEl.selectionEnd) != null ? _b : currentVal.length;
    let textToInsert = transcript;
    const precedingChar = start > 0 ? currentVal[start - 1] : null;
    const followingChar = end < currentVal.length ? currentVal[end] : null;
    if (precedingChar && precedingChar !== " " && precedingChar !== "\n") {
      textToInsert = " " + textToInsert;
    }
    if (followingChar && followingChar !== " " && followingChar !== "\n" && !textToInsert.endsWith(" ")) {
      textToInsert += " ";
    }
    const newValue = currentVal.substring(0, start) + textToInsert + currentVal.substring(end);
    this.inputEl.value = newValue;
    const newCursorPos = start + textToInsert.length;
    this.inputEl.setSelectionRange(newCursorPos, newCursorPos);
    this.inputEl.focus();
    this.inputEl.dispatchEvent(new Event("input"));
  }
  async toggleVoiceRecognition() {
    if (this.mediaRecorder && this.mediaRecorder.state === "recording") {
      this.stopVoiceRecording(true);
    } else {
      await this.startVoiceRecognition();
    }
  }
  async startVoiceRecognition() {
    var _a;
    if (!this.speechWorker) {
      new import_obsidian3.Notice("\u0424\u0443\u043D\u043A\u0446\u0456\u044F \u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u0432\u0430\u043D\u043D\u044F \u043C\u043E\u0432\u043B\u0435\u043D\u043D\u044F \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u0430 (worker \u043D\u0435 \u0456\u043D\u0456\u0446\u0456\u0430\u043B\u0456\u0437\u043E\u0432\u0430\u043D\u043E).");
      return;
    }
    const speechApiKey = this.plugin.settings.googleApiKey;
    if (!speechApiKey) {
      new import_obsidian3.Notice("\u041A\u043B\u044E\u0447 Google API \u0434\u043B\u044F \u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u0432\u0430\u043D\u043D\u044F \u043C\u043E\u0432\u043B\u0435\u043D\u043D\u044F \u043D\u0435 \u043D\u0430\u043B\u0430\u0448\u0442\u043E\u0432\u0430\u043D\u043E. \u0411\u0443\u0434\u044C \u043B\u0430\u0441\u043A\u0430, \u0434\u043E\u0434\u0430\u0439\u0442\u0435 \u0439\u043E\u0433\u043E \u0432 \u043D\u0430\u043B\u0430\u0448\u0442\u0443\u0432\u0430\u043D\u043D\u044F\u0445 \u043F\u043B\u0430\u0433\u0456\u043D\u0430.");
      return;
    }
    try {
      this.audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      let recorderOptions;
      const preferredMimeType = "audio/webm;codecs=opus";
      if (MediaRecorder.isTypeSupported(preferredMimeType)) {
        recorderOptions = { mimeType: preferredMimeType };
      } else {
        recorderOptions = void 0;
      }
      this.mediaRecorder = new MediaRecorder(this.audioStream, recorderOptions);
      const audioChunks = [];
      (_a = this.voiceButton) == null ? void 0 : _a.classList.add(CSS_CLASS_RECORDING);
      (0, import_obsidian3.setIcon)(this.voiceButton, "stop-circle");
      this.inputEl.placeholder = "Recording... Speak now.";
      this.mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          audioChunks.push(event.data);
        }
      };
      this.mediaRecorder.onstop = () => {
        var _a2;
        if (this.speechWorker && audioChunks.length > 0) {
          const audioBlob = new Blob(audioChunks, { type: ((_a2 = this.mediaRecorder) == null ? void 0 : _a2.mimeType) || "audio/webm" });
          this.inputEl.placeholder = "Processing speech...";
          this.speechWorker.postMessage({
            apiKey: speechApiKey,
            // Використовуємо правильний ключ
            audioBlob,
            languageCode: this.plugin.settings.speechLanguage || "uk-UA"
          });
        } else if (audioChunks.length === 0) {
          this.getCurrentRoleDisplayName().then((roleName) => this.updateInputPlaceholder(roleName));
          this.updateSendButtonState();
        }
      };
      this.mediaRecorder.onerror = (event) => {
        new import_obsidian3.Notice("An error occurred during recording.");
        this.stopVoiceRecording(false);
      };
      this.mediaRecorder.start();
    } catch (error) {
      if (error instanceof DOMException && error.name === "NotAllowedError") {
        new import_obsidian3.Notice("Microphone access denied. Please grant permission.");
      } else if (error instanceof DOMException && error.name === "NotFoundError") {
        new import_obsidian3.Notice("Microphone not found. Please ensure it's connected and enabled.");
      } else {
        new import_obsidian3.Notice("Could not start voice recording.");
      }
      this.stopVoiceRecording(false);
    }
  }
  stopVoiceRecording(processAudio) {
    var _a, _b;
    if (this.mediaRecorder && this.mediaRecorder.state === "recording") {
      this.mediaRecorder.stop();
    } else if (!processAudio && ((_a = this.mediaRecorder) == null ? void 0 : _a.state) === "inactive") {
    }
    (_b = this.voiceButton) == null ? void 0 : _b.classList.remove(CSS_CLASS_RECORDING);
    (0, import_obsidian3.setIcon)(this.voiceButton, "mic");
    this.getCurrentRoleDisplayName().then((roleName) => this.updateInputPlaceholder(roleName));
    this.updateSendButtonState();
    if (this.audioStream) {
      this.audioStream.getTracks().forEach((track) => track.stop());
      this.audioStream = null;
    }
    this.mediaRecorder = null;
  }
  // --- Thinking Tag Handling ---
  processThinkingTags(content) {
    const r = /<think>([\s\S]*?)<\/think>/g;
    let i = 0;
    const p = [];
    let m;
    while ((m = r.exec(content)) !== null) {
      if (m.index > i)
        p.push(this.markdownToHtml(content.substring(i, m.index)));
      const c = m[1];
      const h = `<div class="${CSS_CLASS_THINKING_BLOCK}"><div class="${CSS_CLASS_THINKING_HEADER}" data-fold-state="folded"><div class="${CSS_CLASS_THINKING_TOGGLE}">\u25BA</div><div class="${CSS_CLASS_THINKING_TITLE}">Thinking</div></div><div class="${CSS_CLASS_THINKING_CONTENT}" style="display: none;">${this.markdownToHtml(c)}</div></div>`;
      p.push(h);
      i = r.lastIndex;
    }
    if (i < content.length)
      p.push(this.markdownToHtml(content.substring(i)));
    return p.join("");
  }
  markdownToHtml(markdown) {
    var _a, _b;
    if (!(markdown == null ? void 0 : markdown.trim()))
      return "";
    const d = document.createElement("div");
    import_obsidian3.MarkdownRenderer.renderMarkdown(markdown, d, (_b = (_a = this.app.workspace.getActiveFile()) == null ? void 0 : _a.path) != null ? _b : "", this);
    return d.innerHTML;
  }
  addThinkingToggleListeners(contentEl) {
    const h = contentEl.querySelectorAll(`.${CSS_CLASS_THINKING_HEADER}`);
    h.forEach((hdr) => {
      this.registerDomEvent(hdr, "click", () => {
        const c = hdr.nextElementSibling;
        const t = hdr.querySelector(`.${CSS_CLASS_THINKING_TOGGLE}`);
        if (!c || !t)
          return;
        const f = hdr.getAttribute("data-fold-state") === "folded";
        if (f) {
          c.style.display = "block";
          t.textContent = "\u25BC";
          hdr.setAttribute("data-fold-state", "expanded");
        } else {
          c.style.display = "none";
          t.textContent = "\u25BA";
          hdr.setAttribute("data-fold-state", "folded");
        }
      });
    });
  }
  decodeHtmlEntities(text) {
    if (typeof document === "undefined") {
      return text.replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&#39;/g, "'");
    }
    const ta = document.createElement("textarea");
    ta.innerHTML = text;
    return ta.value;
  }
  detectThinkingTags(content) {
    return /<think>[\s\S]*?<\/think>/gi.test(content) ? { hasThinkingTags: true, format: "standard" } : { hasThinkingTags: false, format: "none" };
  }
  // --- Message Collapsing ---
  checkMessageForCollapsing(messageEl) {
    const c = messageEl.querySelector(`.${CSS_CLASS_CONTENT_COLLAPSIBLE}`);
    const h = this.plugin.settings.maxMessageHeight;
    if (!c || h <= 0) {
      if (c && h <= 0) {
        const b = messageEl.querySelector(`.${CSS_CLASS_SHOW_MORE_BUTTON}`);
        b == null ? void 0 : b.remove();
        c.style.maxHeight = "";
        c.classList.remove(CSS_CLASS_CONTENT_COLLAPSED);
      }
      return;
    }
    requestAnimationFrame(() => {
      if (!c)
        return;
      const b = messageEl.querySelector(`.${CSS_CLASS_SHOW_MORE_BUTTON}`);
      b == null ? void 0 : b.remove();
      c.style.maxHeight = "";
      c.classList.remove(CSS_CLASS_CONTENT_COLLAPSED);
      const sh = c.scrollHeight;
      if (sh > h) {
        c.style.maxHeight = `${h}px`;
        c.classList.add(CSS_CLASS_CONTENT_COLLAPSED);
        const smb = messageEl.createEl("button", { cls: CSS_CLASS_SHOW_MORE_BUTTON, text: "Show More \u25BC" });
        this.registerDomEvent(smb, "click", () => this.toggleMessageCollapse(c, smb));
      } else {
        c.style.maxHeight = "";
        c.classList.remove(CSS_CLASS_CONTENT_COLLAPSED);
      }
    });
  }
  checkAllMessagesForCollapsing() {
    var _a;
    (_a = this.chatContainer) == null ? void 0 : _a.querySelectorAll(`.${CSS_CLASS_MESSAGE}`).forEach((msgEl) => {
      this.checkMessageForCollapsing(msgEl);
    });
  }
  toggleMessageCollapse(contentEl, buttonEl) {
    const i = contentEl.classList.contains(CSS_CLASS_CONTENT_COLLAPSED);
    const h = this.plugin.settings.maxMessageHeight;
    if (i) {
      contentEl.style.maxHeight = "";
      contentEl.classList.remove(CSS_CLASS_CONTENT_COLLAPSED);
      buttonEl.setText("Show Less \u25B2");
    } else {
      contentEl.style.maxHeight = `${h}px`;
      contentEl.classList.add(CSS_CLASS_CONTENT_COLLAPSED);
      buttonEl.setText("Show More \u25BC");
    }
  }
  // --- Helpers & Utilities ---
  getChatContainer() {
    return this.chatContainer;
  }
  clearChatContainerInternal() {
    this.currentMessages = [];
    this.lastRenderedMessageDate = null;
    if (this.chatContainer)
      this.chatContainer.empty();
    this.hideEmptyState();
  }
  clearDisplayAndState() {
    this.clearChatContainerInternal();
    this.showEmptyState();
    this.updateSendButtonState();
    setTimeout(() => this.focusInput(), 50);
  }
  addLoadingIndicator() {
    this.hideEmptyState();
    const group = this.chatContainer.createDiv({ cls: `${CSS_CLASS_MESSAGE_GROUP} ${CSS_CLASS_OLLAMA_GROUP}` });
    this.renderAvatar(group, false);
    const message = group.createDiv({ cls: `${CSS_CLASS_MESSAGE} ${CSS_CLASS_OLLAMA_MESSAGE}` });
    const dots = message.createDiv({ cls: CSS_CLASS_THINKING_DOTS });
    for (let i = 0; i < 3; i++)
      dots.createDiv({ cls: CSS_CLASS_THINKING_DOT });
    this.guaranteedScrollToBottom(50, true);
    return group;
  }
  removeLoadingIndicator(loadingEl) {
    if (loadingEl == null ? void 0 : loadingEl.parentNode) {
      loadingEl.remove();
    }
  }
  scrollToBottom() {
    this.guaranteedScrollToBottom(50, true);
  }
  clearInputField() {
    if (this.inputEl) {
      this.inputEl.value = "";
      this.inputEl.dispatchEvent(new Event("input"));
    }
  }
  // Trigger resize/button update
  focusInput() {
    setTimeout(() => {
      var _a;
      (_a = this.inputEl) == null ? void 0 : _a.focus();
    }, 0);
  }
  // Use setTimeout to ensure focus happens after potential UI updates
  /** Guarantees scroll to bottom after a delay, respecting user scroll position unless forced */
  guaranteedScrollToBottom(delay = 50, forceScroll = false) {
    if (this.scrollTimeout) {
      clearTimeout(this.scrollTimeout);
      this.scrollTimeout = null;
    }
    this.scrollTimeout = setTimeout(() => {
      requestAnimationFrame(() => {
        var _a, _b;
        if (this.chatContainer) {
          const threshold = 100;
          const isScrolledUp = this.chatContainer.scrollHeight - this.chatContainer.scrollTop - this.chatContainer.clientHeight > threshold;
          if (isScrolledUp !== this.userScrolledUp) {
            this.userScrolledUp = isScrolledUp;
            if (!isScrolledUp)
              (_a = this.newMessagesIndicatorEl) == null ? void 0 : _a.classList.remove(CSS_CLASS_VISIBLE);
          }
          if (forceScroll || !this.userScrolledUp || this.isProcessing) {
            const behavior = this.isProcessing ? "auto" : "smooth";
            this.chatContainer.scrollTo({ top: this.chatContainer.scrollHeight, behavior });
            if (forceScroll) {
              this.userScrolledUp = false;
              (_b = this.newMessagesIndicatorEl) == null ? void 0 : _b.classList.remove(CSS_CLASS_VISIBLE);
            }
          }
        } else {
        }
      });
      this.scrollTimeout = null;
    }, delay);
  }
  // Formatting Helpers
  formatTime(date) {
    return date.toLocaleTimeString(void 0, { hour: "numeric", minute: "2-digit" });
  }
  // Use locale default time format
  formatDateSeparator(date) {
    const now = new Date();
    const yesterday = new Date(now);
    yesterday.setDate(now.getDate() - 1);
    if (this.isSameDay(date, now))
      return "Today";
    else if (this.isSameDay(date, yesterday))
      return "Yesterday";
    else
      return date.toLocaleDateString(void 0, { weekday: "long", year: "numeric", month: "long", day: "numeric" });
  }
  formatRelativeDate(date) {
    const now = new Date();
    const diffSeconds = Math.round((now.getTime() - date.getTime()) / 1e3);
    const diffDays = Math.floor(diffSeconds / (60 * 60 * 24));
    if (diffDays === 0) {
      const diffHours = Math.floor(diffSeconds / (60 * 60));
      if (diffHours < 1)
        return "Just now";
      if (diffHours === 1)
        return "1 hour ago";
      if (diffHours < now.getHours())
        return `${diffHours} hours ago`;
      else
        return "Today";
    } else if (diffDays === 1) {
      return "Yesterday";
    } else if (diffDays < 7) {
      return `${diffDays} days ago`;
    } else {
      return date.toLocaleDateString(void 0, { month: "short", day: "numeric" });
    }
  }
  isSameDay(date1, date2) {
    return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate();
  }
  // Formatting function used by export
  formatChatToMarkdown(messagesToFormat) {
    let localLastDate = null;
    const exportTimestamp = new Date();
    let markdown = `# AI Forge Chat Export
> Exported on: ${exportTimestamp.toLocaleString(void 0)}

`;
    messagesToFormat.forEach((message) => {
      var _a;
      if (!((_a = message.content) == null ? void 0 : _a.trim()))
        return;
      if (localLastDate === null || !this.isSameDay(localLastDate, message.timestamp)) {
        if (localLastDate !== null)
          markdown += `***
`;
        markdown += `**${this.formatDateSeparator(message.timestamp)}**
***

`;
      }
      localLastDate = message.timestamp;
      const time = this.formatTime(message.timestamp);
      let prefix = "";
      let contentPrefix = "";
      let content = message.content.trim();
      if (message.role === "assistant") {
        content = this.decodeHtmlEntities(content).replace(/<think>[\s\S]*?<\/think>/g, "").trim();
        if (!content)
          return;
      }
      switch (message.role) {
        case "user":
          prefix = `**User (${time}):**
`;
          break;
        case "assistant":
          prefix = `**Assistant (${time}):**
`;
          break;
        case "system":
          prefix = `> _[System (${time})]_ 
> `;
          contentPrefix = "> ";
          break;
        case "error":
          prefix = `> [!ERROR] Error (${time}):
> `;
          contentPrefix = "> ";
          break;
      }
      markdown += prefix;
      if (contentPrefix) {
        markdown += content.split("\n").map((line) => line.trim() ? `${contentPrefix}${line}` : contentPrefix.trim()).join(`
`) + "\n\n";
      } else if (content.includes("```")) {
        content = content.replace(/(\n*\s*)```/g, "\n\n```").replace(/```(\s*\n*)/g, "```\n\n");
        markdown += content.trim() + "\n\n";
      } else {
        markdown += content.split("\n").map((line) => line.trim() ? line : "").join("\n") + "\n\n";
      }
    });
    return markdown.trim();
  }
  async getCurrentRoleDisplayName() {
    var _a, _b, _c, _d;
    try {
      const activeChat = await ((_a = this.plugin.chatManager) == null ? void 0 : _a.getActiveChat());
      const rolePath = (_c = (_b = activeChat == null ? void 0 : activeChat.metadata) == null ? void 0 : _b.selectedRolePath) != null ? _c : this.plugin.settings.selectedRolePath;
      if (rolePath) {
        const allRoles = await this.plugin.listRoleFiles(true);
        const foundRole = allRoles.find((role) => role.path === rolePath);
        if (foundRole) {
          return foundRole.name;
        } else {
          console.warn(`Role with path "${rolePath}" not found in listRoleFiles results.`);
          return ((_d = rolePath.split("/").pop()) == null ? void 0 : _d.replace(".md", "")) || "Selected Role";
        }
      }
    } catch (error) {
      console.error("Error getting current role display name:", error);
    }
    return "None";
  }
};

// src/settings.ts
var import_obsidian4 = require("obsidian");
var LANGUAGES2 = {
  /* ... ваш довгий список мов ... */
  "af": "Afrikaans",
  "sq": "Albanian",
  "am": "Amharic",
  "ar": "Arabic",
  "hy": "Armenian",
  "az": "Azerbaijani",
  "eu": "Basque",
  "be": "Belarusian",
  "bn": "Bengali",
  "bs": "Bosnian",
  "bg": "Bulgarian",
  "ca": "Catalan",
  "ceb": "Cebuano",
  "ny": "Chichewa",
  "zh-CN": "Chinese (Simplified)",
  "zh-TW": "Chinese (Traditional)",
  "co": "Corsican",
  "hr": "Croatian",
  "cs": "Czech",
  "da": "Danish",
  "nl": "Dutch",
  "en": "English",
  "eo": "Esperanto",
  "et": "Estonian",
  "tl": "Filipino",
  "fi": "Finnish",
  "fr": "French",
  "fy": "Frisian",
  "gl": "Galician",
  "ka": "Georgian",
  "de": "German",
  "el": "Greek",
  "gu": "Gujarati",
  "ht": "Haitian Creole",
  "ha": "Hausa",
  "haw": "Hawaiian",
  "iw": "Hebrew",
  "he": "Hebrew",
  "hi": "Hindi",
  "hmn": "Hmong",
  "hu": "Hungarian",
  "is": "Icelandic",
  "ig": "Igbo",
  "id": "Indonesian",
  "ga": "Irish",
  "it": "Italian",
  "ja": "Japanese",
  "jw": "Javanese",
  "kn": "Kannada",
  "kk": "Kazakh",
  "km": "Khmer",
  "rw": "Kinyarwanda",
  "ko": "Korean",
  "ku": "Kurdish (Kurmanji)",
  "ky": "Kyrgyz",
  "lo": "Lao",
  "la": "Latin",
  "lv": "Latvian",
  "lt": "Lithuanian",
  "lb": "Luxembourgish",
  "mk": "Macedonian",
  "mg": "Malagasy",
  "ms": "Malay",
  "ml": "Malayalam",
  "mt": "Maltese",
  "mi": "Maori",
  "mr": "Marathi",
  "mn": "Mongolian",
  "my": "Myanmar (Burmese)",
  "ne": "Nepali",
  "no": "Norwegian",
  "or": "Odia (Oriya)",
  "ps": "Pashto",
  "fa": "Persian",
  "pl": "Polish",
  "pt": "Portuguese",
  "pa": "Punjabi",
  "ro": "Romanian",
  "ru": "Russian",
  "sm": "Samoan",
  "gd": "Scots Gaelic",
  "sr": "Serbian",
  "st": "Sesotho",
  "sn": "Shona",
  "sd": "Sindhi",
  "si": "Sinhala",
  "sk": "Slovak",
  "sl": "Slovenian",
  "so": "Somali",
  "es": "Spanish",
  "su": "Sundanese",
  "sw": "Swahili",
  "sv": "Swedish",
  "tg": "Tajik",
  "ta": "Tamil",
  "tt": "Tatar",
  "te": "Telugu",
  "th": "Thai",
  "tr": "Turkish",
  "tk": "Turkmen",
  "uk": "Ukrainian",
  "ur": "Urdu",
  "ug": "Uyghur",
  "uz": "Uzbek",
  "vi": "Vietnamese",
  "cy": "Welsh",
  "xh": "Xhosa",
  "yi": "Yiddish",
  "yo": "Yoruba",
  "zu": "Zulu"
};
var DEFAULT_SETTINGS = {
  ollamaServerUrl: "http://localhost:11434",
  modelName: "",
  temperature: 0.7,
  contextWindow: 4096,
  userRolesFolderPath: "/etc/roles",
  // Змінено на більш нейтральний шлях
  selectedRolePath: "",
  saveMessageHistory: true,
  ragEnabled: false,
  ragFolderPath: "/etc/RAG",
  // Змінено
  googleApiKey: "",
  speechLanguage: "uk-UA",
  userAvatarType: "initials",
  userAvatarContent: "U",
  aiAvatarType: "icon",
  aiAvatarContent: "bot",
  maxMessageHeight: 300,
  enableTranslation: false,
  translationTargetLanguage: "uk",
  googleTranslationApiKey: "",
  chatHistoryFolderPath: "/etc/chats",
  // Змінено
  chatExportFolderPath: "/etc/xports",
  // Змінено
  enableProductivityFeatures: false,
  dailyTaskFileName: "Tasks_Today.md",
  useAdvancedContextStrategy: false,
  enableSummarization: false,
  summarizationPrompt: "Summarize the key points...",
  keepLastNMessagesBeforeSummary: 10,
  summarizationChunkSize: 1500,
  followRole: true,
  // --- Нові налаштування логера ---
  consoleLogLevel: "INFO",
  // Рівень для консолі за замовчуванням
  fileLoggingEnabled: false,
  // Логування у файл вимкнено за замовчуванням
  fileLogLevel: "WARN",
  // Рівень для файлу за замовчуванням
  logCallerInfo: false,
  // НЕ записувати ім'я викликаючого методу за замовчуванням (для продуктивності)
  // logFilePath: undefined, // Шлях за замовчуванням буде в папці плагіна
  // logFileMaxSizeMB: 5, // Макс. розмір за замовчуванням
  maxCharsPerDoc: 1500,
  ragEnableSemanticSearch: true,
  // Вмикаємо за замовчуванням, якщо RAG взагалі увімкнено
  ragEmbeddingModel: "nomic-embed-text",
  // Рекомендована модель
  ragChunkSize: 512,
  // Популярний розмір чанку
  ragSimilarityThreshold: 0.5,
  // Середній поріг подібності
  ragTopK: 3
  // Брати топ-3 результати
};
var OllamaSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.debouncedUpdateChatPath = (0, import_obsidian4.debounce)(async () => {
      console.log("Debounced: Updating chat path and ensuring folder exists...");
      if (this.plugin.chatManager) {
        this.plugin.chatManager.updateChatsFolderPath();
        await this.plugin.chatManager.ensureChatsFolderExists();
      }
    }, 1e3, true);
    this.debouncedUpdateRolePath = (0, import_obsidian4.debounce)(async () => {
      console.log("Debounced: Refreshing role list due to path change...");
      await this.plugin.listRoleFiles(true);
      this.plugin.emit("roles-updated");
    }, 1e3, true);
    this.debouncedUpdateRagPath = (0, import_obsidian4.debounce)(async () => {
      console.log("Debounced: Re-indexing RAG due to path change...");
      if (this.plugin.settings.ragEnabled && this.plugin.ragService) {
        await this.plugin.ragService.indexDocuments();
      }
    }, 1e3, true);
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "AI Forge Settings" });
    containerEl.createEl("h3", { text: "Connection & Model" });
    new import_obsidian4.Setting(containerEl).setName("Ollama Server URL").setDesc("The URL of your running Ollama server.").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.ollamaServerUrl).setValue(this.plugin.settings.ollamaServerUrl).onChange(async (value) => {
      this.plugin.settings.ollamaServerUrl = value.trim() || DEFAULT_SETTINGS.ollamaServerUrl;
      await this.plugin.saveSettings();
      this.plugin.updateOllamaServiceConfig();
    }));
    const modelSetting = new import_obsidian4.Setting(containerEl).setName("Default Model Name").setDesc("The default Ollama model to use for new chats. Select from available models.");
    let modelDropdown = null;
    const updateOptions = async (dropdown) => {
      if (!dropdown)
        return;
      dropdown.selectEl.innerHTML = "";
      dropdown.addOption("", "Loading models...");
      dropdown.setDisabled(true);
      try {
        const models = await this.plugin.ollamaService.getModels();
        dropdown.selectEl.innerHTML = "";
        dropdown.addOption("", "-- Select default model --");
        if (models && models.length > 0) {
          models.forEach((modelName) => {
            dropdown.addOption(modelName, modelName);
          });
        } else {
          dropdown.addOption("", "No models found");
        }
        dropdown.setValue(this.plugin.settings.modelName);
        dropdown.setDisabled(false);
      } catch (error) {
        console.error("Error fetching models for settings:", error);
        dropdown.selectEl.innerHTML = "";
        dropdown.addOption("", "Error loading models!");
        dropdown.setValue(this.plugin.settings.modelName);
        dropdown.setDisabled(true);
      }
    };
    modelSetting.addDropdown(async (dropdown) => {
      modelDropdown = dropdown;
      dropdown.onChange(async (value) => {
        this.plugin.settings.modelName = value;
        await this.plugin.saveSettings();
      });
      await updateOptions(dropdown);
    });
    modelSetting.controlEl.addClass("ollama-model-setting-control");
    const refreshButton = modelSetting.controlEl.createEl("button", {
      cls: "ollama-refresh-button",
      attr: { "aria-label": "Refresh model list" }
    });
    (0, import_obsidian4.setIcon)(refreshButton, "refresh-cw");
    refreshButton.addEventListener("click", async (e) => {
      e.preventDefault();
      if (!modelDropdown)
        return;
      (0, import_obsidian4.setIcon)(refreshButton, "loader");
      refreshButton.disabled = true;
      await updateOptions(modelDropdown);
      (0, import_obsidian4.setIcon)(refreshButton, "refresh-cw");
      refreshButton.disabled = false;
    });
    new import_obsidian4.Setting(containerEl).setName("Default Temperature").setDesc("Controls randomness. Lower values (e.g., 0.2) make output more deterministic, higher values (e.g., 0.8) make it more creative.").addSlider((slider) => slider.setLimits(0, 1, 0.1).setValue(this.plugin.settings.temperature).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.temperature = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Context Window Size (Tokens)").setDesc("Maximum number of tokens (input + output) the model considers. Adjust based on model and available memory.").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.contextWindow.toString()).setValue(this.plugin.settings.contextWindow.toString()).onChange(async (value) => {
      const num = parseInt(value.trim(), 10);
      if (!isNaN(num) && num > 0) {
        this.plugin.settings.contextWindow = num;
      } else {
        this.plugin.settings.contextWindow = DEFAULT_SETTINGS.contextWindow;
      }
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Roles & Personas" });
    new import_obsidian4.Setting(containerEl).setName("Custom Roles Folder Path").setDesc("Folder within your vault containing custom role definition (.md) files.").addText((text) => text.setPlaceholder("Example: System Prompts/Ollama Roles").setValue(this.plugin.settings.userRolesFolderPath).onChange(async (value) => {
      this.plugin.settings.userRolesFolderPath = value.trim();
      await this.plugin.saveSettings();
      this.debouncedUpdateRolePath();
    }));
    new import_obsidian4.Setting(containerEl).setName("Always Apply Selected Role").setDesc("If enabled, the globally selected role (or chat-specific role) will always be used as the system prompt.").addToggle((toggle) => toggle.setValue(this.plugin.settings.followRole).onChange(async (value) => {
      this.plugin.settings.followRole = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Storage & History" });
    new import_obsidian4.Setting(containerEl).setName("Save Message History").setDesc("Automatically save chat conversations to files.").addToggle((toggle) => toggle.setValue(this.plugin.settings.saveMessageHistory).onChange(async (value) => {
      this.plugin.settings.saveMessageHistory = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Chat History Folder Path").setDesc("Folder within your vault to store chat history (.json files). Leave empty to save in the vault root.").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.chatHistoryFolderPath || "Vault Root").setValue(this.plugin.settings.chatHistoryFolderPath).onChange(async (value) => {
      this.plugin.settings.chatHistoryFolderPath = value.trim();
      await this.plugin.saveSettings();
      this.debouncedUpdateChatPath();
    }));
    containerEl.createEl("h3", { text: "Retrieval-Augmented Generation (RAG)" });
    new import_obsidian4.Setting(containerEl).setName("Enable RAG").setDesc("Allow the chat to retrieve information from your notes for context.").addToggle((toggle) => toggle.setValue(this.plugin.settings.ragEnabled).onChange(async (value) => {
      this.plugin.settings.ragEnabled = value;
      await this.plugin.saveSettings();
      this.display();
      if (value)
        this.debouncedUpdateRagPath();
    }));
    if (this.plugin.settings.ragEnabled) {
      new import_obsidian4.Setting(containerEl).setName("RAG Documents Folder Path").setDesc("Folder containing notes for RAG context.").addText((text) => text.setPlaceholder("Example: Knowledge Base/RAG Docs").setValue(this.plugin.settings.ragFolderPath).onChange(async (value) => {
        var _a, _b, _c, _d;
        this.plugin.settings.ragFolderPath = value.trim();
        await this.plugin.saveSettings();
        this.debouncedUpdateRagPath();
        (_b = (_a = this.plugin).updateDailyTaskFilePath) == null ? void 0 : _b.call(_a);
        (_d = (_c = this.plugin).loadAndProcessInitialTasks) == null ? void 0 : _d.call(_c);
      }));
      new import_obsidian4.Setting(containerEl).setName("Enable Semantic Search").setDesc("Use embedding models for context retrieval (more accurate, requires indexing). If disabled, might fall back to basic keyword search (if implemented).").addToggle((toggle) => toggle.setValue(this.plugin.settings.ragEnableSemanticSearch).onChange(async (value) => {
        this.plugin.settings.ragEnableSemanticSearch = value;
        await this.plugin.saveSettings();
        this.display();
        this.debouncedUpdateRagPath();
      }));
      if (this.plugin.settings.ragEnableSemanticSearch) {
        const embeddingModelSetting = new import_obsidian4.Setting(containerEl).setName("Embedding Model Name").setDesc("Ollama model for generating text embeddings (e.g., nomic-embed-text, all-minilm). Ensure the model is pulled.").setClass("ollama-model-setting-container");
        let embeddingDropdown = null;
        const updateEmbeddingOptions = async (dropdown) => {
          if (!dropdown)
            return;
          const previousValue = dropdown.getValue();
          dropdown.selectEl.innerHTML = "";
          dropdown.addOption("", "Loading models...");
          dropdown.setDisabled(true);
          try {
            const models = await this.plugin.ollamaService.getModels();
            dropdown.selectEl.innerHTML = "";
            dropdown.addOption("", "-- Select Embedding Model --");
            const commonEmbedModels = ["nomic-embed-text", "all-minilm", "mxbai-embed-large", "bge-base-en", "gte-base"];
            commonEmbedModels.forEach((modelName) => {
              dropdown.addOption(modelName, modelName);
            });
            dropdown.addOption("---", "--- Other Installed Models ---").setDisabled(true);
            if (models && models.length > 0) {
              models.forEach((modelName) => {
                if (!commonEmbedModels.includes(modelName)) {
                  dropdown.addOption(modelName, modelName);
                }
              });
            } else {
            }
            dropdown.setValue(this.plugin.settings.ragEmbeddingModel || commonEmbedModels[0]);
            dropdown.setDisabled(false);
          } catch (error) {
            console.error("Error fetching models for embedding dropdown:", error);
            dropdown.selectEl.innerHTML = "";
            dropdown.addOption("", "Error loading models!");
            dropdown.setValue(this.plugin.settings.ragEmbeddingModel);
            dropdown.setDisabled(true);
          }
        };
        embeddingModelSetting.addDropdown(async (dropdown) => {
          embeddingDropdown = dropdown;
          dropdown.onChange(async (value) => {
            this.plugin.settings.ragEmbeddingModel = value;
            await this.plugin.saveSettings();
            this.debouncedUpdateRagPath();
          });
          await updateEmbeddingOptions(dropdown);
        });
        embeddingModelSetting.controlEl.addClass("ollama-model-setting-control");
        const refreshEmbeddingButton = embeddingModelSetting.controlEl.createEl("button", {
          cls: "ollama-refresh-button",
          attr: { "aria-label": "Refresh model list" }
        });
        (0, import_obsidian4.setIcon)(refreshEmbeddingButton, "refresh-cw");
        refreshEmbeddingButton.addEventListener("click", async (e) => {
          e.preventDefault();
          if (!embeddingDropdown)
            return;
          (0, import_obsidian4.setIcon)(refreshEmbeddingButton, "loader");
          refreshEmbeddingButton.disabled = true;
          await updateEmbeddingOptions(embeddingDropdown);
          (0, import_obsidian4.setIcon)(refreshEmbeddingButton, "refresh-cw");
          refreshEmbeddingButton.disabled = false;
        });
        new import_obsidian4.Setting(containerEl).setName("Chunk Size (Characters)").setDesc("Size of text chunks for indexing. Smaller chunks = more specific context, larger = broader context.").addText((text) => text.setPlaceholder(String(DEFAULT_SETTINGS.ragChunkSize)).setValue(String(this.plugin.settings.ragChunkSize)).onChange(async (value) => {
          const num = parseInt(value.trim(), 10);
          this.plugin.settings.ragChunkSize = !isNaN(num) && num > 50 ? num : DEFAULT_SETTINGS.ragChunkSize;
          await this.plugin.saveSettings();
          this.debouncedUpdateRagPath();
        }));
        new import_obsidian4.Setting(containerEl).setName("Similarity Threshold").setDesc("Minimum relevance score (0.0 to 1.0) for a chunk to be included in context. Higher = more strict.").addSlider((slider) => slider.setLimits(0, 1, 0.05).setValue(this.plugin.settings.ragSimilarityThreshold).setDynamicTooltip().onChange(async (value) => {
          this.plugin.settings.ragSimilarityThreshold = value;
          await this.plugin.saveSettings();
        }));
      }
      new import_obsidian4.Setting(containerEl).setName("Top K Results").setDesc("Maximum number of relevant document chunks to include in the context.").addText((text) => text.setPlaceholder(String(DEFAULT_SETTINGS.ragTopK)).setValue(String(this.plugin.settings.ragTopK)).onChange(async (value) => {
        const num = parseInt(value.trim(), 10);
        this.plugin.settings.ragTopK = !isNaN(num) && num > 0 ? num : DEFAULT_SETTINGS.ragTopK;
        await this.plugin.saveSettings();
      }));
    }
    new import_obsidian4.Setting(containerEl).setName("Max Characters Per Document (Fallback/Display?)").setDesc("Maximum characters to display or process from a single RAG document chunk if needed (Legacy?). Set 0 for no limit.").addText((text) => text.setPlaceholder(String(DEFAULT_SETTINGS.maxCharsPerDoc)).setValue(String(this.plugin.settings.maxCharsPerDoc)).onChange(async (value) => {
      const num = parseInt(value.trim(), 10);
      this.plugin.settings.maxCharsPerDoc = !isNaN(num) && num >= 0 ? num : DEFAULT_SETTINGS.maxCharsPerDoc;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Productivity Assistant Features" });
    new import_obsidian4.Setting(containerEl).setName("Enable Productivity Features").setDesc("Activate features like daily task integration and advanced context management for planning-oriented personas.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableProductivityFeatures).onChange(async (value) => {
      this.plugin.settings.enableProductivityFeatures = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.enableProductivityFeatures) {
      new import_obsidian4.Setting(containerEl).setName("Daily Task File Name").setDesc("The exact filename (including .md) of your daily task list within the RAG folder.").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.dailyTaskFileName).setValue(this.plugin.settings.dailyTaskFileName).onChange(async (value) => {
        var _a, _b, _c, _d;
        this.plugin.settings.dailyTaskFileName = value.trim() || DEFAULT_SETTINGS.dailyTaskFileName;
        await this.plugin.saveSettings();
        (_b = (_a = this.plugin).updateDailyTaskFilePath) == null ? void 0 : _b.call(_a);
        (_d = (_c = this.plugin).loadAndProcessInitialTasks) == null ? void 0 : _d.call(_c);
      }));
      new import_obsidian4.Setting(containerEl).setName("Use Advanced Context Strategy").setDesc("Enables summarization and chunking for long conversations (requires Productivity Features enabled).").addToggle((toggle) => toggle.setValue(this.plugin.settings.useAdvancedContextStrategy).onChange(async (value) => {
        this.plugin.settings.useAdvancedContextStrategy = value;
        await this.plugin.saveSettings();
        this.display();
      }));
      if (this.plugin.settings.useAdvancedContextStrategy) {
        new import_obsidian4.Setting(containerEl).setName("Enable Context Summarization").setDesc("Allow summarizing older parts of the chat history.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableSummarization).onChange(async (value) => {
          this.plugin.settings.enableSummarization = value;
          await this.plugin.saveSettings();
          this.display();
        }));
        if (this.plugin.settings.enableSummarization) {
          new import_obsidian4.Setting(containerEl).setName("Summarization Prompt").setDesc("Prompt for summarizing history. Use {text_to_summarize}.").addTextArea(
            (text) => text.setPlaceholder(DEFAULT_SETTINGS.summarizationPrompt).setValue(this.plugin.settings.summarizationPrompt).onChange(async (value) => {
              this.plugin.settings.summarizationPrompt = value || DEFAULT_SETTINGS.summarizationPrompt;
              await this.plugin.saveSettings();
            }).inputEl.setAttrs({ rows: 4 })
          );
        }
        new import_obsidian4.Setting(containerEl).setName("Keep Last N Messages Before Summary").setDesc("Number of recent messages kept verbatim before considering summarization.").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.keepLastNMessagesBeforeSummary.toString()).setValue(this.plugin.settings.keepLastNMessagesBeforeSummary.toString()).onChange(async (value) => {
          const num = parseInt(value.trim(), 10);
          this.plugin.settings.keepLastNMessagesBeforeSummary = !isNaN(num) && num >= 0 ? num : DEFAULT_SETTINGS.keepLastNMessagesBeforeSummary;
          await this.plugin.saveSettings();
        }));
        new import_obsidian4.Setting(containerEl).setName("Summarization Chunk Size (Tokens)").setDesc("Approximate token size of message chunks processed for summarization.").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.summarizationChunkSize.toString()).setValue(this.plugin.settings.summarizationChunkSize.toString()).onChange(async (value) => {
          const num = parseInt(value.trim(), 10);
          this.plugin.settings.summarizationChunkSize = !isNaN(num) && num > 100 ? num : DEFAULT_SETTINGS.summarizationChunkSize;
          await this.plugin.saveSettings();
        }));
      }
    }
    containerEl.createEl("h3", { text: "Appearance" });
    new import_obsidian4.Setting(containerEl).setName("User Avatar Style").addDropdown((dropdown) => dropdown.addOption("initials", "Initials").addOption("icon", "Icon").setValue(this.plugin.settings.userAvatarType).onChange(async (value) => {
      this.plugin.settings.userAvatarType = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.userAvatarType === "initials") {
      new import_obsidian4.Setting(containerEl).setName("User Initials").setDesc("Max 2 characters.").addText((text) => text.setValue(this.plugin.settings.userAvatarContent).onChange(async (value) => {
        this.plugin.settings.userAvatarContent = value.trim().substring(0, 2) || "U";
        await this.plugin.saveSettings();
      }));
    } else {
      new import_obsidian4.Setting(containerEl).setName("User Icon ID").setDesc('Enter an Obsidian icon ID (e.g., "user", "lucide-user").').addText((text) => text.setPlaceholder("user").setValue(this.plugin.settings.userAvatarContent).onChange(async (value) => {
        this.plugin.settings.userAvatarContent = value.trim() || "user";
        await this.plugin.saveSettings();
      }));
    }
    new import_obsidian4.Setting(containerEl).setName("AI Avatar Style").addDropdown((dropdown) => dropdown.addOption("initials", "Initials").addOption("icon", "Icon").setValue(this.plugin.settings.aiAvatarType).onChange(async (value) => {
      this.plugin.settings.aiAvatarType = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.aiAvatarType === "initials") {
      new import_obsidian4.Setting(containerEl).setName("AI Initials").setDesc("Max 2 characters.").addText((text) => text.setValue(this.plugin.settings.aiAvatarContent).onChange(async (value) => {
        this.plugin.settings.aiAvatarContent = value.trim().substring(0, 2) || "AI";
        await this.plugin.saveSettings();
      }));
    } else {
      new import_obsidian4.Setting(containerEl).setName("AI Icon ID").setDesc('Enter an Obsidian icon ID (e.g., "bot", "lucide-bot").').addText((text) => text.setPlaceholder("bot").setValue(this.plugin.settings.aiAvatarContent).onChange(async (value) => {
        this.plugin.settings.aiAvatarContent = value.trim() || "bot";
        await this.plugin.saveSettings();
      }));
    }
    new import_obsidian4.Setting(containerEl).setName("Max Message Height (pixels)").setDesc("Collapse longer messages, showing a 'Show More' button. Set to 0 to disable collapsing.").addText((text) => text.setPlaceholder("Example: 300").setValue(this.plugin.settings.maxMessageHeight.toString()).onChange(async (value) => {
      const num = parseInt(value.trim(), 10);
      if (!isNaN(num) && num >= 0) {
        this.plugin.settings.maxMessageHeight = num;
      } else {
        this.plugin.settings.maxMessageHeight = DEFAULT_SETTINGS.maxMessageHeight;
      }
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Speech & Translation" });
    new import_obsidian4.Setting(containerEl).setName("Google API Key (Speech-to-Text)").setDesc("Required for the voice input feature. Keep this confidential.").addText((text) => text.setPlaceholder("Enter your API Key").setValue(this.plugin.settings.googleApiKey).onChange(async (value) => {
      this.plugin.settings.googleApiKey = value.trim();
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Speech Recognition Language").setDesc("Select the language for voice input.").addDropdown((dropdown) => {
      const speechLangs = { "uk-UA": "Ukrainian", "en-US": "English (US)", "en-GB": "English (UK)", "de-DE": "German", "fr-FR": "French", "es-ES": "Spanish", "it-IT": "Italian", "ja-JP": "Japanese", "ko-KR": "Korean", "pt-BR": "Portuguese (Brazil)", "ru-RU": "Russian", "zh-CN": "Chinese (Mandarin, Simplified)" };
      for (const code in speechLangs) {
        dropdown.addOption(code, speechLangs[code]);
      }
      dropdown.setValue(this.plugin.settings.speechLanguage).onChange(async (value) => {
        this.plugin.settings.speechLanguage = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian4.Setting(containerEl).setName("Enable Translation Feature").setDesc("Show buttons to translate messages or input using Google Translate API.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableTranslation).onChange(async (value) => {
      this.plugin.settings.enableTranslation = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.enableTranslation) {
      new import_obsidian4.Setting(containerEl).setName("Target Translation Language").setDesc("Select the language to translate messages/input into.").addDropdown((dropdown) => {
        for (const code in LANGUAGES2) {
          dropdown.addOption(code, LANGUAGES2[code]);
        }
        dropdown.setValue(this.plugin.settings.translationTargetLanguage).onChange(async (value) => {
          this.plugin.settings.translationTargetLanguage = value;
          await this.plugin.saveSettings();
        });
      });
      new import_obsidian4.Setting(containerEl).setName("Google Cloud Translation API Key").setDesc("Required for the translation feature. Keep this confidential.").addText((text) => text.setPlaceholder("Enter your API Key").setValue(this.plugin.settings.googleTranslationApiKey).onChange(async (value) => {
        this.plugin.settings.googleTranslationApiKey = value.trim();
        await this.plugin.saveSettings();
      }));
    }
    containerEl.createEl("h3", { text: "Export Settings" });
    new import_obsidian4.Setting(containerEl).setName("Chat Export Folder Path").setDesc("Folder within your vault to save exported Markdown chats. Leave empty to save in the vault root.").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.chatExportFolderPath || "Vault Root").setValue(this.plugin.settings.chatExportFolderPath).onChange(async (value) => {
      this.plugin.settings.chatExportFolderPath = value.trim();
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Logging" });
    new import_obsidian4.Setting(containerEl).setName("Console Log Level").setDesc("Minimum level of messages to show in the developer console (DEBUG shows all).").addDropdown((dropdown) => dropdown.addOption("DEBUG", "Debug").addOption("INFO", "Info").addOption("WARN", "Warning").addOption("ERROR", "Error").addOption("NONE", "None").setValue(this.plugin.settings.consoleLogLevel || "INFO").onChange(async (value) => {
      this.plugin.settings.consoleLogLevel = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Enable File Logging").setDesc(`Log messages to a file (${this.plugin.manifest.dir}/ai-forge.log). Useful for debugging on mobile.`).addToggle((toggle) => toggle.setValue(this.plugin.settings.fileLoggingEnabled).onChange(async (value) => {
      this.plugin.settings.fileLoggingEnabled = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.fileLoggingEnabled) {
      new import_obsidian4.Setting(containerEl).setName("File Log Level").setDesc("Minimum level of messages to write to the log file.").addDropdown((dropdown) => dropdown.addOption("DEBUG", "Debug").addOption("INFO", "Info").addOption("WARN", "Warning").addOption("ERROR", "Error").setValue(this.plugin.settings.fileLogLevel || "WARN").onChange(async (value) => {
        this.plugin.settings.fileLogLevel = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian4.Setting(containerEl).setName("Log Caller Method Name").setDesc("Include the calling method name in logs ([MethodName] Message). WARNING: May slightly impact performance, especially with frequent DEBUG/INFO logging.").addToggle((toggle) => toggle.setValue(this.plugin.settings.logCallerInfo).onChange(async (value) => {
        this.plugin.settings.logCallerInfo = value;
        await this.plugin.saveSettings();
      }));
    }
  }
};

// src/ragService.ts
var import_obsidian5 = require("obsidian");
var RagService = class {
  // Модель за замовчуванням
  constructor(plugin) {
    // --- ЗМІНЕНО: Зберігаємо ембединги чанків ---
    this.chunkEmbeddings = [];
    // ------------------------------------------
    this.isIndexing = false;
    this.embeddingModelName = "nomic-embed-text";
    this.plugin = plugin;
    this.adapter = plugin.app.vault.adapter;
    this.embeddingModelName = this.plugin.settings.ragEmbeddingModel || DEFAULT_SETTINGS.ragEmbeddingModel;
  }
  /**
   * Розбиває текст на чанки (проста версія - за абзацами).
   * @param text Вхідний текст документа (бажано без YAML).Я
   * @param chunkSize Максимальна довжина чанка в символах (з налаштувань).
   * @returns Масив текстових чанків.
   */
  splitIntoChunks(text, chunkSize) {
    if (!text)
      return [];
    const paragraphs = text.split(/\n\s*\n/);
    const chunks = [];
    for (const p of paragraphs) {
      const trimmedP = p.trim();
      if (trimmedP.length === 0)
        continue;
      if (trimmedP.length > chunkSize) {
        for (let i = 0; i < trimmedP.length; i += chunkSize) {
          chunks.push(trimmedP.substring(i, i + chunkSize));
        }
      } else {
        chunks.push(trimmedP);
      }
    }
    return chunks.filter((chunk) => chunk.length > 20);
  }
  /**
   * Індексує markdown файли: розбиває на чанки, генерує embeddings, зберігає в пам'яті.
   */
  async indexDocuments() {
    var _a, _b;
    if (!this.plugin.settings.ragEnabled) {
      this.plugin.logger.debug("[RagService] RAG indexing skipped (disabled in settings).");
      this.chunkEmbeddings = [];
      return;
    }
    if (!this.plugin.settings.ragEnableSemanticSearch) {
      this.plugin.logger.debug("[RagService] Semantic Search indexing skipped (disabled in settings).");
      this.chunkEmbeddings = [];
      return;
    }
    if (this.isIndexing) {
      this.plugin.logger.warn("[RagService] Indexing already in progress.");
      return;
    }
    this.isIndexing = true;
    this.plugin.logger.debug("[RagService] Starting semantic indexing...");
    const startTime = Date.now();
    this.embeddingModelName = this.plugin.settings.ragEmbeddingModel || DEFAULT_SETTINGS.ragEmbeddingModel;
    const chunkSize = this.plugin.settings.ragChunkSize || DEFAULT_SETTINGS.ragChunkSize;
    this.plugin.logger.debug(`[RagService] Using embedding model: ${this.embeddingModelName}, Chunk size: ${chunkSize}`);
    const newEmbeddings = [];
    try {
      const folderPath = this.plugin.settings.ragFolderPath;
      const vault = this.plugin.app.vault;
      const metadataCache = this.plugin.app.metadataCache;
      this.plugin.logger.debug(`[RagService] RAG folder path: "${folderPath}"`);
      const files = await this.getMarkdownFiles(vault, folderPath);
      this.plugin.logger.debug(`[RagService] Found ${files.length} markdown files in "${folderPath}".`);
      let processedFiles = 0;
      for (const file of files) {
        this.plugin.logger.debug(`[RagService] Processing file: ${file.path}`);
        try {
          const content = await vault.read(file);
          const fileCache = metadataCache.getFileCache(file);
          const frontmatter = (fileCache == null ? void 0 : fileCache.frontmatter) || {};
          let bodyContent = content;
          if (fileCache == null ? void 0 : fileCache.frontmatterPosition) {
            bodyContent = content.substring(fileCache.frontmatterPosition.end.offset).trim();
          }
          const chunks = this.splitIntoChunks(bodyContent, chunkSize);
          if (!chunks || chunks.length === 0) {
            this.plugin.logger.debug(`[RagService] No valid chunks found in ${file.path}, skipping.`);
            continue;
          }
          this.plugin.logger.debug(`[RagService] Generating ${chunks.length} embeddings for ${file.path} using ${this.embeddingModelName}...`);
          const vectors = await this.plugin.ollamaService.generateEmbeddings(chunks, this.embeddingModelName);
          if (vectors && vectors.length === chunks.length) {
            const metadata = {
              ...frontmatter,
              path: file.path,
              filename: file.name,
              created: (_a = file.stat) == null ? void 0 : _a.ctime,
              modified: (_b = file.stat) == null ? void 0 : _b.mtime,
              "personal-logs": frontmatter["personal-logs"] === true
            };
            for (let i = 0; i < chunks.length; i++) {
              newEmbeddings.push({
                text: chunks[i],
                vector: vectors[i],
                metadata
                // Додаємо однакові метадані до всіх чанків файлу
              });
            }
            this.plugin.logger.debug(`[RagService] Successfully embedded ${vectors.length} chunks from ${file.path}`);
            processedFiles++;
          } else {
            this.plugin.logger.warn(`[RagService] Mismatch or error generating embeddings for ${file.path}. Expected ${chunks.length}, got ${vectors == null ? void 0 : vectors.length}`);
          }
        } catch (error) {
          this.plugin.logger.error(`[RagService] Error processing file ${file.path}:`, error);
        }
      }
      this.chunkEmbeddings = newEmbeddings;
      const duration = (Date.now() - startTime) / 1e3;
      this.plugin.logger.debug(`[RagService] Semantic indexing complete in ${duration.toFixed(2)}s. Indexed ${this.chunkEmbeddings.length} chunks from ${processedFiles} files.`);
    } catch (error) {
      this.plugin.logger.error("[RagService] Error during indexing process:", error);
    } finally {
      this.isIndexing = false;
    }
  }
  /**
   * Get all markdown files in the specified folder path
   */
  async getMarkdownFiles(vault, folderPath) {
    const files = [];
    if (!folderPath) {
      this.plugin.logger.warn("[RagService] RAG folder path is not set.");
      return files;
    }
    const folder = vault.getAbstractFileByPath((0, import_obsidian5.normalizePath)(folderPath));
    if (!(folder instanceof import_obsidian5.TFolder)) {
      this.plugin.logger.warn(`[RagService] RAG folder path "${folderPath}" not found or is not a folder.`);
      return files;
    }
    const allFiles = vault.getMarkdownFiles();
    for (const file of allFiles) {
      if (file.path.startsWith(folder.path + "/")) {
        files.push(file);
      }
    }
    return files;
  }
  // --- Обчислення Косинусної Подібності ---
  calculateCosineSimilarity(vecA, vecB) {
    if (!vecA || !vecB || vecA.length !== vecB.length || vecA.length === 0) {
      return 0;
    }
    let dotProduct = 0;
    let normA = 0;
    let normB = 0;
    for (let i = 0; i < vecA.length; i++) {
      dotProduct += vecA[i] * vecB[i];
      normA += vecA[i] * vecA[i];
      normB += vecB[i] * vecB[i];
    }
    if (normA === 0 || normB === 0)
      return 0;
    const magnitude = Math.sqrt(normA) * Math.sqrt(normB);
    if (magnitude === 0)
      return 0;
    return dotProduct / magnitude;
  }
  // ----------------------------------------------------------------------------
  /**
   * Знаходить релевантні ЧАНКИ документів за допомогою семантичної подібності.
   * @param query Запит користувача.
   * @param limit Максимальна кількість чанків для повернення (з налаштувань topK).
   * @returns Масив об'єктів ChunkVector, відсортований за подібністю.
   */
  async findRelevantDocuments(query, limit) {
    var _a;
    if (!this.plugin.settings.ragEnableSemanticSearch) {
      this.plugin.logger.debug("[RagService] Semantic search disabled, skipping retrieval.");
      return [];
    }
    if (!this.chunkEmbeddings || this.chunkEmbeddings.length === 0 || !query) {
      if (((_a = this.chunkEmbeddings) == null ? void 0 : _a.length) === 0)
        this.plugin.logger.warn("[RagService] No chunk embeddings available for search. Index might be empty or disabled.");
      return [];
    }
    this.plugin.logger.debug(`[RagService] Performing semantic search for query: "${query}"`);
    const startTime = Date.now();
    try {
      const queryEmbeddings = await this.plugin.ollamaService.generateEmbeddings([query], this.embeddingModelName);
      if (!queryEmbeddings || queryEmbeddings.length === 0 || !queryEmbeddings[0]) {
        this.plugin.logger.error("[RagService] Failed to generate embedding for the query.");
        return [];
      }
      const queryVector = queryEmbeddings[0];
      const scoredChunks = this.chunkEmbeddings.map((chunk) => {
        const similarity = this.calculateCosineSimilarity(queryVector, chunk.vector);
        return { ...chunk, score: similarity };
      });
      const similarityThreshold = this.plugin.settings.ragSimilarityThreshold || DEFAULT_SETTINGS.ragSimilarityThreshold;
      const relevantChunks = scoredChunks.filter((chunk) => chunk.score >= similarityThreshold);
      relevantChunks.sort((a, b) => b.score - a.score);
      const duration = Date.now() - startTime;
      this.plugin.logger.debug(`[RagService] Semantic search completed in ${duration}ms. Found ${relevantChunks.length} chunks above threshold ${similarityThreshold}.`);
      return relevantChunks.slice(0, limit);
    } catch (error) {
      this.plugin.logger.error("[RagService] Error during semantic search:", error);
      return [];
    }
  }
  /**
   * Готує контекст для LLM з найбільш релевантних чанків документів.
   * @param query Запит користувача для пошуку релевантних чанків.
   * @returns Рядок з форматованим контекстом або порожній рядок.
   */
  async prepareContext(query) {
    if (!this.plugin.settings.ragEnabled) {
      return "";
    }
    if (this.plugin.settings.ragEnableSemanticSearch) {
      const topK = this.plugin.settings.ragTopK || DEFAULT_SETTINGS.ragTopK;
      const relevantChunks = await this.findRelevantDocuments(query, topK);
      if (relevantChunks.length === 0) {
        this.plugin.logger.debug("[RagService] No relevant documents found via semantic search for context.");
        return "";
      }
      this.plugin.logger.debug(`[RagService] Preparing context from ${relevantChunks.length} top chunks.`);
      let context = "### Context from User Notes (Semantic Search):\n\n";
      relevantChunks.forEach((chunk, index) => {
        var _a, _b, _c, _d;
        let header = `--- Chunk ${index + 1} from: ${((_a = chunk.metadata) == null ? void 0 : _a.filename) || chunk.metadata.path}`;
        if (((_b = chunk.metadata) == null ? void 0 : _b["personal-logs"]) === true)
          header += ` [Type: Personal Log]`;
        header += ` (Score: ${(_d = (_c = chunk.score) == null ? void 0 : _c.toFixed(3)) != null ? _d : "N/A"}) ---
`;
        context += header;
        context += chunk.text.trim() + "\n\n";
      });
      context += "### End of Context\n\n";
      return context.trim();
    } else {
      this.plugin.logger.debug("[RagService] Semantic search disabled. Using legacy keyword search (if implemented) or skipping RAG.");
      return "";
    }
  }
  // Додатково: Функції для старого пошуку, якщо ви їх залишаєте
  /*
      private findRelevantDocuments_Keyword(query: string, limit: number): DocumentVector[] {
          // ... ваша стара логіка пошуку за ключовими словами ...
          const scoredDocs = this.documents
            .map(doc => ({ doc, score: this.calculateRelevanceScore(doc, query) }))
            .filter(item => item.score > 0);
          scoredDocs.sort((a, b) => b.score - a.score);
          return scoredDocs.slice(0, limit).map(item => ({...item.doc, score: item.score}));
      }
  
      private formatKeywordContext(docs: DocumentVector[]): string {
           let context = "### Context from User Notes (Keyword Search):\n\n";
           docs.forEach((doc, index) => {
               let header = `--- Document ${index + 1}: ${doc.metadata?.filename || doc.path} (Score: ${doc.score?.toFixed(0)}) ---\n`;
               // ... решта форматування ...
               const contentToUse = doc.body || doc.content;
               const maxCharsPerDoc = this.plugin.settings.maxCharsPerDoc || 1500;
               const truncatedContent = contentToUse.length > maxCharsPerDoc
                 ? contentToUse.substring(0, maxCharsPerDoc) + "...\n[Content Truncated]"
                 : contentToUse;
               context += header + truncatedContent + "\n\n";
           });
           context += "### End of Context\n\n";
           return context.trim();
      }
      */
};

// src/OllamaService.ts
var import_obsidian6 = require("obsidian");
var OllamaService = class {
  // Keep event emitter for connection errors
  constructor(plugin) {
    this.eventHandlers = {};
    this.plugin = plugin;
    if (!plugin.promptService) {
      const errorMsg = "[OllamaService] CRITICAL: PromptService not available on plugin instance during OllamaService construction!";
      plugin.logger.error(errorMsg);
      throw new Error(errorMsg);
    }
    this.promptService = plugin.promptService;
  }
  on(event, callback) {
    if (!this.eventHandlers[event])
      this.eventHandlers[event] = [];
    this.eventHandlers[event].push(callback);
    return () => {
      var _a, _b;
      this.eventHandlers[event] = (_a = this.eventHandlers[event]) == null ? void 0 : _a.filter((h) => h !== callback);
      if (((_b = this.eventHandlers[event]) == null ? void 0 : _b.length) === 0)
        delete this.eventHandlers[event];
    };
  }
  emit(event, data) {
    const h = this.eventHandlers[event];
    if (h)
      h.slice().forEach((handler) => {
        try {
          handler(data);
        } catch (e) {
          console.error(`Error in OllamaService event handler for ${event}:`, e);
        }
      });
  }
  setBaseUrl(url) {
  }
  /**
   * Sends a raw request body to the Ollama /api/generate endpoint.
   */
  async generateRaw(requestBody) {
    var _a;
    this.plugin.logger.debug("[OllamaService] Sending RAW request to /api/generate:", { model: requestBody.model, temp: requestBody.temperature, system: !!requestBody.system, prompt_len: (_a = requestBody.prompt) == null ? void 0 : _a.length });
    if (!requestBody.model || !requestBody.prompt) {
      throw new Error("generateRaw requires 'model' and 'prompt' in requestBody");
    }
    if (!requestBody.system) {
      delete requestBody.system;
    }
    return await this._ollamaFetch(
      "/api/generate",
      "POST",
      // Explicitly pass method
      JSON.stringify(requestBody)
      // Pass the stringified body
    );
  }
  /**
   * Generates embeddings for a list of text prompts.
   */
  async generateEmbeddings(prompts, model) {
    if (!prompts || prompts.length === 0)
      return [];
    const endpoint = "/api/embeddings";
    this.plugin.logger.debug(`[OllamaService] Generating ${prompts.length} embeddings using model ${model}...`);
    const embeddingsList = [];
    try {
      for (const prompt of prompts) {
        const trimmedPrompt = prompt.trim();
        if (!trimmedPrompt) {
          this.plugin.logger.warn("[OllamaService] Skipping empty prompt for embedding.");
          continue;
        }
        const requestBody = JSON.stringify({ model, prompt: trimmedPrompt });
        try {
          const embeddingResponse = await this._ollamaFetch(
            endpoint,
            "POST",
            // Explicitly pass method
            requestBody
            // Pass the stringified body
          );
          if (embeddingResponse && embeddingResponse.embedding) {
            embeddingsList.push(embeddingResponse.embedding);
          } else {
            this.plugin.logger.warn(`[OllamaService] Invalid structure in embedding response for model ${model}. Prompt (start): "${trimmedPrompt.substring(0, 50)}..."`);
          }
        } catch (singleError) {
          this.plugin.logger.error(`[OllamaService] Failed to generate embedding for one prompt using model ${model}. Prompt (start): "${trimmedPrompt.substring(0, 50)}..."`, singleError);
        }
      }
      this.plugin.logger.debug(`[OllamaService] Successfully generated ${embeddingsList.length} embeddings (out of ${prompts.length} prompts).`);
      return embeddingsList.length > 0 ? embeddingsList : null;
    } catch (error) {
      this.plugin.logger.error(`[OllamaService] General error during embedding generation for model ${model}:`, error);
      return null;
    }
  }
  async getModels(forceRefresh = false) {
    const endpoint = "/api/tags";
    const fullUrlForLogging = `${this.plugin.settings.ollamaServerUrl}${endpoint}`;
    this.plugin.logger.debug(`[OllamaService] Fetching models from ${fullUrlForLogging}`);
    let modelListResult = [];
    try {
      const data = await this._ollamaFetch(
        endpoint,
        // Передаємо '/api/tags'
        "GET"
        // Передаємо метод
      );
      if (data && Array.isArray(data.models)) {
        const modelNames = data.models.map((m) => m == null ? void 0 : m.name).filter((name) => typeof name === "string" && name.length > 0).sort();
        this.plugin.logger.debug(`[OllamaService] Found ${modelNames.length} models.`);
        modelListResult = modelNames;
      } else {
        this.plugin.logger.warn("[OllamaService] Invalid response structure received from /api/tags (expected { models: [...] }):", data);
      }
    } catch (e) {
      this.plugin.logger.error(`[OllamaService] Failed to fetch models:`, e);
    }
    return modelListResult;
  }
  // End getModels
  async getModelDetails(modelName) {
    this.plugin.logger.debug(`[OllamaService] Fetching details for model: ${modelName}`);
    const endpoint = "/api/show";
    try {
      const data = await this._ollamaFetch(
        endpoint,
        "POST",
        // Explicitly pass method
        JSON.stringify({ name: modelName })
        // Pass the stringified body
      );
      return data;
    } catch (e) {
      this.plugin.logger.warn(`[OllamaService] Failed to get details for model ${modelName}:`, e);
      return null;
    }
  }
  /**
       * Private helper for fetch requests to Ollama API.
       * Now accepts method and optional string body.
       */
  // --- FIX: Changed method signature and implementation ---
  async _ollamaFetch(endpoint, method, body) {
    var _a, _b;
    const url = `${this.plugin.settings.ollamaServerUrl}${endpoint}`;
    const headers = { "Content-Type": "application/json" };
    try {
      const requestParams = { url, method, headers, body, throw: false };
      const response = await (0, import_obsidian6.requestUrl)(requestParams);
      if (response.status >= 400) {
        let errorText = `Ollama API error! Status: ${response.status} at ${endpoint}`;
        try {
          errorText += `: ${response.text || ((_a = response.json) == null ? void 0 : _a.error) || "No details"}`;
        } catch (e) {
        }
        this.plugin.logger.error(`[OllamaService] ${errorText}`);
        this.emit("connection-error", new Error(errorText));
        throw new Error(errorText);
      }
      if (response.status === 204 || !response.text) {
        const errorMsg = `Ollama API success status (${response.status}) but empty response body at ${endpoint}`;
        this.plugin.logger.warn(`[OllamaService] ${errorMsg}`);
        throw new Error(errorMsg);
      }
      try {
        const jsonData = response.json;
        if (jsonData === null || jsonData === void 0) {
          throw new Error(`Ollama API returned null/undefined JSON at ${endpoint}`);
        }
        return jsonData;
      } catch (jsonError) {
        this.plugin.logger.error(`[OllamaService] Failed to parse JSON response from ${url}. Status: ${response.status}`, jsonError, "Response Text:", response.text);
        throw new Error(`Failed to parse Ollama JSON response from ${endpoint}`);
      }
    } catch (error) {
      this.plugin.logger.error(`[OllamaService] Error in _ollamaFetch (${url}):`, error);
      const connectionErrorMsg = `Failed to connect/communicate with Ollama server at ${this.plugin.settings.ollamaServerUrl}. Is it running? (Endpoint: ${endpoint})`;
      if (!((_b = error.message) == null ? void 0 : _b.includes("Ollama API error"))) {
        this.emit("connection-error", new Error(connectionErrorMsg));
      }
      throw new Error(error.message || connectionErrorMsg);
    }
  }
  /**
       * Генерує відповідь чату, готуючи промпт та викликаючи generateRaw.
       */
  async generateChatResponse(chat) {
    var _a, _b;
    if (!chat) {
      this.plugin.logger.error("[OllamaService] generateChatResponse called with null chat.");
      return null;
    }
    if (!this.promptService) {
      this.plugin.logger.error("[OllamaService] PromptService is not initialized!");
      new import_obsidian6.Notice("Error: Prompt service is unavailable.");
      return null;
    }
    const currentSettings = this.plugin.settings;
    const modelName = chat.metadata.modelName || currentSettings.modelName;
    const temperature = (_a = chat.metadata.temperature) != null ? _a : currentSettings.temperature;
    if (!modelName) {
      this.plugin.logger.error("[OllamaService] No model specified in chat metadata or settings.");
      new import_obsidian6.Notice("Error: No Ollama model selected.");
      return null;
    }
    try {
      const history = chat.getMessages();
      this.plugin.logger.debug("[OllamaService] Getting system prompt from PromptService...");
      const systemPrompt = await this.promptService.getSystemPromptForAPI(chat.metadata);
      this.plugin.logger.debug("[OllamaService] Preparing prompt body from PromptService...");
      const promptBody = await this.promptService.preparePromptBody(history, chat.metadata);
      if (promptBody === null || promptBody === void 0) {
        this.plugin.logger.error("[OllamaService] Prompt body generation failed (returned null/undefined).");
        new import_obsidian6.Notice("Error: Could not generate prompt body.");
        return null;
      }
      const requestBody = {
        model: modelName,
        prompt: promptBody,
        // Тут вже є історія + RAG + завдання
        stream: false,
        temperature,
        options: { num_ctx: currentSettings.contextWindow },
        // Додаємо system, тільки якщо він існує і не порожній
        ...systemPrompt && { system: systemPrompt }
      };
      this.plugin.logger.debug(`[OllamaService] Calling generateRaw for chat response: Model:"${modelName}", Temp:${temperature}, System Prompt Provided: ${!!systemPrompt}`);
      this.plugin.logger.debug("[OllamaService] Request body (prompt truncated):", { ...requestBody, prompt: promptBody.substring(0, 200) + "..." });
      const responseData = await this.generateRaw(requestBody);
      if (responseData && typeof responseData.response === "string") {
        this.plugin.logger.debug(`[OllamaService] Received response. Length: ${responseData.response.length} chars`);
        const assistantMessage = {
          role: "assistant",
          content: responseData.response.trim(),
          timestamp: new Date(responseData.created_at || Date.now())
          // Використовуємо час відповіді або поточний
        };
        return assistantMessage;
      } else {
        this.plugin.logger.warn("[OllamaService] generateRaw returned unexpected structure or no response.", responseData);
        throw new Error("Received unexpected or empty response from the model.");
      }
    } catch (error) {
      this.plugin.logger.error("[OllamaService] Error during chat response generation cycle:", error);
      let errorMessage = error instanceof Error ? error.message : "Unknown error generating response.";
      if (errorMessage.includes("model not found")) {
        errorMessage = `Model '${modelName}' not found. Check Ollama server or model name.`;
      } else if (errorMessage.includes("context window")) {
        errorMessage = `Context window error (${currentSettings.contextWindow} tokens): ${error.message}. Adjust context settings.`;
      } else if (errorMessage.includes("connect") || errorMessage.includes("fetch") || errorMessage.includes("NetworkError") || ((_b = error.message) == null ? void 0 : _b.includes("Failed to connect"))) {
        errorMessage = `Connection Error: Failed to reach Ollama at ${currentSettings.ollamaServerUrl}. Is it running?`;
      }
      new import_obsidian6.Notice(errorMessage);
      return null;
    }
  }
};

// src/PromptService.ts
var import_obsidian7 = require("obsidian");
var PromptService = class {
  constructor(plugin) {
    this.currentSystemPrompt = null;
    // Кеш для системного промпту ролі
    this.currentRolePath = null;
    // Кеш для шляху поточної ролі
    this.roleCache = {};
    // Кеш для завантажених ролей
    this.modelDetailsCache = {};
    this.plugin = plugin;
    this.app = plugin.app;
  }
  _countTokens(text) {
    if (!text)
      return 0;
    return Math.ceil(text.length / 4);
  }
  clearRoleCache() {
    this.plugin.logger.debug("[PromptService] Clearing role definition cache.");
    this.roleCache = {};
    this.currentRolePath = null;
    this.currentSystemPrompt = null;
  }
  clearModelDetailsCache() {
    this.plugin.logger.debug("[PromptService] Clearing model details cache.");
    this.modelDetailsCache = {};
  }
  /**
   * Завантажує визначення ролі (системний промпт + тип) з файлу або кешу.
   */
  async getRoleDefinition(rolePath) {
    var _a, _b, _c;
    const normalizedPath = rolePath ? (0, import_obsidian7.normalizePath)(rolePath) : null;
    if (normalizedPath === this.currentRolePath && normalizedPath && this.roleCache[normalizedPath]) {
      return this.roleCache[normalizedPath];
    }
    if (normalizedPath !== this.currentRolePath) {
      this.plugin.logger.info(`[PromptService] Role path changing from '${this.currentRolePath}' to '${normalizedPath}'. Clearing cache.`);
      if (this.currentRolePath && this.roleCache[this.currentRolePath]) {
        delete this.roleCache[this.currentRolePath];
      }
      this.currentRolePath = normalizedPath;
      this.currentSystemPrompt = null;
    }
    if (!normalizedPath || !this.plugin.settings.followRole) {
      this.plugin.logger.debug("[PromptService] No role path or followRole disabled. Role definition is null.");
      return { systemPrompt: null, isProductivityPersona: false };
    }
    if (this.roleCache[normalizedPath]) {
      this.plugin.logger.debug(`[PromptService] Returning newly cached role definition for: ${normalizedPath}`);
      this.currentSystemPrompt = this.roleCache[normalizedPath].systemPrompt;
      return this.roleCache[normalizedPath];
    }
    this.plugin.logger.debug(`[PromptService] Loading role definition from file: ${normalizedPath}`);
    const file = this.app.vault.getAbstractFileByPath(normalizedPath);
    if (file instanceof import_obsidian7.TFile) {
      try {
        const fileCache = this.app.metadataCache.getFileCache(file);
        const frontmatter = fileCache == null ? void 0 : fileCache.frontmatter;
        const content = await this.app.vault.cachedRead(file);
        const systemPromptBody = ((_a = fileCache == null ? void 0 : fileCache.frontmatterPosition) == null ? void 0 : _a.end) ? content.substring(fileCache.frontmatterPosition.end.offset).trim() : content.trim();
        const isProductivity = ((_b = frontmatter == null ? void 0 : frontmatter.assistant_type) == null ? void 0 : _b.toLowerCase()) === "productivity" || (frontmatter == null ? void 0 : frontmatter.is_planner) === true;
        const definition = {
          systemPrompt: systemPromptBody || null,
          isProductivityPersona: isProductivity
        };
        this.plugin.logger.info(`[PromptService] Role loaded: ${normalizedPath}. Is Productivity: ${isProductivity}. Prompt length: ${((_c = definition.systemPrompt) == null ? void 0 : _c.length) || 0}`);
        this.roleCache[normalizedPath] = definition;
        this.currentSystemPrompt = definition.systemPrompt;
        return definition;
      } catch (error) {
        this.plugin.logger.error(`[PromptService] Error processing role file ${normalizedPath}:`, error);
        new import_obsidian7.Notice(`Error loading role: ${file.basename}. Check console.`);
        this.currentSystemPrompt = null;
        return null;
      }
    } else {
      this.plugin.logger.warn(`[PromptService] Role file not found or not a file: ${normalizedPath}`);
      this.currentSystemPrompt = null;
      return null;
    }
  }
  /**
   * Перевіряє, чи активна зараз роль "продуктивності".
   */
  async _isProductivityPersonaActive(rolePath) {
    var _a;
    if (!this.plugin.settings.enableProductivityFeatures) {
      return false;
    }
    const roleDefinition = await this.getRoleDefinition(rolePath);
    return (_a = roleDefinition == null ? void 0 : roleDefinition.isProductivityPersona) != null ? _a : false;
  }
  /**
  * Повертає фінальний системний промпт для API, можливо включаючи RAG інструкції.
  * Не включає RAG контент чи історію.
  */
  async getSystemPromptForAPI(chatMetadata) {
    var _a;
    const settings = this.plugin.settings;
    this.plugin.logger.debug(`[PromptService] getSystemPromptForAPI checking chat path: '${chatMetadata.selectedRolePath}', settings path: '${settings.selectedRolePath}'`);
    const selectedRolePath = chatMetadata.selectedRolePath !== void 0 && chatMetadata.selectedRolePath !== null ? chatMetadata.selectedRolePath : settings.selectedRolePath;
    this.plugin.logger.debug(`[PromptService] getSystemPromptForAPI using determined path: '${selectedRolePath}'`);
    let roleDefinition = null;
    if (selectedRolePath && settings.followRole) {
      this.plugin.logger.debug(`[PromptService] getSystemPromptForAPI loading definition for: '${selectedRolePath}'`);
      roleDefinition = await this.getRoleDefinition(selectedRolePath);
    } else {
      this.plugin.logger.debug(`[PromptService] getSystemPromptForAPI skipping role load (Path: '${selectedRolePath}', Follow: ${settings.followRole})`);
    }
    let roleSystemPrompt = (roleDefinition == null ? void 0 : roleDefinition.systemPrompt) || null;
    const isProductivityActive = (_a = roleDefinition == null ? void 0 : roleDefinition.isProductivityPersona) != null ? _a : false;
    const ragInstructions = `
--- RAG Data Interpretation Rules ---
1.  You have access to context chunks from the user's notes provided under '### Context from User Notes (...)'. Each chunk originates from a specific file indicated in its header.
2.  Context from files/chunks marked with "[Type: Personal Log]" contains personal reflections, activities, or logs. Use this for analysis of personal state, mood, energy, and progress.
3.  Assume ANY bullet point item (lines starting with '-', '*', '+') OR any line containing one or more hash tags (#tag) represents a potential user goal, task, objective, idea, or key point. **Pay special attention to categorizing these:**
    * **Critical Goals/Tasks:** Identify these if the line contains tags like #critical, #critical\u{1F198} or keywords like "\u043A\u0440\u0438\u0442\u0438\u0447\u043D\u043E", "critical", "\u0442\u0435\u0440\u043C\u0456\u043D\u043E\u0432\u043E", "urgent". **Prioritize discussing these items, potential blockers, and progress.**
    * **Weekly Goals/Tasks:** Identify these if the line contains tags like #week, #weekly or keywords like "weekly", "\u0442\u0438\u0436\u043D\u0435\u0432\u0430", "\u0442\u0438\u0436\u043D\u0435\u0432\u0438\u0439". Consider their relevance for the current or upcoming week's planning.
    * Use the surrounding text and the source document name for context for all identified items.
4.  You can refer to specific source files by their names mentioned in the context chunk headers (e.g., "Chunk 2 from 'My Notes.md' suggests...").
5.  If the user asks about "available data", "all my notes", "summarize my RAG data", or similar general terms, base your answer on the entire provided context ('### Context from User Notes (...)'). Analyze themes across different chunks and documents.
--- End RAG Data Interpretation Rules ---
        `.trim();
    let finalSystemPrompt = "";
    if (settings.ragEnabled && this.plugin.ragService && settings.ragEnableSemanticSearch) {
      finalSystemPrompt += ragInstructions + "\n\n";
      this.plugin.logger.debug("[PromptService] RAG instructions added to system prompt.");
    } else {
      this.plugin.logger.debug("[PromptService] RAG instructions NOT added (RAG disabled or semantic search disabled).");
    }
    if (roleSystemPrompt) {
      finalSystemPrompt += roleSystemPrompt.trim();
      this.plugin.logger.debug(`[PromptService] Role system prompt added (Length: ${roleSystemPrompt.trim().length})`);
    } else {
      this.plugin.logger.debug("[PromptService] No role system prompt to add.");
    }
    if (isProductivityActive && finalSystemPrompt && settings.enableProductivityFeatures) {
      const now = new Date();
      const formattedDate = now.toLocaleDateString(void 0, { weekday: "long", year: "numeric", month: "long", day: "numeric" });
      const formattedTime = now.toLocaleTimeString(void 0, { hour: "numeric", minute: "2-digit" });
      finalSystemPrompt = finalSystemPrompt.replace(/\[Current Time\]/gi, formattedTime);
      finalSystemPrompt = finalSystemPrompt.replace(/\[Current Date\]/gi, formattedDate);
      this.plugin.logger.debug("[PromptService] Dynamic date/time injected.");
    }
    const trimmedFinalPrompt = finalSystemPrompt.trim();
    this.plugin.logger.debug(`[PromptService] Final System Prompt Length: ${trimmedFinalPrompt.length} chars. Has content: ${trimmedFinalPrompt.length > 0}`);
    return trimmedFinalPrompt.length > 0 ? trimmedFinalPrompt : null;
  }
  /**
   * Готує ТІЛО основного промпту (без системного), включаючи історію, контекст завдань та RAG.
   */
  async preparePromptBody(history, chatMetadata) {
    var _a, _b, _c, _d, _e, _f, _g;
    this.plugin.logger.debug("[PromptService] Preparing prompt body...");
    const settings = this.plugin.settings;
    const selectedRolePath = chatMetadata.selectedRolePath !== void 0 && chatMetadata.selectedRolePath !== null ? chatMetadata.selectedRolePath : settings.selectedRolePath;
    const isProductivityActive = await this._isProductivityPersonaActive(selectedRolePath);
    this.plugin.logger.debug(`[PromptService] Productivity features potentially active for body: ${isProductivityActive}`);
    let taskContext = "";
    if (isProductivityActive && settings.enableProductivityFeatures && this.plugin.chatManager) {
      if ((_a = this.plugin.chatManager) == null ? void 0 : _a.filePlanExists) {
        const needsUpdateBefore = (_c = (_b = this.plugin).isTaskFileUpdated) == null ? void 0 : _c.call(_b);
        await ((_e = (_d = this.plugin).checkAndProcessTaskUpdate) == null ? void 0 : _e.call(_d));
        const tasksWereUpdated = needsUpdateBefore && !((_g = (_f = this.plugin).isTaskFileUpdated) == null ? void 0 : _g.call(_f));
        taskContext = tasksWereUpdated ? "\n--- Updated Tasks Context ---\n" : "\n--- Today's Tasks Context ---\n";
        taskContext += `Urgent: ${this.plugin.chatManager.fileUrgentTasks.join(", ") || "None"}
`;
        taskContext += `Other: ${this.plugin.chatManager.fileRegularTasks.join(", ") || "None"}
`;
        taskContext += "--- End Tasks Context ---";
        this.plugin.logger.debug(`[PromptService] Injecting task context.`);
      }
    }
    const approxTaskTokens = this._countTokens(taskContext);
    const maxRagTokens = settings.ragEnabled ? settings.ragTopK * settings.ragChunkSize / 4 * 1.5 : 0;
    const maxHistoryTokens = settings.contextWindow - approxTaskTokens - maxRagTokens - 200;
    this.plugin.logger.debug(`[PromptService] Max tokens available for history processing: ${maxHistoryTokens}`);
    let processedHistoryString = "";
    if (isProductivityActive && settings.useAdvancedContextStrategy) {
      processedHistoryString = await this._buildAdvancedContext(history, chatMetadata, maxHistoryTokens);
    } else {
      processedHistoryString = this._buildSimpleContext(history, maxHistoryTokens);
    }
    let ragContext = "";
    if (settings.ragEnabled && this.plugin.ragService) {
      const lastUserMessage = history.findLast((m) => m.role === "user");
      if (lastUserMessage == null ? void 0 : lastUserMessage.content) {
        ragContext = await this.plugin.ragService.prepareContext(lastUserMessage.content);
        if (!ragContext)
          this.plugin.logger.info("[PromptService] RAG prepareContext returned empty.");
      } else {
        this.plugin.logger.warn("[PromptService] RAG enabled, but no last user message found.");
      }
    }
    const finalPromptBody = `${ragContext}${taskContext}

### Conversation History:
${processedHistoryString}`.trim();
    this.plugin.logger.debug(`[PromptService] Final prompt body length (approx tokens): ${this._countTokens(finalPromptBody)}`);
    return finalPromptBody.length > 0 ? finalPromptBody : null;
  }
  // Методи _buildSimpleContext, _buildAdvancedContext, _summarizeMessages залишаються
  // але мають використовувати this.plugin.logger замість console.log/warn
  _buildSimpleContext(history, maxTokens) {
    let context = "";
    let currentTokens = 0;
    for (let i = history.length - 1; i >= 0; i--) {
      const message = history[i];
      const formattedMessage = `${message.role === "user" ? "User" : "Assistant"}: ${message.content.trim()}`;
      const messageTokens = this._countTokens(formattedMessage) + 5;
      if (currentTokens + messageTokens <= maxTokens) {
        context = formattedMessage + "\n\n" + context;
        currentTokens += messageTokens;
      } else {
        this.plugin.logger.debug(`[PromptService] Simple context limit reached (${currentTokens}/${maxTokens} tokens).`);
        break;
      }
    }
    return context.trim();
  }
  async _buildAdvancedContext(history, chatMetadata, maxTokens) {
    this.plugin.logger.debug("[PromptService] Building advanced context...");
    const settings = this.plugin.settings;
    const processedParts = [];
    let currentTokens = 0;
    const keepN = Math.min(history.length, settings.keepLastNMessagesBeforeSummary || 3);
    const messagesToKeep = history.slice(-keepN);
    const messagesToProcess = history.slice(0, -keepN);
    this.plugin.logger.debug(`[PromptService] Advanced Context: Keeping last ${messagesToKeep.length}, processing ${messagesToProcess.length} older messages.`);
    if (messagesToProcess.length > 0) {
      if (settings.enableSummarization) {
        this.plugin.logger.info("[PromptService] Summarization enabled...");
      } else {
        this.plugin.logger.info("[PromptService] Summarization disabled. Including older messages directly if space allows.");
      }
    }
    this.plugin.logger.debug(`[PromptService] Advanced context built. Total approx tokens: ${currentTokens}`);
    return processedParts.join("\n\n").trim();
  }
  async _summarizeMessages(messagesToSummarize, chatMetadata) {
    if (!this.plugin.settings.enableSummarization || messagesToSummarize.length === 0) {
      return null;
    }
    this.plugin.logger.info(`[PromptService] Summarizing chunk of ${messagesToSummarize.length} messages...`);
    const textToSummarize = messagesToSummarize.map((m) => `${m.role === "user" ? "User" : "Assistant"}: ${m.content.trim()}`).join("\n");
    if (!textToSummarize.trim()) {
      this.plugin.logger.warn("[PromptService] No actual text content in messages to summarize.");
      return null;
    }
    const summarizationPromptTemplate = this.plugin.settings.summarizationPrompt || "Summarize the following conversation concisely:\n\n{text_to_summarize}";
    const summarizationFullPrompt = summarizationPromptTemplate.replace("{text_to_summarize}", textToSummarize);
    const modelName = chatMetadata.modelName || this.plugin.settings.modelName;
    const summarizationContextWindow = Math.min(this.plugin.settings.contextWindow || 4096, 4096);
    const requestBody = {
      model: modelName,
      prompt: summarizationFullPrompt,
      stream: false,
      temperature: 0.3,
      options: {
        num_ctx: summarizationContextWindow
      },
      system: "You are a helpful assistant specializing in concisely summarizing conversation history. Focus on extracting key points and decisions."
    };
    try {
      if (!this.plugin.ollamaService) {
        this.plugin.logger.error("[PromptService] OllamaService is not available for summarization.");
        return null;
      }
      const responseData = await this.plugin.ollamaService.generateRaw(requestBody);
      if (responseData && typeof responseData.response === "string") {
        const summary = responseData.response.trim();
        this.plugin.logger.info(`[PromptService] Summarization successful (${this._countTokens(summary)} tokens).`);
        return summary;
      } else {
        this.plugin.logger.warn("[PromptService] Summarization request returned unexpected structure:", responseData);
        return null;
      }
    } catch (error) {
      this.plugin.logger.error("[PromptService] Error during summarization request:", error, "Request body (first 100 chars):", JSON.stringify(requestBody).substring(0, 100));
      return null;
    }
  }
};

// src/ChatManager.ts
var import_obsidian9 = require("obsidian");

// src/Chat.ts
var import_obsidian8 = require("obsidian");
var Chat = class {
  // Debounced function for saving
  /**
   * Creates an instance of Chat. Should be called by ChatManager.
   * @param adapter - Obsidian's DataAdapter.
   * @param settings - Plugin settings relevant for chat operation.
   * @param data - The initial chat data (metadata and messages).
   * @param filePath - The full, normalized path where this chat should be saved/loaded from within the vault. **Required**.
   */
  constructor(adapter, settings, data, filePath) {
    var _a, _b, _c;
    this.adapter = adapter;
    this.pluginSettings = settings;
    if (!filePath || typeof filePath !== "string" || filePath.trim() === "") {
      const errorMsg = "[Chat] Critical Error: Chat constructor called without a valid filePath.";
      console.error(errorMsg, { settings, data });
      this.filePath = `INVALID_PATH_${((_a = data == null ? void 0 : data.metadata) == null ? void 0 : _a.id) || Date.now()}.json`;
      new import_obsidian8.Notice("Critical Error: Chat created without a valid save path!");
    } else {
      this.filePath = (0, import_obsidian8.normalizePath)(filePath);
    }
    console.log(`[Chat ${(_c = (_b = data == null ? void 0 : data.metadata) == null ? void 0 : _b.id) != null ? _c : "initializing"}] Initialized. File path set to: ${this.filePath}`);
    this.metadata = data.metadata;
    this.messages = data.messages.map((m) => ({
      ...m,
      timestamp: new Date(m.timestamp)
      // Ensure timestamp is a Date object
    }));
    this.debouncedSave = (0, import_obsidian8.debounce)(this._saveToFile.bind(this), 1500, true);
  }
  // --- Message Management ---
  /**
   * Adds a new message to the chat history.
   * Updates the lastModified timestamp and triggers a debounced save.
   * @param role - The role of the message sender ('user', 'assistant', etc.).
   * @param content - The text content of the message.
   * @param timestamp - The timestamp for the message (defaults to now).
   * @returns The newly added message object.
   */
  addMessage(role, content, timestamp = new Date()) {
    const newMessage = { role, content, timestamp };
    this.messages.push(newMessage);
    this.metadata.lastModified = timestamp.toISOString();
    this.save();
    return newMessage;
  }
  /** Returns a copy of the chat messages array. */
  getMessages() {
    return [...this.messages];
  }
  /** Clears all messages from the chat history. Updates lastModified and saves. */
  clearMessages() {
    console.log(`[Chat ${this.metadata.id}] Clearing messages.`);
    this.messages = [];
    this.metadata.lastModified = new Date().toISOString();
    this.save();
  }
  /**
   * Updates specified metadata fields for the chat.
   * Automatically updates the lastModified timestamp and triggers a save.
   * @param updates - An object containing metadata fields to update (cannot update 'id' or 'createdAt').
   */
  updateMetadata(updates) {
    const originalId = this.metadata.id;
    const originalCreatedAt = this.metadata.createdAt;
    this.metadata = {
      ...this.metadata,
      ...updates,
      id: originalId,
      // Preserve original ID
      createdAt: originalCreatedAt,
      // Preserve original creation date
      lastModified: new Date().toISOString()
      // Always update last modified
    };
    console.log(`[Chat ${this.metadata.id}] Metadata updated:`, updates);
    this.save();
  }
  // --- Persistence ---
  /** Triggers a debounced save if message history saving is enabled. */
  save() {
    if (this.pluginSettings.saveMessageHistory) {
      this.debouncedSave();
    } else {
    }
  }
  /**
   * Saves the current chat state to its file immediately.
   * Bypasses the debounce timer. Returns true on success, false on failure.
   */
  async saveImmediately() {
    if (!this.pluginSettings.saveMessageHistory) {
      console.log(`[Chat ${this.metadata.id}] Save disabled, immediate save skipped for ${this.filePath}.`);
      return true;
    }
    return await this._saveToFile();
  }
  /**
   * Internal method to perform the actual file writing operation.
   * Creates necessary directories if they don't exist.
   */
  async _saveToFile() {
    const chatData = {
      metadata: this.metadata,
      messages: this.messages.map((m) => ({
        ...m,
        timestamp: m.timestamp.toISOString()
        // Cast to any to satisfy type, it's a string
      }))
    };
    const jsonString = JSON.stringify(chatData, null, 2);
    try {
      const dirPath = this.filePath.substring(0, this.filePath.lastIndexOf("/"));
      if (dirPath && !await this.adapter.exists(dirPath)) {
        console.log(`[Chat ${this.metadata.id}] Directory ${dirPath} does not exist. Creating...`);
        await this.adapter.mkdir(dirPath);
        console.log(`[Chat ${this.metadata.id}] Directory ${dirPath} created.`);
      }
      await this.adapter.write(this.filePath, jsonString);
      return true;
    } catch (error) {
      console.error(`[Chat ${this.metadata.id}] Error saving chat to ${this.filePath}:`, error);
      new import_obsidian8.Notice(`Error saving chat: ${this.metadata.name}. Check console.`);
      return false;
    }
  }
  /**
   * Static method to load chat data from a specified file path within the vault.
   * Called by ChatManager.
   * @param filePath - The full, normalized path to the chat file.
   * @param adapter - Obsidian's DataAdapter.
   * @param settings - Plugin settings.
   * @returns A new Chat instance or null if loading fails.
   */
  static async loadFromFile(filePath, adapter, settings) {
    var _a;
    const normPath = (0, import_obsidian8.normalizePath)(filePath);
    console.log(`[Chat] Static loadFromFile attempting for vault path: ${normPath}`);
    try {
      if (!await adapter.exists(normPath)) {
        console.warn(`[Chat] File not found for loading: ${normPath}`);
        return null;
      }
      const json = await adapter.read(normPath);
      const data = JSON.parse(json);
      if (((_a = data == null ? void 0 : data.metadata) == null ? void 0 : _a.id) && Array.isArray(data.messages)) {
        console.log(`[Chat] Successfully parsed data for static load, creating Chat instance for ID: ${data.metadata.id}`);
        return new Chat(adapter, settings, data, normPath);
      } else {
        console.error(`[Chat] Invalid data structure in file for static load: ${normPath}`, data);
        new import_obsidian8.Notice(`Error loading chat: Invalid data structure in ${filePath}`);
        return null;
      }
    } catch (e) {
      console.error(`[Chat] Error loading or parsing file for static load: ${normPath}`, e);
      new import_obsidian8.Notice(`Error loading chat file: ${filePath}. ${e.message}`);
      return null;
    }
  }
  /**
   * Deletes the chat's associated `.json` file from the vault.
   * @returns true if the file was deleted or didn't exist, false on error.
   */
  async deleteFile() {
    console.log(`[Chat ${this.metadata.id}] Attempting to delete file: ${this.filePath}`);
    try {
      if (await this.adapter.exists(this.filePath)) {
        await this.adapter.remove(this.filePath);
        console.log(`[Chat ${this.metadata.id}] Successfully deleted file: ${this.filePath}`);
        return true;
      }
      console.log(`[Chat ${this.metadata.id}] File already deleted or never existed: ${this.filePath}`);
      return true;
    } catch (e) {
      console.error(`[Chat ${this.metadata.id}] Error deleting file ${this.filePath}:`, e);
      new import_obsidian8.Notice(`Error deleting chat file: ${this.metadata.name}. Check console.`);
      return false;
    }
  }
};

// src/ChatManager.ts
var path = __toESM(require("path"));
var SESSIONS_INDEX_KEY = "chatSessionsIndex_v1";
var ACTIVE_SESSION_ID_KEY = "activeChatSessionId_v1";
var ChatManager = class {
  // Звичайні завдання з файлу
  constructor(plugin) {
    // Obsidian Vault Adapter
    this.chatsFolderPath = "/";
    // Шлях до папки чатів В СХОВИЩІ
    this.sessionIndex = {};
    // In-memory index of available chats {id: metadata}
    this.activeChatId = null;
    this.loadedChats = {};
    // Cache for loaded Chat objects
    this.filePlanExists = false;
    // Стан файлу плану
    this.fileUrgentTasks = [];
    // Термінові завдання з файлу
    this.fileRegularTasks = [];
    this.plugin = plugin;
    this.app = plugin.app;
    this.adapter = plugin.app.vault.adapter;
    this.updateChatsFolderPath();
    console.log(`[ChatManager] Initialized. Base path set to: ${this.chatsFolderPath}`);
  }
  /**
   * Оновлює внутрішній шлях `chatsFolderPath` на основі поточних налаштувань плагіна.
   */
  updateChatsFolderPath() {
    var _a;
    const settingsPath = (_a = this.plugin.settings.chatHistoryFolderPath) == null ? void 0 : _a.trim();
    this.chatsFolderPath = settingsPath ? (0, import_obsidian9.normalizePath)(settingsPath) : "/";
    console.log(`[ChatManager] Updated chatsFolderPath to: ${this.chatsFolderPath}`);
  }
  /** Оновлює стан завдань на основі даних, отриманих з плагіна. */
  updateTaskState(tasks) {
    if (tasks) {
      this.filePlanExists = tasks.hasContent;
      this.fileUrgentTasks = [...tasks.urgent];
      this.fileRegularTasks = [...tasks.regular];
    } else {
      this.filePlanExists = false;
      this.fileUrgentTasks = [];
      this.fileRegularTasks = [];
    }
  }
  /**
   * Ініціалізує ChatManager: оновлює шлях, перевіряє папку, завантажує індекс та активний ID.
   */
  async initialize() {
    console.log("[ChatManager] Initializing...");
    this.updateChatsFolderPath();
    await this.ensureChatsFolderExists();
    await this.loadChatIndex(true);
    this.activeChatId = await this.plugin.loadDataKey(ACTIVE_SESSION_ID_KEY) || null;
    if (this.activeChatId && !this.sessionIndex[this.activeChatId]) {
      this.activeChatId = null;
      await this.plugin.saveDataKey(ACTIVE_SESSION_ID_KEY, null);
    } else if (this.activeChatId) {
    }
  }
  /**
   * Гарантує існування папки для історії чатів.
   */
  async ensureChatsFolderExists() {
    if (this.chatsFolderPath === "/" || !this.chatsFolderPath) {
      return;
    }
    try {
      if (!await this.adapter.exists(this.chatsFolderPath)) {
        await this.adapter.mkdir(this.chatsFolderPath);
      } else {
        const stat = await this.adapter.stat(this.chatsFolderPath);
        if ((stat == null ? void 0 : stat.type) !== "folder") {
          const errorMsg = `Error: Configured chat history path '${this.chatsFolderPath}' exists but is not a folder.`;
          console.error(`[ChatManager] ${errorMsg}`);
          new import_obsidian9.Notice(errorMsg);
        }
      }
    } catch (error) {
      const errorMsg = `Error creating/checking chat history directory '${this.chatsFolderPath}'.`;
      console.error(`[ChatManager] ${errorMsg}`, error);
      new import_obsidian9.Notice(errorMsg);
    }
  }
  /**
   * Завантажує або оновлює індекс чатів, скануючи файли у папці історії.
   * @param forceScanFromFile Завжди true для пересканування.
   */
  async loadChatIndex(forceScanFromFile = true) {
    var _a;
    if (!forceScanFromFile) {
      const loadedIndex = await this.plugin.loadDataKey(SESSIONS_INDEX_KEY);
      this.sessionIndex = loadedIndex || {};
      return;
    }
    const newIndex = {};
    let filesScanned = 0;
    let chatsLoaded = 0;
    try {
      if (!await this.adapter.exists(this.chatsFolderPath) && this.chatsFolderPath !== "/") {
        console.warn(`[ChatManager] Chat history folder '${this.chatsFolderPath}' not found. Index is empty.`);
        this.sessionIndex = {};
        await this.saveChatIndex();
        return;
      }
      const listResult = await this.adapter.list(this.chatsFolderPath);
      const chatFiles = listResult.files.filter(
        (filePath) => filePath.toLowerCase().endsWith(".json")
        // Тільки .json
      );
      filesScanned = chatFiles.length;
      this.plugin.logger.info(`[ChatManager] Found ${filesScanned} potential chat files.`);
      for (const filePath of chatFiles) {
        const fullPath = (0, import_obsidian9.normalizePath)(filePath);
        const fileName = path.basename(fullPath);
        const chatId = fileName.endsWith(".json") ? fileName.slice(0, -5) : null;
        if (!chatId) {
          console.warn(`[ChatManager] Could not extract chat ID from file path: ${fullPath}`);
          continue;
        }
        try {
          const jsonContent = await this.adapter.read(fullPath);
          const data = JSON.parse(jsonContent);
          if (((_a = data == null ? void 0 : data.metadata) == null ? void 0 : _a.id) && data.metadata.id === chatId) {
            const metadata = data.metadata;
            newIndex[chatId] = {
              name: metadata.name,
              modelName: metadata.modelName,
              selectedRolePath: metadata.selectedRolePath,
              temperature: metadata.temperature,
              createdAt: metadata.createdAt,
              lastModified: metadata.lastModified
            };
            chatsLoaded++;
          } else {
            console.warn(`[ChatManager] Metadata validation FAILED for file: ${fullPath}. ID mismatch or missing metadata. ChatID from filename: ${chatId}`, data == null ? void 0 : data.metadata);
          }
        } catch (e) {
          console.error(`[ChatManager] Error reading or parsing chat file ${fullPath}:`, e);
        }
      }
      this.plugin.logger.info(`[ChatManager] Index rebuild complete. Scanned: ${filesScanned}, Loaded metadata for: ${chatsLoaded}`);
      this.sessionIndex = newIndex;
      await this.saveChatIndex();
    } catch (error) {
      this.plugin.logger.error(`[ChatManager] Critical error during index rebuild:`, error);
      this.sessionIndex = {};
      await this.saveChatIndex();
    }
  }
  /** Зберігає поточний індекс чатів у сховище плагіна. */
  async saveChatIndex() {
    await this.plugin.saveDataKey(SESSIONS_INDEX_KEY, this.sessionIndex);
  }
  /** Генерує повний шлях до файлу чату. */
  getChatFilePath(id) {
    const fileName = `${id}.json`;
    return this.chatsFolderPath === "/" || !this.chatsFolderPath ? (0, import_obsidian9.normalizePath)(fileName) : (0, import_obsidian9.normalizePath)(`${this.chatsFolderPath}/${fileName}`);
  }
  /** Зберігає дані вказаного чату у файл. */
  async saveChat(chat) {
    try {
      const filePath = this.getChatFilePath(chat.metadata.id);
      chat.metadata.lastModified = new Date().toISOString();
      const dataToSave = {
        metadata: chat.metadata,
        messages: chat.getMessages()
      };
      await this.adapter.write(filePath, JSON.stringify(dataToSave, null, 2));
      this.sessionIndex[chat.metadata.id] = { ...chat.metadata };
      delete this.sessionIndex[chat.metadata.id].id;
      await this.saveChatIndex();
      this.plugin.emit("chat-list-updated");
      return true;
    } catch (error) {
      console.error(`[ChatManager] Error saving chat ${chat.metadata.id} to ${chat.filePath}:`, error);
      new import_obsidian9.Notice(`Error saving chat: ${chat.metadata.name}`);
      return false;
    }
  }
  /** Створює новий чат. */
  async createNewChat(name) {
    console.log("[ChatManager] Creating new chat...");
    try {
      const now = new Date();
      const newId = `chat_${now.getTime()}_${Math.random().toString(36).substring(2, 8)}`;
      const filePath = this.getChatFilePath(newId);
      const initialMetadata = {
        id: newId,
        name: name || `Chat ${now.toLocaleDateString()} ${now.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })}`,
        // Use locale time format
        modelName: this.plugin.settings.modelName,
        selectedRolePath: this.plugin.settings.selectedRolePath,
        temperature: this.plugin.settings.temperature,
        createdAt: now.toISOString(),
        lastModified: now.toISOString()
      };
      const constructorSettings = { ...this.plugin.settings };
      const newChat = new Chat(this.adapter, constructorSettings, { metadata: initialMetadata, messages: [] }, filePath);
      const saved = await this.saveChat(newChat);
      if (!saved) {
        throw new Error("Failed to save initial chat file via saveChat.");
      }
      this.loadedChats[newChat.metadata.id] = newChat;
      await this.setActiveChat(newChat.metadata.id);
      return newChat;
    } catch (error) {
      console.error("[ChatManager] Error creating new chat:", error);
      new import_obsidian9.Notice("Error creating new chat session.");
      return null;
    }
  }
  /** Повертає масив метаданих всіх доступних чатів, відсортований за датою зміни. */
  listAvailableChats() {
    return Object.entries(this.sessionIndex).map(([id, meta]) => ({
      id,
      ...meta
    })).sort((a, b) => new Date(b.lastModified).getTime() - new Date(a.lastModified).getTime());
  }
  /** Повертає ID поточного активного чату. */
  getActiveChatId() {
    return this.activeChatId;
  }
  /** Встановлює активний чат за його ID. */
  async setActiveChat(id) {
    if (id && !this.sessionIndex[id]) {
      console.error(`[ChatManager] Attempted to set active chat to non-existent ID: ${id}. Setting to null.`);
      id = null;
    }
    if (id === this.activeChatId) {
      if (id)
        await this.getChat(id);
      return;
    }
    this.activeChatId = id;
    await this.plugin.saveDataKey(ACTIVE_SESSION_ID_KEY, id);
    let loadedChat = null;
    if (id) {
      loadedChat = await this.getChat(id);
      if (!loadedChat) {
        console.error(`[ChatManager] Failed to load chat data for newly activated ID ${id}. Resetting active chat to null.`);
        await this.setActiveChat(null);
        return;
      }
    }
    this.plugin.emit("active-chat-changed", { chatId: id, chat: loadedChat });
  }
  /** Отримує конкретний чат за ID (з кешу або файлу). */
  async getChat(id) {
    if (this.loadedChats[id]) {
      return this.loadedChats[id];
    }
    if (this.sessionIndex[id]) {
      const filePath = this.getChatFilePath(id);
      const constructorSettings = { ...this.plugin.settings };
      const chat = await Chat.loadFromFile(filePath, this.adapter, constructorSettings);
      if (chat) {
        this.loadedChats[id] = chat;
        return chat;
      } else {
        console.error(`[ChatManager] Failed to load chat ${id} from ${filePath}. Removing from index.`);
        delete this.sessionIndex[id];
        await this.saveChatIndex();
        if (this.activeChatId === id) {
          await this.setActiveChat(null);
        }
        this.plugin.emit("chat-list-updated");
        return null;
      }
    }
    console.warn(`[ChatManager] Chat with ID ${id} not found in session index.`);
    return null;
  }
  /** Отримує поточний активний чат (або останній, або створює новий). */
  async getActiveChat() {
    if (this.activeChatId) {
      const chat = await this.getChat(this.activeChatId);
      if (chat)
        return chat;
      console.warn(`[ChatManager] Active chat ${this.activeChatId} failed to load. Finding alternative.`);
    }
    const availableChats = this.listAvailableChats();
    if (availableChats.length > 0) {
      const mostRecentId = availableChats[0].id;
      await this.setActiveChat(mostRecentId);
      return this.activeChatId ? this.loadedChats[this.activeChatId] : null;
    } else {
      return await this.createNewChat();
    }
  }
  /** Додає повідомлення до активного чату. */
  async addMessageToActiveChat(role, content) {
    const activeChat = await this.getActiveChat();
    if (activeChat) {
      const newMessage = activeChat.addMessage(role, content);
      this.sessionIndex[activeChat.metadata.id].lastModified = new Date().toISOString();
      await this.saveChatIndex();
      this.plugin.emit("message-added", { chatId: activeChat.metadata.id, message: newMessage });
      this.plugin.emit("chat-list-updated");
      return newMessage;
    } else {
      console.error("[ChatManager] Cannot add message, no active chat.");
      new import_obsidian9.Notice("Error: No active chat session to add message to.");
      return null;
    }
  }
  /** Очищує історію повідомлень активного чату. */
  async clearActiveChatMessages() {
    const activeChat = await this.getActiveChat();
    if (activeChat) {
      activeChat.clearMessages();
      this.plugin.emit("messages-cleared", activeChat.metadata.id);
    } else {
      console.warn("[ChatManager] Cannot clear messages, no active chat.");
      new import_obsidian9.Notice("No active chat to clear.");
    }
  }
  /** Оновлює метадані активного чату та генерує відповідні події. */
  // ChatManager.ts
  /** Оновлює метадані активного чату та генерує відповідні події. */
  async updateActiveChatMetadata(metadataUpdate) {
    var _a, _b, _c, _d;
    const activeChat = await this.getActiveChat();
    if (!activeChat) {
      console.warn("[ChatManager] Cannot update metadata, no active chat.");
      new import_obsidian9.Notice("No active chat to update metadata for.");
      return false;
    }
    const oldRolePath = activeChat.metadata.selectedRolePath;
    const oldModelName = activeChat.metadata.modelName;
    activeChat.updateMetadata(metadataUpdate);
    const saved = await this.saveChat(activeChat);
    if (saved) {
      const newRolePath = activeChat.metadata.selectedRolePath;
      const newModelName = activeChat.metadata.modelName;
      if (metadataUpdate.selectedRolePath !== void 0 && oldRolePath !== newRolePath) {
        try {
          const newRoleName = this.plugin.findRoleNameByPath(newRolePath);
          this.plugin.emit("role-changed", newRoleName);
          (_b = (_a = this.plugin.promptService) == null ? void 0 : _a.clearRoleCache) == null ? void 0 : _b.call(_a);
        } catch (e) {
          console.error("[ChatManager] Error finding role name or emitting role-changed event:", e);
        }
      }
      if (metadataUpdate.modelName !== void 0 && oldModelName !== newModelName) {
        this.plugin.emit("model-changed", newModelName);
        (_d = (_c = this.plugin.promptService) == null ? void 0 : _c.clearModelDetailsCache) == null ? void 0 : _d.call(_c);
      }
      this.plugin.emit("active-chat-changed", { chatId: this.activeChatId, chat: activeChat });
      return true;
    } else {
      console.error(`[ChatManager] Failed to save chat file after metadata update for ${activeChat.metadata.id}.`);
      new import_obsidian9.Notice("Error saving chat after metadata update.");
      return false;
    }
  }
  // ... (решта коду ChatManager) ...
  /** Видаляє чат за ID. */
  async deleteChat(id) {
    const filePath = this.getChatFilePath(id);
    let deletedFile = false;
    try {
      if (await this.adapter.exists(filePath)) {
        await this.adapter.remove(filePath);
      } else {
        console.warn(`[ChatManager] Chat file not found, assuming already deleted: ${filePath}`);
      }
      deletedFile = true;
    } catch (error) {
      console.error(`[ChatManager] Error deleting chat file ${filePath}:`, error);
      new import_obsidian9.Notice(`Error deleting chat file for ID ${id}.`);
      deletedFile = false;
    }
    if (this.sessionIndex[id]) {
      delete this.sessionIndex[id];
      delete this.loadedChats[id];
      await this.saveChatIndex();
      if (this.activeChatId === id) {
        const available = this.listAvailableChats();
        const nextActiveId = available.length > 0 ? available[0].id : null;
        await this.setActiveChat(nextActiveId);
      }
      this.plugin.emit("chat-list-updated");
      return true;
    } else {
      console.warn(`[ChatManager] Chat ${id} not found in index while trying to delete.`);
      return deletedFile;
    }
  }
  /** Перейменовує чат за ID. */
  async renameChat(id, newName) {
    const trimmedName = newName.trim();
    if (!trimmedName) {
      new import_obsidian9.Notice("Chat name cannot be empty.");
      return false;
    }
    if (!this.sessionIndex[id]) {
      console.warn(`[ChatManager] Cannot rename chat ${id}: Not found in index.`);
      new import_obsidian9.Notice(`Chat with ID ${id} not found.`);
      return false;
    }
    console.log(`[ChatManager] Renaming chat ${id} to "${trimmedName}"`);
    const chatToRename = await this.getChat(id);
    if (!chatToRename) {
      console.error(`[ChatManager] Failed to load chat ${id} for renaming.`);
      new import_obsidian9.Notice(`Error loading chat data for rename.`);
      return false;
    }
    chatToRename.updateMetadata({ name: trimmedName });
    const saved = await this.saveChat(chatToRename);
    if (saved) {
      new import_obsidian9.Notice(`Chat renamed to "${trimmedName}"`);
      return true;
    } else {
      console.error(`[ChatManager] Failed to save renamed chat file for ${id}.`);
      new import_obsidian9.Notice(`Error saving renamed chat ${trimmedName}.`);
      return false;
    }
  }
  /** Створює копію існуючого чату. */
  async cloneChat(chatIdToClone) {
    const originalChat = await this.getChat(chatIdToClone);
    if (!originalChat) {
      console.error(`[ChatManager] Cannot clone: Original chat ${chatIdToClone} not found.`);
      new import_obsidian9.Notice("Original chat not found for cloning.");
      return null;
    }
    try {
      const now = new Date();
      const newId = `chat_${now.getTime()}_${Math.random().toString(36).substring(2, 8)}`;
      const newFilePath = this.getChatFilePath(newId);
      const originalMetadata = originalChat.metadata;
      const clonedMetadata = {
        ...originalMetadata,
        id: newId,
        name: `Copy of ${originalMetadata.name}`,
        createdAt: now.toISOString(),
        lastModified: now.toISOString()
      };
      const clonedChatData = {
        metadata: clonedMetadata,
        messages: originalChat.getMessages().map((msg) => ({ ...msg }))
      };
      const constructorSettings = { ...this.plugin.settings };
      const clonedChat = new Chat(this.adapter, constructorSettings, clonedChatData, newFilePath);
      const saved = await this.saveChat(clonedChat);
      if (!saved) {
        throw new Error("Failed to save the cloned chat file.");
      }
      this.loadedChats[clonedChat.metadata.id] = clonedChat;
      await this.setActiveChat(clonedChat.metadata.id);
      return clonedChat;
    } catch (error) {
      console.error("[ChatManager] Error cloning chat:", error);
      new import_obsidian9.Notice("An error occurred while cloning the chat.");
      return null;
    }
  }
};

// src/main.ts
var import_child_process = require("child_process");

// src/TranslationService.ts
var import_obsidian10 = require("obsidian");
var GOOGLE_TRANSLATE_API_URL = "https://translation.googleapis.com/language/translate/v2";
var TranslationService = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  /**
   * Translates text using the Google Translate API.
   * @param text The text to translate.
   * @param targetLang The target language code (e.g., 'uk', 'en', 'de').
   * @returns The translated text or null if translation fails.
   */
  async translate(text, targetLang) {
    var _a, _b;
    const apiKey = this.plugin.settings.googleTranslationApiKey;
    if (!this.plugin.settings.enableTranslation) {
      console.warn("Translation feature is disabled in settings.");
      return null;
    }
    if (!apiKey) {
      console.error("Google Translation API Key is missing.");
      new import_obsidian10.Notice("Translation Error: Google Cloud Translation API Key is not configured in settings.");
      return null;
    }
    if (!text) {
      console.warn("Translate called with empty text.");
      return "";
    }
    if (!targetLang) {
      console.error("Target language is not set for translation.");
      new import_obsidian10.Notice("Translation Error: Target language not configured.");
      return null;
    }
    console.log(`[TranslationService] Translating to ${targetLang}...`);
    try {
      const response = await fetch(`${GOOGLE_TRANSLATE_API_URL}?key=${apiKey}`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          q: text,
          target: targetLang,
          format: "text"
          // Request plain text translation
        })
      });
      const data = await response.json();
      if (!response.ok) {
        const errorMsg = ((_a = data.error) == null ? void 0 : _a.message) || `HTTP error ${response.status}`;
        console.error(`Google Translate API error: ${errorMsg}`, data);
        new import_obsidian10.Notice(`Translation Error: ${errorMsg}`);
        return null;
      }
      if (((_b = data.data) == null ? void 0 : _b.translations) && data.data.translations.length > 0) {
        const translatedText = this.decodeHtmlEntities(data.data.translations[0].translatedText);
        console.log("[TranslationService] Translation successful.");
        return translatedText;
      } else {
        console.error("Google Translate API returned unexpected response structure:", data);
        new import_obsidian10.Notice("Translation Error: Unexpected response from API.");
        return null;
      }
    } catch (error) {
      console.error("Error calling Google Translate API:", error);
      new import_obsidian10.Notice(`Translation Error: Failed to fetch. ${error.message}`);
      return null;
    }
  }
  // Helper to decode HTML entities (like &amp;, &lt;, etc.)
  decodeHtmlEntities(text) {
    if (typeof document !== "undefined") {
      const textArea = document.createElement("textarea");
      textArea.innerHTML = text;
      return textArea.value;
    } else {
      return text.replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&#39;/g, "'");
    }
  }
};

// src/Logger.ts
var import_obsidian11 = require("obsidian");
var LogLevel = /* @__PURE__ */ ((LogLevel3) => {
  LogLevel3[LogLevel3["DEBUG"] = 1] = "DEBUG";
  LogLevel3[LogLevel3["INFO"] = 2] = "INFO";
  LogLevel3[LogLevel3["WARN"] = 3] = "WARN";
  LogLevel3[LogLevel3["ERROR"] = 4] = "ERROR";
  LogLevel3[LogLevel3["NONE"] = 5] = "NONE";
  return LogLevel3;
})(LogLevel || {});
var Logger = class {
  constructor(plugin, initialSettings) {
    this.consoleLogLevel = 2 /* INFO */;
    this.fileLogLevel = 3 /* WARN */;
    this.fileLoggingEnabled = false;
    this.logCallerInfo = false;
    // <--- Прапорець для опції
    this.logFileMaxSizeMB = 5;
    this.logQueue = [];
    // Буфер для запису у файл
    this.isWritingToFile = false;
    this.writeDebounceTimeout = null;
    this.plugin = plugin;
    this.adapter = plugin.app.vault.adapter;
    this.logFilePath = (0, import_obsidian11.normalizePath)(initialSettings.logFilePath || `${this.plugin.manifest.dir}/ai-forge.log`);
    this.logFileMaxSizeMB = initialSettings.logFileMaxSizeMB || 5;
    this.updateSettings(initialSettings);
    console.log(`[Logger] Initialized. Console Level: ${this.getLogLevelName(this.consoleLogLevel)}, File Logging: ${this.fileLoggingEnabled}, File Level: ${this.getLogLevelName(this.fileLogLevel)}, Log Caller: ${this.logCallerInfo}, Path: ${this.logFilePath}`);
    if (this.fileLoggingEnabled) {
      this.rotateLogFileIfNeeded().then(() => {
        this.info("Logger initialized & file rotation checked.");
      });
    } else {
      this.info("Logger initialized.");
    }
  }
  getLogLevelName(level) {
    return LogLevel[level] || "UNKNOWN";
  }
  getLogLevelFromString(levelString, defaultLevel = 2 /* INFO */) {
    switch (levelString == null ? void 0 : levelString.toUpperCase()) {
      case "DEBUG":
        return 1 /* DEBUG */;
      case "INFO":
        return 2 /* INFO */;
      case "WARN":
        return 3 /* WARN */;
      case "ERROR":
        return 4 /* ERROR */;
      case "NONE":
        return 5 /* NONE */;
      default:
        return defaultLevel;
    }
  }
  // --- Оновлення Налаштувань ---
  updateSettings(settings) {
    if (settings.consoleLogLevel !== void 0) {
      this.consoleLogLevel = this.getLogLevelFromString(settings.consoleLogLevel, 2 /* INFO */);
      console.log(`[Logger] Console log level set to: ${this.getLogLevelName(this.consoleLogLevel)}`);
    }
    if (settings.fileLogLevel !== void 0) {
      this.fileLogLevel = this.getLogLevelFromString(settings.fileLogLevel, 3 /* WARN */);
      console.log(`[Logger] File log level set to: ${this.getLogLevelName(this.fileLogLevel)}`);
    }
    if (settings.fileLoggingEnabled !== void 0) {
      const wasEnabled = this.fileLoggingEnabled;
      this.fileLoggingEnabled = settings.fileLoggingEnabled;
      console.log(`[Logger] File logging enabled: ${this.fileLoggingEnabled}`);
      if (!wasEnabled && this.fileLoggingEnabled) {
        this.rotateLogFileIfNeeded();
      }
    }
    if (settings.logCallerInfo !== void 0) {
      this.logCallerInfo = settings.logCallerInfo;
      console.log(`[Logger] Log Caller Info enabled: ${this.logCallerInfo}`);
    }
  }
  // --- Отримання Інформації про Викликаючого ---
  /**
   * Намагається визначити ім'я/контекст функції, що викликала метод логера.
   * УВАГА: Має вплив на продуктивність! Використовуйте обережно.
   */
  getCallerInfo() {
    var _a, _b;
    if (!this.logCallerInfo) {
      return "unknown";
    }
    try {
      const err = new Error();
      const stackLines = (_a = err.stack) == null ? void 0 : _a.split("\n");
      if (stackLines && stackLines.length > 3) {
        const callerLine = stackLines[3];
        const match = callerLine.match(/at (?:new )?([\w$.<>\[\] ]+)?(?: \[as \w+\])? ?\(?/);
        let callerName = (_b = match == null ? void 0 : match[1]) == null ? void 0 : _b.trim();
        if (callerName) {
          callerName = callerName.replace(/^Object\./, "");
          callerName = callerName.replace(/<anonymous>/, "anonymous");
          if (callerName.includes("/") || callerName.includes("\\")) {
            return "(file context)";
          }
          return callerName;
        }
      }
    } catch (e) {
    }
    return "unknown";
  }
  // --- Методи Логування ---
  debug(...args) {
    this.log(1 /* DEBUG */, console.debug, ...args);
  }
  info(...args) {
    this.log(2 /* INFO */, console.info, ...args);
  }
  warn(...args) {
    this.log(3 /* WARN */, console.warn, ...args);
  }
  error(...args) {
    this.log(4 /* ERROR */, console.error, ...args);
  }
  // --- Ядро Логування ---
  log(level, consoleMethod, ...args) {
    const caller = this.getCallerInfo();
    if (level >= this.consoleLogLevel) {
      const prefix = this.logCallerInfo && caller !== "unknown" ? `[${this.getLogLevelName(level)}] [${caller}]` : `[${this.getLogLevelName(level)}]`;
      consoleMethod(prefix, ...args);
    }
    if (this.fileLoggingEnabled && level >= this.fileLogLevel) {
      this.queueOrWriteToFile(level, caller, args);
    }
  }
  // --- Робота з Файлом (з чергою/буфером) ---
  queueOrWriteToFile(level, caller, args) {
    try {
      const timestamp = new Date().toISOString();
      const levelName = this.getLogLevelName(level);
      const message = args.map((arg) => {
        if (typeof arg === "string")
          return arg;
        if (arg instanceof Error)
          return arg.stack || arg.message;
        try {
          return JSON.stringify(arg);
        } catch (e) {
          return String(arg);
        }
      }).join(" ");
      const callerInfo = this.logCallerInfo && caller !== "unknown" ? ` [${caller}]` : "";
      const logLine = `${timestamp} [${levelName}]${callerInfo} ${message}
`;
      this.logQueue.push(logLine);
      if (!this.isWritingToFile) {
        this.triggerWriteToFile();
      }
    } catch (error) {
      console.error("[Logger] Error formatting log line:", error);
    }
  }
  triggerWriteToFile() {
    if (this.writeDebounceTimeout) {
      clearTimeout(this.writeDebounceTimeout);
    }
    this.writeDebounceTimeout = setTimeout(async () => {
      if (this.isWritingToFile || this.logQueue.length === 0) {
        return;
      }
      this.isWritingToFile = true;
      const linesToWrite = [...this.logQueue];
      this.logQueue = [];
      try {
        const contentToWrite = linesToWrite.join("");
        await this.adapter.append(this.logFilePath, contentToWrite);
      } catch (error) {
        console.error("[Logger] Failed to write batch to log file:", error);
        this.logQueue.unshift(...linesToWrite);
      } finally {
        this.isWritingToFile = false;
        if (this.logQueue.length > 0) {
          this.triggerWriteToFile();
        }
      }
    }, 500);
  }
  async rotateLogFileIfNeeded() {
    if (!this.fileLoggingEnabled)
      return;
    try {
      if (await this.adapter.exists(this.logFilePath)) {
        const stats = await this.adapter.stat(this.logFilePath);
        const maxSizeInBytes = (this.logFileMaxSizeMB || 5) * 1024 * 1024;
        if (stats && stats.type === "file" && stats.size > maxSizeInBytes) {
          const backupPath = this.logFilePath + ".bak";
          console.log(`[Logger] Rotating log file (size ${stats.size} > ${maxSizeInBytes}). Backup: ${backupPath}`);
          if (await this.adapter.exists(backupPath)) {
            await this.adapter.remove(backupPath);
          }
          await this.adapter.rename(this.logFilePath, backupPath);
        }
      }
    } catch (error) {
      console.error("[Logger] Error rotating log file:", error);
    }
  }
};

// src/main.ts
var ACTIVE_SESSION_ID_KEY2 = "activeChatSessionId_v1";
var OllamaPlugin = class extends import_obsidian12.Plugin {
  constructor() {
    super(...arguments);
    this.view = null;
    // Події та кеш
    this.eventHandlers = {};
    this.roleListCache = null;
    this.roleCacheClearTimeout = null;
    this.indexUpdateTimeout = null;
    // --- Логіка файлу завдань ---
    this.dailyTaskFilePath = null;
    this.taskFileContentCache = null;
    this.taskFileNeedsUpdate = false;
    // Прапорець про оновлення
    // --- RAG data (приклад) ---
    // Можливо, ці дані мають зберігатися в RagService?
    this.documents = [];
    this.embeddings = [];
    this.handleTaskFileModify = (file) => {
      if (this.settings.enableProductivityFeatures && file.path === this.dailyTaskFilePath) {
        console.log(`[Plugin] Detected modification in task file: ${file.path}`);
        this.taskFileNeedsUpdate = true;
      }
    };
  }
  // ------------------------
  // --- Event Emitter Methods ---
  on(event, callback) {
    if (!this.eventHandlers[event])
      this.eventHandlers[event] = [];
    this.eventHandlers[event].push(callback);
    return () => {
      var _a, _b;
      this.eventHandlers[event] = (_a = this.eventHandlers[event]) == null ? void 0 : _a.filter((h) => h !== callback);
      if (((_b = this.eventHandlers[event]) == null ? void 0 : _b.length) === 0) {
        delete this.eventHandlers[event];
      }
    };
  }
  emit(event, data) {
    const h = this.eventHandlers[event];
    if (h)
      h.slice().forEach((handler) => {
        try {
          handler(data);
        } catch (e) {
          console.error(`[OllamaPlugin] Error in event handler for ${event}:`, e);
        }
      });
  }
  // --- Гетер для прапорця оновлення файлу завдань ---
  isTaskFileUpdated() {
    return this.taskFileNeedsUpdate;
  }
  async onload() {
    console.log("Loading AI Forge Plugin...");
    await this.loadSettings();
    const isProduction = true;
    const initialConsoleLogLevel = isProduction ? this.settings.consoleLogLevel || "INFO" : "DEBUG";
    const loggerSettings = {
      consoleLogLevel: initialConsoleLogLevel,
      fileLoggingEnabled: this.settings.fileLoggingEnabled,
      fileLogLevel: this.settings.fileLogLevel,
      logCallerInfo: this.settings.logCallerInfo,
      logFilePath: this.settings.logFilePath,
      // Передаємо налаштування шляху
      logFileMaxSizeMB: this.settings.logFileMaxSizeMB
      // Передаємо налаштування розміру
    };
    this.logger = new Logger(this, loggerSettings);
    this.logger.info("Initializing services...");
    this.promptService = new PromptService(this);
    this.ollamaService = new OllamaService(this);
    this.translationService = new TranslationService(this);
    this.ragService = new RagService(this);
    this.chatManager = new ChatManager(this);
    this.logger.info("Services initialized.");
    await this.chatManager.initialize();
    this.registerView(
      VIEW_TYPE_OLLAMA_PERSONAS,
      (leaf) => {
        this.logger.debug("AI Forge Plugin: Registering view.");
        this.view = new OllamaView(leaf, this);
        return this.view;
      }
    );
    this.ollamaService.on("connection-error", (error) => {
      this.logger.error("[Plugin] Connection error event received:", error);
      this.emit("ollama-connection-error", error.message);
      if (!this.view) {
        new import_obsidian12.Notice(`Failed to connect to Ollama: ${error.message}`);
      }
    });
    this.register(this.on("ollama-connection-error", (message) => {
      var _a, _b;
      (_b = (_a = this.view) == null ? void 0 : _a.addMessageToDisplay) == null ? void 0 : _b.call(_a, "error", message, new Date());
    }));
    this.register(this.on("active-chat-changed", this.handleActiveChatChangedLocally.bind(this)));
    this.register(this.on("chat-list-updated", () => {
      this.logger.debug("[Plugin] Event 'chat-list-updated' received.");
    }));
    this.register(this.on("settings-updated", () => {
      var _a;
      this.logger.info("[Plugin] Event 'settings-updated' received.");
      this.logger.updateSettings(this.settings);
      this.updateDailyTaskFilePath();
      this.loadAndProcessInitialTasks();
      this.updateOllamaServiceConfig();
      this.roleListCache = null;
      (_a = this.promptService) == null ? void 0 : _a.clearRoleCache();
      this.emit("roles-updated");
    }));
    this.addRibbonIcon("brain-circuit", "Open AI Forge Chat", () => {
      this.activateView();
    });
    this.addCommand({ id: "open-chat-view", name: "Open AI Forge Chat", callback: () => {
      this.activateView();
    } });
    this.addCommand({ id: "index-rag-documents", name: "AI Forge: Index documents for RAG", callback: async () => {
      await this.ragService.indexDocuments();
    } });
    this.addCommand({ id: "clear-active-chat-history", name: "AI Forge: Clear Active Chat History", callback: async () => {
      await this.clearMessageHistory();
    } });
    this.addCommand({ id: "refresh-roles", name: "AI Forge: Refresh Roles List", callback: async () => {
      await this.listRoleFiles(true);
      this.emit("roles-updated");
      new import_obsidian12.Notice("Role list refreshed.");
    } });
    this.addCommand({ id: "new-chat", name: "AI Forge: New Chat", callback: async () => {
      const newChat = await this.chatManager.createNewChat();
      if (newChat) {
        new import_obsidian12.Notice(`Created new chat: ${newChat.metadata.name}`);
      }
    } });
    this.addCommand({ id: "switch-chat", name: "AI Forge: Switch Chat", callback: async () => {
      await this.showChatSwitcher();
    } });
    this.addCommand({ id: "rename-active-chat", name: "AI Forge: Rename Active Chat", callback: async () => {
      await this.renameActiveChat();
    } });
    this.addCommand({ id: "delete-active-chat", name: "AI Forge: Delete Active Chat", callback: async () => {
      await this.deleteActiveChatWithConfirmation();
    } });
    this.settingTab = new OllamaSettingTab(this.app, this);
    this.addSettingTab(this.settingTab);
    this.app.workspace.onLayoutReady(async () => {
      if (this.settings.ragEnabled) {
        setTimeout(() => {
          var _a;
          (_a = this.ragService) == null ? void 0 : _a.indexDocuments();
        }, 5e3);
      }
    });
    const debouncedRoleClear = (0, import_obsidian12.debounce)(() => {
      var _a, _b;
      console.log("[OllamaPlugin] Role change detected, clearing cache & emitting.");
      this.roleListCache = null;
      (_b = (_a = this.promptService) == null ? void 0 : _a.clearRoleCache) == null ? void 0 : _b.call(_a);
      this.emit("roles-updated");
    }, 1500, true);
    const fileChangeHandler = (file) => {
      if (!file)
        return;
      this.handleRoleOrRagFileChange(file.path, debouncedRoleClear);
    };
    const handleModify = (file) => {
      fileChangeHandler(file);
      this.handleTaskFileModify(file);
    };
    const handleDelete = (file) => {
      var _a;
      console.log("Delete event:", file.path);
      fileChangeHandler(file);
      if (file.path === this.dailyTaskFilePath) {
        console.log(`[Plugin] Task file ${this.dailyTaskFilePath} deleted.`);
        this.dailyTaskFilePath = null;
        this.taskFileContentCache = null;
        this.taskFileNeedsUpdate = false;
        (_a = this.chatManager) == null ? void 0 : _a.updateTaskState(null);
      }
    };
    const handleRename = (file, oldPath) => {
      console.log("Rename event:", oldPath, "->", file.path);
      fileChangeHandler(file);
      this.handleRoleOrRagFileChange(oldPath, debouncedRoleClear);
      if (oldPath === this.dailyTaskFilePath) {
        console.log(`[Plugin] Task file potentially renamed from ${oldPath} to ${file.path}`);
        this.updateDailyTaskFilePath();
        this.loadAndProcessInitialTasks();
      } else if (file.path === this.dailyTaskFilePath) {
        console.log(`[Plugin] A file was renamed to become the task file: ${file.path}`);
        this.taskFileNeedsUpdate = true;
        this.checkAndProcessTaskUpdate();
      }
    };
    const handleCreate = (file) => {
      fileChangeHandler(file);
      if (file.path === this.dailyTaskFilePath) {
        console.log(`[Plugin] Task file ${this.dailyTaskFilePath} created.`);
        this.taskFileNeedsUpdate = true;
        this.checkAndProcessTaskUpdate();
      }
    };
    this.registerEvent(this.app.vault.on("modify", handleModify));
    this.registerEvent(this.app.vault.on("delete", handleDelete));
    this.registerEvent(this.app.vault.on("rename", handleRename));
    this.registerEvent(this.app.vault.on("create", handleCreate));
    this.updateDailyTaskFilePath();
    await this.loadAndProcessInitialTasks();
  }
  // --- Логіка файлу завдань (залишається в main.ts) ---
  updateDailyTaskFilePath() {
    var _a, _b;
    const folderPath = (_a = this.settings.ragFolderPath) == null ? void 0 : _a.trim();
    const fileName = (_b = this.settings.dailyTaskFileName) == null ? void 0 : _b.trim();
    const newPath = folderPath && fileName ? (0, import_obsidian12.normalizePath)(`${folderPath}/${fileName}`) : null;
    if (newPath !== this.dailyTaskFilePath) {
      console.log(`[Plugin] Daily task file path changed to: ${newPath}`);
      this.dailyTaskFilePath = newPath;
      this.taskFileContentCache = null;
      this.taskFileNeedsUpdate = true;
    } else if (!newPath) {
      this.dailyTaskFilePath = null;
      console.log(`[Plugin] Daily task file path is not configured.`);
    }
  }
  async loadAndProcessInitialTasks() {
    var _a, _b, _c, _d, _e;
    if (!this.settings.enableProductivityFeatures) {
      this.taskFileContentCache = null;
      (_a = this.chatManager) == null ? void 0 : _a.updateTaskState(null);
      this.taskFileNeedsUpdate = false;
      return;
    }
    if (!this.dailyTaskFilePath) {
      this.taskFileContentCache = null;
      (_b = this.chatManager) == null ? void 0 : _b.updateTaskState(null);
      this.taskFileNeedsUpdate = false;
      return;
    }
    try {
      if (await this.app.vault.adapter.exists(this.dailyTaskFilePath)) {
        const content = await this.app.vault.adapter.read(this.dailyTaskFilePath);
        if (content !== this.taskFileContentCache) {
          console.log(`[Plugin] Loading and processing tasks from ${this.dailyTaskFilePath}`);
          this.taskFileContentCache = content;
          const tasks = this.parseTasks(content);
          (_c = this.chatManager) == null ? void 0 : _c.updateTaskState(tasks);
          this.taskFileNeedsUpdate = false;
        } else {
          this.taskFileNeedsUpdate = false;
        }
      } else {
        console.log(`[Plugin] Task file ${this.dailyTaskFilePath} not found.`);
        this.taskFileContentCache = null;
        (_d = this.chatManager) == null ? void 0 : _d.updateTaskState(null);
        this.taskFileNeedsUpdate = false;
      }
    } catch (error) {
      console.error(`[Plugin] Error loading/processing task file ${this.dailyTaskFilePath}:`, error);
      this.taskFileContentCache = null;
      (_e = this.chatManager) == null ? void 0 : _e.updateTaskState(null);
      this.taskFileNeedsUpdate = false;
    }
  }
  parseTasks(content) {
    const lines = content.split("\n");
    const urgent = [];
    const regular = [];
    let hasContent = false;
    for (const line of lines) {
      const trimmedLine = line.trim();
      if (!trimmedLine)
        continue;
      hasContent = true;
      if (trimmedLine.startsWith("!") || trimmedLine.toLowerCase().includes("[urgent]")) {
        urgent.push(trimmedLine.replace(/^!/, "").replace(/\[urgent\]/i, "").trim());
      } else if (trimmedLine.startsWith("- [ ]") || trimmedLine.startsWith("- [x]")) {
        regular.push(trimmedLine.substring(trimmedLine.indexOf("]") + 1).trim());
      } else {
        regular.push(trimmedLine);
      }
    }
    return { urgent, regular, hasContent };
  }
  async checkAndProcessTaskUpdate() {
    if (this.taskFileNeedsUpdate) {
      console.log("[Plugin] checkAndProcessTaskUpdate: taskFileNeedsUpdate is true, reloading...");
      await this.loadAndProcessInitialTasks();
    }
  }
  // --- Кінець логіки файлу завдань ---
  // Обробник змін для ролей та RAG
  handleRoleOrRagFileChange(changedPath, debouncedRoleClear) {
    const normPath = (0, import_obsidian12.normalizePath)(changedPath);
    const userRolesPath = this.settings.userRolesFolderPath ? (0, import_obsidian12.normalizePath)(this.settings.userRolesFolderPath) : null;
    const defaultRolesPath = (0, import_obsidian12.normalizePath)(this.manifest.dir + "/roles");
    if (normPath.toLowerCase().endsWith(".md")) {
      if (userRolesPath && normPath.startsWith(userRolesPath + "/") || normPath.startsWith(defaultRolesPath + "/")) {
        console.log(`[Plugin] Role file change detected: ${normPath}`);
        debouncedRoleClear();
      }
    }
    const ragFolderPath = this.settings.ragFolderPath ? (0, import_obsidian12.normalizePath)(this.settings.ragFolderPath) : null;
    if (this.settings.ragEnabled && ragFolderPath && normPath.startsWith(ragFolderPath + "/")) {
      console.log(`[Plugin] RAG file change detected: ${normPath}`);
      this.debounceIndexUpdate();
    }
  }
  async onunload() {
    var _a, _b, _c, _d;
    this.app.workspace.getLeavesOfType(VIEW_TYPE_OLLAMA_PERSONAS).forEach((l) => l.detach());
    if (this.indexUpdateTimeout)
      clearTimeout(this.indexUpdateTimeout);
    if (this.roleCacheClearTimeout)
      clearTimeout(this.roleCacheClearTimeout);
    try {
      if (this.chatManager && this.settings.saveMessageHistory) {
        const lastActiveId = this.chatManager.getActiveChatId();
        if (lastActiveId !== void 0 && lastActiveId !== null) {
          console.log(`[OllamaPlugin] Saving activeChatId (${lastActiveId}) on unload.`);
          await this.saveDataKey(ACTIVE_SESSION_ID_KEY2, lastActiveId);
        } else {
          console.log(`[OllamaPlugin] No active chat ID found to save on unload.`);
          await this.saveDataKey(ACTIVE_SESSION_ID_KEY2, null);
        }
      }
    } catch (error) {
      console.error("[OllamaPlugin] Error saving active chat ID on unload:", error);
    }
    (_b = (_a = this.promptService) == null ? void 0 : _a.clearModelDetailsCache) == null ? void 0 : _b.call(_a);
    (_d = (_c = this.promptService) == null ? void 0 : _c.clearRoleCache) == null ? void 0 : _d.call(_c);
    this.roleListCache = null;
    console.log("Ollama Personas Plugin unloaded.");
  }
  updateOllamaServiceConfig() {
    var _a;
    if (this.ollamaService) {
      console.log("[OllamaPlugin] Settings changed, potentially updating Ollama service config and clearing model cache.");
      (_a = this.promptService) == null ? void 0 : _a.clearModelDetailsCache();
    }
  }
  debounceIndexUpdate() {
    if (this.indexUpdateTimeout)
      clearTimeout(this.indexUpdateTimeout);
    this.indexUpdateTimeout = setTimeout(async () => {
      this.logger.debug("[OllamaPlugin] Debounced RAG index update starting...");
      if (this.settings.ragEnabled && this.ragService) {
        await this.ragService.indexDocuments();
      }
      this.indexUpdateTimeout = null;
    }, 3e4);
  }
  async activateView() {
    var _a;
    const { workspace: e } = this.app;
    let l = null;
    const s = e.getLeavesOfType(VIEW_TYPE_OLLAMA_PERSONAS);
    if (s.length > 0) {
      l = s[0];
    } else {
      l = (_a = e.getRightLeaf(false)) != null ? _a : e.getLeaf(true);
      if (l) {
        await l.setViewState({ type: VIEW_TYPE_OLLAMA_PERSONAS, active: true });
      }
    }
    if (l) {
      e.revealLeaf(l);
      const v = l.view;
      if (v instanceof OllamaView) {
        this.view = v;
        console.log("Ollama Personas View activated/revealed.");
      } else {
        console.error("Activated view is not an instance of OllamaView?");
      }
    } else {
      console.error("Failed to create or find leaf for Ollama Personas View.");
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    console.log("OllamaPlugin: Settings saved.");
    this.emit("settings-updated");
  }
  // Data Helpers
  async saveDataKey(key, value) {
    const d = await this.loadData() || {};
    d[key] = value;
    await this.saveData(d);
  }
  async loadDataKey(key) {
    const d = await this.loadData() || {};
    return d[key];
  }
  // History Persistence (Delegated)
  async clearMessageHistory() {
    console.log("[OllamaPlugin] Clearing active chat via ChatManager.");
    if (this.chatManager) {
      await this.chatManager.clearActiveChatMessages();
    } else {
      console.error("ChatManager not ready when clearMessageHistory called.");
      new import_obsidian12.Notice("Error: Chat Manager not ready.");
    }
  }
  // List Role Files Method
  /**
     * Отримує список доступних ролей, включаючи вбудовану роль "Productivity Assistant".
     * @param forceRefresh Якщо true, кеш буде проігноровано і список буде зчитано з файлів.
     * @returns Масив об'єктів RoleInfo.
     */
  async listRoleFiles(forceRefresh = false) {
    var _a;
    if (this.roleListCache && !forceRefresh) {
      this.logger.debug("Returning cached roles.");
      return this.roleListCache;
    }
    const roles = [];
    const addedNamesLowerCase = /* @__PURE__ */ new Set();
    const adapter = this.app.vault.adapter;
    const pluginDir = this.manifest.dir;
    const builtInRoleName = "Productivity Assistant";
    const builtInRoleFileName = "Productivity_Assistant.md";
    const builtInRolePath = (0, import_obsidian12.normalizePath)(`${pluginDir}/roles/${builtInRoleFileName}`);
    try {
      if (await adapter.exists(builtInRolePath)) {
        const stat = await adapter.stat(builtInRolePath);
        if ((stat == null ? void 0 : stat.type) === "file") {
          roles.push({
            name: builtInRoleName,
            path: builtInRolePath,
            isCustom: false
          });
          addedNamesLowerCase.add(builtInRoleName.toLowerCase());
        } else {
          this.logger.warn(`Built-in role path exists but is not a file: ${builtInRolePath}`);
        }
      } else {
        this.logger.warn(`Built-in role file NOT FOUND at: ${builtInRolePath}. Productivity features might rely on it.`);
      }
    } catch (error) {
      this.logger.error(`Error checking/adding built-in role at ${builtInRolePath}:`, error);
    }
    const userRolesFolderPath = this.settings.userRolesFolderPath ? (0, import_obsidian12.normalizePath)(this.settings.userRolesFolderPath) : null;
    if (userRolesFolderPath) {
      this.logger.debug(`Processing user roles from: ${userRolesFolderPath}`);
      try {
        if (await adapter.exists(userRolesFolderPath) && ((_a = await adapter.stat(userRolesFolderPath)) == null ? void 0 : _a.type) === "folder") {
          const listResult = await adapter.list(userRolesFolderPath);
          for (const filePath of listResult.files) {
            if (filePath.toLowerCase().endsWith(".md") && (userRolesFolderPath === "/" || filePath.split("/").length === userRolesFolderPath.split("/").length + 1) && filePath !== builtInRolePath) {
              const fileName = filePath.split("/").pop() || filePath;
              const roleName = fileName.substring(0, fileName.length - 3);
              if (!addedNamesLowerCase.has(roleName.toLowerCase())) {
                roles.push({ name: roleName, path: filePath, isCustom: true });
                addedNamesLowerCase.add(roleName.toLowerCase());
              } else {
              }
            }
          }
        } else if (userRolesFolderPath !== "/") {
          this.logger.warn(`User roles path not found or not a folder: ${userRolesFolderPath}`);
        }
      } catch (e) {
        this.logger.error(`Error listing user roles in ${userRolesFolderPath}:`, e);
      }
    }
    roles.sort((a, b) => a.name.localeCompare(b.name));
    this.roleListCache = roles;
    return roles;
  }
  // async listRoleFiles(forceRefresh: boolean = false): Promise<RoleInfo[]> {
  //   if (this.roleListCache && !forceRefresh) {
  //     return this.roleListCache;
  //   }
  //   console.log("[OllamaPlugin] Fetching roles (including built-in)...");
  //   const roles: RoleInfo[] = [];
  //   const addedNamesLowerCase = new Set<string>(); // Для уникнення дублікатів імен
  //   const adapter = this.app.vault.adapter;
  //   const pluginDir = this.manifest.dir; // Шлях до папки плагіна відносно .obsidian/plugins/
  //   // --- 1. Додаємо Вбудовану Роль "Productivity Assistant" ---
  //   const builtInRoleName = "Productivity Assistant";
  //   const builtInRoleFileName = "Productivity_Assistant.md"; // Назва файлу (можна зробити константою)
  //   // Шлях до файлу відносно кореня сховища
  //   const builtInRolePath = normalizePath(`${pluginDir}/roles/${builtInRoleFileName}`);
  //   this.logger.debug(`[OllamaPlugin] Checking for built-in role at: ${builtInRolePath}`);
  //   try {
  //     // Перевіряємо існування файлу через адаптер
  //     if (await adapter.exists(builtInRolePath)) {
  //       // Додатково перевіряємо, чи це файл (stat може бути повільним)
  //       const stat = await adapter.stat(builtInRolePath);
  //       if (stat?.type === 'file') {
  //         this.logger.debug(`[OllamaPlugin] Found built-in role: ${builtInRoleName}`);
  //         // Додаємо першою або просто до загального списку
  //         roles.push({
  //           name: builtInRoleName,
  //           path: builtInRolePath, // Зберігаємо шлях відносно кореня сховища
  //           isCustom: false, // Позначаємо як не користувацьку
  //           // isBuiltIn: true // Можна додати окремий прапорець
  //         });
  //         addedNamesLowerCase.add(builtInRoleName.toLowerCase());
  //       } else {
  //         this.logger.warn(`[OllamaPlugin] Built-in role path exists but is not a file: ${builtInRolePath}`);
  //       }
  //     } else {
  //       this.logger.warn(`[OllamaPlugin] Built-in role file NOT FOUND at: ${builtInRolePath}. Productivity features might rely on it.`);
  //       // Можливо, варто показати Notice, якщо ця роль критична
  //       // new Notice("Built-in 'Productivity Assistant' role file is missing!");
  //     }
  //   } catch (error) {
  //     this.logger.error(`[OllamaPlugin] Error checking/adding built-in role at ${builtInRolePath}:`, error);
  //   }
  //   // --- Кінець Вбудованої Ролі ---
  //   // --- 2. Додаємо Користувацькі Ролі (з папки налаштувань) ---
  //   const userRolesFolderPath = this.settings.userRolesFolderPath ? normalizePath(this.settings.userRolesFolderPath) : null;
  //   if (userRolesFolderPath) {
  //     this.logger.info(`[OllamaPlugin] Processing user roles from: ${userRolesFolderPath}`);
  //     try {
  //       if (await adapter.exists(userRolesFolderPath) && (await adapter.stat(userRolesFolderPath))?.type === 'folder') {
  //         const listResult = await adapter.list(userRolesFolderPath);
  //         for (const filePath of listResult.files) {
  //           // Обробляємо лише .md файли безпосередньо в цій папці
  //           if (filePath.toLowerCase().endsWith('.md') &&
  //             (userRolesFolderPath === '/' || filePath.split('/').length === userRolesFolderPath.split('/').length + 1) &&
  //             filePath !== builtInRolePath) { // Не додаємо вбудовану роль ще раз, якщо папки співпали
  //             const fileName = path.basename(filePath); // Використовуємо path для надійності
  //             const roleName = fileName.substring(0, fileName.length - 3);
  //             // Додаємо, тільки якщо ім'я унікальне (регістронезалежно)
  //             if (!addedNamesLowerCase.has(roleName.toLowerCase())) {
  //               this.logger.info(`[OllamaPlugin] Adding user role: ${roleName}`);
  //               roles.push({ name: roleName, path: filePath, isCustom: true });
  //               addedNamesLowerCase.add(roleName.toLowerCase());
  //             } else {
  //               this.logger.warn(`[OllamaPlugin] Skipping user role "${roleName}" from "${userRolesFolderPath}" due to name conflict.`);
  //             }
  //           }
  //         }
  //       } else if (userRolesFolderPath !== "/") { // Не виводимо попередження для кореневої папки
  //         this.logger.warn(`[OllamaPlugin] User roles path not found or not a folder: ${userRolesFolderPath}`);
  //         // Можливо, варто повідомити користувача через Notice?
  //       }
  //     } catch (e) {
  //       this.logger.error(`Error listing user roles in ${userRolesFolderPath}:`, e);
  //     }
  //   }
  //   // --- Кінець Користувацьких Ролей ---
  //   // --- 3. Додаємо Інші Стандартні Ролі (Якщо є папка roles/ крім файлу Productivity_Assistant) ---
  //   // const defaultRolesPath = normalizePath(pluginDir + '/roles');
  //   // // ... (схожа логіка обробки папки, як для userRolesPath, перевіряючи addedNamesLowerCase) ...
  //   // --- Кінець Інших Стандартних Ролей ---
  //   // --- 4. Сортування та Кешування ---
  //   roles.sort((a, b) => {
  //     // Можна зробити, щоб вбудована роль була завжди першою
  //     // if (a.name === builtInRoleName) return -1;
  //     // if (b.name === builtInRoleName) return 1;
  //     return a.name.localeCompare(b.name); // Або просто сортуємо за алфавітом
  //   });
  //   this.roleListCache = roles;
  //   this.logger.debug(`[OllamaPlugin] Found total ${roles.length} roles (including built-in if present).`);
  //   return roles;
  // }
  // Execute System Command Method
  async executeSystemCommand(command) {
    var _a;
    console.log(`Executing: ${command}`);
    if (!(command == null ? void 0 : command.trim())) {
      return { stdout: "", stderr: "Empty cmd.", error: new Error("Empty cmd") };
    }
    if (typeof process === "undefined" || !((_a = process == null ? void 0 : process.versions) == null ? void 0 : _a.node)) {
      console.error("Node.js environment not available. Cannot execute system command.");
      new import_obsidian12.Notice("Cannot execute system command.");
      return { stdout: "", stderr: "Node.js required.", error: new Error("Node.js required") };
    }
    return new Promise((resolve) => {
      (0, import_child_process.exec)(command, (error, stdout, stderr) => {
        if (error)
          console.error(`Exec error for "${command}": ${error}`);
        if (stderr)
          console.error(`Exec stderr for "${command}": ${stderr}`);
        if (stdout)
          console.log(`Exec stdout for "${command}": ${stdout}`);
        resolve({ stdout: stdout.toString(), stderr: stderr.toString(), error });
      });
    });
  }
  // --- Session Management Command Helpers ---
  // Ці методи зараз не використовуються View, але можуть бути корисними для команд
  async showChatSwitcher() {
    new import_obsidian12.Notice("Switch Chat UI not implemented yet.");
  }
  async renameActiveChat() {
    var _a;
    const activeChat = await ((_a = this.chatManager) == null ? void 0 : _a.getActiveChat());
    if (!activeChat) {
      new import_obsidian12.Notice("No active chat.");
      return;
    }
    const currentName = activeChat.metadata.name;
    new PromptModal(
      this.app,
      "Rename Chat",
      `Enter new name for "${currentName}":`,
      currentName,
      async (newName) => {
        if (newName && newName.trim() !== "" && newName.trim() !== currentName) {
          await this.chatManager.renameChat(activeChat.metadata.id, newName.trim());
        } else if (newName !== null) {
          new import_obsidian12.Notice("Rename cancelled or name unchanged.");
        }
      }
    ).open();
  }
  async deleteActiveChatWithConfirmation() {
    var _a;
    const activeChat = await ((_a = this.chatManager) == null ? void 0 : _a.getActiveChat());
    if (!activeChat) {
      new import_obsidian12.Notice("No active chat.");
      return;
    }
    const chatName = activeChat.metadata.name;
    new ConfirmModal(
      this.app,
      "Delete Chat",
      `Delete chat "${chatName}"? This cannot be undone.`,
      async () => {
        await this.chatManager.deleteChat(activeChat.metadata.id);
      }
    ).open();
  }
  // Обробник зміни активного чату (локальний)
  async handleActiveChatChangedLocally(data) {
    console.log(`[OllamaPlugin] Handled 'active-chat-changed' locally. New active ID: ${data.chatId}. View will update itself.`);
  }
  findRoleNameByPath(rolePath) {
    var _a;
    if (!rolePath)
      return "None";
    const cachedRole = (_a = this.roleListCache) == null ? void 0 : _a.find((rl) => rl.path === rolePath);
    if (cachedRole)
      return cachedRole.name;
    try {
      const fileName = rolePath.split("/").pop() || rolePath;
      const roleName = fileName.endsWith(".md") ? fileName.slice(0, -5) : fileName;
      return roleName;
    } catch (e) {
      this.logger.warn(`Could not determine role name for path: ${rolePath}`, e);
      return "Unknown Role";
    }
  }
};
