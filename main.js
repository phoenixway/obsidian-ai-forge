/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => OllamaPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// ollamaView.ts
var import_obsidian2 = require("obsidian");

// messageService.ts
var import_obsidian = require("obsidian");
var MessageService = class {
  constructor(plugin) {
    this.view = null;
    this.messages = [];
    this.isProcessing = false;
    this.messagesPairCount = 0;
    this.plugin = plugin;
  }
  // Set the view reference
  setView(view) {
    this.view = view;
  }
  // Load message history from storage
  async loadMessageHistory() {
    if (!this.view)
      return;
    try {
      const history = await this.plugin.loadMessageHistory();
      if (Array.isArray(history) && history.length > 0) {
        this.messages = [];
        this.view.clearChatContainer();
        for (const msg of history) {
          const message = {
            ...msg,
            timestamp: new Date(msg.timestamp)
          };
          this.messages.push(message);
          this.renderMessage(message);
        }
        this.view.scrollToBottom();
        this.initializeThinkingBlocks();
      } else {
        this.view.showEmptyState();
      }
    } catch (error) {
      console.error("Error loading message history:", error);
      this.view.showEmptyState();
    }
  }
  // Save message history to storage
  async saveMessageHistory() {
    if (this.messages.length === 0)
      return;
    try {
      const serializedMessages = this.messages.map((msg) => ({
        role: msg.role,
        content: msg.content,
        timestamp: msg.timestamp.toISOString()
      }));
      await this.plugin.saveMessageHistory(JSON.stringify(serializedMessages));
    } catch (error) {
      console.error("Error saving message history:", error);
    }
  }
  // Send a message from the user to Ollama
  async sendMessage(content) {
    if (this.isProcessing || !content.trim() || !this.view)
      return;
    this.view.hideEmptyState();
    this.addMessage("user" /* USER */, content);
    this.view.clearInputField();
    await this.processWithOllama(content);
  }
  // Add a message to the chat and render it
  addMessage(role, content) {
    const message = {
      role,
      content,
      timestamp: new Date()
    };
    this.messages.push(message);
    this.renderMessage(message);
    if (role === "assistant" /* ASSISTANT */ && this.messages.length >= 2) {
      if (this.messages[this.messages.length - 2].role === "user" /* USER */) {
        this.messagesPairCount++;
      }
    }
    this.saveMessageHistory();
    setTimeout(() => {
      if (this.view) {
        this.view.scrollToBottom();
      }
    }, 100);
  }
  // Reset the chat history
  clearChatMessages() {
    this.messages = [];
    if (this.view) {
      this.view.clearChatContainer();
      this.view.showEmptyState();
    }
  }
  // Render a message in the chat container
  renderMessage(message) {
    console.log(`messageService.ts -> renderMessage: this.view: ${this.view}`);
    if (!this.view)
      return;
    const isUser = message.role === "user" /* USER */;
    const isError = message.role === "error" /* ERROR */;
    const isSystem = message.role === "system" /* SYSTEM */;
    const isFirstInGroup = this.isFirstMessageInGroup(message);
    const isLastInGroup = this.isLastMessageInGroup(message);
    let messageGroup;
    const lastGroup = this.view.getChatContainer().lastElementChild;
    if (isFirstInGroup) {
      let groupClass = "message-group ";
      if (isUser) {
        groupClass += "user-message-group";
      } else if (isAssistant(message.role)) {
        groupClass += "ollama-message-group";
      } else if (isError) {
        groupClass += "error-message-group";
      } else if (isSystem) {
        groupClass += "system-message-group";
      }
      messageGroup = this.view.createGroupElement(groupClass);
    } else {
      messageGroup = lastGroup;
    }
  }
  // Create a copy button for the message
  createCopyButton(container, message) {
    const copyButton = container.createEl("button", {
      cls: "copy-button",
      attr: { title: "Copy message" }
    });
    (0, import_obsidian.setIcon)(copyButton, "copy");
    copyButton.addEventListener("click", () => {
      let textToCopy = message.content;
      if (isAssistant(message.role) && textToCopy.includes("<think>")) {
        textToCopy = textToCopy.replace(/<think>[\s\S]*?<\/think>/g, "");
      }
      navigator.clipboard.writeText(textToCopy);
      copyButton.setText("Copied!");
      setTimeout(() => {
        copyButton.empty();
        (0, import_obsidian.setIcon)(copyButton, "copy");
      }, 2e3);
    });
    return copyButton;
  }
  // Process request with Ollama
  async processWithOllama(content) {
    if (!this.view)
      return;
    this.isProcessing = true;
    const loadingMessageEl = this.view.addLoadingMessage();
    setTimeout(async () => {
      try {
        let useSystemPrompt = false;
        if (this.plugin.settings.followRole) {
          const systemPromptInterval = this.plugin.settings.systemPromptInterval || 0;
          if (systemPromptInterval === 0) {
            useSystemPrompt = true;
          } else if (systemPromptInterval > 0) {
            useSystemPrompt = this.messagesPairCount % systemPromptInterval === 0;
          }
        }
        const isNewConversation = this.messages.length <= 1;
        const formattedPrompt = await this.plugin.promptService.prepareFullPrompt(
          content,
          isNewConversation
        );
        const requestBody = {
          model: this.plugin.settings.modelName,
          prompt: formattedPrompt,
          stream: false,
          temperature: this.plugin.settings.temperature || 0.2,
          options: {
            num_ctx: this.plugin.settings.contextWindow || 8192
          }
        };
        if (useSystemPrompt) {
          const systemPrompt = this.plugin.promptService.getSystemPrompt();
          if (systemPrompt) {
            requestBody.system = systemPrompt;
          }
        }
        const data = await this.plugin.apiService.generateResponse(requestBody);
        this.removeLoadingMessage(loadingMessageEl);
        this.addMessage("assistant" /* ASSISTANT */, data.response);
        this.initializeThinkingBlocks();
      } catch (error) {
        console.error("Error processing request with Ollama:", error);
        this.removeLoadingMessage(loadingMessageEl);
        const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
        this.addMessage(
          "error" /* ERROR */,
          `Connection error with Ollama: ${errorMessage}. Please check the settings and ensure the server is running.`
        );
      } finally {
        this.isProcessing = false;
      }
    }, 0);
  }
  addSystemMessage(content) {
    this.addMessage("system" /* SYSTEM */, content);
  }
  removeLoadingMessage(loadingMessageEl) {
    if (loadingMessageEl && loadingMessageEl.parentNode) {
      loadingMessageEl.parentNode.removeChild(loadingMessageEl);
    }
  }
  isFirstMessageInGroup(message) {
    const index = this.messages.indexOf(message);
    if (index === 0)
      return true;
    const prevMessage = this.messages[index - 1];
    return prevMessage.role !== message.role;
  }
  isLastMessageInGroup(message) {
    const index = this.messages.indexOf(message);
    if (index === this.messages.length - 1)
      return true;
    const nextMessage = this.messages[index + 1];
    return nextMessage.role !== message.role;
  }
  formatTime(date) {
    return date.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
  }
  decodeHtmlEntities(text) {
    const textArea = document.createElement("textarea");
    textArea.innerHTML = text;
    return textArea.value;
  }
  renderMarkdown(content, element) {
    if (!this.view)
      return;
    import_obsidian.MarkdownRenderer.renderMarkdown(content, element, "", this.view);
  }
  processThinkingTags(content) {
    if (!content.includes("<think>")) {
      return content;
    }
    const parts = [];
    let currentPosition = 0;
    const thinkingRegex = /<think>([\s\S]*?)<\/think>/g;
    let match;
    while ((match = thinkingRegex.exec(content)) !== null) {
      if (match.index > currentPosition) {
        const textBefore = content.substring(currentPosition, match.index);
        parts.push(this.markdownToHtml(textBefore));
      }
      const thinkingContent = match[1];
      const foldableHtml = `
          <div class="thinking-block">
            <div class="thinking-header" data-fold-state="expanded">
              <div class="thinking-toggle">\u25BC</div>
              <div class="thinking-title">Thinking</div>
            </div>
            <div class="thinking-content">${this.markdownToHtml(
        thinkingContent
      )}</div>
          </div>
        `;
      parts.push(foldableHtml);
      currentPosition = match.index + match[0].length;
    }
    if (currentPosition < content.length) {
      const textAfter = content.substring(currentPosition);
      parts.push(this.markdownToHtml(textAfter));
    }
    return parts.join("");
  }
  markdownToHtml(markdown) {
    if (!markdown || markdown.trim() === "" || !this.view)
      return "";
    const tempDiv = document.createElement("div");
    import_obsidian.MarkdownRenderer.renderMarkdown(markdown, tempDiv, "", this.view);
    return tempDiv.innerHTML;
  }
  addThinkingToggleListeners(contentEl) {
    const thinkingHeaders = contentEl.querySelectorAll(".thinking-header");
    thinkingHeaders.forEach((header) => {
      header.addEventListener("click", () => {
        const content = header.nextElementSibling;
        const toggleIcon = header.querySelector(
          ".thinking-toggle"
        );
        if (!content || !toggleIcon)
          return;
        const isFolded = header.getAttribute("data-fold-state") === "folded";
        if (isFolded) {
          content.style.display = "block";
          toggleIcon.textContent = "\u25BC";
          header.setAttribute("data-fold-state", "expanded");
        } else {
          content.style.display = "none";
          toggleIcon.textContent = "\u25BA";
          header.setAttribute("data-fold-state", "folded");
        }
      });
    });
  }
  initializeThinkingBlocks() {
    if (!this.view)
      return;
    setTimeout(() => {
      if (!this.view)
        return;
      const thinkingHeaders = this.view.getChatContainer().querySelectorAll(".thinking-header");
      thinkingHeaders.forEach((header) => {
        const content = header.nextElementSibling;
        const toggleIcon = header.querySelector(
          ".thinking-toggle"
        );
        if (!content || !toggleIcon)
          return;
        content.style.display = "none";
        toggleIcon.textContent = "\u25BA";
        header.setAttribute("data-fold-state", "folded");
      });
    }, 100);
  }
};
function isAssistant(role) {
  return role === "assistant" /* ASSISTANT */;
}

// ollamaView.ts
var VIEW_TYPE_OLLAMA = "ollama-chat-view";
var _OllamaView = class extends import_obsidian2.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.messages = [];
    this.isProcessing = false;
    this.historyLoaded = false;
    this.scrollTimeout = null;
    this.mediaRecorder = null;
    this.systemMessageInterval = 0;
    this.messagesPairCount = 0;
    this.emptyStateEl = null;
    this.plugin = plugin;
    if (_OllamaView.instance) {
      return _OllamaView.instance;
    }
    _OllamaView.instance = this;
    if (this.plugin.apiService) {
      this.plugin.apiService.setOllamaView(this);
    }
    this.mediaRecorder = null;
    try {
      const workerCode = `
onmessage = async (event) => {
    try {
      const { apiKey, audioBlob, languageCode = 'uk-UA' } = event.data;
      console.log("Worker received audioBlob:", audioBlob);
      
      if (!apiKey || apiKey.trim() === '') {
        postMessage({ error: true, message: 'Google API Key is not configured. Please add it in plugin settings.' });
        return;
      }

      const url = "https://speech.googleapis.com/v1/speech:recognize?key=" + apiKey;
      
      const arrayBuffer = await audioBlob.arrayBuffer();
      const base64Audio = btoa(
        new Uint8Array(arrayBuffer).reduce(
          (data, byte) => data + String.fromCharCode(byte), ''
        )
      );
      
      console.log("Audio converted to Base64");
  
      const response = await fetch(url, {
        method: 'POST',
        body: JSON.stringify({
          config: {
            encoding: 'WEBM_OPUS',
            sampleRateHertz: 48000,
            languageCode: languageCode,
            model: 'latest_long',
            enableAutomaticPunctuation: true,
          },
          audio: {
            content: base64Audio
          },
        }),
        headers: {
          'Content-Type': 'application/json',
        },
      });
  
      if (!response.ok) {
        const errorData = await response.json();
        console.error("API error details:", errorData);
        postMessage({ 
          error: true, 
          message: "Error from Google Speech API: " + (errorData.error?.message || response.status)
        });
        return;
      }
  
      const data = await response.json();
      console.log("Speech recognition data:", data);
      
      if (data.results && data.results.length > 0) {
        const transcript = data.results
          .map(result => result.alternatives[0].transcript)
          .join(' ')
          .trim();
        
        postMessage(transcript);
      } else {
        postMessage({ error: true, message: 'No speech detected' });
      }
    } catch (error) {
      console.error('Error in speech recognition:', error);
      postMessage({ 
        error: true, 
        message: 'Error processing speech recognition: ' + error.message 
      });
    }
};
  
onerror = (event) => {
  console.error('Worker error:', event);
};
`;
      const workerBlob = new Blob([workerCode], { type: "application/javascript" });
      const workerUrl = URL.createObjectURL(workerBlob);
      this.speechWorker = new Worker(workerUrl);
    } catch (error) {
      console.error("Failed to initialize worker:", error);
    }
    this.speechWorker.onmessage = (event) => {
      const data = event.data;
      console.log("Received data from worker:", data);
      if (data && typeof data === "object" && data.error) {
        console.error("Speech recognition error:", data.message);
        return;
      }
      const transcript = typeof data === "string" ? data : "";
      console.log("Received transcript from worker:", transcript);
      if (!transcript) {
        return;
      }
      const cursorPosition = this.inputEl.selectionStart || 0;
      const currentValue = this.inputEl.value;
      let insertText = transcript;
      if (cursorPosition > 0 && currentValue.charAt(cursorPosition - 1) !== " " && insertText.charAt(0) !== " ") {
        insertText = " " + insertText;
      }
      const newValue = currentValue.substring(0, cursorPosition) + insertText + currentValue.substring(cursorPosition);
      this.inputEl.value = newValue;
      const newCursorPosition = cursorPosition + insertText.length;
      this.inputEl.setSelectionRange(newCursorPosition, newCursorPosition);
      this.inputEl.focus();
    };
    this.speechWorker.onerror = (error) => {
      console.error("Worker error:", error);
    };
    this.messageService = new MessageService(plugin);
    this.messageService.setView(this);
  }
  // New methods to support MessageService
  getChatContainer() {
    return this.chatContainer;
  }
  clearChatContainer() {
    this.chatContainer.empty();
  }
  scrollToBottom() {
    this.guaranteedScrollToBottom();
  }
  clearInputField() {
    this.inputEl.value = "";
  }
  createGroupElement(className) {
    return this.chatContainer.createDiv({
      cls: className
    });
  }
  createMessageElement(parent, className) {
    return parent.createDiv({
      cls: className
    });
  }
  createContentContainer(parent) {
    return parent.createDiv({
      cls: "message-content-container"
    });
  }
  createContentElement(parent) {
    return parent.createDiv({
      cls: "message-content"
    });
  }
  addLoadingMessage1() {
    const messageGroup = this.chatContainer.createDiv({
      cls: "message-group ollama-message-group"
    });
    const messageEl = messageGroup.createDiv({
      cls: "message ollama-message ollama-message-tail"
    });
    const dotsContainer = messageEl.createDiv({
      cls: "thinking-dots"
    });
    for (let i = 0; i < 3; i++) {
      dotsContainer.createDiv({
        cls: "thinking-dot"
      });
    }
    this.guaranteedScrollToBottom();
    return messageGroup;
  }
  getViewType() {
    return VIEW_TYPE_OLLAMA;
  }
  getDisplayText() {
    return "Ollama Chat";
  }
  getIcon() {
    return "message-square";
  }
  autoResizeTextarea() {
    const adjustHeight = () => {
      const buttonsContainer = this.contentEl.querySelector(".buttons-container");
      if (!buttonsContainer || !this.inputEl)
        return;
      const viewHeight = this.contentEl.clientHeight;
      const maxHeight = viewHeight * 0.66;
      requestAnimationFrame(() => {
        this.inputEl.style.height = "auto";
        const newHeight = Math.min(this.inputEl.scrollHeight, maxHeight);
        this.inputEl.style.height = newHeight + "px";
        if (newHeight > 40) {
          buttonsContainer.style.cssText = "bottom: 10px; top: auto; transform: translateY(0);";
        } else {
          buttonsContainer.style.cssText = "bottom: 50%; top: auto; transform: translateY(50%);";
        }
        this.inputEl.classList.toggle("expanded", this.inputEl.scrollHeight > maxHeight);
      });
    };
    let resizeTimeout;
    this.inputEl.addEventListener("input", () => {
      if (resizeTimeout)
        clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(adjustHeight, 50);
    });
    setTimeout(adjustHeight, 100);
    const handleResize = () => {
      if (resizeTimeout)
        clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(adjustHeight, 50);
    };
    this.registerDomEvent(window, "resize", handleResize);
    this.registerEvent(this.app.workspace.on("resize", handleResize));
  }
  // In the onOpen() method of ollamaView.ts, remove the reset option code
  // and only keep the settings option in the menu dropdown
  async onOpen() {
    this.chatContainerEl = this.contentEl.createDiv({
      cls: "ollama-container"
    });
    this.chatContainer = this.chatContainerEl.createDiv({
      cls: "ollama-chat-container"
    });
    const inputContainer = this.chatContainerEl.createDiv({
      cls: "chat-input-container"
    });
    this.inputEl = inputContainer.createEl("textarea", {
      attr: {
        placeholder: `Text to ${this.plugin.settings.modelName}...`
      }
    });
    const buttonsContainer = inputContainer.createDiv({
      cls: "buttons-container"
    });
    this.sendButton = buttonsContainer.createEl("button", {
      cls: "send-button"
    });
    (0, import_obsidian2.setIcon)(this.sendButton, "send");
    this.voiceButton = buttonsContainer.createEl("button", {
      cls: "voice-button"
    });
    (0, import_obsidian2.setIcon)(this.voiceButton, "microphone");
    this.menuButton = buttonsContainer.createEl("button", {
      cls: "menu-button"
    });
    (0, import_obsidian2.setIcon)(this.menuButton, "more-vertical");
    this.menuDropdown = inputContainer.createEl("div", {
      cls: "menu-dropdown"
    });
    this.menuDropdown.style.display = "none";
    this.settingsOption = this.menuDropdown.createEl("div", {
      cls: "menu-option settings-option"
    });
    const settingsIcon = this.settingsOption.createEl("span", { cls: "menu-option-icon" });
    (0, import_obsidian2.setIcon)(settingsIcon, "settings");
    this.settingsOption.createEl("span", {
      cls: "menu-option-text",
      text: "Settings"
    });
    await this.messageService.loadMessageHistory();
    this.showEmptyState();
    this.autoResizeTextarea();
    setTimeout(() => {
      this.forceInitialization();
      this.attachEventListeners();
    }, 500);
    const removeListener = this.plugin.on("model-changed", (modelName) => {
      this.updateInputPlaceholder(modelName);
      this.plugin.messageService.addSystemMessage(`Model changed to: ${modelName}`);
    });
    this.register(() => removeListener());
    this.registerDomEvent(document, "visibilitychange", () => {
      if (document.visibilityState === "visible") {
        setTimeout(() => {
          this.guaranteedScrollToBottom();
          const event = new Event("input");
          this.inputEl.dispatchEvent(event);
        }, 200);
      }
    });
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        if (this.app.workspace.getActiveViewOfType(this.constructor) === this) {
          setTimeout(() => this.guaranteedScrollToBottom(), 100);
        }
      })
    );
  }
  forceInitialization() {
    setTimeout(() => {
      this.guaranteedScrollToBottom();
      this.inputEl.focus();
      const event = new Event("input");
      this.inputEl.dispatchEvent(event);
    }, 200);
  }
  attachEventListeners() {
    this.inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        this.sendMessage();
      }
    });
    this.sendButton.addEventListener("click", () => {
      this.sendMessage();
    });
    this.voiceButton.addEventListener("click", () => {
      this.startVoiceRecognition();
    });
    const closeMenu = () => {
      this.menuDropdown.style.display = "none";
      document.removeEventListener("click", closeMenu);
    };
    this.menuButton.addEventListener("click", (e) => {
      e.stopPropagation();
      if (this.menuDropdown.style.display === "none") {
        this.menuDropdown.style.display = "block";
        setTimeout(() => {
          document.addEventListener("click", closeMenu);
        }, 0);
      } else {
        closeMenu();
      }
    });
    this.settingsOption.addEventListener("click", async () => {
      const setting = this.app.setting;
      await setting.open();
      setting.openTabById("obsidian-ollama-duet");
      closeMenu();
    });
  }
  updateInputPlaceholder(modelName) {
    if (this.inputEl) {
      this.inputEl.placeholder = `Text to ${modelName}...`;
    }
  }
  showEmptyState() {
    if (this.messages.length === 0 && !this.emptyStateEl) {
      this.emptyStateEl = this.chatContainer.createDiv({
        cls: "ollama-empty-state"
      });
      const messageEl = this.emptyStateEl.createDiv({
        cls: "empty-state-message",
        text: "No messages yet"
      });
      const tipEl = this.emptyStateEl.createDiv({
        cls: "empty-state-tip",
        text: `Type a message to start chatting with ${this.plugin.settings.modelName}`
      });
    }
  }
  hideEmptyState() {
    if (this.emptyStateEl && this.emptyStateEl.parentNode) {
      this.emptyStateEl.remove();
      this.emptyStateEl = null;
    }
  }
  async loadMessageHistory() {
    this.messageService.loadMessageHistory();
  }
  async saveMessageHistory() {
    if (this.messages.length === 0)
      return;
    try {
      const serializedMessages = this.messages.map((msg) => ({
        role: msg.role,
        content: msg.content,
        timestamp: msg.timestamp.toISOString()
      }));
      await this.plugin.saveMessageHistory(JSON.stringify(serializedMessages));
    } catch (error) {
      console.error("Error saving message history:", error);
    }
  }
  guaranteedScrollToBottom() {
    if (this.scrollTimeout) {
      clearTimeout(this.scrollTimeout);
    }
    this.scrollTimeout = setTimeout(() => {
      requestAnimationFrame(() => {
        if (!this.chatContainer)
          return;
        this.chatContainer.scrollTop = this.chatContainer.scrollHeight;
      });
    }, 50);
  }
  async sendMessage() {
    const content = this.inputEl.value.trim();
    if (!content)
      return;
    this.messageService.sendMessage(content);
  }
  addMessage(role, content) {
    const message = {
      role,
      content,
      timestamp: new Date()
    };
    this.messages.push(message);
    this.renderMessage(message);
    if (role === "assistant" && this.messages.length >= 2) {
      if (this.messages[this.messages.length - 2].role === "user") {
        this.messagesPairCount++;
      }
    }
    this.saveMessageHistory();
    setTimeout(() => {
      this.guaranteedScrollToBottom();
    }, 100);
  }
  processThinkingTags(content) {
    if (!content.includes("<think>")) {
      return content;
    }
    const parts = [];
    let currentPosition = 0;
    const thinkingRegex = /<think>([\s\S]*?)<\/think>/g;
    let match;
    while ((match = thinkingRegex.exec(content)) !== null) {
      if (match.index > currentPosition) {
        const textBefore = content.substring(currentPosition, match.index);
        parts.push(this.markdownToHtml(textBefore));
      }
      const thinkingContent = match[1];
      const foldableHtml = `
        <div class="thinking-block">
          <div class="thinking-header" data-fold-state="expanded">
            <div class="thinking-toggle">\u25BC</div>
            <div class="thinking-title">Thinking</div>
          </div>
          <div class="thinking-content">${this.markdownToHtml(
        thinkingContent
      )}</div>
        </div>
      `;
      parts.push(foldableHtml);
      currentPosition = match.index + match[0].length;
    }
    if (currentPosition < content.length) {
      const textAfter = content.substring(currentPosition);
      parts.push(this.markdownToHtml(textAfter));
    }
    return parts.join("");
  }
  markdownToHtml(markdown) {
    if (!markdown || markdown.trim() === "")
      return "";
    const tempDiv = document.createElement("div");
    import_obsidian2.MarkdownRenderer.renderMarkdown(markdown, tempDiv, "", this);
    return tempDiv.innerHTML;
  }
  escapeHtml(unsafe) {
    return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
  }
  addThinkingToggleListeners(contentEl) {
    const thinkingHeaders = contentEl.querySelectorAll(".thinking-header");
    thinkingHeaders.forEach((header) => {
      header.addEventListener("click", () => {
        const content = header.nextElementSibling;
        const toggleIcon = header.querySelector(
          ".thinking-toggle"
        );
        if (!content || !toggleIcon)
          return;
        const isFolded = header.getAttribute("data-fold-state") === "folded";
        if (isFolded) {
          content.style.display = "block";
          toggleIcon.textContent = "\u25BC";
          header.setAttribute("data-fold-state", "expanded");
        } else {
          content.style.display = "none";
          toggleIcon.textContent = "\u25BA";
          header.setAttribute("data-fold-state", "folded");
        }
      });
    });
  }
  hasThinkingTags(content) {
    const formats = [
      "<think>",
      "&lt;think&gt;",
      "<think ",
      "\\<think\\>",
      "%3Cthink%3E"
    ];
    return formats.some((format) => content.includes(format));
  }
  addToggleAllButton(contentContainer, contentEl) {
    const toggleAllButton = contentContainer.createEl("button", {
      cls: "toggle-all-thinking-button",
      attr: { title: "\u0417\u0433\u043E\u0440\u043D\u0443\u0442\u0438/\u0440\u043E\u0437\u0433\u043E\u0440\u043D\u0443\u0442\u0438 \u0432\u0441\u0456 \u0431\u043B\u043E\u043A\u0438 thinking" }
    });
    toggleAllButton.textContent = "Toggle All Thinking";
    toggleAllButton.addEventListener("click", () => {
      const thinkingContents = contentEl.querySelectorAll(".thinking-content");
      const thinkingToggles = contentEl.querySelectorAll(".thinking-toggle");
      let allHidden = true;
      thinkingContents.forEach((content) => {
        if (content.style.display !== "none") {
          allHidden = false;
        }
      });
      thinkingContents.forEach((content, index) => {
        content.style.display = allHidden ? "block" : "none";
        thinkingToggles[index].textContent = allHidden ? "\u25BC" : "\u25BA";
      });
    });
  }
  renderMessage(message) {
    const isUser = message.role === "user";
    const isFirstInGroup = this.isFirstMessageInGroup(message);
    const isLastInGroup = this.isLastMessageInGroup(message);
    let messageGroup;
    const lastGroup = this.chatContainer.lastElementChild;
    if (isFirstInGroup) {
      messageGroup = this.chatContainer.createDiv({
        cls: `message-group ${isUser ? "user-message-group" : "ollama-message-group"}`
      });
    } else {
      messageGroup = lastGroup;
    }
    const messageEl = messageGroup.createDiv({
      cls: `message ${isUser ? "user-message bubble user-bubble" : "ollama-message bubble ollama-bubble"} ${isLastInGroup ? isUser ? "user-message-tail" : "ollama-message-tail" : ""}`
    });
    const contentContainer = messageEl.createDiv({
      cls: "message-content-container"
    });
    const contentEl = contentContainer.createDiv({
      cls: "message-content"
    });
    if (message.role === "assistant") {
      const decodedContent = this.decodeHtmlEntities(message.content);
      const hasThinkingTags = message.content.includes("<think>") || decodedContent.includes("<think>");
      if (hasThinkingTags) {
        const contentToProcess = hasThinkingTags && !message.content.includes("<thing>") ? decodedContent : message.content;
        const processedContent = this.processThinkingTags(contentToProcess);
        contentEl.innerHTML = processedContent;
        this.addThinkingToggleListeners(contentEl);
      } else {
        import_obsidian2.MarkdownRenderer.renderMarkdown(
          message.content,
          contentEl,
          "",
          this
        );
      }
    } else {
      message.content.split("\n").forEach((line, index, array) => {
        contentEl.createSpan({ text: line });
        if (index < array.length - 1) {
          contentEl.createEl("br");
        }
      });
    }
    const copyButton = contentContainer.createEl("button", {
      cls: "copy-button",
      attr: { title: "\u0421\u043A\u043E\u043F\u0456\u044E\u0432\u0430\u0442\u0438" }
    });
    (0, import_obsidian2.setIcon)(copyButton, "copy");
    copyButton.addEventListener("click", () => {
      let textToCopy = message.content;
      if (message.role === "assistant" && textToCopy.includes("<think>")) {
        textToCopy = textToCopy.replace(/<think>[\s\S]*?<\/think>/g, "");
      }
      navigator.clipboard.writeText(textToCopy);
      copyButton.setText("Copied!");
      setTimeout(() => {
        copyButton.empty();
        (0, import_obsidian2.setIcon)(copyButton, "copy");
      }, 2e3);
    });
    if (isLastInGroup) {
      messageEl.createDiv({
        cls: "message-timestamp",
        text: this.formatTime(message.timestamp)
      });
    }
  }
  isFirstMessageInGroup(message) {
    const index = this.messages.indexOf(message);
    if (index === 0)
      return true;
    const prevMessage = this.messages[index - 1];
    return prevMessage.role !== message.role;
  }
  isLastMessageInGroup(message) {
    const index = this.messages.indexOf(message);
    if (index === this.messages.length - 1)
      return true;
    const nextMessage = this.messages[index + 1];
    return nextMessage.role !== message.role;
  }
  formatTime(date) {
    return date.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
  }
  decodeHtmlEntities(text) {
    const textArea = document.createElement("textarea");
    textArea.innerHTML = text;
    return textArea.value;
  }
  detectThinkingTags(content) {
    const formats = [
      { name: "standard", regex: /<think>[\s\S]*?<\/think>/g },
      { name: "escaped", regex: /&lt;think&gt;[\s\S]*?&lt;\/think&gt;/g },
      { name: "backslash-escaped", regex: /\\<think\\>[\s\S]*?\\<\/think\\>/g },
      { name: "url-encoded", regex: /%3Cthink%3E[\s\S]*?%3C\/think%3E/g }
    ];
    for (const format of formats) {
      if (format.regex.test(content)) {
        return { hasThinkingTags: true, format: format.name };
      }
    }
    return { hasThinkingTags: false, format: "none" };
  }
  async processWithOllama(content) {
    this.isProcessing = true;
    const loadingMessageEl = this.addLoadingMessage();
    setTimeout(async () => {
      try {
        const isNewConversation = this.messages.length <= 1;
        const systemPromptInterval = this.plugin.settings.systemPromptInterval || 0;
        let useSystemPrompt = false;
        if (systemPromptInterval === 0) {
          useSystemPrompt = true;
        } else if (systemPromptInterval > 0) {
          useSystemPrompt = this.messagesPairCount % systemPromptInterval === 0;
        }
        const formattedPrompt = await this.plugin.promptService.prepareFullPrompt(
          content,
          isNewConversation
        );
        const requestBody = {
          model: this.plugin.settings.modelName,
          prompt: formattedPrompt,
          stream: false,
          temperature: this.plugin.settings.temperature || 0.2,
          options: {
            num_ctx: this.plugin.settings.contextWindow || 8192
          }
        };
        if (useSystemPrompt) {
          const systemPrompt = this.plugin.promptService.getSystemPrompt();
          if (systemPrompt) {
            requestBody.system = systemPrompt;
          }
        }
        const data = await this.plugin.apiService.generateResponse(requestBody);
        if (loadingMessageEl && loadingMessageEl.parentNode) {
          loadingMessageEl.parentNode.removeChild(loadingMessageEl);
        }
        this.addMessage("assistant", data.response);
        this.initializeThinkingBlocks();
      } catch (error) {
        console.error("Error processing request with Ollama:", error);
        if (loadingMessageEl && loadingMessageEl.parentNode) {
          loadingMessageEl.parentNode.removeChild(loadingMessageEl);
        }
        this.addMessage(
          "assistant",
          "Connection error with Ollama. Please check the settings and ensure the server is running."
        );
      } finally {
        this.isProcessing = false;
      }
    }, 0);
  }
  initializeThinkingBlocks() {
    setTimeout(() => {
      const thinkingHeaders = this.chatContainer.querySelectorAll(".thinking-header");
      thinkingHeaders.forEach((header) => {
        const content = header.nextElementSibling;
        const toggleIcon = header.querySelector(
          ".thinking-toggle"
        );
        if (!content || !toggleIcon)
          return;
        content.style.display = "none";
        toggleIcon.textContent = "\u25BA";
        header.setAttribute("data-fold-state", "folded");
      });
    }, 100);
  }
  addLoadingMessage() {
    const messageGroup = this.chatContainer.createDiv({
      cls: "message-group ollama-message-group"
    });
    const messageEl = messageGroup.createDiv({
      cls: "message ollama-message ollama-message-tail"
    });
    const dotsContainer = messageEl.createDiv({
      cls: "thinking-dots"
    });
    for (let i = 0; i < 3; i++) {
      dotsContainer.createDiv({
        cls: "thinking-dot"
      });
    }
    this.guaranteedScrollToBottom();
    return messageGroup;
  }
  async clearChatMessages() {
    this.messageService.clearChatMessages();
  }
  async startVoiceRecognition() {
    const voiceButton = this.contentEl.querySelector(".voice-button");
    if (voiceButton == null ? void 0 : voiceButton.classList.contains("recording")) {
      if (this.mediaRecorder && this.mediaRecorder.state === "recording") {
        this.mediaRecorder.stop();
      }
      return;
    }
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const mediaRecorder = new MediaRecorder(stream);
      this.mediaRecorder = mediaRecorder;
      const audioChunks = [];
      voiceButton == null ? void 0 : voiceButton.classList.add("recording");
      mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          audioChunks.push(event.data);
        }
      };
      mediaRecorder.onstop = () => {
        console.log("Recording stopped, chunks:", audioChunks.length);
        voiceButton == null ? void 0 : voiceButton.classList.remove("recording");
        stream.getTracks().forEach((track) => track.stop());
        this.updateInputPlaceholder(this.plugin.settings.modelName);
        if (audioChunks.length > 0) {
          const audioBlob = new Blob(audioChunks, { type: mediaRecorder.mimeType });
          console.log("Audio blob created, type:", mediaRecorder.mimeType, "size:", audioBlob.size);
          if (this.speechWorker) {
            this.speechWorker.postMessage({
              apiKey: this.plugin.settings.googleApiKey,
              audioBlob
            });
          }
        } else {
          console.error("No audio data recorded");
        }
      };
      mediaRecorder.start(100);
      console.log("Recording started with mime type:", mediaRecorder.mimeType);
      this.inputEl.placeholder = "Record...";
      setTimeout(() => {
        if (mediaRecorder.state === "recording") {
          mediaRecorder.stop();
          console.log("Recording stopped after timeout");
        }
      }, 15e3);
    } catch (error) {
      console.error("Error accessing microphone:", error);
      voiceButton == null ? void 0 : voiceButton.classList.remove("recording");
    }
  }
  setSystemMessageInterval(interval) {
    this.systemMessageInterval = interval;
  }
  onModelChanged(modelName) {
    this.updateInputPlaceholder(modelName);
  }
};
var OllamaView = _OllamaView;
OllamaView.instance = null;

// settings.ts
var import_obsidian3 = require("obsidian");
var DEFAULT_SETTINGS = {
  modelName: "mistral",
  ollamaServerUrl: "http://localhost:11434",
  logFileSizeLimit: 1024,
  saveMessageHistory: true,
  ragEnabled: false,
  ragFolderPath: "data",
  contextWindowSize: 5,
  googleApiKey: "",
  speechLanguage: "uk-UA",
  maxRecordingTime: 15,
  silenceDetection: true,
  followRole: true,
  useDefaultRoleDefinition: true,
  customRoleFilePath: "",
  systemPromptInterval: 0,
  temperature: 0.1,
  contextWindow: 8192
};
var OllamaSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  getDisplayText() {
    return "Ollama";
  }
  getId() {
    return "ollama-plugin";
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian3.Setting(containerEl).setName("Ollama Server URL").setDesc(
      "IP address and port where Ollama is running (e.g. http://192.168.1.10:11434)"
    ).addText(
      (text) => text.setPlaceholder("http://localhost:11434").setValue(this.plugin.settings.ollamaServerUrl).onChange(async (value) => {
        this.plugin.settings.ollamaServerUrl = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Server Connection").setDesc("Reconnect to local model server and refresh available models").addButton(
      (button) => button.setButtonText("Reconnect").setIcon("refresh-cw").onClick(async () => {
        try {
          new import_obsidian3.Notice("Connecting to Ollama server...");
          const response = await fetch(
            `${this.plugin.settings.ollamaServerUrl}/api/tags`,
            {
              method: "GET",
              headers: { "Content-Type": "application/json" }
            }
          );
          if (response.ok) {
            new import_obsidian3.Notice("Successfully connected to Ollama server!");
            containerEl.empty();
            this.display();
          } else {
            new import_obsidian3.Notice(
              "Failed to connect to Ollama server. Check the URL and ensure the server is running."
            );
            this.plugin.apiService.emit("connection-error");
          }
        } catch (error) {
          new import_obsidian3.Notice(
            "Connection error. Please check the server URL and your network connection."
          );
          this.plugin.apiService.emit("connection-error");
        }
      })
    );
    let availableModels = [];
    try {
      availableModels = await this.plugin.apiService.getModels();
    } catch (error) {
      console.error("Error fetching available models:", error);
      this.plugin.apiService.emit("connection-error");
    }
    const selectedModel = availableModels.includes(
      this.plugin.settings.modelName
    ) ? this.plugin.settings.modelName : availableModels.length > 0 ? availableModels[0] : "";
    const modelSetting = new import_obsidian3.Setting(containerEl).setName("Model Name").setDesc("Select the language model to use");
    const dropdown = modelSetting.addDropdown((dropdown2) => {
      const selectEl = dropdown2.selectEl;
      while (selectEl.firstChild) {
        selectEl.removeChild(selectEl.firstChild);
      }
      availableModels.forEach((model) => {
        dropdown2.addOption(model, model);
      });
      if (availableModels.length === 0) {
        dropdown2.addOption("", "No models available");
      }
      dropdown2.setValue(selectedModel);
      dropdown2.onChange(async (value) => {
        this.plugin.settings.modelName = value;
        this.plugin.emit("model-changed", value);
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian3.Setting(containerEl).setName("Save Message History").setDesc("Save chat message history between sessions").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.saveMessageHistory).onChange(async (value) => {
        this.plugin.settings.saveMessageHistory = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Log File Size Limit").setDesc(
      "Maximum size of message history log file in KB (1024 KB = 1 MB)"
    ).addSlider(
      (slider) => slider.setLimits(256, 10240, 256).setValue(this.plugin.settings.logFileSizeLimit).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.logFileSizeLimit = value;
        await this.plugin.saveSettings();
      })
    ).addExtraButton(
      (button) => button.setIcon("reset").setTooltip("Reset to default (1024 KB)").onClick(async () => {
        this.plugin.settings.logFileSizeLimit = DEFAULT_SETTINGS.logFileSizeLimit;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Clear History").setDesc("Delete all chat history").addButton(
      (button) => button.setButtonText("Clear").onClick(async () => {
        await this.plugin.clearMessageHistory();
        new import_obsidian3.Notice("Chat history cleared.");
      })
    );
    containerEl.createEl("h3", { text: "Role Configuration" });
    new import_obsidian3.Setting(containerEl).setName("Enable Role Definition").setDesc("Make Ollama follow a defined role from a file").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.followRole).onChange(async (value) => {
        this.plugin.settings.followRole = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Use Default Role Definition").setDesc("Use the default role definition file from the plugin folder").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.useDefaultRoleDefinition).onChange(async (value) => {
        this.plugin.settings.useDefaultRoleDefinition = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Custom Role Definition Path").setDesc(
      "Path to a custom role definition file (relative to vault root)"
    ).addText(
      (text) => text.setPlaceholder("folder/role.md").setValue(this.plugin.settings.customRoleFilePath).onChange(async (value) => {
        this.plugin.settings.customRoleFilePath = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("System Prompt Interval").setDesc("Number of message pairs between system prompt resends. 0 - with every request, negative - never send").addText(
      (text) => text.setValue(String(this.plugin.settings.systemPromptInterval || 0)).onChange(async (value) => {
        this.plugin.settings.systemPromptInterval = parseInt(value) || 0;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "RAG Configuration" });
    new import_obsidian3.Setting(containerEl).setName("Enable RAG").setDesc("Use Retrieval Augmented Generation with your notes").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.ragEnabled).onChange(async (value) => {
        this.plugin.settings.ragEnabled = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("AI Assistant Path").setDesc(
      "Path to the folder containing assistant settings. RAG documents will be loaded from 'data' subfolder (relative to vault root)"
    ).addText(
      (text) => text.setPlaceholder("").setValue(this.plugin.settings.ragFolderPath).onChange(async (value) => {
        this.plugin.settings.ragFolderPath = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Context Window Size").setDesc("Number of relevant documents to include in context").addSlider(
      (slider) => slider.setLimits(1, 10, 1).setValue(this.plugin.settings.contextWindowSize).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.contextWindowSize = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Speech Recognition" });
    new import_obsidian3.Setting(containerEl).setName("Google API Key").setDesc("API key for Google Speech-to-Text service").addText(
      (text) => text.setPlaceholder("Enter your Google API key").setValue(this.plugin.settings.googleApiKey).onChange(async (value) => {
        this.plugin.settings.googleApiKey = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Speech Recognition Language").setDesc(
      "Language code for Google Speech-to-Text (e.g., uk-UA, en-US, ru-RU)"
    ).addText(
      (text) => text.setPlaceholder("uk-UA").setValue(this.plugin.settings.speechLanguage).onChange(async (value) => {
        this.plugin.settings.speechLanguage = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Maximum Recording Time").setDesc(
      "Maximum time (in seconds) to record before automatically stopping"
    ).addSlider(
      (slider) => slider.setLimits(5, 60, 5).setValue(this.plugin.settings.maxRecordingTime).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.maxRecordingTime = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Advanced Configuration" });
    new import_obsidian3.Setting(containerEl).setName("AI context window").setDesc("Model context window size (recommended > 8192)").addText(
      (text) => text.setValue(String(this.plugin.settings.contextWindow || 8192)).onChange(async (value) => {
        this.plugin.settings.contextWindow = parseInt(value) || 8192;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Temperature").setDesc("Controls randomness in model responses (0.0-1.0)").addSlider(
      (slider) => slider.setLimits(0, 1, 0.1).setValue(this.plugin.settings.temperature).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.temperature = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

// ragService.ts
var RagService = class {
  constructor(plugin) {
    this.documents = [];
    this.isIndexing = false;
    this.plugin = plugin;
  }
  /**
   * Index all markdown files in the specified folder path
   */
  async indexDocuments() {
    var _a, _b;
    if (this.isIndexing)
      return;
    this.isIndexing = true;
    try {
      const folderPath = this.plugin.settings.ragFolderPath;
      const vault = this.plugin.app.vault;
      console.log(`AI Assistant path: "${folderPath}" (RAG documents will be loaded from 'data' subfolder)`);
      const allFiles = vault.getFiles();
      console.log(`Total files in vault: ${allFiles.length}`);
      const files = await this.getMarkdownFiles(vault, folderPath);
      console.log(`Found ${files.length} markdown files from "${folderPath}"`);
      console.log(`Indexing ${files.length} markdown files from ${folderPath}`);
      this.documents = [];
      for (const file of files) {
        try {
          const content = await vault.read(file);
          this.documents.push({
            path: file.path,
            content,
            metadata: {
              filename: file.name,
              created: (_a = file.stat) == null ? void 0 : _a.ctime,
              modified: (_b = file.stat) == null ? void 0 : _b.mtime
            }
          });
        } catch (error) {
          console.error(`Error reading file ${file.path}:`, error);
        }
      }
      console.log(`Indexed ${this.documents.length} documents for RAG`);
    } catch (error) {
      console.error("Error indexing documents:", error);
    } finally {
      this.isIndexing = false;
    }
  }
  /**
   * Get all markdown files in the specified folder path
   */
  async getMarkdownFiles(vault, folderPath) {
    const files = [];
    if (!folderPath) {
      return files;
    }
    let normalizedFolderPath = folderPath;
    if (!normalizedFolderPath.endsWith("/")) {
      normalizedFolderPath += "/";
    }
    const dataFolderPath = normalizedFolderPath + "data/";
    console.log(`Looking for markdown files in: "${dataFolderPath}"`);
    const allFiles = vault.getFiles();
    for (const file of allFiles) {
      if (file.extension === "md" && file.path.startsWith(dataFolderPath)) {
        console.log(`Adding file: ${file.path}`);
        files.push(file);
      }
    }
    return files;
  }
  /**
   * Simple search implementation to find relevant documents for a query
   * Later this could be replaced with a more sophisticated vector search
   */
  findRelevantDocuments(query, limit = 5) {
    if (!this.documents.length) {
      return [];
    }
    const scoredDocs = this.documents.map((doc) => {
      const lowerContent = doc.content.toLowerCase();
      const lowerQuery = query.toLowerCase();
      const terms = lowerQuery.split(/\s+/);
      let score = 0;
      for (const term of terms) {
        if (term.length > 2) {
          const regex = new RegExp(term, "gi");
          const matches = lowerContent.match(regex);
          if (matches) {
            score += matches.length;
          }
        }
      }
      return { doc, score };
    });
    return scoredDocs.sort((a, b) => b.score - a.score).slice(0, limit).map((item) => item.doc);
  }
  /**
   * Prepare context from relevant documents
   */
  prepareContext(query) {
    if (!this.plugin.settings.ragEnabled || this.documents.length === 0) {
      return "";
    }
    const limit = this.plugin.settings.contextWindowSize;
    const relevantDocs = this.findRelevantDocuments(query, limit);
    if (relevantDocs.length === 0) {
      return "";
    }
    let context = "### Context:\n\n";
    relevantDocs.forEach((doc, index) => {
      var _a;
      context += `Document ${index + 1} (${(_a = doc.metadata) == null ? void 0 : _a.filename}):
`;
      const maxChars = 1500;
      const content = doc.content.length > maxChars ? doc.content.substring(0, maxChars) + "..." : doc.content;
      context += content + "\n\n";
    });
    context += "### End of context\n\n";
    return context;
  }
};

// stateManager.ts
var StateManager = class {
  constructor() {
    this.state = {
      currentPhase: "next goal choosing",
      currentGoal: "Identify if there are any urgent tasks",
      userActivity: "talking with AI",
      hasUrgentTasks: "unknown",
      urgentTasksList: [],
      currentUrgentTask: null,
      planExists: "unknown",
      lastUpdateTime: new Date()
    };
  }
  // Singleton паттерн для доступа к состоянию
  static getInstance() {
    if (!StateManager.instance) {
      StateManager.instance = new StateManager();
    }
    return StateManager.instance;
  }
  // Получить текущее состояние
  getState() {
    this.state.lastUpdateTime = new Date();
    return { ...this.state };
  }
  // Обновить состояние
  updateState(newState) {
    this.state = {
      ...this.state,
      ...newState,
      lastUpdateTime: new Date()
    };
  }
  // Добавление задачи в список срочных задач
  addUrgentTask(task) {
    if (!this.state.urgentTasksList.includes(task)) {
      this.state.urgentTasksList.push(task);
      if (!this.state.currentUrgentTask && this.state.urgentTasksList.length > 0) {
        this.state.currentUrgentTask = this.state.urgentTasksList[0];
      }
      this.state.hasUrgentTasks = true;
    }
  }
  // Удаление задачи из списка и обновление текущей задачи
  completeUrgentTask(task) {
    const index = this.state.urgentTasksList.indexOf(task);
    if (index !== -1) {
      this.state.urgentTasksList.splice(index, 1);
      if (this.state.urgentTasksList.length > 0) {
        this.state.currentUrgentTask = this.state.urgentTasksList[0];
      } else {
        this.state.currentUrgentTask = null;
        this.state.hasUrgentTasks = false;
      }
    }
  }
  // Получить состояние в формате для вставки в сообщение
  getStateFormatted() {
    const currentTime = new Date().toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
    return `- **[day phase]** ${this.state.currentPhase}
  - **[next goal]** ${this.state.currentGoal}
  - **[user activity]** ${this.state.userActivity}
  - **[AI time]** ${currentTime}`;
  }
  // Анализ сообщения пользователя для обновления состояния
  processUserMessage(message) {
  }
  // Сохранение состояния в локальное хранилище
  saveStateToStorage() {
    localStorage.setItem("assistantState", JSON.stringify(this.state));
  }
  // Загрузка состояния из локального хранилища
  loadStateFromStorage() {
    const savedState = localStorage.getItem("assistantState");
    if (savedState) {
      try {
        const parsedState = JSON.parse(savedState);
        parsedState.lastUpdateTime = new Date(parsedState.lastUpdateTime);
        this.state = parsedState;
        return true;
      } catch (e) {
        console.error("Error parsing saved state:", e);
      }
    }
    return false;
  }
};

// promptService.ts
var import_obsidian4 = require("obsidian");
var path = __toESM(require("path"));
var PromptService = class {
  // Reference to the plugin for accessing services
  constructor(plugin) {
    this.systemPrompt = null;
    this.stateManager = StateManager.getInstance();
    this.plugin = plugin;
  }
  /**
   * Set plugin reference for accessing services
   */
  setPlugin(plugin) {
    this.plugin = plugin;
  }
  /**
   * Set system prompt to be used with each request
   */
  setSystemPrompt(prompt) {
    this.systemPrompt = prompt;
  }
  /**
   * Get system prompt if set
   */
  getSystemPrompt() {
    return this.systemPrompt;
  }
  /**
   * Format user prompt with necessary context and state information
   */
  formatPrompt(userInput, isNewConversation = false) {
    this.stateManager.processUserMessage(userInput);
    if (isNewConversation) {
      return userInput;
    }
    return userInput;
  }
  /**
   * Enhance prompt with RAG context if available
   */
  enhanceWithRagContext(prompt, ragContext) {
    if (!ragContext) {
      return prompt;
    }
    return `Context information:
${ragContext}

User message: ${prompt}`;
  }
  /**
   * Prepare request body for model API call
   */
  prepareRequestBody(modelName, prompt, temperature = 0.2) {
    const requestBody = {
      model: modelName,
      prompt,
      stream: false,
      temperature
    };
    if (this.systemPrompt) {
      requestBody.system = this.systemPrompt;
    }
    return requestBody;
  }
  /**
   * Process response from language model
   */
  processModelResponse(response) {
    const textArea = document.createElement("textarea");
    textArea.innerHTML = response;
    const decodedResponse = textArea.value;
    return decodedResponse.includes("<think>") ? decodedResponse : response;
  }
  /**
   * Get default role definition from plugin folder
   */
  async getDefaultRoleDefinition() {
    if (!this.plugin) {
      return null;
    }
    try {
      const pluginFolder = this.plugin.manifest.dir;
      const rolePath = "default-role.md";
      const fullPath = path.join(pluginFolder, rolePath);
      let content;
      try {
        content = await this.plugin.app.vault.adapter.read(fullPath);
      } catch (readError) {
        console.log("Couldn't read file, attempting to create it");
        try {
          const defaultContent = "# Default AI Role\n\nYou are a helpful assistant.";
          const exists = await this.plugin.app.vault.adapter.exists(fullPath);
          if (!exists) {
            await this.plugin.app.vault.adapter.write(fullPath, defaultContent);
            content = defaultContent;
          } else {
            console.error("File exists but couldn't be read:", fullPath);
            return null;
          }
        } catch (createError) {
          console.error("Error creating default role file:", createError);
          return null;
        }
      }
      if (content) {
        const currentTime = new Date().toLocaleTimeString();
        content += `
AI time is ${currentTime} now`;
        return content;
      }
      return null;
    } catch (error) {
      console.error("Error handling default role definition:", error);
      return null;
    }
  }
  /**
   * Get custom role definition from specified path
   */
  async getCustomRoleDefinition() {
    if (!this.plugin || !this.plugin.settings.customRoleFilePath) {
      return null;
    }
    try {
      const customPath = this.plugin.settings.customRoleFilePath;
      const file = this.plugin.app.vault.getAbstractFileByPath(customPath);
      if (file instanceof import_obsidian4.TFile) {
        let content = await this.plugin.app.vault.read(file);
        const currentTime = new Date().toLocaleTimeString();
        content += `
AI time is ${currentTime} now`;
        return content;
      }
      return null;
    } catch (error) {
      console.error("Error reading custom role definition:", error);
      return null;
    }
  }
  /**
   * Get role definition based on settings
   */
  async getRoleDefinition() {
    if (!this.plugin || !this.plugin.settings.followRole) {
      return null;
    }
    try {
      if (this.plugin.settings.useDefaultRoleDefinition) {
        return await this.getDefaultRoleDefinition();
      } else if (this.plugin.settings.customRoleFilePath) {
        return await this.getCustomRoleDefinition();
      }
      return null;
    } catch (error) {
      console.error("Error reading role definition:", error);
      return null;
    }
  }
  /**
   * Prepare a complete prompt with all enhancements (RAG, role definition, etc.)
   */
  async prepareFullPrompt(content, isNewConversation = false) {
    if (!this.plugin) {
      return this.formatPrompt(content, isNewConversation);
    }
    try {
      const roleDefinition = await this.getRoleDefinition();
      if (roleDefinition) {
        this.setSystemPrompt(roleDefinition);
      }
    } catch (error) {
      console.error("Error getting role definition:", error);
    }
    let formattedPrompt = this.formatPrompt(content, isNewConversation);
    if (this.plugin.settings.ragEnabled && this.plugin.ragService) {
      try {
        if (this.plugin.ragService.findRelevantDocuments("test").length === 0) {
          await this.plugin.ragService.indexDocuments();
        }
        const ragContext = this.plugin.ragService.prepareContext(content);
        if (ragContext) {
          formattedPrompt = this.enhanceWithRagContext(formattedPrompt, ragContext);
        }
      } catch (error) {
        console.error("Error processing RAG:", error);
      }
    }
    return formattedPrompt;
  }
};

// apiServices.ts
var ApiService = class {
  constructor(baseUrl, plugin) {
    this.ollamaView = null;
    this.eventHandlers = {};
    this.baseUrl = baseUrl;
    this.stateManager = StateManager.getInstance();
    this.promptService = new PromptService(plugin);
    this.stateManager.loadStateFromStorage();
  }
  on(event, callback) {
    if (!this.eventHandlers[event]) {
      this.eventHandlers[event] = [];
    }
    this.eventHandlers[event].push(callback);
    return () => {
      this.eventHandlers[event] = this.eventHandlers[event].filter(
        (handler) => handler !== callback
      );
    };
  }
  emit(event, data) {
    const handlers = this.eventHandlers[event];
    if (handlers) {
      handlers.forEach((handler) => handler(data));
    }
  }
  getPromptService() {
    return this.promptService;
  }
  setOllamaView(view) {
    this.ollamaView = view;
  }
  /**
   * Set system prompt to be used with each request
   */
  setSystemPrompt(prompt) {
    this.promptService.setSystemPrompt(prompt);
  }
  /**
   * Set base URL for the API
   */
  setBaseUrl(url) {
    this.baseUrl = url;
  }
  /**
   * Set plugin reference for prompt service
   */
  setPlugin(plugin) {
    this.promptService.setPlugin(plugin);
  }
  /**
   * Generate response from Ollama
   */
  async generateResponse(requestBody) {
    const response = await fetch(`${this.baseUrl}/api/generate`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(requestBody)
    });
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`HTTP error! Status: ${response.status}, ${errorText}`);
    }
    const data = await response.json();
    data.response = this.promptService.processModelResponse(data.response);
    this.stateManager.saveStateToStorage();
    return {
      model: requestBody.model,
      response: this.promptService.processModelResponse(data.response)
    };
  }
  /**
   * Get available models from Ollama
   */
  async getModels() {
    try {
      const response = await fetch(`${this.baseUrl}/api/tags`, {
        method: "GET",
        headers: { "Content-Type": "application/json" }
      });
      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
      const data = await response.json();
      if (Array.isArray(data.models)) {
        return data.models.map(
          (model) => typeof model === "object" ? model.name : model
        );
      }
      return [];
    } catch (error) {
      console.error("Error fetching models:", error);
      return [];
    }
  }
  /**
   * Reset assistant state to initial values
   */
  resetState() {
    const initialState = {
      currentPhase: "next goal choosing",
      currentGoal: "Identify if there are any urgent tasks",
      userActivity: "talking with AI",
      hasUrgentTasks: "unknown",
      urgentTasksList: [],
      currentUrgentTask: null,
      planExists: "unknown"
    };
    this.stateManager.updateState(initialState);
    this.stateManager.saveStateToStorage();
    if (this.ollamaView) {
      this.ollamaView.messagesPairCount = 0;
    }
  }
};

// main.ts
var OllamaPlugin = class extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    this.view = null;
    this.eventHandlers = {};
    this.documents = [];
    this.embeddings = [];
    // Add debouncing to prevent excessive indexing
    this.indexUpdateTimeout = null;
  }
  on(event, callback) {
    if (!this.eventHandlers[event]) {
      this.eventHandlers[event] = [];
    }
    this.eventHandlers[event].push(callback);
    return () => {
      this.eventHandlers[event] = this.eventHandlers[event].filter(
        (handler) => handler !== callback
      );
    };
  }
  emit(event, data) {
    const handlers = this.eventHandlers[event];
    if (handlers) {
      handlers.forEach((handler) => handler(data));
    }
  }
  async onload() {
    console.log("Ollama Plugin Loaded!");
    await this.loadSettings();
    this.apiService = new ApiService(this.settings.ollamaServerUrl);
    this.ragService = new RagService(this);
    this.promptService = new PromptService(this);
    this.messageService = new MessageService(this);
    this.registerView(VIEW_TYPE_OLLAMA, (leaf) => {
      this.view = new OllamaView(leaf, this);
      this.messageService.setView(this.view);
      return this.view;
    });
    this.addCommand({
      id: "change-model",
      name: "Change Ollama Model",
      callback: async () => {
        const newModel = "llama2:13b";
        this.settings.modelName = newModel;
        await this.saveSettings();
        this.emit("model-changed", newModel);
      }
    });
    this.apiService.on("connection-error", (error) => {
      this.messageService.addMessage(
        "error" /* ERROR */,
        `Failed to connect to Ollama: ${error.message}`
      );
    });
    this.addRibbonIcon("message-square", "\u0412\u0456\u0434\u043A\u0440\u0438\u0442\u0438 Ollama", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-ollama-view",
      name: "\u0412\u0456\u0434\u043A\u0440\u0438\u0442\u0438 Ollama Chat",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "index-rag-documents",
      name: "\u0406\u043D\u0434\u0435\u043A\u0441\u0443\u0432\u0430\u0442\u0438 \u0434\u043E\u043A\u0443\u043C\u0435\u043D\u0442\u0438 \u0434\u043B\u044F RAG",
      callback: async () => {
        await this.ragService.indexDocuments();
      }
    });
    this.settingTab = new OllamaSettingTab(this.app, this);
    this.addSettingTab(this.settingTab);
    this.app.workspace.onLayoutReady(() => {
      const existingLeaf = this.app.workspace.getLeavesOfType(VIEW_TYPE_OLLAMA)[0];
      if (!existingLeaf) {
        this.activateView();
      } else {
      }
      if (this.settings.ragEnabled) {
        this.ragService.indexDocuments();
      }
    });
    this.registerEvent(
      this.app.vault.on("modify", () => {
        if (this.settings.ragEnabled) {
          this.debounceIndexUpdate();
        }
      })
    );
  }
  // Update API service when settings change
  updateApiService() {
    this.apiService.setBaseUrl(this.settings.ollamaServerUrl);
  }
  debounceIndexUpdate() {
    if (this.indexUpdateTimeout) {
      clearTimeout(this.indexUpdateTimeout);
    }
    this.indexUpdateTimeout = setTimeout(() => {
      this.ragService.indexDocuments();
      this.indexUpdateTimeout = null;
    }, 3e4);
  }
  async activateView() {
    var _a;
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(VIEW_TYPE_OLLAMA)[0];
    if (!leaf) {
      console.log("Creating new Ollama view leaf");
      leaf = (_a = workspace.getRightLeaf(false)) != null ? _a : workspace.getLeaf();
      await leaf.setViewState({ type: VIEW_TYPE_OLLAMA, active: true });
    } else {
      console.log("Ollama view leaf already exists");
    }
    workspace.revealLeaf(leaf);
    if (this.view) {
      this.messageService.setView(this.view);
    }
    return leaf;
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.updateApiService();
  }
  getOllamaApiUrl() {
    return this.settings.ollamaServerUrl || DEFAULT_SETTINGS.ollamaServerUrl;
  }
  // Function to save message history
  async saveMessageHistory(messages) {
    if (!this.settings.saveMessageHistory)
      return;
    try {
      const basePath = this.app.vault.configDir + "/plugins/obsidian-ollama-duet";
      const logPath = basePath + "/chat_history.json";
      const adapter = this.app.vault.adapter;
      let fileExists = await adapter.exists(logPath);
      let fileSize = 0;
      if (fileExists) {
        const stat = await adapter.stat(logPath);
        fileSize = (stat == null ? void 0 : stat.size) ? stat.size / 1024 : 0;
      }
      if (fileSize > this.settings.logFileSizeLimit) {
        if (fileExists) {
          const backupPath = logPath + ".backup";
          if (await adapter.exists(backupPath)) {
            await adapter.remove(backupPath);
          }
          await adapter.copy(logPath, backupPath);
        }
        await adapter.write(logPath, messages);
      } else {
        if (!fileExists) {
          await adapter.write(logPath, messages);
        } else {
          const existingData = await adapter.read(logPath);
          try {
            const existingMessages = JSON.parse(existingData);
            const newMessages = JSON.parse(messages);
            const merged = JSON.stringify([...existingMessages, ...newMessages]);
            if (merged.length / 1024 > this.settings.logFileSizeLimit) {
              const allMessages = [...existingMessages, ...newMessages];
              let trimmedMessages = allMessages;
              while (JSON.stringify(trimmedMessages).length / 1024 > this.settings.logFileSizeLimit) {
                trimmedMessages = trimmedMessages.slice(1);
              }
              await adapter.write(logPath, JSON.stringify(trimmedMessages));
            } else {
              await adapter.write(logPath, merged);
            }
          } catch (e) {
            console.error("Error parsing message history:", e);
            await adapter.write(logPath, messages);
          }
        }
      }
    } catch (error) {
      console.error("Failed to save message history:", error);
    }
  }
  async loadMessageHistory() {
    if (!this.settings.saveMessageHistory)
      return [];
    try {
      const logPath = this.app.vault.configDir + "/plugins/obsidian-ollama-duet/chat_history.json";
      const adapter = this.app.vault.adapter;
      if (await adapter.exists(logPath)) {
        const data = await adapter.read(logPath);
        return JSON.parse(data);
      }
    } catch (error) {
      console.error("Failed to load message history:", error);
    }
    return [];
  }
  async clearMessageHistory() {
    try {
      const logPath = this.app.vault.configDir + "/plugins/obsidian-ollama-duet/chat_history.json";
      const adapter = this.app.vault.adapter;
      if (await adapter.exists(logPath)) {
        await adapter.remove(logPath);
        if (this.view) {
          this.view.clearChatMessages();
        }
      }
    } catch (error) {
      console.error("Failed to clear message history:", error);
    }
  }
};
